{
    "HTML": [
        "https://duckdb.org/docs/sql/data_types/literal_types"
    ],
    "Title": [
        "Literal Types"
    ],
    "Feature": [
        "Literal Types"
    ],
    "Description": [
        "\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n\n\n\n\nLiteral Types\n",
        "DuckDB has special literal types for representing NULL, integer and string literals in queries. These have their own binding and conversion rules.",
        "Note\nPrior to DuckDB version 0.10.0, integer and string literals behaved identically to the INTEGER and VARCHAR types.\n",
        "\nNull Literals\n",
        "The NULL literal is denoted with the keyword NULL. The NULL literal can be implicitly converted to any other type.",
        "\nInteger Literals\n",
        "Integer literals are denoted as a sequence of one or more digits. At runtime, these result in values of the INTEGER_LITERAL type. INTEGER_LITERAL types can be implicitly converted to any integer type in which the value fits. For example, the integer literal 42 can be implicitly converted to a TINYINT, but the integer literal 1000 cannot be.",
        "\nOther Numeric Literals\n",
        "Non-integer numeric literals can be denoted with decimal notation, using the period character (.) to separate the integer part and the decimal part of the number.\nEither the integer part or the decimal part may be omitted:",
        "SELECT 1.5;          -- 1.5\nSELECT .50;          -- 0.5\nSELECT 2.;           -- 2.0\n",
        "Non-integer numeric literals can also be denoted using E notation. In E notation, an integer or decimal literal is followed by and exponential part, which is denoted by e or E, followed by a literal integer indicating the exponent.\nThe exponential part indicates that the preceding value should be multiplied by 10 raised to the power of the exponent:",
        "SELECT 1e2;           -- 100\nSELECT 6.02214e23;    -- Avogadro's constant\nSELECT 1e-10;         -- 1 \u00e5ngstr\u00f6m\n",
        "\nUnderscores in Numeric Literals\n",
        "DuckDB's SQL dialect allows using the underscore character _ in numeric literals as an optional separator. The rules for using underscores are as follows:",
        "\nUnderscores are allowed in integer, decimal, hexadecimal and binary notation.\nUnderscores can not be the first or last character in a literal.\nUnderscores have to have an integer/numeric part on either side of them, i.e., there can not be multiple underscores in a row and not immediately before/after a decimal or exponent.\n",
        "Examples:",
        "SELECT 100_000_000;          -- 100000000\nSELECT '0xFF_FF'::INTEGER;   -- 65535\nSELECT 1_2.1_2E0_1;          -- 121.2\nSELECT '0b0_1_0_1'::INTEGER; -- 5\n",
        "\nString Literals\n",
        "String literals are delimited using single quotes (', apostrophe) and result in STRING_LITERAL values.\nNote that double quotes (\") cannot be used as string delimiter character: instead, double quotes are used to delimit quoted identifiers.",
        "\nImplicit String Literal Concatenation\n",
        "Consecutive single-quoted string literals separated only by whitespace that contains at least one newline are implicitly concatenated:",
        "SELECT 'Hello'\n    ' '\n    'World' AS greeting;\n",
        "is equivalent to:",
        "SELECT 'Hello'\n    || ' '\n    || 'World' AS greeting;\n",
        "They both return the following result:",
        "\n\n\ngreeting\n\n\n\n\nHello World\n\n\n",
        "Note that implicit concatenation only works if there is at least one newline between the literals. Using adjacent string literals separated by whitespace without a newline results in a syntax error:",
        "SELECT 'Hello' ' ' 'World' AS greeting;\n",
        "Parser Error: syntax error at or near \"' '\"\nLINE 1: SELECT 'Hello' ' ' 'World' AS greeting;\n                       ^\n",
        "Also note that implicit concatenation only works with single-quoted string literals, and does not work with other kinds of string values.",
        "\nImplicit String Conversion\n",
        "STRING_LITERAL instances can be implicitly converted to any other type.",
        "For example, we can compare string literals with dates:",
        "SELECT d > '1992-01-01' AS result FROM (VALUES (DATE '1992-01-01')) t(d);\n",
        "\n\n\nresult\n\n\n\n\nfalse\n\n\n",
        "However, we cannot compare VARCHAR values with dates.",
        "SELECT d > '1992-01-01'::VARCHAR FROM (VALUES (DATE '1992-01-01')) t(d);\n",
        "Binder Error: Cannot compare values of type DATE and type VARCHAR - an explicit cast is required\n",
        "\nEscape String Literals\n",
        "To escape a single quote (apostrophe) character in a string literal, use ''. For example, SELECT '''' AS s returns '.",
        "To include special characters such as newline, use E escape the string. Both the uppercase (E'...') and lowercase variants (e'...') work.",
        "SELECT E'Hello\\nworld' AS msg;\n",
        "Or:",
        "SELECT e'Hello\\nworld' AS msg;\n",
        "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     msg      \u2502\n\u2502   varchar    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Hello\\nworld \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n",
        "The following backslash escape sequences are supported:",
        "\n\n\nEscape sequence\nName\nASCII code\n\n\n\n\n\\b\nbackspace\n8\n\n\n\\f\nform feed\n12\n\n\n\\n\nnewline\n10\n\n\n\\r\ncarriage return\n13\n\n\n\\t\ntab\n9\n\n\n",
        "\nDollar-Quoted String Literals\n",
        "DuckDB supports dollar-quoted string literals, which are surrounded by double-dollar symbols ($$):",
        "SELECT $$Hello\nworld$$ AS msg;\n",
        "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     msg      \u2502\n\u2502   varchar    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Hello\\nworld \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n",
        "SELECT $$The price is $9.95$$ AS msg;\n",
        "\n\n\nmsg\n\n\n\n\nThe price is $9.95\n\n\n",
        "Implicit concatenation only works for single-quoted string literals, not with dollar-quoted ones.",
        "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"
    ],
    "Examples": [
        "SELECT 1.5;          -- 1.5\nSELECT .50;          -- 0.5\nSELECT 2.;           -- 2.0\n",
        "SELECT 1e2;           -- 100\nSELECT 6.02214e23;    -- Avogadro's constant\nSELECT 1e-10;         -- 1 \u00e5ngstr\u00f6m\n",
        "SELECT 100_000_000;          -- 100000000\nSELECT '0xFF_FF'::INTEGER;   -- 65535\nSELECT 1_2.1_2E0_1;          -- 121.2\nSELECT '0b0_1_0_1'::INTEGER; -- 5\n",
        "SELECT 'Hello'\n    ' '\n    'World' AS greeting;\n",
        "SELECT 'Hello'\n    || ' '\n    || 'World' AS greeting;\n",
        "SELECT 'Hello' ' ' 'World' AS greeting;\n",
        "Parser Error: syntax error at or near \"' '\"\nLINE 1: SELECT 'Hello' ' ' 'World' AS greeting;\n                       ^\n",
        "SELECT d > '1992-01-01' AS result FROM (VALUES (DATE '1992-01-01')) t(d);\n",
        "SELECT d > '1992-01-01'::VARCHAR FROM (VALUES (DATE '1992-01-01')) t(d);\n",
        "Binder Error: Cannot compare values of type DATE and type VARCHAR - an explicit cast is required\n",
        "SELECT E'Hello\\nworld' AS msg;\n",
        "SELECT e'Hello\\nworld' AS msg;\n",
        "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     msg      \u2502\n\u2502   varchar    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Hello\\nworld \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n",
        "SELECT $$Hello\nworld$$ AS msg;\n",
        "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     msg      \u2502\n\u2502   varchar    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Hello\\nworld \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n",
        "SELECT $$The price is $9.95$$ AS msg;\n"
    ],
    "Category": [
        "Literal Types"
    ],
    "EffectiveSQLsRefined": [
        "SELECT 1.5;",
        "SELECT .50;",
        "SELECT 2.;",
        "SELECT 1e2;",
        "SELECT 6.02214e23;",
        "SELECT 1e-10;",
        "SELECT 100_000_000;",
        "SELECT '0xFF_FF'::INTEGER;",
        "SELECT 1_2.1_2E0_1;",
        "SELECT '0b0_1_0_1'::INTEGER;",
        "SELECT 'Hello'\n    ' '\n    'World' AS greeting;",
        "SELECT 'Hello'\n    || ' '\n    || 'World' AS greeting;",
        "SELECT d > '1992-01-01' AS result FROM (VALUES (DATE '1992-01-01')) t(d);",
        "SELECT E'Hello\\nworld' AS msg;",
        "SELECT e'Hello\\nworld' AS msg;",
        "SELECT $$Hello\nworld$$ AS msg;",
        "SELECT $$The price is $9.95$$ AS msg;"
    ],
    "EffectiveSQLsGenerated": [],
    "EffectiveSQLsGeneratedCosts": [],
    "EffectiveSQLsGeneratedErrors": [],
    "EffectiveSQLs": [
        "SELECT 1.5;",
        "SELECT .50;",
        "SELECT 2.;",
        "SELECT 1e2;",
        "SELECT 6.02214e23;",
        "SELECT 1e-10;",
        "SELECT 100_000_000;",
        "SELECT '0xFF_FF'::INTEGER;",
        "SELECT 1_2.1_2E0_1;",
        "SELECT '0b0_1_0_1'::INTEGER;",
        "SELECT 'Hello'\n    ' '\n    'World' AS greeting;",
        "SELECT 'Hello'\n    || ' '\n    || 'World' AS greeting;",
        "SELECT d > '1992-01-01' AS result FROM (VALUES (DATE '1992-01-01')) t(d);",
        "SELECT E'Hello\\nworld' AS msg;",
        "SELECT e'Hello\\nworld' AS msg;",
        "SELECT $$Hello\nworld$$ AS msg;",
        "SELECT $$The price is $9.95$$ AS msg;"
    ]
}