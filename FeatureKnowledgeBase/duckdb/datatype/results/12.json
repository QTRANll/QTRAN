{
    "HTML": [
        "https://duckdb.org/docs/sql/data_types/struct"
    ],
    "Title": [
        "Struct"
    ],
    "Feature": [
        "Struct"
    ],
    "Description": [
        "\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n0.9\n0.8\n0.7\n\n\n\n\nStruct Data Type\n",
        "Conceptually, a STRUCT column contains an ordered list of columns called \u201centries\u201d. The entries are referenced by name using strings. This document refers to those entry names as keys. Each row in the STRUCT column must have the same keys. The names of the struct entries are part of the schema. Each row in a STRUCT column must have the same layout. The names of the struct entries are case-insensitive.",
        "STRUCTs are typically used to nest multiple columns into a single column, and the nested column can be of any type, including other STRUCTs and LISTs.",
        "STRUCTs are similar to PostgreSQL's ROW type. The key difference is that DuckDB STRUCTs require the same keys in each row of a STRUCT column. This allows DuckDB to provide significantly improved performance by fully utilizing its vectorized execution engine, and also enforces type consistency for improved correctness. DuckDB includes a row function as a special way to produce a STRUCT, but does not have a ROW data type. See an example below and the STRUCT functions documentation for details.",
        "STRUCTs have a fixed schema. It is not possible to change the schema of a STRUCT using UPDATE operations.",
        "See the data types overview for a comparison between nested data types.",
        "\nCreating Structs\n",
        "Structs can be created using the struct_pack(name := expr, ...) function, the equivalent array notation {'name': expr, ...}, using a row variable, or using the row function.",
        "Create a struct using the struct_pack function. Note the lack of single quotes around the keys and the use of the := operator:",
        "SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;\n",
        "Create a struct using the array notation:",
        "SELECT {'key1': 'value1', 'key2': 42} AS s;\n",
        "Create a struct using a row variable:",
        "SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;\n",
        "Create a struct of integers:",
        "SELECT {'x': 1, 'y': 2, 'z': 3} AS s;\n",
        "Create a struct of strings with a NULL value:",
        "SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;\n",
        "Create a struct with a different type for each key:",
        "SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;\n",
        "Create a struct of structs with NULL values:",
        "SELECT {\n        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n        'aliens': NULL,\n        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n    } AS s;\n",
        "\nAdding Field(s)/Value(s) to Structs\n",
        "Add to a struct of integers:",
        "SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;\n",
        "\nRetrieving from Structs\n",
        "Retrieving a value from a struct can be accomplished using dot notation, bracket notation, or through struct functions like struct_extract.",
        "Use dot notation to retrieve the value at a key's location. In the following query, the subquery generates a struct column a, which we then query with a.x.",
        "SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n",
        "If a key contains a space, simply wrap it in double quotes (\").",
        "SELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n",
        "Bracket notation may also be used. Note that this uses single quotes (') since the goal is to specify a certain string key and only constant expressions may be used inside the brackets (no expressions):",
        "SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n",
        "The struct_extract function is also equivalent. This returns 1:",
        "SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');\n",
        "\nSTRUCT.*\n",
        "Rather than retrieving a single key from a struct, star notation (*) can be used to retrieve all keys from a struct as separate columns.\nThis is particularly useful when a prior operation creates a struct of unknown shape, or if a query must handle any potential struct keys.",
        "All keys within a struct can be returned as separate columns using *:",
        "SELECT a.*\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n",
        "\n\n\nx\ny\nz\n\n\n\n\n1\n2\n3\n\n\n",
        "\nDot Notation Order of Operations\n",
        "Referring to structs with dot notation can be ambiguous with referring to schemas and tables. In general, DuckDB looks for columns first, then for struct keys within columns. DuckDB resolves references in these orders, using the first match to occur:",
        "\nNo Dots\n",
        "SELECT part1\nFROM tbl;\n",
        "\npart1 is a column\n",
        "\nOne Dot\n",
        "SELECT part1.part2\nFROM tbl;\n",
        "\npart1 is a table, part2 is a column\npart1 is a column, part2 is a property of that column\n",
        "\nTwo (or More) Dots\n",
        "SELECT part1.part2.part3\nFROM tbl;\n",
        "\npart1 is a schema, part2 is a table, part3 is a column\npart1 is a table, part2 is a column, part3 is a property of that column\npart1 is a column, part2 is a property of that column, part3 is a property of that column\n",
        "Any extra parts (e.g., .part4.part5, etc.) are always treated as properties",
        "\nCreating Structs with the row Function\n",
        "The row function can be used to automatically convert multiple columns to a single struct column.\nWhen using row the keys will be empty strings allowing for easy insertion into a table with a struct column.\nColumns, however, cannot be initialized with the row function, and must be explicitly named.\nFor example, inserting values into a struct column using the row function:",
        "CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));\nINSERT INTO t1 VALUES (row('a', 42));\nSELECT * FROM t1;\n",
        "The table will contain a single entry:",
        "{'v': a, 'i': 42}\n",
        "The following produces the same result as above:",
        "CREATE TABLE t1 AS (\n    SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)\n);\n",
        "Initializing a struct column with the row function will fail:",
        "CREATE TABLE t2 AS SELECT row('a');\n",
        "Invalid Input Error: A table cannot be created from an unnamed struct\n",
        "When casting structs, the names of fields have to match. Therefore, the following query will fail:",
        "SELECT a::STRUCT(y INTEGER) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n",
        "Mismatch Type Error: Type STRUCT(x INTEGER) does not match with STRUCT(y INTEGER). Cannot cast STRUCTs - element \"x\" in source struct was not found in target struct\n",
        "A workaround for this is to use struct_pack instead:",
        "SELECT struct_pack(y := a.x) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n",
        "The row function can be used to return unnamed structs. For example:",
        "SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;\n",
        "This produces (1, 2, a).",
        "If using multiple expressions when creating a struct, the row function is optional. The following query returns the same result as the previous one:",
        "SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);\n",
        "\nComparison and Ordering\n",
        "The STRUCT type can be compared using all the comparison operators.\nThese comparisons can be used in logical expressions\nsuch as WHERE and HAVING clauses, and return BOOLEAN values.",
        "For comparisons, the keys of a STRUCT have a fixed positional order, from left to right. \nComparisons behave the same as row comparisons, therefore, matching keys must be at identical positions.",
        "Specifically, for any STRUCT comparison, the following rules apply:",
        "\nEquality. s1 and s2 are equal, if all respective values are equal.\nLess Than. For the first index i where s1.value[i] != s2.value[i]:\nIf s1.value[i] < s2.value[i], s1 is less than s2.\n",
        "NULL values are compared following PostgreSQL's semantics.\nLower nesting levels are used for tie-breaking.",
        "Here are some queries returning true for the comparison.",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': 4} AS result;\n",
        "SELECT {'k1': 'hello'} < {'k1': 'world'} AS result;\n",
        "These queries return false.",
        "SELECT {'k2': 4, 'k1': 3} < {'k2': 2, 'k1': 4} AS result;\n",
        "SELECT {'k1': [4, 3]} < {'k1': [3, 6, 7]} AS result;\n",
        "These queries return NULL.",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': NULL} AS result;\n",
        "This query returns a Binder Error because the keys do not match positionally.",
        "SELECT {'k1': 2, 'k2': 3} < {'k2': 2, 'k1': 4} AS result;\n",
        "Binder Error: Cannot compare values of type STRUCT(k1 INTEGER, k2 INTEGER)\nand type STRUCT(k2 INTEGER, k1 INTEGER) - an explicit cast is required\n",
        "\nFunctions\n",
        "See Struct Functions.",
        "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"
    ],
    "Examples": [
        "SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;\n",
        "SELECT {'key1': 'value1', 'key2': 42} AS s;\n",
        "SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;\n",
        "SELECT {'x': 1, 'y': 2, 'z': 3} AS s;\n",
        "SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;\n",
        "SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;\n",
        "SELECT {\n        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n        'aliens': NULL,\n        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n    } AS s;\n",
        "SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;\n",
        "SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n",
        "SELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n",
        "SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n",
        "SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');\n",
        "SELECT a.*\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n",
        "SELECT part1\nFROM tbl;\n",
        "SELECT part1.part2\nFROM tbl;\n",
        "SELECT part1.part2.part3\nFROM tbl;\n",
        "CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));\nINSERT INTO t1 VALUES (row('a', 42));\nSELECT * FROM t1;\n",
        "{'v': a, 'i': 42}\n",
        "CREATE TABLE t1 AS (\n    SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)\n);\n",
        "CREATE TABLE t2 AS SELECT row('a');\n",
        "Invalid Input Error: A table cannot be created from an unnamed struct\n",
        "SELECT a::STRUCT(y INTEGER) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n",
        "Mismatch Type Error: Type STRUCT(x INTEGER) does not match with STRUCT(y INTEGER). Cannot cast STRUCTs - element \"x\" in source struct was not found in target struct\n",
        "SELECT struct_pack(y := a.x) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n",
        "SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;\n",
        "SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);\n",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': 4} AS result;\n",
        "SELECT {'k1': 'hello'} < {'k1': 'world'} AS result;\n",
        "SELECT {'k2': 4, 'k1': 3} < {'k2': 2, 'k1': 4} AS result;\n",
        "SELECT {'k1': [4, 3]} < {'k1': [3, 6, 7]} AS result;\n",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': NULL} AS result;\n",
        "SELECT {'k1': 2, 'k2': 3} < {'k2': 2, 'k1': 4} AS result;\n",
        "Binder Error: Cannot compare values of type STRUCT(k1 INTEGER, k2 INTEGER)\nand type STRUCT(k2 INTEGER, k1 INTEGER) - an explicit cast is required\n"
    ],
    "Category": [
        "Struct"
    ],
    "EffectiveSQLsRefined": [
        "SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;",
        "SELECT {'key1': 'value1', 'key2': 42} AS s;",
        "SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;",
        "SELECT {'x': 1, 'y': 2, 'z': 3} AS s;",
        "SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;",
        "SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;",
        "SELECT {\n        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n        'aliens': NULL,\n        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n    } AS s;",
        "SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;",
        "SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);",
        "SELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);",
        "SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);",
        "SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');",
        "SELECT a.*\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);",
        "CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));",
        "INSERT INTO t1 VALUES (row('a', 42));",
        "SELECT * FROM t1;",
        "SELECT struct_pack(y := a.x) AS b\nFROM\n    (SELECT {'x': 42} AS a);",
        "SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;",
        "SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': 4} AS result;",
        "SELECT {'k1': 'hello'} < {'k1': 'world'} AS result;",
        "SELECT {'k2': 4, 'k1': 3} < {'k2': 2, 'k1': 4} AS result;",
        "SELECT {'k1': [4, 3]} < {'k1': [3, 6, 7]} AS result;",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': NULL} AS result;"
    ],
    "EffectiveSQLsGenerated": [],
    "EffectiveSQLsGeneratedCosts": [],
    "EffectiveSQLsGeneratedErrors": [],
    "EffectiveSQLs": [
        "SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;",
        "SELECT {'key1': 'value1', 'key2': 42} AS s;",
        "SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;",
        "SELECT {'x': 1, 'y': 2, 'z': 3} AS s;",
        "SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;",
        "SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;",
        "SELECT {\n        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n        'aliens': NULL,\n        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n    } AS s;",
        "SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;",
        "SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);",
        "SELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);",
        "SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);",
        "SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');",
        "SELECT a.*\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);",
        "CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));",
        "INSERT INTO t1 VALUES (row('a', 42));",
        "SELECT * FROM t1;",
        "SELECT struct_pack(y := a.x) AS b\nFROM\n    (SELECT {'x': 42} AS a);",
        "SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;",
        "SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': 4} AS result;",
        "SELECT {'k1': 'hello'} < {'k1': 'world'} AS result;",
        "SELECT {'k2': 4, 'k1': 3} < {'k2': 2, 'k1': 4} AS result;",
        "SELECT {'k1': [4, 3]} < {'k1': [3, 6, 7]} AS result;",
        "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': NULL} AS result;"
    ]
}