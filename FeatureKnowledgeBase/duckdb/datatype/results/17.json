{
    "HTML": [
        "https://duckdb.org/docs/sql/data_types/union"
    ],
    "Title": [
        "Union"
    ],
    "Feature": [
        "Union"
    ],
    "Description": [
        "\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n0.9\n0.8\n0.7\n\n\n\n\nUnion Type\n",
        "A UNION type (not to be confused with the SQL UNION operator) is a nested type capable of holding one of multiple \u201calternative\u201d values, much like the union in C. The main difference being that these UNION types are tagged unions and thus always carry a discriminator \u201ctag\u201d which signals which alternative it is currently holding, even if the inner value itself is null. UNION types are thus more similar to C++17's std::variant, Rust's Enum or the \u201csum type\u201d present in most functional languages.",
        "UNION types must always have at least one member, and while they can contain multiple members of the same type, the tag names must be unique. UNION types can have at most 256 members.",
        "Under the hood, UNION types are implemented on top of STRUCT types, and simply keep the \u201ctag\u201d as the first entry.",
        "UNION values can be created with the union_value(tag := expr) function or by casting from a member type.",
        "\nExample\n",
        "Create a table with a UNION column:",
        "CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));\nINSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));\n",
        "Any type can be implicitly cast to a UNION containing the type. Any UNION can also be implicitly cast to another UNION if the source UNION members are a subset of the target's (if the cast is unambiguous).",
        "UNION uses the member types' VARCHAR cast functions when casting to VARCHAR:",
        "SELECT u FROM tbl1;\n",
        "\n\n\nu\n\n\n\n\n1\n\n\ntwo\n\n\nthree\n\n\n",
        "Select all the str members:",
        "SELECT union_extract(u, 'str') AS str\nFROM tbl1;\n",
        "\n\n\nstr\n\n\n\n\nNULL\n\n\ntwo\n\n\nthree\n\n\n",
        "Alternatively, you can use 'dot syntax' similarly to STRUCTs.",
        "SELECT u.str\nFROM tbl1;\n",
        "\n\n\nstr\n\n\n\n\nNULL\n\n\ntwo\n\n\nthree\n\n\n",
        "Select the currently active tag from the UNION as an ENUM.",
        "SELECT union_tag(u) AS t\nFROM tbl1;\n",
        "\n\n\nt\n\n\n\n\nnum\n\n\nstr\n\n\nstr\n\n\n",
        "\nUnion Casts\n",
        "Compared to other nested types, UNIONs allow a set of implicit casts to facilitate unintrusive and natural usage when working with their members as \u201csubtypes\u201d.\nHowever, these casts have been designed with two principles in mind, to avoid ambiguity and to avoid casts that could lead to loss of information. This prevents UNIONs from being completely \u201ctransparent\u201d, while still allowing UNION types to have a \u201csupertype\u201d relationship with their members.",
        "Thus UNION types can't be implicitly cast to any of their member types in general, since the information in the other members not matching the target type would be \u201clost\u201d. If you want to coerce a UNION into one of its members, you should use the union_extract function explicitly instead.",
        "The only exception to this is when casting a UNION to VARCHAR, in which case the members will all use their corresponding VARCHAR casts. Since everything can be cast to VARCHAR, this is \u201csafe\u201d in a sense.",
        "\nCasting to Unions\n",
        "A type can always be implicitly cast to a UNION if it can be implicitly cast to one of the UNION member types.",
        "\nIf there are multiple candidates, the built in implicit casting priority rules determine the target type. For example, a FLOAT \u2192 UNION(i INTEGER, v VARCHAR) cast will always cast the FLOAT to the INTEGER member before VARCHAR.\nIf the cast still is ambiguous, i.e., there are multiple candidates with the same implicit casting priority, an error is raised. This usually happens when the UNION contains multiple members of the same type, e.g., a FLOAT \u2192 UNION(i INTEGER, num INTEGER) is always ambiguous.\n",
        "So how do we disambiguate if we want to create a UNION with multiple members of the same type? By using the union_value function, which takes a keyword argument specifying the tag. For example, union_value(num := 2::INTEGER) will create a UNION with a single member of type INTEGER with the tag num. This can then be used to disambiguate in an explicit (or implicit, read on below!) UNION to UNION cast, like CAST(union_value(b := 2) AS UNION(a INTEGER, b INTEGER)).",
        "\nCasting between Unions\n",
        "UNION types can be cast between each other if the source type is a \u201csubset\u201d of the target type. In other words, all the tags in the source UNION must be present in the target UNION, and all the types of the matching tags must be implicitly castable between source and target. In essence, this means that UNION types are covariant with respect to their members.",
        "\n\n\nOk\nSource\nTarget\nComments\n\n\n\n\n\u2705\nUNION(a A, b B)\nUNION(a A, b B, c C)\n\u00a0\n\n\n\u2705\nUNION(a A, b B)\nUNION(a A, b C)\nif B can be implicitly cast to C\n\n\n\u274c\nUNION(a A, b B, c C)\nUNION(a A, b B)\n\u00a0\n\n\n\u274c\nUNION(a A, b B)\nUNION(a A, b C)\nif B can't be implicitly cast to C\n\n\n\u274c\nUNION(A, B, D)\nUNION(A, B, C)\n\u00a0\n\n\n",
        "\nComparison and Sorting\n",
        "Since UNION types are implemented on top of STRUCT types internally, they can be used with all the comparison operators as well as in both WHERE and HAVING clauses with the same semantics as STRUCTs. The \u201ctag\u201d is always stored as the first struct entry, which ensures that the UNION types are compared and ordered by \u201ctag\u201d first.",
        "\nFunctions\n",
        "See Union Functions.",
        "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"
    ],
    "Examples": [
        "CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));\nINSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));\n",
        "SELECT u FROM tbl1;\n",
        "SELECT union_extract(u, 'str') AS str\nFROM tbl1;\n",
        "SELECT u.str\nFROM tbl1;\n",
        "SELECT union_tag(u) AS t\nFROM tbl1;\n"
    ],
    "Category": [
        "Union"
    ],
    "EffectiveSQLsRefined": [
        "CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));",
        "INSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));",
        "SELECT u FROM tbl1;",
        "SELECT union_extract(u, 'str') AS str\nFROM tbl1;",
        "SELECT u.str\nFROM tbl1;",
        "SELECT union_tag(u) AS t\nFROM tbl1;"
    ],
    "EffectiveSQLsGenerated": [],
    "EffectiveSQLsGeneratedCosts": [],
    "EffectiveSQLsGeneratedErrors": [],
    "EffectiveSQLs": [
        "CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));",
        "INSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));",
        "SELECT u FROM tbl1;",
        "SELECT union_extract(u, 'str') AS str\nFROM tbl1;",
        "SELECT u.str\nFROM tbl1;",
        "SELECT union_tag(u) AS t\nFROM tbl1;"
    ]
}