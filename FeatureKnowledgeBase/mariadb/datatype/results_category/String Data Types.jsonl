{"HTML": ["https://mariadb.com/kb/en/binary/"], "Title": ["BINARY"], "Feature": ["BINARY(M)\n"], "Description": ["The BINARY type is similar to the CHAR type, but stores binary\nbyte strings rather than non-binary character strings. M represents the\ncolumn length in bytes.", "It contains no character set, and comparison and sorting are based on the numeric value of the bytes.", "If the maximum length is exceeded, and SQL strict mode is not enabled , the extra characters will be dropped with a warning. If strict mode is enabled, an error will occur.", "BINARY values are right-padded with 0x00 (the zero byte) to the specified length when inserted. The padding is not removed on select, so this needs to be taken into account when sorting and comparing, where all bytes are significant. The zero byte, 0x00 is less than a space for comparison purposes."], "Examples": ["CREATE TABLE bins (a BINARY(10));\n\nINSERT INTO bins VALUES('12345678901');\nQuery OK, 1 row affected, 1 warning (0.04 sec)\n\nSELECT * FROM bins;\n+------------+\n| a          |\n+------------+\n| 1234567890 |\n+------------+\n\nSET sql_mode='STRICT_ALL_TABLES';\n\nINSERT INTO bins VALUES('12345678901');\nERROR 1406 (22001): Data too long for column 'a' at row 1\n", "TRUNCATE bins;\n\nINSERT INTO bins VALUES('A'),('B'),('a'),('b');\n\nSELECT * FROM bins ORDER BY a;\n+------+\n| a    |\n+------+\n| A    |\n| B    |\n| a    |\n| b    |\n+------+\n", "SELECT * FROM bins ORDER BY CAST(a AS CHAR);\n+------+\n| a    |\n+------+\n| a    |\n| A    |\n| b    |\n| B    |\n+------+\n", "TRUNCATE bins;\n\nINSERT INTO bins VALUES('12345678');\n\nSELECT a = '12345678', a = '12345678\\0\\0' from bins;\n+----------------+--------------------+\n| a = '12345678' | a = '12345678\\0\\0' |\n+----------------+--------------------+\n|              0 |                  1 |\n+----------------+--------------------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/blob/"], "Title": ["BLOB"], "Feature": ["BLOB[(M)]\n"], "Description": ["A BLOB column with a maximum length of 65,535 (216 - 1) bytes. Each\nBLOB value is stored using a two-byte length prefix that indicates the\nnumber of bytes in the value.", "An optional length M can be given for this type. If this is done,\nMariaDB creates the column as the smallest BLOB type large enough to\nhold values M bytes long.", "BLOBS can also be used to store dynamic columns.", "BLOB and TEXT columns can both be assigned a DEFAULT value.", "Indexing", "MariaDB starting with 10.4From MariaDB 10.4, it is possible to set a unique index on a column that uses the BLOB data type.  In previous releases this was not possible, as the index would only guarantee the uniqueness of a fixed number of characters.\n", "Oracle Mode", "In Oracle mode from MariaDB 10.3, BLOB is a synonym for LONGBLOB."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/blob-and-text-data-types/"], "Title": ["BLOB and TEXT Data Types"], "Feature": [], "Description": ["A BLOB is a binary large object that can hold a variable amount of\ndata. The four BLOB types are ", "TINYBLOB,\nBLOB, \nMEDIUMBLOB, and\nLONGBLOB.\n", "These differ only in the maximum length of the values they can hold. ", "The TEXT types are ", "TINYTEXT,\nTEXT,\nMEDIUMTEXT, and\nLONGTEXT.\nJSON (alias for LONGTEXT)\n", "These correspond to the four BLOB types and have the same\nmaximum lengths and storage requirements.", "BLOB and TEXT columns can have a DEFAULT value.", "MariaDB starting with 10.4.3From MariaDB 10.4, it is possible to set a unique index on columns that use the BLOB or TEXT data types.\n"], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/char/"], "Title": ["CHAR"], "Feature": ["[NATIONAL] CHAR[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A fixed-length string that is always right-padded with spaces to the specified\nlength when stored. M represents the column length in characters. The range\nof M is 0 to 255. If M is omitted, the length is 1.", "CHAR(0) columns can contain 2 values: an empty string or NULL. Such columns cannot be part of an index. The CONNECT storage engine does not support CHAR(0).", "Note: Trailing spaces are removed when CHAR values are retrieved\nunless the PAD_CHAR_TO_FULL_LENGTH SQL mode is enabled.", "Before MariaDB 10.2, all collations were of type PADSPACE, meaning that CHAR (as well as VARCHAR and TEXT) values are compared without regard for trailing spaces. This does not apply to the LIKE pattern-matching operator, which takes into account trailing spaces.", "If a unique index consists of a column where trailing pad characters are stripped or ignored, inserts into that column where values differ only by the number of trailing pad characters will result in a duplicate-key error."], "Examples": ["CREATE TABLE strtest (c CHAR(10));\nINSERT INTO strtest VALUES('Maria   ');\n\nSELECT c='Maria',c='Maria   ' FROM strtest;\n+-----------+--------------+\n| c='Maria' | c='Maria   ' |\n+-----------+--------------+\n|         1 |            1 |\n+-----------+--------------+\n\nSELECT c LIKE 'Maria',c LIKE 'Maria   ' FROM strtest;\n+----------------+-------------------+\n| c LIKE 'Maria' | c LIKE 'Maria   ' |\n+----------------+-------------------+\n|              1 |                 0 |\n+----------------+-------------------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/char-byte/"], "Title": ["CHAR BYTE"], "Feature": [], "Description": ["The CHAR BYTE data type is an alias for the \nBINARY data type. This is a\ncompatibility feature."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/enum/"], "Title": ["ENUM"], "Feature": ["ENUM('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["An enumeration. A string object that can have only one value, chosen\nfrom the list of values 'value1', 'value2', ..., NULL or the special \n'' error value. In theory, an ENUM column can have a maximum of 65,535 distinct\nvalues; in practice, the real maximum depends on many factors. ENUM values are represented internally as integers.", "Trailing spaces are automatically stripped from ENUM values on table creation.", "ENUMs require relatively little storage space compared to strings, either one or two bytes depending on the number of enumeration values.", "NULL and empty values", "An ENUM can also contain NULL and empty values. If the ENUM column is declared to permit NULL values, NULL becomes a valid value, as well as the default value (see below). If strict SQL Mode is not enabled, and an invalid value is inserted into an ENUM, a special empty string, with an index value of zero (see Numeric index, below), is inserted, with a warning. This may be confusing, because the empty string is also a possible value, and the only difference if that is this case its index is not 0. Inserting will fail with an error if strict mode is active.", "If a DEFAULT clause is missing, the default value will be:", "NULL if the column is nullable;\notherwise, the first value in the enumeration.\n", "Numeric index", "ENUM values are indexed numerically in the order they are defined, and sorting will be performed in this numeric order. We suggest not using ENUM to store numerals, as there is little to no storage space benefit, and it is easy to confuse the enum integer with the enum numeral value by leaving out the quotes.", "An ENUM defined as ENUM('apple','orange','pear') would have the following index values:", "IndexValue\nNULLNULL\n0''\n1'apple'\n2'orange'\n3'pear'\n\n"], "Examples": ["CREATE TABLE fruits (\n  id INT NOT NULL auto_increment PRIMARY KEY,\n  fruit ENUM('apple','orange','pear'),\n  bushels INT);\n\nDESCRIBE fruits;\n+---------+-------------------------------+------+-----+---------+----------------+\n| Field   | Type                          | Null | Key | Default | Extra          |\n+---------+-------------------------------+------+-----+---------+----------------+\n| id      | int(11)                       | NO   | PRI | NULL    | auto_increment |\n| fruit   | enum('apple','orange','pear') | YES  |     | NULL    |                |\n| bushels | int(11)                       | YES  |     | NULL    |                |\n+---------+-------------------------------+------+-----+---------+----------------+\n\nINSERT INTO fruits\n    (fruit,bushels) VALUES\n    ('pear',20),\n    ('apple',100),\n    ('orange',25);\n\nINSERT INTO fruits\n    (fruit,bushels) VALUES\n    ('avocado',10);\nERROR 1265 (01000): Data truncated for column 'fruit' at row 1\n\nSELECT * FROM fruits;\n+----+--------+---------+\n| id | fruit  | bushels |\n+----+--------+---------+\n|  1 | pear   |      20 |\n|  2 | apple  |     100 |\n|  3 | orange |      25 |\n+----+--------+---------+\n", "SELECT * FROM fruits WHERE fruit=2;\n+----+--------+---------+\n| id | fruit  | bushels |\n+----+--------+---------+\n|  3 | orange |      25 |\n+----+--------+---------+\n", "CREATE TABLE enums (a ENUM('2','1'));\n\nINSERT INTO enums VALUES ('1'),('2');\n\nSELECT * FROM enums ORDER BY a ASC;\n+------+\n| a    |\n+------+\n| 2    |\n| 1    |\n+------+\n", "SELECT * FROM enums WHERE a=1;\n+------+\n| a    |\n+------+\n| 2    |\n+------+\n\nSELECT * FROM enums WHERE a='1';\n+------+\n| a    |\n+------+\n| 1    |\n+------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/inet4/"], "Title": ["INET4"], "Feature": ["INET4\n"], "Description": ["INET4 is a data type to store IPv4 addresses, as 4-byte binary strings.", "From MariaDB 11.3.0, casting from INET4 data types to INET6 is permitted, allowing for example comparisons between the two data types, and for INET 4 values to be inserted into INET6 columns."], "Examples": ["CREATE OR REPLACE TABLE t1 (a INET4);\n\nINSERT INTO t1 VALUES('0.0.0.0'), ('255.10.0.0'), ('255.255.255.255');\n\nINSERT INTO t1 VALUES (0xa0000001);\nINSERT INTO t1 VALUES (0xf0000000);\nINSERT INTO t1 VALUES (0xff000001);\n\nSELECT HEX(a), a FROM t1 ORDER BY a;\n+----------+-----------------+\n| HEX(a)   | a               |\n+----------+-----------------+\n| 00000000 | 0.0.0.0         |\n| A0000001 | 160.0.0.1       |\n| F0000000 | 240.0.0.0       |\n| FF000001 | 255.0.0.1       |\n| FF0A0000 | 255.10.0.0      |\n| FFFFFFFF | 255.255.255.255 |\n+----------+-----------------+\n", "CREATE TABLE t1 (a INET6);\n\nINSERT INTO t1 VALUES('0.0.0.0'), ('255.10.0.0'), ('255.255.255.255');\nERROR 1292 (22007): Incorrect inet6 value: '0.0.0.0' for column `test`.`t1`.`a` at row 1\n", "CREATE TABLE t1 (a INET6);\n\nINSERT INTO t1 VALUES('0.0.0.0'), ('255.10.0.0'), ('255.255.255.255');\nQuery OK, 3 rows affected (0.027 sec)\n", "CREATE OR REPLACE TABLE t1 (i4 INET4, i6 INET6); \nINSERT INTO t1 VALUES('10.10.10.10','::ffff:192.168.0.1');\n\nSELECT LEAST(i4,i6) FROM t1;\n+--------------------+\n| LEAST(i4,i6)       |\n+--------------------+\n| ::ffff:10.10.10.10 |\n+--------------------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/inet6/"], "Title": ["INET6"], "Feature": ["INET6\n"], "Description": ["The INET6 data type is intended for storage of IPv6 addresses, as well as IPv4 addresses assuming conventional mapping of IPv4 addresses into IPv6 addresses.", "Both short and long IPv6 notation are permitted, according to RFC-5952.", "Values are stored as a 16-byte fixed length binary string, with most significant byte first.\nStorage engines see INET6 as BINARY(16).\nClients see INET6 as CHAR(39) and get text representation on retrieval.\n", "The IPv4-compatible notation is considered as deprecated. It is supported for compatibility with the INET6_ATON function, which also understands this format. It's recommended to use the mapped format to store IPv4 addresses in INET6.", "When an IPv4 mapped (or compatible) value is stored in INET6, it still occupies 16 bytes:", "Retrieval", "On retrieval, in the client-server text protocol, INET6 values are converted to the short text representation, according to RFC-5952, that is with all leading zeroes in each group removed and with consequent zero groups compressed.", "Besides creating one's own stored function, there is no a way to retrieve an INET6 value using long text representation.", "Casting", "CAST from a character string to INET6 understands addresses in short or long text notation (including IPv4 mapped and compatible addresses). NULL is returned if the format is not understood.\nCAST from a binary string to INET6 requires a 16-byte string as an argument. NULL is returned if the argument length is not equal to 16.\nCAST from other data types to INET6 first converts data to a character string, then CAST from character string to INET6 is applied.\nCAST from INET6 to CHAR returns short text address notation.\nCAST from INET6 to BINARY returns its 16-byte binary string representation.\nCAST from INET6 to data types other than CHAR (e.g. SIGNED, UNSIGNED, TIME, etc) returns an error.\n", "Comparisons", "An INET6 expression can be compared to:", "another INET6 expression\na character string expression with a text (short or long) address representation:\na 16-byte binary string expression:\n", "Attempting to compare INET6 to an expression of any other data type returns an error.", "Mixing INET6 Values for Result", "An INET6 expression can be mixed for result (i.e. UNION, CASE..THEN, COALESCE etc) with:", "another INET6 expression. The resulting data type is INET6.\na character string in text (short or long) address representation. The result data type is INET6. The character string counterpart is automatically converted to INET6. If the string format is not understood, it's converted with a warning to either NULL or to '::', depending on the NULL-ability of the result.\na 16-byte binary string. The resulting data type is INET6. The binary string counterpart is automatically converted to INET6. If the length of the binary string is not equal to 16, it's converted with a warning to NULL or to '::' depending on the NULL-ability of the result.\n", "Attempts to mix INET6 for result with other data types will return an error.", "Mixing INET6 with other data types for LEAST and GREATEST, when mixing for comparison and mixing for result are involved at the same time, uses the same rules with mixing for result, described in the previous paragraphs.", "Functions and Operators", "HEX() with an INET6 argument returns a hexadecimal representation of the underlying 16-byte binary string\nArithmetic operators (+,-,*,/,MOD,DIV) are not supported for INET6. This may change in the future.\nThe INET6_ATON function now understands INET6 values as an argument\nThe prototypes of the IS_IPV4_COMPAT and IS_IPV4_MAPPED functions have changed from a BINARY(16) to a INET6,\nWhen the argument for these two functions is not INET6, automatic implicit CAST to INET6 is applied. As a consequence, both functions now understand arguments in both text representation and binary(16) representation. Before MariaDB 10.5.0, these functions understood only binary(16) representation.\n", "Prepared Statement Parameters", "INET6 understands both text and binary(16) address representation in prepared statement parameters (PREPARE..EXECUTE and EXECUTE IMMEDIATE statements).", "Migration between  BINARY(16) and INET6", "Before MariaDB 10.5.0, you may have used BINARY(16) as a storage for IPv6 internet addresses, in combination with INET6_ATON and INET6_NTOA to respectively insert and retrieve data.", "From 10.5, you can ALTER BINARY(16) columns storing IPv6 addresses to INET6. After such an alter, there is no a need to use INET6_ATON() and INET6_NTOA(). Addresses can be inserted and retrieved directly.", "It is also possible to convert INET6 columns to BINARY(16) and continue using the data in combination with INET6_NTOA() and INET6_ATON()."], "Examples": ["CREATE TABLE t1 (a INET6);\n", "INSERT INTO t1 VALUES ('2001:db8::ff00:42:8329');\n", "INSERT INTO t1 VALUES ('2001:0db8:0000:0000:0000:ff00:0042:8329');\n", "INSERT INTO t1 VALUES (0x20010DB8000000000000FF0000428329);\nINSERT INTO t1 VALUES (UNHEX('20010DB8000000000000FF0000428329'));\n", "INSERT INTO t1 VALUES ('::ffff:192.0.2.128'); -- mapped\nINSERT INTO t1 VALUES ('::192.0.2.128'); -- compatible\n", "SELECT * FROM t1;\n+------------------------+\n| a                      |\n+------------------------+\n| 2001:db8::ff00:42:8329 |\n| 2001:db8::ff00:42:8329 |\n| 2001:db8::ff00:42:8329 |\n| 2001:db8::ff00:42:8329 |\n| ::ffff:192.0.2.128     |\n| ::192.0.2.128          |\n+------------------------+\n", "CREATE OR REPLACE TABLE t1 (a INET6);\n\nINSERT INTO t1 VALUES ('::ffff:192.0.2.128');\n\nSELECT * FROM t1;\n+--------------------+\n| a                  |\n+--------------------+\n| ::ffff:192.0.2.128 |\n+--------------------+\n\nSELECT HEX(a) FROM t1;\n+----------------------------------+\n| HEX(a)                           |\n+----------------------------------+\n| 00000000000000000000FFFFC0000280 |\n+----------------------------------+\n", "SELECT CAST(a AS DECIMAL) FROM t1;\n\nERROR 4079 (HY000): Illegal parameter data type inet6 for operation 'decimal_typecast'\n", "    CREATE OR REPLACE TABLE t1 (a INET6);\n    CREATE OR REPLACE TABLE t2 (a INET6);\n\n    INSERT INTO t1 VALUES ('2001:db8::ff00:42:8328'),('2001:db8::ff00:42:8329');\n    INSERT INTO t2 VALUES ('2001:db8::ff00:42:832a'),('2001:db8::ff00:42:8329');\n\n    SELECT t1.* FROM t1,t2 WHERE t1.a=t2.a;\n    +------------------------+\n    | a                      |\n    +------------------------+\n    | 2001:db8::ff00:42:8329 |\n    +------------------------+\n", "    CREATE OR REPLACE TABLE t1 (a INET6);\n\n    INSERT INTO t1 VALUES ('2001:db8::ff00:42:8329');\n\n    SELECT * FROM t1 WHERE a='2001:db8::ff00:42:8329';\n    +------------------------+\n    | a                      |\n    +------------------------+\n    | 2001:db8::ff00:42:8329 |\n    +------------------------+\n", "    CREATE OR REPLACE TABLE t1 (a INET6);\n\n    INSERT INTO t1 VALUES ('2001:db8::ff00:42:8329');\n\n    SELECT * FROM t1 WHERE a=X'20010DB8000000000000FF0000428329';\n    +------------------------+\n    | a                      |\n    +------------------------+\n    | 2001:db8::ff00:42:8329 |\n    +------------------------+\n", "SELECT * FROM t1 WHERE a=1;\nERROR 4078 (HY000): Illegal parameter data types inet6 and int for operation '='\n", "    CREATE OR REPLACE TABLE t1 (a INET6, b INET6);\n\n    INSERT INTO t1 VALUES (NULL,'2001:db8::ff00:42:8329');\n\n    SELECT a FROM t1 UNION SELECT b FROM t1;\n    +------------------------+\n    | a                      |\n    +------------------------+\n    | NULL                   |\n    | 2001:db8::ff00:42:8329 |\n    +------------------------+\n\n    SELECT COALESCE(a, b) FROM t1;\n    +------------------------+\n    | COALESCE(a, b)         |\n    +------------------------+\n    | 2001:db8::ff00:42:8329 |\n    +------------------------+\n", "    CREATE OR REPLACE TABLE t1 (a INET6, b VARCHAR(64));\n\n    INSERT INTO t1 VALUES (NULL,'2001:db8::ff00:42:8328');\n\n    INSERT INTO t1 VALUES (NULL,'2001:db8::ff00:42:832a garbage');\n\n    SELECT COALESCE(a,b) FROM t1;\n    +------------------------+\n    | COALESCE(a,b)          |\n    +------------------------+\n    | 2001:db8::ff00:42:8328 |\n    | NULL                   |\n    +------------------------+\n    2 rows in set, 1 warning (0.001 sec)\n\n    SHOW WARNINGS;\n    +---------+------+---------------------------------------------------------+\n    | Level   | Code | Message                                                 |\n    +---------+------+---------------------------------------------------------+\n    | Warning | 1292 | Incorrect inet6 value: '2001:db8::ff00:42:832a garbage' |\n    +---------+------+---------------------------------------------------------+\n", "    CREATE OR REPLACE TABLE t1 (a INET6, b VARBINARY(16));\n\n    INSERT INTO t1 VALUES (NULL,CONCAT(0xFFFF,REPEAT(0x0000,6),0xFFFF));\n\n    INSERT INTO t1 VALUES (NULL,0x00/*garbage*/);\n\n    SELECT COALESCE(a,b) FROM t1;\n    +---------------+\n    | COALESCE(a,b) |\n    +---------------+\n    | ffff::ffff    |\n    | NULL          |\n    +---------------+\n    2 rows in set, 1 warning (0.001 sec)\n\n    SHOW WARNINGS;\n    +---------+------+-------------------------------+\n    | Level   | Code | Message                       |\n    +---------+------+-------------------------------+\n    | Warning | 1292 | Incorrect inet6 value: '\\x00' |\n    +---------+------+-------------------------------+\n", "SELECT CAST('ffff::ffff' AS INET6) UNION SELECT 1;\nERROR 4078 (HY000): Illegal parameter data types inet6 and int for operation 'UNION'\n", "    SELECT HEX(CAST('2001:db8::ff00:42:8329' AS INET6));\n    +----------------------------------------------+\n    | HEX(CAST('2001:db8::ff00:42:8329' AS INET6)) |\n    +----------------------------------------------+\n    | 20010DB8000000000000FF0000428329             |\n    +----------------------------------------------+\n", "    CREATE OR REPLACE TABLE t1 (a INET6);\n\n    INSERT INTO t1 VALUES ('2001:db8::ff00:42:8329');\n\n    SELECT a, HEX(INET6_ATON(a)) FROM t1;\n    +------------------------+----------------------------------+\n    | a                      | HEX(INET6_ATON(a))               |\n    +------------------------+----------------------------------+\n    | 2001:db8::ff00:42:8329 | 20010DB8000000000000FF0000428329 |\n    +------------------------+----------------------------------+\n", "    CREATE OR REPLACE TABLE t1 (a INET6);\n\n    INSERT INTO t1 VALUES ('2001:db8::ff00:42:8329');\n    INSERT INTO t1 VALUES ('::ffff:192.168.0.1');\n    INSERT INTO t1 VALUES ('::192.168.0.1');\n\n    SELECT a, IS_IPV4_MAPPED(a), IS_IPV4_COMPAT(a) FROM t1;\n    +------------------------+-------------------+-------------------+\n    | a                      | IS_IPV4_MAPPED(a) | IS_IPV4_COMPAT(a) |\n    +------------------------+-------------------+-------------------+\n    | 2001:db8::ff00:42:8329 |                 0 |                 0 |\n    | ::ffff:192.168.0.1     |                 1 |                 0 |\n    | ::192.168.0.1          |                 0 |                 1 |\n    +------------------------+-------------------+-------------------+\n", "    CREATE OR REPLACE TABLE t1 (\n      a INET6,\n      b VARCHAR(39) DEFAULT a\n    );\n\n    INSERT INTO t1 (a) VALUES ('ffff::ffff'),('::ffff:192.168.0.1');\n\n    SELECT a, IS_IPV4_MAPPED(a), b, IS_IPV4_MAPPED(b) FROM t1;\n    +--------------------+-------------------+--------------------+-------------------+\n    | a                  | IS_IPV4_MAPPED(a) | b                  | IS_IPV4_MAPPED(b) |\n    +--------------------+-------------------+--------------------+-------------------+\n    | ffff::ffff         |                 0 | ffff::ffff         |                 0 |\n    | ::ffff:192.168.0.1 |                 1 | ::ffff:192.168.0.1 |                 1 |\n    +--------------------+-------------------+--------------------+-------------------+\n\n    CREATE OR REPLACE TABLE t1 (\n      a INET6,\n      b BINARY(16) DEFAULT UNHEX(HEX(a))\n    );\n\n    INSERT INTO t1 (a) VALUES ('ffff::ffff'),('::ffff:192.168.0.1');\n\n    SELECT a, IS_IPV4_MAPPED(a), HEX(b), IS_IPV4_MAPPED(b) FROM t1;\n    +--------------------+-------------------+----------------------------------+-------------------+\n    | a                  | IS_IPV4_MAPPED(a) | HEX(b)                           | IS_IPV4_MAPPED(b) |\n    +--------------------+-------------------+----------------------------------+-------------------+\n    | ffff::ffff         |                 0 | FFFF000000000000000000000000FFFF |                 0 |\n    | ::ffff:192.168.0.1 |                 1 | 00000000000000000000FFFFC0A80001 |                 1 |\n    +--------------------+-------------------+----------------------------------+-------------------+\n", "CREATE OR REPLACE TABLE t1 (a INET6);\n\nEXECUTE IMMEDIATE 'INSERT INTO t1 VALUES (?)' USING 'ffff::fffe';\nEXECUTE IMMEDIATE 'INSERT INTO t1 VALUES (?)' USING X'FFFF000000000000000000000000FFFF';\n\nSELECT * FROM t1;\n+------------+\n| a          |\n+------------+\n| ffff::fffe |\n| ffff::ffff |\n+------------+\n\nEXECUTE IMMEDIATE 'SELECT * FROM t1 WHERE a=?' USING 'ffff::fffe';\n+------------+\n| a          |\n+------------+\n| ffff::fffe |\n+------------+\n\nEXECUTE IMMEDIATE 'SELECT * FROM t1 WHERE a=?' USING X'FFFF000000000000000000000000FFFF';\n+------------+\n| a          |\n+------------+\n| ffff::ffff |\n+------------+\n", "CREATE OR REPLACE TABLE t1 (a BINARY(16));\n\nINSERT INTO t1 VALUES (INET6_ATON('ffff::ffff'));\n\nSELECT INET6_NTOA(a) FROM t1;\n+---------------+\n| INET6_NTOA(a) |\n+---------------+\n| ffff::ffff    |\n+---------------+\n", "ALTER TABLE t1 MODIFY a INET6;\n\nINSERT INTO t1 VALUES ('ffff::fffe');\n\nSELECT * FROM t1;\n+------------+\n| a          |\n+------------+\n| ffff::ffff |\n| ffff::fffe |\n+------------+\n", "CREATE OR REPLACE TABLE t1 (a INET6);\n\nINSERT INTO t1 VALUES ('2001:db8::ff00:42:8329');\nINSERT INTO t1 VALUES ('::ffff:192.168.0.1');\nINSERT INTO t1 VALUES ('::192.168.0.1');\n\nALTER TABLE t1 MODIFY a BINARY(16);\n\nSELECT INET6_NTOA(a) FROM t1;\n+------------------------+\n| INET6_NTOA(a)          |\n+------------------------+\n| 2001:db8::ff00:42:8329 |\n| ::ffff:192.168.0.1     |\n| ::192.168.0.1          |\n+------------------------+\n", "CREATE TABLE t1 (a INET6);\n\nINSERT INTO t1 VALUES('0.0.0.0'), ('255.10.0.0'), ('255.255.255.255');\nERROR 1292 (22007): Incorrect inet6 value: '0.0.0.0' for column `test`.`t1`.`a` at row 1\n", "CREATE TABLE t1 (a INET6);\n\nINSERT INTO t1 VALUES('0.0.0.0'), ('255.10.0.0'), ('255.255.255.255');\nQuery OK, 3 rows affected (0.027 sec)\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/json-data-type/"], "Title": ["JSON Data Type"], "Feature": [], "Description": [], "Examples": ["CREATE TABLE t (j JSON);\n\nDESC t;\n+-------+----------+------+-----+---------+-------+\n| Field | Type     | Null | Key | Default | Extra |\n+-------+----------+------+-----+---------+-------+\n| j     | longtext | YES  |     | NULL    |       |\n+-------+----------+------+-----+---------+-------+\n", "CREATE TABLE t2 (\n  j JSON \n  CHECK (JSON_VALID(j))\n);\n\nINSERT INTO t2 VALUES ('invalid');\nERROR 4025 (23000): CONSTRAINT `j` failed for `test`.`t2`\n\nINSERT INTO t2 VALUES ('{\"id\": 1, \"name\": \"Monty\"}');\nQuery OK, 1 row affected (0.13 sec)\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/mediumblob/"], "Title": ["MEDIUMBLOB"], "Feature": ["MEDIUMBLOB\n"], "Description": ["A BLOB column with a maximum\nlength of 16,777,215 (224 - 1) bytes.\nEach MEDIUMBLOB value is stored using a three-byte length prefix that\nindicates the number of bytes in the value. "], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/mediumtext/"], "Title": ["MEDIUMTEXT"], "Feature": ["MEDIUMTEXT [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A TEXT column with a \nmaximum length of 16,777,215 (224 - 1)\ncharacters.  The effective maximum length is less if the value\ncontains multi-byte characters. Each MEDIUMTEXT value is stored using\na three-byte length prefix that indicates the number of bytes in the\nvalue."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/longblob/"], "Title": ["LONGBLOB"], "Feature": ["LONGBLOB\n"], "Description": ["A BLOB column with a \nmaximum length of 4,294,967,295 bytes or 4GB (232 - 1). The effective maximum length of LONGBLOB columns depends on the\nconfigured maximum packet size in the client/server protocol and\navailable memory. Each LONGBLOB value is stored using a four-byte\nlength prefix that indicates the number of bytes in the value.", "Oracle Mode", "In Oracle mode from MariaDB 10.3, BLOB is a synonym for LONGBLOB."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/longtext/"], "Title": ["LONGTEXT"], "Feature": ["LONGTEXT [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A TEXT column with a maximum length of 4,294,967,295 or 4GB (232 - 1) characters. The effective maximum length is less if the value contains multi-byte characters. The effective maximum length of LONGTEXT columns also depends on the configured maximum packet size in the client/server protocol and available memory. Each LONGTEXT value is stored using a four-byte length prefix that indicates the number of bytes in the value.", "From MariaDB 10.2.7, JSON is an alias for LONGTEXT. See JSON Data Type for details."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/row/"], "Title": ["ROW"], "Feature": ["ROW (<field name> <data type> [{, <field name> <data type>}... ])"], "Description": ["ROW is a data type for stored procedure variables."], "Examples": ["DELIMITER $$\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE r ROW (c1 INT, c2 VARCHAR(10));\n  SET r.c1= 10;\n  SET r.c2= 'test';\n  INSERT INTO t1 VALUES (r.c1, r.c2);\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "DROP TABLE IF EXISTS t1;\nCREATE TABLE t1 (a INT, b VARCHAR(32));\nINSERT INTO t1 VALUES (10,'b10');\nINSERT INTO t1 VALUES (20,'b20');\nINSERT INTO t1 VALUES (30,'b30');\n\nSET sql_mode=oracle;\nDROP PROCEDURE IF EXISTS p1;\nDELIMITER $$\nCREATE PROCEDURE p1 AS\n  rec ROW(a INT, b VARCHAR(32));\n  CURSOR c IS SELECT a,b FROM t1;\nBEGIN\n  OPEN c;\n  LOOP\n    FETCH c INTO rec;\n    EXIT WHEN c%NOTFOUND;\n    SELECT ('rec=(' || rec.a ||','|| rec.b||')');\n  END LOOP;\n  CLOSE c;\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "DROP TABLE IF EXISTS t1;\nCREATE TABLE t1 (a INT, b VARCHAR(32));\nINSERT INTO t1 VALUES (10,'b10');\nINSERT INTO t1 VALUES (20,'b20');\nINSERT INTO t1 VALUES (30,'b30');\n\nSET sql_mode=DEFAULT;\nDROP PROCEDURE IF EXISTS p1;\nDELIMITER $$\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE done INT DEFAULT FALSE;\n  DECLARE rec ROW(a INT, b VARCHAR(32));\n  DECLARE c CURSOR FOR SELECT a,b FROM t1;\n  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n  OPEN c;\nread_loop:\n  LOOP\n    FETCH c INTO rec;\n    IF done THEN\n      LEAVE read_loop;\n    END IF;\n    SELECT CONCAT('rec=(',rec.a,',',rec.b,')');\n  END LOOP;\n  CLOSE c;\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "SET sql_mode=DEFAULT;\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\nCREATE TABLE t1 (a INT, b VARCHAR(32));\nINSERT INTO t1 VALUES (10,'b10');\nDELIMITER $$\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE rec1 ROW(a INT, b VARCHAR(32));\n  SELECT * FROM t1 INTO rec1;\n  SELECT rec1.a, rec1.b;\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "+--------+--------+\n| rec1.a | rec1.b |\n+--------+--------+\n|     10 | b10    |\n+--------+--------+\n", "SET sql_mode=ORACLE;\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\nCREATE TABLE t1 (a INT, b VARCHAR(32));\nINSERT INTO t1 VALUES (10,'b10');\nDELIMITER $$\nCREATE PROCEDURE p1 AS\n  rec1 ROW(a INT, b VARCHAR(32));\nBEGIN\n  SELECT * FROM t1 INTO rec1;\n  SELECT rec1.a, rec1.b;\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "+--------+--------+\n| rec1.a | rec1.b |\n+--------+--------+\n|     10 | b10    |\n+--------+--------+\n", "SET sql_mode=ORACLE;\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\nCREATE TABLE t1 (a INT, b VARCHAR(32));\nINSERT INTO t1 VALUES (10,'b10');\nDELIMITER $$\nCREATE PROCEDURE p1 AS\n  rec1 t1%ROWTYPE;\nBEGIN\n  SELECT * FROM t1 INTO rec1;\n  SELECT rec1.a, rec1.b;\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "+--------+--------+\n| rec1.a | rec1.b |\n+--------+--------+\n|     10 | b10    |\n+--------+--------+\n", "SET sql_mode=ORACLE;\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\nCREATE TABLE t1 (a INT, b VARCHAR(32));\nINSERT INTO t1 VALUES (10,'b10');\nDELIMITER $$\nCREATE PROCEDURE p1 AS\n  CURSOR cur1 IS SELECT * FROM t1;\n  rec1 cur1%ROWTYPE;\nBEGIN\n  SELECT * FROM t1 INTO rec1;\n  SELECT rec1.a, rec1.b;\nEND;\n$$\nDELIMITER ;\nCALL p1();\n", "+--------+--------+\n| rec1.a | rec1.b |\n+--------+--------+\n|     10 | b10    |\n+--------+--------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/text/"], "Title": ["TEXT"], "Feature": ["TEXT[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A TEXT column with a maximum length of 65,535 (216 - 1)\ncharacters. The effective maximum length is less if the value contains\nmulti-byte characters. Each TEXT value is stored using a two-byte length\nprefix that indicates the number of bytes in the value.  If you need a bigger storage, consider using MEDIUMTEXT instead.", "An optional length M can be given for this type. If this is done, MariaDB\ncreates the column as the smallest TEXT type large enough to hold values\nM characters long.", "Before MariaDB 10.2, all MariaDB collations were of type PADSPACE, meaning that TEXT (as well as VARCHAR and CHAR values) are compared without regard for trailing spaces. This does not apply to the LIKE pattern-matching operator, which takes into account trailing spaces.", "BLOB and TEXT columns can be assigned a DEFAULT value. This was not possible prior to MariaDB 10.2."], "Examples": ["CREATE TABLE strtest (d TEXT(10));\nINSERT INTO strtest VALUES('Maria   ');\n\nSELECT d='Maria',d='Maria   ' FROM strtest;\n+-----------+--------------+\n| d='Maria' | d='Maria   ' |\n+-----------+--------------+\n|         1 |            1 |\n+-----------+--------------+\n\nSELECT d LIKE 'Maria',d LIKE 'Maria   ' FROM strtest;\n+----------------+-------------------+\n| d LIKE 'Maria' | d LIKE 'Maria   ' |\n+----------------+-------------------+\n|              0 |                 1 |\n+----------------+-------------------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/tinyblob/"], "Title": ["TINYBLOB"], "Feature": ["TINYBLOB\n"], "Description": ["A BLOB column with a maximum length of \n255 (28 - 1) bytes. Each\nTINYBLOB value is stored using a one-byte length prefix that indicates\nthe number of bytes in the value."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/tinytext/"], "Title": ["TINYTEXT"], "Feature": ["TINYTEXT [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A TEXT column with a maximum length of 255 (28 - 1) characters. The effective maximum length is less if the value contains multi-byte characters. Each TINYTEXT value is stored using a one-byte length prefix that indicates the number of bytes in the value."], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/varbinary/"], "Title": ["VARBINARY"], "Feature": ["VARBINARY(M)\n"], "Description": ["The VARBINARY type is similar to the VARCHAR type, but stores binary byte strings rather than non-binary character strings. M represents the maximum column length in bytes. ", "It contains no character set, and comparison and sorting are based on the numeric value of the bytes.", "If the maximum length is exceeded, and SQL strict mode is not enabled , the extra characters will be dropped with a warning. If strict mode is enabled, an error will occur.", "Unlike BINARY values, VARBINARYs are not right-padded when inserting.", "Oracle Mode", "In Oracle mode from MariaDB 10.3, RAW is a synonym for VARBINARY."], "Examples": ["CREATE TABLE varbins (a VARBINARY(10));\n\nINSERT INTO varbins VALUES('12345678901');\nQuery OK, 1 row affected, 1 warning (0.04 sec)\n\nSELECT * FROM varbins;\n+------------+\n| a          |\n+------------+\n| 1234567890 |\n+------------+\n\nSET sql_mode='STRICT_ALL_TABLES';\n\nINSERT INTO varbins VALUES('12345678901');\nERROR 1406 (22001): Data too long for column 'a' at row 1\n", "TRUNCATE varbins;\n\nINSERT INTO varbins VALUES('A'),('B'),('a'),('b');\n\nSELECT * FROM varbins ORDER BY a;\n+------+\n| a    |\n+------+\n| A    |\n| B    |\n| a    |\n| b    |\n+------+\n", "SELECT * FROM varbins ORDER BY CAST(a AS CHAR);\n+------+\n| a    |\n+------+\n| a    |\n| A    |\n| b    |\n| B    |\n+------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/varchar/"], "Title": ["VARCHAR"], "Feature": ["[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A variable-length string. M represents the maximum column length in\ncharacters. The range of M is 0 to 65,532. The effective maximum\nlength of a VARCHAR is subject to the maximum row size and the character set used. For\nexample, utf8 characters can require up to three bytes per character,\nso a VARCHAR column that uses the utf8 character set can be declared\nto be a maximum of 21,844 characters.", "Note: For the ColumnStore engine, M represents the maximum column length in\nbytes.", "MariaDB stores VARCHAR values as a one-byte or two-byte length prefix\nplus data. The length prefix indicates the number of bytes in the\nvalue. A VARCHAR column uses one length byte if values require no more\nthan 255 bytes, two length bytes if values may require more than 255\nbytes.", "MariaDB follows the standard SQL specification, and does not remove trailing spaces from VARCHAR values.", "VARCHAR(0) columns can contain 2 values: an empty string or NULL. Such columns cannot be part of an index. The CONNECT storage engine does not support VARCHAR(0).", "VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is the\nstandard SQL way to define that a VARCHAR column should use some\npredefined character set. MariaDB uses utf8 as this\npredefined character set, as does MySQL 4.1 and up.\nNVARCHAR is shorthand for NATIONAL VARCHAR.", "Before MariaDB 10.2, all MariaDB collations were of type PADSPACE, meaning that VARCHAR (as well as CHAR and TEXT values) are compared without regard for trailing spaces. This does not apply to the LIKE pattern-matching operator, which takes into account trailing spaces. From MariaDB 10.2, a number of NO PAD collations are available.", "If a unique index consists of a column where trailing pad characters are stripped or ignored, inserts into that column where values differ only by the number of trailing pad characters will result in a duplicate-key error."], "Examples": ["VARCHAR(30) CHARACTER SET utf8\nNATIONAL VARCHAR(30)\nNVARCHAR(30)\nNCHAR VARCHAR(30)\nNATIONAL CHARACTER VARYING(30)\nNATIONAL CHAR VARYING(30)\n", "CREATE TABLE strtest (v VARCHAR(10));\nINSERT INTO strtest VALUES('Maria   ');\n\nSELECT v='Maria',v='Maria   ' FROM strtest;\n+-----------+--------------+\n| v='Maria' | v='Maria   ' |\n+-----------+--------------+\n|         1 |            1 |\n+-----------+--------------+\n\nSELECT v LIKE 'Maria',v LIKE 'Maria   ' FROM strtest;\n+----------------+-------------------+\n| v LIKE 'Maria' | v LIKE 'Maria   ' |\n+----------------+-------------------+\n|              0 |                 1 |\n+----------------+-------------------+\n"], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/set-data-type/"], "Title": ["SET Data Type"], "Feature": ["SET('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]\n"], "Description": ["A set. A string object that can have zero or more values, each of\nwhich must be chosen from the list of values 'value1', 'value2', ... A\nSET column can have a maximum of 64 members. SET values are\nrepresented internally as integers.", "SET values cannot contain commas.", "If a SET contains duplicate values, an error will be returned if strict mode is enabled, or a warning if strict mode is not enabled. "], "Examples": [], "Category": ["String Data Types"]}
{"HTML": ["https://mariadb.com/kb/en/uuid-data-type/"], "Title": ["UUID Data Type"], "Feature": ["UUID\n"], "Description": ["The UUID data type is intended for the storage of 128-bit UUID (Universally Unique Identifier) data. See the UUID function page for more details on UUIDs themselves.", "Retrieval", "Data retrieved by this data type is in the string representation defined in RFC4122.", "Casting", "String literals of hexadecimal characters and CHAR/VARCHAR/TEXT can be cast to the UUID data type. Likewise hexadecimal literals, binary-literals, and BINARY/VARBINARY/BLOB types can also be cast to UUID.", "The data type will not accept a short UUID generated with the UUID_SHORT function, but will accept a value without the - character generated by the SYS_GUID function (or inserted directly). Hyphens can be partially omitted as well, or included after any group of two digits.", "The type does not accept UUIDs in braces, permitted by some implementations.", "Storage", "UUID are stored in an index friendly manner, the order of a UUID of llllllll-mmmm-Vhhh-vsss-nnnnnnnnnnnn is stored as:", "nnnnnnnnnnnn-vsss-Vhhh-mmmm-llllllll\n", "This provides a sorting order, assuming a UUIDv1 (node and timestamp) is used, of the node, followed by the timestamp. The key aspect is the timestamps are sequential.", "MariaDB starting with 10.10Starting from MariaDB 10.10.6 and MariaDB 10.11.5, taking into account that UUIDv7 and other versions are designed around time ordering, UUIDs version >= 6 are now stored without byte-swapping, and UUIDs with version >=8 and variant=0 are now considered invalid (as the standard expects)\n"], "Examples": ["CREATE TABLE t1 (id UUID);\n", "INSERT INTO t1 VALUES('123e4567-e89b-12d3-a456-426655440000');\n", "INSERT INTO t1 VALUES (x'fffffffffffffffffffffffffffffffe');\n", "INSERT INTO t1 VALUES (UUID());\n\n", "SELECT * FROM t1;\n+--------------------------------------+\n| id                                   |\n+--------------------------------------+\n| 123e4567-e89b-12d3-a456-426655440000 |\n| ffffffff-ffff-ffff-ffff-fffffffffffe |\n| 93aac041-1a14-11ec-ab4e-f859713e4be4 |\n+--------------------------------------+\n", "INSERT INTO t1 VALUES (UUID_SHORT());\nERROR 1292 (22007): Incorrect uuid value: '99440417627439104' \n  for column `test`.`t1`.`id` at row 1\n", "INSERT INTO t1 VALUES (SYS_GUID());\n\nSELECT * FROM t1;\n+--------------------------------------+\n| id                                   |\n+--------------------------------------+\n| 123e4567-e89b-12d3-a456-426655440000 |\n| ffffffff-ffff-ffff-ffff-fffffffffffe |\n| 93aac041-1a14-11ec-ab4e-f859713e4be4 |\n| ea0368d3-1a14-11ec-ab4e-f859713e4be4 |\n+--------------------------------------+\n\nSELECT SYS_GUID();\n+----------------------------------+\n| SYS_GUID()                       |\n+----------------------------------+\n| ff5b6bcc1a1411ecab4ef859713e4be4 |\n+----------------------------------+\n\nINSERT INTO t1 VALUES ('ff5b6bcc1a1411ecab4ef859713e4be4');\n\nSELECT * FROM t1;\n+--------------------------------------+\n| id                                   |\n+--------------------------------------+\n| 123e4567-e89b-12d3-a456-426655440000 |\n| ffffffff-ffff-ffff-ffff-fffffffffffe |\n| 93aac041-1a14-11ec-ab4e-f859713e4be4 |\n| ea0368d3-1a14-11ec-ab4e-f859713e4be4 |\n| ff5b6bcc-1a14-11ec-ab4e-f859713e4be4 |\n+--------------------------------------+\n", "TRUNCATE t1;\n\nINSERT INTO t1 VALUES ('f8aa-ed66-1a1b-11ec-ab4e-f859-713e-4be4');\n\nINSERT INTO t1 VALUES ('1b80667f1a1c-11ecab4ef859713e4be4');\n\nINSERT INTO t1 VALUES ('2fd6c945-1a-1c-11ec-ab4e-f859713e4be4');\n\nINSERT INTO t1 VALUES ('49-c9-f9-59-1a-1c-11ec-ab4e-f859713e4be4');\n\nINSERT INTO t1 VALUES ('57-96-da-c1-1a-1c-11-ec-ab-4e-f8-59-71-3e-4b-e4');\n\nINSERT INTO t1 VALUES ('6-eb74f8f-1a1c-11ec-ab4e-f859713e4be4');\n\nINSERT INTO t1 VALUES ('{29bad136-1a1d-11ec-ab4e-f859713e4be4}');\nERROR 1292 (22007): Incorrect uuid value: '{29bad136-1a1d-11ec-ab4e-f859713e4be4}' \n  for column `test`.`t1`.`id` at row 1\n\nSELECT * FROM t1;\n+--------------------------------------+\n| id                                   |\n+--------------------------------------+\n| f8aaed66-1a1b-11ec-ab4e-f859713e4be4 |\n| 1b80667f-1a1c-11ec-ab4e-f859713e4be4 |\n| 2fd6c945-1a1c-11ec-ab4e-f859713e4be4 |\n| 49c9f959-1a1c-11ec-ab4e-f859713e4be4 |\n| 5796dac1-1a1c-11ec-ab4e-f859713e4be4 |\n| 6eb74f8f-1a1c-11ec-ab4e-f859713e4be4 |\n+--------------------------------------+\n"], "Category": ["String Data Types"]}
