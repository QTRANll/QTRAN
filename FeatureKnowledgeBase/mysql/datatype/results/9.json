{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.0/en/char.html"
    ],
    "Title": [
        "13.3.2 The CHAR and VARCHAR Types"
    ],
    "Feature": [
        "13.3.2 The CHAR and VARCHAR Types"
    ],
    "Description": [
        "\n\n\n\n13.3.2\u00a0The CHAR and VARCHAR Types\n\n\n\n\n        The CHAR and VARCHAR types\n        are similar, but differ in the way they are stored and\n        retrieved. They also differ in maximum length and in whether\n        trailing spaces are retained.\n      \n        The CHAR and VARCHAR types\n        are declared with a length that indicates the maximum number of\n        characters you want to store. For example,\n        CHAR(30) can hold up to 30 characters.\n      \n        The length of a CHAR column is fixed to the\n        length that you declare when you create the table. The length\n        can be any value from 0 to 255. When CHAR\n        values are stored, they are right-padded with spaces to the\n        specified length. When CHAR values are\n        retrieved, trailing spaces are removed unless the\n        PAD_CHAR_TO_FULL_LENGTH SQL\n        mode is enabled.\n      \n        Values in VARCHAR columns are variable-length\n        strings. The length can be specified as a value from 0 to\n        65,535. The effective maximum length of a\n        VARCHAR is subject to the maximum row size\n        (65,535 bytes, which is shared among all columns) and the\n        character set used. See Section\u00a010.4.7, \u201cLimits on Table Column Count and Row Size\u201d.\n      \n        In contrast to CHAR,\n        VARCHAR values are stored as a 1-byte or\n        2-byte length prefix plus data. The length prefix indicates the\n        number of bytes in the value. A column uses one length byte if\n        values require no more than 255 bytes, two length bytes if\n        values may require more than 255 bytes.\n      \n        If strict SQL mode is not enabled and you assign a value to a\n        CHAR or VARCHAR column\n        that exceeds the column's maximum length, the value is truncated\n        to fit and a warning is generated. For truncation of nonspace\n        characters, you can cause an error to occur (rather than a\n        warning) and suppress insertion of the value by using strict SQL\n        mode. See Section\u00a07.1.11, \u201cServer SQL Modes\u201d.\n      \n        For VARCHAR columns, trailing spaces in\n        excess of the column length are truncated prior to insertion and\n        a warning is generated, regardless of the SQL mode in use. For\n        CHAR columns, truncation of excess trailing\n        spaces from inserted values is performed silently regardless of\n        the SQL mode.\n      \nVARCHAR values are not padded when they are\n        stored. Trailing spaces are retained when values are stored and\n        retrieved, in conformance with standard SQL.\n      \n        The following table illustrates the differences between\n        CHAR and VARCHAR by\n        showing the result of storing various string values into\n        CHAR(4) and VARCHAR(4)\n        columns (assuming that the column uses a single-byte character\n        set such as latin1).\n\n\n\nValue\nCHAR(4)\nStorage Required\nVARCHAR(4)\nStorage Required\n\n''\n'\u00a0\u00a0\u00a0\u00a0'\n4 bytes\n''\n1 byte\n\n'ab'\n'ab\u00a0\u00a0'\n4 bytes\n'ab'\n3 bytes\n\n'abcd'\n'abcd'\n4 bytes\n'abcd'\n5 bytes\n\n'abcdefgh'\n'abcd'\n4 bytes\n'abcd'\n5 bytes\n\n\n\n        The values shown as stored in the last row of the table apply\n        only when not using strict SQL mode; if\n        strict mode is enabled, values that exceed the column length are\n        not stored, and an error results.\n      \nInnoDB encodes fixed-length fields greater\n        than or equal to 768 bytes in length as variable-length fields,\n        which can be stored off-page. For example, a\n        CHAR(255) column can exceed 768 bytes if the\n        maximum byte length of the character set is greater than 3, as\n        it is with utf8mb4.\n      \n        If a given value is stored into the CHAR(4)\n        and VARCHAR(4) columns, the values retrieved\n        from the columns are not always the same because trailing spaces\n        are removed from CHAR columns upon retrieval.\n        The following example illustrates this difference:\n      Press CTRL+C to copy mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> INSERT INTO vc VALUES ('ab  ', 'ab  ');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;\n+---------------------+---------------------+\n| CONCAT('(', v, ')') | CONCAT('(', c, ')') |\n+---------------------+---------------------+\n| (ab  )              | (ab)                |\n+---------------------+---------------------+\n1 row in set (0.06 sec)\n        Values in CHAR, VARCHAR,\n        and TEXT columns are sorted and compared\n        according to the character set collation assigned to the column.\n      \n        MySQL collations have a pad attribute of PAD\n        SPACE, other than Unicode collations based on UCA\n        9.0.0 and higher, which have a pad attribute of NO\n        PAD. (see Section\u00a012.10.1, \u201cUnicode Character Sets\u201d).\n      \n        To determine the pad attribute for a collation, use the\n        INFORMATION_SCHEMA\nCOLLATIONS table, which has a\n        PAD_ATTRIBUTE column.\n      \n        For nonbinary strings (CHAR,\n        VARCHAR, and TEXT values),\n        the string collation pad attribute determines treatment in\n        comparisons of trailing spaces at the end of strings.\n        NO PAD collations treat trailing spaces as\n        significant in comparisons, like any other character.\n        PAD SPACE collations treat trailing spaces as\n        insignificant in comparisons; strings are compared without\n        regard to trailing spaces. See\n        Trailing Space Handling in Comparisons.\n        The server SQL mode has no effect on comparison behavior with\n        respect to trailing spaces.\n\n\n\nNote\n\n\n          For more information about MySQL character sets and\n          collations, see Chapter\u00a012, Character Sets, Collations, Unicode. For additional\n          information about storage requirements, see\n          Section\u00a013.7, \u201cData Type Storage Requirements\u201d.\n\n\n\n        For those cases where trailing pad characters are stripped or\n        comparisons ignore them, if a column has an index that requires\n        unique values, inserting into the column values that differ only\n        in number of trailing pad characters results in a duplicate-key\n        error. For example, if a table contains 'a',\n        an attempt to store 'a\u00a0' causes a\n        duplicate-key error.\n\n"
    ],
    "Examples": [
        "mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> INSERT INTO vc VALUES ('ab  ', 'ab  ');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;\n+---------------------+---------------------+\n| CONCAT('(', v, ')') | CONCAT('(', c, ')') |\n+---------------------+---------------------+\n| (ab  )              | (ab)                |\n+---------------------+---------------------+\n1 row in set (0.06 sec)"
    ],
    "Category": [
        "The CHAR and VARCHAR Types"
    ],
    "EffectiveSQLsRefined": [
        "CREATE TABLE vc (v VARCHAR(4), c CHAR(4));",
        "INSERT INTO vc VALUES ('ab  ', 'ab  ');",
        "SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;"
    ],
    "EffectiveSQLsGenerated": [],
    "EffectiveSQLsGeneratedCosts": [],
    "EffectiveSQLsGeneratedErrors": [],
    "EffectiveSQLs": [
        "CREATE TABLE vc (v VARCHAR(4), c CHAR(4));",
        "INSERT INTO vc VALUES ('ab  ', 'ab  ');",
        "SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;"
    ]
}