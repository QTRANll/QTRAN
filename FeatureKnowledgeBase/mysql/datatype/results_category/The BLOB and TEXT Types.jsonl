{"HTML": ["https://dev.mysql.com/doc/refman/8.0/en/blob.html"], "Title": ["13.3.4 The BLOB and TEXT Types"], "Feature": ["13.3.4 The BLOB and TEXT Types"], "Description": ["\n\n\n\n13.3.4\u00a0The BLOB and TEXT Types\n\n\n\n\n        A BLOB is a binary large object that can hold\n        a variable amount of data. The four BLOB\n        types are TINYBLOB, BLOB,\n        MEDIUMBLOB, and LONGBLOB.\n        These differ only in the maximum length of the values they can\n        hold. The four TEXT types are\n        TINYTEXT, TEXT,\n        MEDIUMTEXT, and LONGTEXT.\n        These correspond to the four BLOB types and\n        have the same maximum lengths and storage requirements. See\n        Section\u00a013.7, \u201cData Type Storage Requirements\u201d.\n      \nBLOB values are treated as binary strings\n        (byte strings). They have the binary\n        character set and collation, and comparison and sorting are\n        based on the numeric values of the bytes in column values.\n        TEXT values are treated as nonbinary strings\n        (character strings). They have a character set other than\n        binary, and values are sorted and compared\n        based on the collation of the character set.\n      \n        If strict SQL mode is not enabled and you assign a value to a\n        BLOB or TEXT column that\n        exceeds the column's maximum length, the value is truncated to\n        fit and a warning is generated. For truncation of nonspace\n        characters, you can cause an error to occur (rather than a\n        warning) and suppress insertion of the value by using strict SQL\n        mode. See Section\u00a07.1.11, \u201cServer SQL Modes\u201d.\n      \n        Truncation of excess trailing spaces from values to be inserted\n        into TEXT columns always\n        generates a warning, regardless of the SQL mode.\n      \n        For TEXT and BLOB columns,\n        there is no padding on insert and no bytes are stripped on\n        select.\n      \n        If a TEXT column is indexed, index entry\n        comparisons are space-padded at the end. This means that, if the\n        index requires unique values, duplicate-key errors occur for\n        values that differ only in the number of trailing spaces. For\n        example, if a table contains 'a', an attempt\n        to store 'a\u00a0' causes a duplicate-key\n        error. This is not true for BLOB columns.\n      \n        In most respects, you can regard a BLOB\n        column as a VARBINARY column that\n        can be as large as you like. Similarly, you can regard a\n        TEXT column as a\n        VARCHAR column.\n        BLOB and TEXT differ from\n        VARBINARY and\n        VARCHAR in the following ways:\n\n\n\n            For indexes on BLOB and\n            TEXT columns, you must specify an index\n            prefix length. For CHAR and\n            VARCHAR, a prefix length is\n            optional. See Section\u00a010.3.5, \u201cColumn Indexes\u201d.\n          \n\n\n\nBLOB and TEXT columns\n            cannot have DEFAULT values.\n\n\n\n        If you use the BINARY attribute with a\n        TEXT data type, the column is assigned the\n        binary (_bin) collation of the column\n        character set.\n      \nLONG and LONG VARCHAR map\n        to the MEDIUMTEXT data type. This is a\n        compatibility feature.\n      \n        MySQL Connector/ODBC defines BLOB values as\n        LONGVARBINARY and TEXT\n        values as LONGVARCHAR.\n      \n        Because BLOB and TEXT\n        values can be extremely long, you might encounter some\n        constraints in using them:\n\n\n\n            Only the first\n            max_sort_length bytes of\n            the column are used when sorting. The default value of\n            max_sort_length is 1024.\n            You can make more bytes significant in sorting or grouping\n            by increasing the value of\n            max_sort_length at server\n            startup or runtime. Any client can change the value of its\n            session max_sort_length\n            variable:\n          Press CTRL+C to copy mysql> SET max_sort_length = 2000;\nmysql> SELECT id, comment FROM t\n    -> ORDER BY comment;\n            Instances of BLOB or\n            TEXT columns in the result of a query\n            that is processed using a temporary table causes the server\n            to use a table on disk rather than in memory because the\n            MEMORY storage engine does not support\n            those data types (see\n            Section\u00a010.4.4, \u201cInternal Temporary Table Use in MySQL\u201d). Use of disk\n            incurs a performance penalty, so include\n            BLOB or TEXT columns\n            in the query result only if they are really needed. For\n            example, avoid using\n            SELECT *,\n            which selects all columns.\n          \n            The maximum size of a BLOB or\n            TEXT object is determined by its type,\n            but the largest value you actually can transmit between the\n            client and server is determined by the amount of available\n            memory and the size of the communications buffers. You can\n            change the message buffer size by changing the value of the\n            max_allowed_packet\n            variable, but you must do so for both the server and your\n            client program. For example, both mysql\n            and mysqldump enable you to change the\n            client-side\n            max_allowed_packet value.\n            See Section\u00a07.1.1, \u201cConfiguring the Server\u201d,\n            Section\u00a06.5.1, \u201cmysql \u2014 The MySQL Command-Line Client\u201d, and Section\u00a06.5.4, \u201cmysqldump \u2014 A Database Backup Program\u201d.\n            You may also want to compare the packet sizes and the size\n            of the data objects you are storing with the storage\n            requirements, see Section\u00a013.7, \u201cData Type Storage Requirements\u201d\n\n\n\n        Each BLOB or TEXT value is\n        represented internally by a separately allocated object. This is\n        in contrast to all other data types, for which storage is\n        allocated once per column when the table is opened.\n      \n        In some cases, it may be desirable to store binary data such as\n        media files in BLOB or\n        TEXT columns. You may find MySQL's string\n        handling functions useful for working with such data. See\n        Section\u00a014.8, \u201cString Functions and Operators\u201d. For security and other\n        reasons, it is usually preferable to do so using application\n        code rather than giving application users the\n        FILE privilege. You can discuss\n        specifics for various languages and platforms in the MySQL\n        Forums (http://forums.mysql.com/).\n\n\n\nNote\n\n\n          Within the mysql client, binary strings\n          display using hexadecimal notation, depending on the value of\n          the --binary-as-hex. For more\n          information about that option, see Section\u00a06.5.1, \u201cmysql \u2014 The MySQL Command-Line Client\u201d.\n\n\n"], "Examples": ["mysql> SET max_sort_length = 2000;\nmysql> SELECT id, comment FROM t\n    -> ORDER BY comment;"], "Category": ["The BLOB and TEXT Types"]}
