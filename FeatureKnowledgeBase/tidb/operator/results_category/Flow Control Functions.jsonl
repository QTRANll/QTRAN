{"HTML": "https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#operator_case", "Title": "CASE", "Feature": ["CASE\n          value WHEN\n          compare_value THEN\n          result [WHEN\n          compare_value THEN\n          result ...] [ELSE\n          result] END"], "Description": ["\nCASE\n          value WHEN\n          compare_value THEN\n          result [WHEN\n          compare_value THEN\n          result ...] [ELSE\n          result] END\n", "\nCASE WHEN\n          condition THEN\n          result [WHEN\n          condition THEN\n          result ...] [ELSE\n          result] END\n", "\n          The first CASE syntax returns the\n          result for the first\n          value=compare_value\n          comparison that is true. The second syntax returns the result\n          for the first condition that is true. If no comparison or\n          condition is true, the result after ELSE is\n          returned, or NULL if there is no\n          ELSE part.\n", "\n\nNote\n\n\n            The syntax of the CASE\noperator described here differs\n            slightly from that of the SQL\n            CASE\nstatement described in\n            Section\u00a015.6.5.1, \u201cCASE Statement\u201d, for use inside stored programs. The\n            CASE statement cannot have an\n            ELSE NULL clause, and it is terminated\n            with END CASE instead of\n            END.\n\n", "\n          The return type of a CASE\n          expression result is the aggregated type of all result values:\n", "\n\n              If all types are numeric, the aggregated type is also\n              numeric:\n\n\n\n                  If at least one argument is double precision, the\n                  result is double precision.\n                \n                  Otherwise, if at least one argument is\n                  DECIMAL, the result is\n                  DECIMAL.\n                \n                  Otherwise, the result is an integer type (with one\n                  exception):\n\n\n\n                      If all integer types are all signed or all\n                      unsigned, the result is the same sign and the\n                      precision is the highest of all specified integer\n                      types (that is,\n                      TINYINT,\n                      SMALLINT,\n                      MEDIUMINT,\n                      INT, or\n                      BIGINT).\n                    \n                      If there is a combination of signed and unsigned\n                      integer types, the result is signed and the\n                      precision may be higher. For example, if the types\n                      are signed INT and\n                      unsigned INT, the\n                      result is signed\n                      BIGINT.\n                    \n                      The exception is unsigned\n                      BIGINT combined\n                      with any signed integer type. The result is\n                      DECIMAL with\n                      sufficient precision and scale 0.\n\n\n\n\n\n              If all types are BIT, the\n              result is BIT. Otherwise,\n              BIT arguments are treated\n              similar to BIGINT.\n            \n              If all types are YEAR, the\n              result is YEAR. Otherwise,\n              YEAR arguments are treated similar to\n              INT.\n            \n              If all types are character string\n              (CHAR or\n              VARCHAR), the result is\n              VARCHAR with maximum length\n              determined by the longest character length of the\n              operands.\n            \n              If all types are character or binary string, the result is\n              VARBINARY.\n            \nSET and\n              ENUM are treated similar to\n              VARCHAR; the result is\n              VARCHAR.\n            \n              If all types are JSON, the\n              result is JSON.\n            \n              If all types are temporal, the result is temporal:\n\n\n\n                  If all temporal types are\n                  DATE,\n                  TIME, or\n                  TIMESTAMP, the result\n                  is DATE,\n                  TIME, or\n                  TIMESTAMP,\n                  respectively.\n                \n                  Otherwise, for a mix of temporal types, the result is\n                  DATETIME.\n\n\n\n              If all types are GEOMETRY, the result\n              is GEOMETRY.\n            \n              If any type is BLOB, the\n              result is BLOB.\n            \n              For all other type combinations, the result is\n              VARCHAR.\n            \n              Literal NULL operands are ignored for\n              type aggregation.\n\n", "Press CTRL+C to copy mysql> SELECT CASE 1 WHEN 1 THEN 'one'\n    ->     WHEN 2 THEN 'two' ELSE 'more' END;\n        -> 'one'\nmysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;\n        -> 'true'\nmysql> SELECT CASE BINARY 'B'\n    ->     WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;\n        -> NULL"], "Examples": ["mysql> SELECT CASE 1 WHEN 1 THEN 'one'\n    ->     WHEN 2 THEN 'two' ELSE 'more' END;\n        -> 'one'\nmysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;\n        -> 'true'\nmysql> SELECT CASE BINARY 'B'\n    ->     WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;\n        -> NULL"], "Category": ["Flow Control Functions"]}
