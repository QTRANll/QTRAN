{"HTML": ["https://mariadb.com//kb/en/analyze-table/"], "Title": ["ANALYZE TABLE"], "Feature": ["ANALYZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE tbl_name [,tbl_name ...]\n  [PERSISTENT FOR \n    { ALL\n      | COLUMNS ([col_name [,col_name ...]]) INDEXES ([index_name [,index_name ...]])\n    }\n  ]         \n"], "Description": ["ANALYZE TABLE analyzes and stores the key distribution for a\ntable (index statistics). This statement works with MyISAM, Aria and InnoDB tables. During the analysis, InnoDB will allow reads/writes, and MyISAM/Aria reads/inserts. For MyISAM tables, this statement is equivalent to using myisamchk --analyze.", "For more information on how the analysis works within InnoDB, see\nInnoDB Limitations.", "MariaDB uses the stored key distribution to decide the order in which\ntables should be joined when you perform a join on something other than\na constant. In addition, key distributions can be used when deciding\nwhich indexes to use for a specific table within a query.", "This statement requires SELECT and INSERT privileges for the table.", "By default, ANALYZE TABLE statements are written to the binary log and will be replicated. The NO_WRITE_TO_BINLOG keyword (LOCAL is an alias) will ensure the statement is not written to the binary log. ", "From MariaDB 10.3.19, ANALYZE TABLE statements are not logged to the binary log if read_only is set. See also Read-Only Replicas.", "ANALYZE TABLE is also supported for partitioned tables. You\ncan use ALTER TABLE ... ANALYZE PARTITION to analyze one or\nmore partitions.", "The Aria storage engine supports progress reporting for the ANALYZE TABLE statement."], "Examples": ["-- update all engine-independent statistics for all columns and indexes\nANALYZE TABLE tbl PERSISTENT FOR ALL;\n\n-- update specific columns and indexes:\nANALYZE TABLE tbl PERSISTENT FOR COLUMNS (col1,col2,...) INDEXES (idx1,idx2,...);\n\n-- empty lists are allowed:\nANALYZE TABLE tbl PERSISTENT FOR COLUMNS (col1,col2,...) INDEXES ();\nANALYZE TABLE tbl PERSISTENT FOR COLUMNS () INDEXES (idx1,idx2,...);\n\n-- the following will only update mysql.table_stats fields:\nANALYZE TABLE tbl PERSISTENT FOR COLUMNS () INDEXES ();\n\n-- when use_stat_tables is set to 'COMPLEMENTARY' or 'PREFERABLY', \n-- a simple ANALYZE TABLE  collects engine-independent statistics for all columns and indexes.\nSET SESSION use_stat_tables='COMPLEMENTARY';\nANALYZE TABLE tbl;\n"], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/repair-table/"], "Title": ["REPAIR TABLE"], "Feature": ["<= MariaDB 11.4", "REPAIR [NO_WRITE_TO_BINLOG | LOCAL] TABLE\n    tbl_name [, tbl_name] ...\n    [QUICK] [EXTENDED] [USE_FRM]\n", " >= MariaDB 11.5", "REPAIR [NO_WRITE_TO_BINLOG | LOCAL] TABLE\n    tbl_name [, tbl_name] ...\n    [QUICK] [EXTENDED] [USE_FRM] [FORCE]\n"], "Description": ["REPAIR TABLE repairs a possibly corrupted table. By default,\nit has the same effect as", "myisamchk --recover tbl_name\n", "or", "aria_chk --recover tbl_name\n", "See aria_chk and myisamchk for more.", "REPAIR TABLE works for Archive, Aria, CSV and MyISAM tables. For InnoDB, see recovery modes. For CSV, see also Checking and Repairing CSV Tables. For Archive, this statement also improves compression. If the storage engine does not support this statement, a warning is issued.", "This statement requires SELECT and INSERT privileges for the table.", "By default, REPAIR TABLE statements are written to the binary log and will be replicated. The NO_WRITE_TO_BINLOG keyword (LOCAL is an alias) will ensure the statement is not written to the binary log.", "From MariaDB 10.3.19, REPAIR TABLE statements are not logged to the binary log if read_only is set. See also Read-Only Replicas.", "When an index is recreated, the storage engine may use a configurable buffer in the process. Incrementing the buffer speeds up the index creation. Aria and MyISAM allocate a buffer whose size is defined by aria_sort_buffer_size or myisam_sort_buffer_size, also used for ALTER TABLE.", "QUICK", "When specified, REPAIR TABLE will not modify the data file, only attempting to repair the index file. The same behavior can be achieved with myisamchk --recover --quick.", "EXTENDED", "Creates the index row by row rather than sorting and creating a single index. Similar to myisamchk --safe-recover. ", "USE_FRM", "For use only when the index file is missing or its header corrupted. MariaDB then attempts to recreate it using the .frm file. There is no equivalent myisamchk option. ", "MariaDB starting with 11.5FORCE\nThe FORCE argument was added in MariaDB 11.5 to allow one to first run internal repair to fix damaged blocks and then follow it with ALTER TABLE (MDEV-33449).\n", "Partitioned Tables", "REPAIR TABLE is also supported for partitioned tables with the ALTER TABLE ... REPAIR PARTITION statement. However, the USE_FRM option cannot be used with this statement on a partitioned table. See Repairing Partitions for details.", "Progress Reporting", "The Aria storage engine supports progress reporting for this statement."], "Examples": [], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/repair-view/"], "Title": ["REPAIR VIEW"], "Feature": ["REPAIR [NO_WRITE_TO_BINLOG | LOCAL] VIEW  view_name[, view_name] ... [FROM MYSQL]\n"], "Description": ["The REPAIR VIEW statement was introduced to assist with fixing MDEV-6916, an issue introduced in MariaDB 5.2 where the view algorithms were swapped compared to their MySQL on disk representation. It checks whether the view algorithm is correct. It is run as part of mariadb-upgrade, and should not normally be required in regular use.", "By default it corrects the checksum and if necessary adds the mariadb-version field. If the optional FROM MYSQL clause is used, and no mariadb-version field is present, the MERGE and TEMPTABLE algorithms are toggled.", "By default, REPAIR VIEW statements are written to the binary log and will be replicated. The NO_WRITE_TO_BINLOG keyword (LOCAL is an alias) will ensure the statement is not written to the binary log."], "Examples": [], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/restore-table-removed/"], "Title": ["RESTORE TABLE (removed)"], "Feature": ["RESTORE TABLE tbl_name [, tbl_name] ... FROM '/path/to/backup/directory'"], "Description": ["Note: Like BACKUP TABLE, this command was not reliable and has been removed in current versions of MariaDB. For doing a backup of MariaDB use mysqldump, mysqlhotcopy or XtraBackup. See Backing Up and Restoring.\n", "RESTORE TABLE restores the table or tables from a backup\nthat was made with BACKUP TABLE. The\ndirectory should be specified as a full path name.", "Existing tables are not overwritten; if you try to restore over an existing\ntable, an error occurs. Just as for BACKUP TABLE,\nRESTORE TABLE works only for MyISAM tables.\nRestored tables are not replicated from master to slave.", "The backup for each table consists of its .frm format file and .MYD\ndata file. The restore operation restores those files, and then uses\nthem to rebuild the .MYI index file. Restoring takes longer than\nbacking up due to the need to rebuild the indexes. The more indexes the\ntable has, the longer it takes."], "Examples": [], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/backup-table-removed/"], "Title": ["BACKUP TABLE (removed)"], "Feature": ["BACKUP TABLE tbl_name [, tbl_name] ... TO '/path/to/backup/directory'\n"], "Description": ["Note: Like RESTORE TABLE, this command was not reliable and has been removed in current versions of MariaDB.\n", "For doing a backup of MariaDB use mysqldump or MariaDB Backup. See Backing Up and Restoring."], "Examples": [], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/check-table/"], "Title": ["CHECK TABLE"], "Feature": ["CHECK TABLE tbl_name [, tbl_name] ... [option] ...\n\noption = {FOR UPGRADE | QUICK | FAST | MEDIUM | EXTENDED | CHANGED}\n"], "Description": ["CHECK TABLE checks a table or tables for errors. CHECK TABLE works for\nArchive, Aria, CSV, InnoDB and MyISAM tables. For Aria and MyISAM tables, the\nkey statistics are updated as well. For CSV, see also Checking and Repairing CSV Tables.", "As an alternative, myisamchk is a commandline tool for checking MyISAM tables when the tables are not being accessed. For Aria tables, there is a similar tool: aria_chk.", "For checking dynamic columns integrity, COLUMN_CHECK() can be used.", "CHECK TABLE can also check views for problems, such as tables\nthat are referenced in the view definition that no longer exist.", "CHECK TABLE is also supported for partitioned tables. You can\nuse ALTER TABLE ... CHECK PARTITION \nto check one or more partitions.", "The meaning of the different options are as follows - note that this can vary a bit between\nstorage engines:", "FOR UPGRADEDo a very quick check if the storage format for the table has changed so that one needs to do a REPAIR. This is only needed when one upgrades between major versions of MariaDB or MySQL. This is usually done by running mariadb-upgrade.\nFASTOnly check tables that has not been closed properly or are marked as corrupt. Only supported by the MyISAM and Aria engines. For other engines the table is checked normally\nCHANGEDCheck only tables that has changed since last REPAIR / CHECK. Only supported by the MyISAM and Aria engines. For other engines the table is checked normally.\nQUICKDo a fast check. For MyISAM and Aria, this means skipping the check of the delete link chain, which may take some time.\nMEDIUMScan also the data files. Checks integrity between data and index files with checksums. In most cases this should find all possible errors.\nEXTENDEDDoes a full check to verify every possible error. For InnoDB, Aria, and MyISAM, verify for each row that all its keys exists, and for those index keys, they point back to the primary clustered key. This may take a long time on large tables. This option was previously ignored by InnoDB before MariaDB 10.6.11, MariaDB 10.7.7, MariaDB 10.8.6 and MariaDB 10.9.4.\n\n", "For most cases running CHECK TABLE without options or MEDIUM should be\ngood enough.", "The Aria storage engine supports progress reporting for this statement.", "If you want to know if two tables are identical, take a look\nat CHECKSUM TABLE."], "Examples": ["check table y extended;\n+--------+-------+----------+----------+\n| Table  | Op    | Msg_type | Msg_text |\n+--------+-------+----------+----------+\n| test.y | check | status   | OK       |\n+--------+-------+----------+----------+\n"], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/truncate-table/"], "Title": ["TRUNCATE TABLE"], "Feature": ["TRUNCATE [TABLE] tbl_name\n  [WAIT n | NOWAIT]\n"], "Description": ["TRUNCATE TABLE empties a table completely. It requires the DROP privilege. See GRANT.", "tbl_name can also be specified in the form db_name.tbl_name (see Identifier Qualifiers).", "Logically, TRUNCATE TABLE is equivalent to a DELETE statement that deletes all rows, but there are practical differences under some circumstances.", "TRUNCATE TABLE will fail for an InnoDB table if any FOREIGN KEY constraints from other tables reference the table, returning the error:", "ERROR 1701 (42000): Cannot truncate a table referenced in a foreign key constraint\n", "Foreign Key constraints between columns in the same table are permitted.", "For an InnoDB table, if there are no FOREIGN KEY constraints, InnoDB performs fast truncation by dropping the original table and creating an empty one with the same definition, which is much faster than deleting rows one by one. The AUTO_INCREMENT counter is reset by TRUNCATE TABLE, regardless of whether there is a FOREIGN KEY constraint.", "The count of rows affected by TRUNCATE TABLE is accurate only\nwhen it is mapped to a DELETE statement.", "For other storage engines, TRUNCATE TABLE differs from\nDELETE in the following ways:", "Truncate operations drop and re-create the table, which is much\n  faster than deleting rows one by one, particularly for large tables.\nTruncate operations cause an implicit commit.\nTruncation operations cannot be performed if the session holds an\n  active table lock.\nTruncation operations do not return a meaningful value for the number\n  of deleted rows. The usual result is \"0 rows affected,\" which should\n  be interpreted as \"no information.\"\nAs long as the table format file tbl_name.frm is valid, the\n  table can be re-created as an empty table\n  with TRUNCATE TABLE, even if the data or index files have become\n  corrupted.\nThe table handler does not remember the last\n  used AUTO_INCREMENT value, but starts counting\n  from the beginning. This is true even for MyISAM and InnoDB, which normally\n  do not reuse sequence values.\nWhen used with partitioned tables, TRUNCATE TABLE preserves\n  the partitioning; that is, the data and index files are dropped and\n  re-created, while the partition definitions (.par) file is\n  unaffected.\nSince truncation of a table does not make any use of DELETE,\n  the TRUNCATE statement does not invoke ON DELETE triggers.\nTRUNCATE TABLE will only reset the values in the Performance Schema summary tables to zero or null, and will not remove the rows.\n", "For the purposes of binary logging and replication, TRUNCATE TABLE is treated as DROP TABLE followed by CREATE TABLE (DDL rather than DML).", "TRUNCATE TABLE does not work on views. Currently, TRUNCATE TABLE drops all historical records from a system-versioned table.", "WAIT/NOWAIT", "Set the lock wait timeout. See WAIT and NOWAIT.", "Oracle-mode", "Oracle-mode from MariaDB 10.3 permits the optional keywords REUSE STORAGE or DROP STORAGE to be used.", "TRUNCATE [TABLE] tbl_name [{DROP | REUSE} STORAGE] [WAIT n | NOWAIT]\n", "These have no effect on the operation.", "Performance", "TRUNCATE TABLE is faster than DELETE, because it drops and re-creates a table.", "With InnoDB, TRUNCATE TABLE is slower if innodb_file_per_table=ON is set (the default). This is because TRUNCATE TABLE unlinks the underlying tablespace file, which can be an expensive operation. See MDEV-8069 for more details.", "The performance issues with innodb_file_per_table=ON can be exacerbated in cases where the InnoDB buffer pool is very large and innodb_adaptive_hash_index=ON is set. In that case, using DROP TABLE followed by CREATE TABLE instead of TRUNCATE TABLE may perform better. Setting innodb_adaptive_hash_index=OFF (it defaults to ON before MariaDB 10.5) can also help. In MariaDB 10.2 only, from MariaDB 10.2.19, this performance can also be improved by setting innodb_safe_truncate=OFF. See MDEV-9459 for more details.", "Setting innodb_adaptive_hash_index=OFF can also improve TRUNCATE TABLE performance in general. See MDEV-16796 for more details."], "Examples": [], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/check-view/"], "Title": ["CHECK VIEW"], "Feature": ["CHECK VIEW view_name\n"], "Description": ["The CHECK VIEW statement was introduced in MariaDB 10.0.18 to assist with fixing MDEV-6916, an issue introduced in MariaDB 5.2 where the view algorithms were swapped. It checks whether the view algorithm is correct. It is run as part of mariadb-upgrade, and should not normally be required in regular use."], "Examples": [], "Category": ["Table Statements"]}
{"HTML": ["https://mariadb.com//kb/en/checksum-table/"], "Title": ["CHECKSUM TABLE"], "Feature": ["CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]\n"], "Description": ["CHECKSUM TABLE reports a table checksum.  This is very\nuseful if you want to know if two tables are the same (for example on a master\nand slave).", "With QUICK, the live table checksum is reported if it is\navailable, or NULL otherwise. This is very fast. A live\nchecksum is enabled by specifying the CHECKSUM=1 table\noption when you create the table; currently, this is supported\nonly for Aria and MyISAM tables.", "With EXTENDED, the entire table is read row by row and the\nchecksum is calculated. This can be very slow for large tables.", "If neither QUICK nor EXTENDED is\nspecified, MariaDB returns a live checksum if the table storage engine supports\nit and scans the table otherwise.", "CHECKSUM TABLE requires the SELECT privilege for the table.", "For a nonexistent table, CHECKSUM TABLE returns\nNULL and generates a warning.", "The table row format affects the checksum value. If the row format changes, the checksum will change. This means that when a table created with a MariaDB/MySQL version is upgraded to another version, the checksum value will probably change.", "Two identical tables should always match to the same checksum value; however, also for non-identical tables there is a very slight chance that they will return the same value as the hashing algorithm is not completely collision-free."], "Examples": [], "Category": ["Table Statements"]}
