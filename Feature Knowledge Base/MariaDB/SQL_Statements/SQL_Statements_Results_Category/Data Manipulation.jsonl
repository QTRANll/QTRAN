{"HTML": ["https://mariadb.com//kb/en/precedence-control-in-table-operations/"], "Title": ["Precedence Control in Table Operations"], "Feature": ["(  expression )\n[ORDER BY [column[, column...]]]\n[LIMIT {[offset,] row_count | row_count OFFSET offset}]\n"], "Description": ["Using parentheses in your SQL allows you to control the order of execution for SELECT statements and Table Value Constructor, including UNION, EXCEPT, and INTERSECT operations.  MariaDB executes the parenthetical expression before the rest of the statement.  You can then use ORDER BY and LIMIT clauses the further organize the result-set.", "Note: In practice, the Optimizer may rearrange the exact order in which MariaDB executes different parts of the statement.  When it calculates the result-set, however, it returns values as though the parenthetical expression were executed first.\n"], "Examples": ["CREATE TABLE test.t1 (num INT);\n\nINSERT INTO test.t1 VALUES (1),(2),(3);\n\n(SELECT * FROM test.t1 \n UNION \n VALUES (10)) \nINTERSECT \nVALUES (1),(3),(10),(11);\n+------+\n| num  |\n+------+\n|    1 |\n|    3 |\n|   10 |\n+------+\n\n((SELECT * FROM test.t1 \n  UNION \n  VALUES (10)) \n INTERSECT \n VALUES (1),(3),(10),(11)) \nORDER BY 1 DESC;\n+------+\n| num  |\n+------+\n|   10 |\n|    3 |\n|    1 |\n+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/replacereturning/"], "Title": ["REPLACE...RETURNING"], "Feature": ["REPLACE [LOW_PRIORITY | DELAYED]\n [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n {VALUES | VALUE} ({expr | DEFAULT},...),(...),...\n[RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "REPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name [PARTITION (partition_list)]\n    SET col={expr | DEFAULT}, ...\n[RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "REPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n    SELECT ...\n[RETURNING select_expr \n      [, select_expr ...]]\n"], "Description": ["REPLACE ... RETURNING returns a resultset of the replaced rows.\nThis returns the listed columns for all the rows that are replaced, or alternatively, the specified SELECT expression. Any SQL expressions which can be calculated can be used in the select expression for the RETURNING clause, including virtual columns and aliases, expressions which use various operators such as bitwise, logical and arithmetic operators, string functions, date-time functions, numeric functions, control flow functions, secondary functions and stored functions. Along with this, statements which have subqueries and prepared statements can also be used.\n"], "Examples": ["REPLACE INTO t2 VALUES (1,'Leopard'),(2,'Dog') RETURNING id2, id2+id2 \nas Total ,id2|id2, id2&&id2;\n+-----+-------+---------+----------+\n| id2 | Total | id2|id2 | id2&&id2 |\n+-----+-------+---------+----------+\n|   1 |     2 |       1 |        1 |\n|   2 |     4 |       2 |        1 |\n+-----+-------+---------+----------+\n", "DELIMITER |\nCREATE FUNCTION f(arg INT) RETURNS INT\n    BEGIN\n      RETURN (SELECT arg+arg);\n    END|\n\nDELIMITER ;\nPREPARE stmt FROM \"REPLACE INTO t2 SET id2=3, animal2='Fox' RETURNING f2(id2),\nUPPER(animal2)\";\n\nEXECUTE stmt;\n+---------+----------------+\n| f2(id2) | UPPER(animal2) |\n+---------+----------------+\n|       6 | FOX            |\n+---------+----------------+\n", "REPLACE INTO t1 SELECT * FROM t2 RETURNING (SELECT id2 FROM t2 WHERE \nid2 IN (SELECT id2 FROM t2 WHERE id2=1)) AS new_id;\n+--------+\n| new_id |\n+--------+\n|      1 |\n|      1 |\n|      1 |\n|      1 |\n+--------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/replace/"], "Title": ["REPLACE"], "Feature": ["REPLACE [LOW_PRIORITY | DELAYED]\n [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n {VALUES | VALUE} ({expr | DEFAULT},...),(...),...\n[RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "REPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name [PARTITION (partition_list)]\n    SET col={expr | DEFAULT}, ...\n[RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "REPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n    SELECT ...\n[RETURNING select_expr \n      [, select_expr ...]]\n"], "Description": [" REPLACE works exactly like\n INSERT, except that if an old row in the table\n has the same value as a new row for a PRIMARY KEY or a\n UNIQUE index, the old row is deleted before the new row is\n inserted. If the table has more than one UNIQUE keys, it is possible that the new row conflicts with more than one row. In this case, all conflicting rows will be deleted.", "The table name can be specified in the form db_name.tbl_name or, if a default database is selected, in the form tbl_name (see Identifier Qualifiers). This allows to use REPLACE ... SELECT to copy rows between different databases.\n", "MariaDB starting with 10.5.0The RETURNING clause was introduced in MariaDB 10.5.0\n", "Basically it works like this:", "BEGIN;\nSELECT 1 FROM t1 WHERE key=# FOR UPDATE;\nIF found-row\n  DELETE FROM t1 WHERE key=# ;\nENDIF\nINSERT INTO t1 VALUES (...);\nEND;\n", "The above can be replaced with:", "REPLACE INTO t1 VALUES (...)\n", " REPLACE is a MariaDB/MySQL extension to the SQL standard. It\n either inserts, or deletes and inserts. For other MariaDB/MySQL extensions to\n standard SQL --- that also handle duplicate values --- see IGNORE and INSERT ON DUPLICATE KEY UPDATE.", "Note that unless the table has a PRIMARY KEY or\n UNIQUE index, using a REPLACE statement\nmakes no sense. It becomes equivalent to INSERT, because\nthere is no index to be used to determine whether a new row duplicates another.", "Values for all columns are taken from the values sSee Partition Pruning and Selection for details.pecified in the\n REPLACE statement. Any missing columns are set to their\ndefault values, just as happens for INSERT. You cannot refer\nto values from the current row and use them in the new row. If you use an\nassignment such as 'SET col = col + 1', the\nreference to the column name on the right hand side is treated as\n DEFAULT(col), so the assignment is equivalent to\n 'SET col = DEFAULT(col) + 1'.", "To use REPLACE, you must have both the\n INSERT and DELETE privileges\nfor the table.", "There are some gotchas you should be aware of, before using REPLACE:", "If there is an AUTO_INCREMENT field, a new value will be generated.\nIf there are foreign keys, ON DELETE action will be activated by REPLACE.\nTriggers on DELETE and INSERT will be activated by REPLACE.\n", "To avoid some of these behaviors, you can use INSERT ... ON DUPLICATE KEY UPDATE.", "This statement activates INSERT and DELETE triggers. See Trigger Overview for details.", "PARTITION", "See Partition Pruning and Selection for details.", "REPLACE RETURNING", "REPLACE ... RETURNING returns a resultset of the replaced rows.\nThis returns the listed columns for all the rows that are replaced, or alternatively, the specified SELECT expression. Any SQL expressions which can be calculated can be used in the select expression for the RETURNING clause, including virtual columns and aliases, expressions which use various operators such as bitwise, logical and arithmetic operators, string functions, date-time functions, numeric functions, control flow functions, secondary functions and stored functions. Along with this, statements which have subqueries and prepared statements can also be used.\n", "Examples", "Simple REPLACE statement", "REPLACE INTO t2 VALUES (1,'Leopard'),(2,'Dog') RETURNING id2, id2+id2 \nas Total ,id2|id2, id2&&id2;\n+-----+-------+---------+----------+\n| id2 | Total | id2|id2 | id2&&id2 |\n+-----+-------+---------+----------+\n|   1 |     2 |       1 |        1 |\n|   2 |     4 |       2 |        1 |\n+-----+-------+---------+----------+\n", "Using stored functions in RETURNING", "DELIMITER |\nCREATE FUNCTION f(arg INT) RETURNS INT\n    BEGIN\n      RETURN (SELECT arg+arg);\n    END|\n\nDELIMITER ;\nPREPARE stmt FROM \"REPLACE INTO t2 SET id2=3, animal2='Fox' RETURNING f2(id2),\nUPPER(animal2)\";\n\nEXECUTE stmt;\n+---------+----------------+\n| f2(id2) | UPPER(animal2) |\n+---------+----------------+\n|       6 | FOX            |\n+---------+----------------+\n", "Subqueries in the statement", "REPLACE INTO t1 SELECT * FROM t2 RETURNING (SELECT id2 FROM t2 WHERE \nid2 IN (SELECT id2 FROM t2 WHERE id2=1)) AS new_id;\n+--------+\n| new_id |\n+--------+\n|      1 |\n|      1 |\n|      1 |\n|      1 |\n+--------+\n", "Subqueries in the RETURNING clause that return more than one row or column cannot be used..", "Aggregate functions cannot be used in the RETURNING clause. Since aggregate functions work on a set of values and if the purpose is to get the row count, ROW_COUNT() with SELECT can be used, or it can be used in REPLACE...SEL== Description", "REPLACE ... RETURNING returns a resultset of the replaced rows.\nThis returns the listed columns for all the rows that are replaced, or alternatively, the specified SELECT expression. Any SQL expressions which can be calculated can be used in the select expression for the RETURNING clause, including virtual columns and aliases, expressions which use various operators such as bitwise, logical and arithmetic operators, string functions, date-time functions, numeric functions, control flow functions, secondary functions and stored functions. Along with this, statements which have subqueries and prepared statements can also be used.\n"], "Examples": ["REPLACE INTO t2 VALUES (1,'Leopard'),(2,'Dog') RETURNING id2, id2+id2 \nas Total ,id2|id2, id2&&id2;\n+-----+-------+---------+----------+\n| id2 | Total | id2|id2 | id2&&id2 |\n+-----+-------+---------+----------+\n|   1 |     2 |       1 |        1 |\n|   2 |     4 |       2 |        1 |\n+-----+-------+---------+----------+\n", "DELIMITER |\nCREATE FUNCTION f(arg INT) RETURNS INT\n    BEGIN\n      RETURN (SELECT arg+arg);\n    END|\n\nDELIMITER ;\nPREPARE stmt FROM \"REPLACE INTO t2 SET id2=3, animal2='Fox' RETURNING f2(id2),\nUPPER(animal2)\";\n\nEXECUTE stmt;\n+---------+----------------+\n| f2(id2) | UPPER(animal2) |\n+---------+----------------+\n|       6 | FOX            |\n+---------+----------------+\n", "REPLACE INTO t1 SELECT * FROM t2 RETURNING (SELECT id2 FROM t2 WHERE \nid2 IN (SELECT id2 FROM t2 WHERE id2=1)) AS new_id;\n+--------+\n| new_id |\n+--------+\n|      1 |\n|      1 |\n|      1 |\n|      1 |\n+--------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/select-offset-fetch/"], "Title": ["SELECT ... OFFSET ... FETCH"], "Feature": ["OFFSET start { ROW | ROWS }\nFETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES }\n"], "Description": ["The OFFSET clause allows one to return only those elements of a resultset that come after a specified offset. The FETCH clause specifies the number of rows to return, while ONLY or WITH TIES specifies whether or not to also return any further results that tie for last place according to the ordered resultset.", "Either the singular ROW or the plural ROWS can be used after the OFFSET and FETCH clauses; the choice has no impact on the results. ", "FIRST and NEXT gives the same result.", "In the case of WITH TIES, an ORDER BY clause is required, otherwise an ERROR will be returned.", "SELECT i FROM t1 FETCH FIRST 2 ROWS WITH TIES;\nERROR 4180 (HY000): FETCH ... WITH TIES requires ORDER BY clause to be present\n"], "Examples": ["CREATE OR REPLACE TABLE t1 (i INT);\nINSERT INTO t1 VALUES (1),(2),(3),(4), (4), (5);\nSELECT i FROM t1 ORDER BY i ASC;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n|    4 |\n|    5 |\n+------+\n\n", "SELECT i FROM t1 ORDER BY i ASC OFFSET 2 ROWS;\n+------+\n| i    |\n+------+\n|    3 |\n|    4 |\n|    4 |\n|    5 |\n+------+\n", "SELECT i FROM t1 ORDER BY i ASC OFFSET 1 ROWS FETCH FIRST 3 ROWS ONLY;\n+------+\n| i    |\n+------+\n|    2 |\n|    3 |\n|    4 |\n+------+\n", "SELECT i FROM t1 ORDER BY i ASC LIMIT 3 OFFSET 1;\n+------+\n| i    |\n+------+\n|    2 |\n|    3 |\n|    4 |\n+------+\n", "SELECT i FROM t1 ORDER BY i ASC OFFSET 1 ROWS FETCH FIRST 3 ROWS WITH TIES;\n+------+\n| i    |\n+------+\n|    2 |\n|    3 |\n|    4 |\n|    4 |\n+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/select-into-dumpfile/"], "Title": ["SELECT INTO DUMPFILE"], "Feature": ["SELECT ... INTO DUMPFILE 'file_path'\n"], "Description": ["SELECT ... INTO DUMPFILE is a SELECT clause which writes the resultset into a single unformatted row, without any separators, in a file. The results will not be returned to the client.", "file_path can be an absolute path, or a relative path starting from the data directory. It can only be specified as a string literal, not as a variable. However, the statement can be dynamically composed and executed as a prepared statement to work around this limitation.", "This statement is binary-safe and so is particularly useful for writing BLOB values to file. It can be used, for example, to copy an image or an audio document from the database to a file.", "The file must not exist. It cannot be overwritten. A user needs the FILE privilege to run this statement. Also, MariaDB needs permission to write files in the specified location. If the secure_file_priv system variable is set to a non-empty directory name, the file can only be written to that directory.", "Since MariaDB 5.1, the character_set_filesystem system variable has controlled interpretation of file names that are given as literal strings."], "Examples": ["SELECT _utf8'Hello world!' INTO DUMPFILE '/tmp/world';\n\nSELECT LOAD_FILE('/tmp/world') AS world;\n+--------------+\n| world        |\n+--------------+\n| Hello world! |\n+--------------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/select-into-outfile/"], "Title": ["SELECT INTO OUTFILE"], "Feature": ["SELECT ... INTO OUTFILE 'file_name'\n        [CHARACTER SET charset_name]\n        [export_options]\n\nexport_options:\n    [{FIELDS | COLUMNS}\n        [TERMINATED BY 'string']\n        [[OPTIONALLY] ENCLOSED BY 'char']\n        [ESCAPED BY 'char']\n    ]\n    [LINES\n        [STARTING BY 'string']\n        [TERMINATED BY 'string']\n    ]\n"], "Description": ["SELECT INTO OUTFILE writes the resulting rows to a file, and allows the use of column and row terminators to specify a particular output format. The default is to terminate fields with tabs (\\t) and lines with newlines (\\n).", "The file must not exist. It cannot be overwritten. A user needs the FILE privilege to run this statement. Also, MariaDB needs permission to write files in the specified location. If the secure_file_priv system variable is set to a non-empty directory name, the file can only be written to that directory.", "The LOAD DATA INFILE statement complements SELECT INTO OUTFILE.", "Character-sets", "The CHARACTER SET clause specifies the character set in which the results are to be written. Without the clause, no conversion takes place (the binary character set). In this case, if there are multiple character sets, the output will contain these too, and may not easily be able to be reloaded.", "In cases where you have two servers using different character-sets, using SELECT INTO OUTFILE to transfer data from one to the other can have unexpected results.  To ensure that MariaDB correctly interprets the escape sequences, use the CHARACTER SET clause on both the SELECT INTO OUTFILE statement and the subsequent LOAD DATA INFILE statement."], "Examples": ["SELECT customer_id, firstname, surname from customer\n  INTO OUTFILE '/exportdata/customers.txt'\n  FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'\n  LINES TERMINATED BY '\\n';\n", "SELECT customer_id, firstname, surname INTO OUTFILE '/exportdata/customers.txt'\n  FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'\n  LINES TERMINATED BY '\\n'\n  FROM customers;\n", "SELECT  * INTO OUTFILE \"/tmp/skr3\" FROM (SELECT * FROM t1 UNION SELECT * FROM t1);\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/select-with-rollup/"], "Title": ["SELECT WITH ROLLUP"], "Feature": ["See SELECT for the full syntax."], "Description": ["The WITH ROLLUP modifier adds extra rows to the resultset that represent super-aggregate summaries. The super-aggregated column is represented by a NULL value. Multiple aggregates over different columns will be added if there are multiple GROUP BY columns.", "The LIMIT clause can be used at the same time, and is applied after the WITH ROLLUP rows have been added.", "WITH ROLLUP cannot be used with ORDER BY. Some sorting is still possible by using ASC or DESC clauses with the GROUP BY column, although the super-aggregate rows will always be added last."], "Examples": ["CREATE TABLE booksales ( \n  country VARCHAR(35), genre ENUM('fiction','non-fiction'), year YEAR, sales INT);\n\nINSERT INTO booksales VALUES\n  ('Senegal','fiction',2014,12234), ('Senegal','fiction',2015,15647),\n  ('Senegal','non-fiction',2014,64980), ('Senegal','non-fiction',2015,78901),\n  ('Paraguay','fiction',2014,87970), ('Paraguay','fiction',2015,76940),\n  ('Paraguay','non-fiction',2014,8760), ('Paraguay','non-fiction',2015,9030);\n", "SELECT year, SUM(sales) FROM booksales GROUP BY year;\n+------+------------+\n| year | SUM(sales) |\n+------+------------+\n| 2014 |     173944 |\n| 2015 |     180518 |\n+------+------------+\n2 rows in set (0.08 sec)\n\nSELECT year, SUM(sales) FROM booksales GROUP BY year WITH ROLLUP;\n+------+------------+\n| year | SUM(sales) |\n+------+------------+\n| 2014 |     173944 |\n| 2015 |     180518 |\n| NULL |     354462 |\n+------+------------+\n", "SELECT country, year, genre, SUM(sales) \n  FROM booksales GROUP BY country, year, genre;\n+----------+------+-------------+------------+\n| country  | year | genre       | SUM(sales) |\n+----------+------+-------------+------------+\n| Paraguay | 2014 | fiction     |      87970 |\n| Paraguay | 2014 | non-fiction |       8760 |\n| Paraguay | 2015 | fiction     |      76940 |\n| Paraguay | 2015 | non-fiction |       9030 |\n| Senegal  | 2014 | fiction     |      12234 |\n| Senegal  | 2014 | non-fiction |      64980 |\n| Senegal  | 2015 | fiction     |      15647 |\n| Senegal  | 2015 | non-fiction |      78901 |\n+----------+------+-------------+------------+\n\nSELECT country, year, genre, SUM(sales) \n  FROM booksales GROUP BY country, year, genre WITH ROLLUP;\n+----------+------+-------------+------------+\n| country  | year | genre       | SUM(sales) |\n+----------+------+-------------+------------+\n| Paraguay | 2014 | fiction     |      87970 |\n| Paraguay | 2014 | non-fiction |       8760 |\n| Paraguay | 2014 | NULL        |      96730 |\n| Paraguay | 2015 | fiction     |      76940 |\n| Paraguay | 2015 | non-fiction |       9030 |\n| Paraguay | 2015 | NULL        |      85970 |\n| Paraguay | NULL | NULL        |     182700 |\n| Senegal  | 2014 | fiction     |      12234 |\n| Senegal  | 2014 | non-fiction |      64980 |\n| Senegal  | 2014 | NULL        |      77214 |\n| Senegal  | 2015 | fiction     |      15647 |\n| Senegal  | 2015 | non-fiction |      78901 |\n| Senegal  | 2015 | NULL        |      94548 |\n| Senegal  | NULL | NULL        |     171762 |\n| NULL     | NULL | NULL        |     354462 |\n+----------+------+-------------+------------+\n", "SELECT country, year, genre, SUM(sales) \n  FROM booksales GROUP BY country, year, genre WITH ROLLUP LIMIT 4;\n+----------+------+-------------+------------+\n| country  | year | genre       | SUM(sales) |\n+----------+------+-------------+------------+\n| Paraguay | 2014 | fiction     |      87970 |\n| Paraguay | 2014 | non-fiction |       8760 |\n| Paraguay | 2014 | NULL        |      96730 |\n| Paraguay | 2015 | fiction     |      76940 |\n+----------+------+-------------+------------+\n", "SELECT country, year, genre, SUM(sales) \n  FROM booksales GROUP BY country, year DESC, genre WITH ROLLUP;\n+----------+------+-------------+------------+\n| country  | year | genre       | SUM(sales) |\n+----------+------+-------------+------------+\n| Paraguay | 2015 | fiction     |      76940 |\n| Paraguay | 2015 | non-fiction |       9030 |\n| Paraguay | 2015 | NULL        |      85970 |\n| Paraguay | 2014 | fiction     |      87970 |\n| Paraguay | 2014 | non-fiction |       8760 |\n| Paraguay | 2014 | NULL        |      96730 |\n| Paraguay | NULL | NULL        |     182700 |\n| Senegal  | 2015 | fiction     |      15647 |\n| Senegal  | 2015 | non-fiction |      78901 |\n| Senegal  | 2015 | NULL        |      94548 |\n| Senegal  | 2014 | fiction     |      12234 |\n| Senegal  | 2014 | non-fiction |      64980 |\n| Senegal  | 2014 | NULL        |      77214 |\n| Senegal  | NULL | NULL        |     171762 |\n| NULL     | NULL | NULL        |     354462 |\n+----------+------+-------------+------------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/select/"], "Title": ["SELECT"], "Feature": ["SELECT\n    [ALL | DISTINCT | DISTINCTROW]\n    [HIGH_PRIORITY]\n    [STRAIGHT_JOIN]\n    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]\n    [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]\n    select_expr [, select_expr ...]\n    [ FROM table_references\n      [WHERE where_condition]\n      [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]]\n      [HAVING where_condition]\n      [ORDER BY {col_name | expr | position} [ASC | DESC], ...]\n      [LIMIT {[offset,] row_count | row_count OFFSET offset  [ROWS EXAMINED rows_limit] } |\n        [OFFSET start { ROW | ROWS }]\n        [FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES }] ]\n      procedure|[PROCEDURE procedure_name(argument_list)]\n      [INTO OUTFILE 'file_name' [CHARACTER SET charset_name] [export_options] |\n        INTO DUMPFILE 'file_name' | INTO var_name [, var_name] ]\n      [FOR UPDATE lock_option | LOCK IN SHARE MODE lock_option]\nexport_options:\n    [{FIELDS | COLUMNS}\n        [TERMINATED BY 'string']\n        [[OPTIONALLY] ENCLOSED BY 'char']\n        [ESCAPED BY 'char']\n    ]\n    [LINES\n        [STARTING BY 'string']\n        [TERMINATED BY 'string']\n    ]\nlock_option:\n    [WAIT n | NOWAIT | SKIP LOCKED]"], "Description": ["SELECT is used to retrieve rows selected from one or more\ntables, and can include UNION statements and subqueries.", "Each select_expr expression indicates a column or data that you want to retrieve. You\nmust have at least one select expression. See Select Expressions below.\n", "The FROM clause indicates the table or tables from which to retrieve rows.\nUse either a single table name or a JOIN expression. See JOIN\nfor details. If no table is involved, FROM DUAL can be specified.\n", "Each table can also be specified as db_name.tabl_name. Each column can also be specified as tbl_name.col_name or even db_name.tbl_name.col_name. This allows one to write queries which involve multiple databases. See Identifier Qualifiers for syntax details.\n", "The WHERE clause, if given, indicates the condition or\n  conditions that rows must satisfy to be selected.\n  where_condition is an expression that evaluates to true for\n  each row to be selected. The statement selects all rows if there is no WHERE\n  clause.\nIn the WHERE clause, you can use any of the functions and\n   operators that MariaDB supports, except for aggregate (summary) functions. See Functions and Operators and Functions and Modifiers for use with GROUP BY (aggregate).\n\n", "Use the ORDER BY clause to order the results.\n", "Use the LIMIT clause allows you to restrict the results to only\na certain number of rows, optionally with an offset.\n", "Use the GROUP BY and HAVING clauses to group\nrows together when they have columns or computed values in common.\n", "SELECT can also be used to retrieve rows computed without reference to\nany table.", "Select Expressions", "A SELECT statement must contain one or more select expressions, separated\nby commas. Each select expression can be one of the following:", "The name of a column.\nAny expression using functions and operators.\n* to select all columns from all tables in the FROM clause.\ntbl_name.* to select all columns from just the table tbl_name.\n", "When specifying a column, you can either use just the column name or qualify the column\nname with  the name of the table using tbl_name.col_name. The qualified form is\nuseful if you are joining multiple tables in the FROM clause. If you do not qualify the\ncolumn names when selecting from multiple tables, MariaDB will try to find the column in\neach table. It is an error if that column name exists in multiple tables.", "You can quote column names using backticks. If you are qualifying column names\nwith table names, quote each part separately as `tbl_name`.`col_name`.", "If you use any grouping functions\nin any of the select expressions, all rows in your results will be implicitly grouped, as if\nyou had used GROUP BY NULL. GROUP BY NULL being an expression behaves specially\nsuch that the entire result set is treated as a group.", "DISTINCT", "A query may produce some identical rows. By default, all rows are retrieved, even when their values are the same. To explicitly specify that you want to retrieve identical rows, use the ALL option. If you want duplicates to be removed from the resultset, use the DISTINCT option. DISTINCTROW is a synonym for DISTINCT. See also COUNT DISTINCT and SELECT UNIQUE in Oracle mode.", "INTO", "The INTO clause is used to specify that the query results should be written to a file or variable.", "SELECT INTO OUTFILE - formatting and writing the result to an external file.\nSELECT INTO DUMPFILE - binary-safe writing of the unformatted results to an external file.\nSELECT INTO Variable - selecting and setting variables.\n", "The reverse of SELECT INTO OUTFILE is LOAD DATA.", "LIMIT", "Restricts the number of returned rows. See LIMIT and LIMIT ROWS EXAMINED for details.", "LOCK IN SHARE MODE/FOR UPDATE", "See LOCK IN SHARE MODE and FOR UPDATE for details on the respective locking clauses.", "OFFSET ... FETCH", "MariaDB starting with 10.6See SELECT ... OFFSET ... FETCH.\n", "ORDER BY", "Order a resultset. See ORDER BY for details.", "PARTITION", "Specifies to the optimizer which partitions are relevant for the query. Other partitions will not be read.  See Partition Pruning and Selection for details.", "PROCEDURE", "Passes the whole result set to a C Procedure. See PROCEDURE and PROCEDURE ANALYSE (the only built-in procedure not requiring the server to be recompiled).", "SKIP LOCKED", "MariaDB starting with 10.6The SKIP LOCKED clause was introduced in MariaDB 10.6.0.\nThis causes those rows that couldn't be locked (LOCK IN SHARE MODE or FOR UPDATE) to be excluded from the result set. An explicit NOWAIT is implied here. This is only implemented on InnoDB tables and ignored otherwise.\n", "SQL_CALC_FOUND_ROWS", "When SQL_CALC_FOUND_ROWS is used, then MariaDB will calculate how many rows would\nhave been in the result, if there would be no LIMIT clause. The result can be found by calling the function FOUND_ROWS() in your next sql statement.", "max_statement_time clause", "By using max_statement_time in conjunction with SET STATEMENT, it is possible to limit the execution time of individual queries. For example:", "SET STATEMENT max_statement_time=100 FOR \n  SELECT field1 FROM table_name ORDER BY field1;\n", "WAIT/NOWAIT", "Set the lock wait timeout. See WAIT and NOWAIT."], "Examples": ["SELECT f1,f2 FROM t1 WHERE (f3<=10) AND (f4='y');\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/subqueries-and-all/"], "Title": ["Subqueries and ALL"], "Feature": ["scalar_expression comparison_operator ALL <Table subquery>\n", "scalar_expression may be any expression that evaluates to a single\nvalue\ncomparison_operator may be any one of: =, >, <, >=, <=, <> or !=\n", "ALL returns:", "NULL if the comparison operator returns NULL for at least one row returned by the Table subquery or scalar_expression returns NULL.\nFALSE if the comparison operator returns FALSE for at least one row returned by the Table subquery.\nTRUE if the comparison operator returns TRUE for all rows returned by the Table subquery, or if Table subquery returns no rows.\n", "NOT IN is an alias for <> ALL."], "Description": [], "Examples": ["CREATE TABLE sq1 (num TINYINT);\n\nCREATE TABLE sq2 (num2 TINYINT);\n\nINSERT INTO sq1 VALUES(100);\n\nINSERT INTO sq2 VALUES(40),(50),(60);\n\nSELECT * FROM sq1 WHERE num > ALL (SELECT * FROM sq2);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n", "INSERT INTO sq1 VALUES(30);\n\nSELECT * FROM sq1 WHERE num > ALL (SELECT * FROM sq2);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n", "INSERT INTO sq2 VALUES(120);\n\nSELECT * FROM sq1 WHERE num > ALL (SELECT * FROM sq2);\nEmpty set (0.00 sec)\n", "SELECT * FROM sq1 WHERE num > ALL (SELECT * FROM sq2 WHERE num2 > 300);\n+------+\n| num  |\n+------+\n|  100 |\n|   30 |\n+------+\n", "INSERT INTO sq2 VALUES (NULL);\n\nSELECT * FROM sq1 WHERE num > ALL (SELECT * FROM sq2);\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/subqueries-and-any/"], "Title": ["Subqueries and ANY"], "Feature": ["The required syntax for an ANY or SOME quantified comparison is:", "scalar_expression comparison_operator ANY <Table subquery>\n", "Or:", "scalar_expression comparison_operator SOME <Table subquery>\n", "scalar_expression may be any expression that evaluates to a\nsingle value.\ncomparison_operator may be any one of =, >, <, >=, <=, <> or !=.  \n", "ANY returns:", "TRUE if the comparison operator returns TRUE for at least one row returned by the Table subquery.\nFALSE if the comparison operator returns FALSE for all rows returned by the Table subquery, or Table subquery has zero rows.\nNULL if the comparison operator returns NULL for at least one row returned by the Table subquery and doesn't returns TRUE for any of them, or if scalar_expression returns NULL.\n", "SOME is a synmonym for ANY, and IN is a synonym for = ANY"], "Description": [], "Examples": ["CREATE TABLE sq1 (num TINYINT);\n\nCREATE TABLE sq2 (num2 TINYINT);\n\nINSERT INTO sq1 VALUES(100);\n\nINSERT INTO sq2 VALUES(40),(50),(120);\n\nSELECT * FROM sq1 WHERE num > ANY (SELECT * FROM sq2);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n", "SELECT * FROM sq1 WHERE num < SOME (SELECT * FROM sq2);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n", "SELECT * FROM sq1 WHERE num IN (SELECT * FROM sq2);\nEmpty set (0.00 sec)\n", "INSERT INTO sq2 VALUES(100);\nQuery OK, 1 row affected (0.05 sec)\n\nSELECT * FROM sq1 WHERE num <> ANY (SELECT * FROM sq2);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n", "SELECT * FROM sq1 WHERE num <> SOME (SELECT * FROM sq2);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/subqueries-and-exists/"], "Title": ["Subqueries and EXISTS"], "Feature": ["SELECT ... WHERE EXISTS <Table subquery>\n"], "Description": ["Subqueries using the EXISTS keyword will return true if the subquery returns any rows. Conversely, subqueries using NOT EXISTS will return true only if the subquery returns no rows from the table.", "EXISTS subqueries ignore the columns specified by the SELECT of the subquery, since they're not relevant. For example, ", "SELECT col1 FROM t1 WHERE EXISTS (SELECT * FROM t2); \n", "and ", "SELECT col1 FROM t1 WHERE EXISTS (SELECT col2 FROM t2); \n", "produce identical results."], "Examples": ["CREATE TABLE sq1 (num TINYINT);\n\nCREATE TABLE sq2 (num2 TINYINT);\n\nINSERT INTO sq1 VALUES(100);\n\nINSERT INTO sq2 VALUES(40),(50),(60);\n\nSELECT * FROM sq1 WHERE EXISTS (SELECT * FROM sq2 WHERE num2>50);\n+------+\n| num  |\n+------+\n|  100 |\n+------+\n\nSELECT * FROM sq1 WHERE NOT EXISTS (SELECT * FROM sq2 GROUP BY num2 HAVING MIN(num2)=40);\nEmpty set (0.00 sec)\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/union/"], "Title": ["UNION"], "Feature": ["SELECT ...\nUNION [ALL | DISTINCT] SELECT ...\n[UNION [ALL | DISTINCT] SELECT ...]\n[ORDER BY [column [, column ...]]]\n[LIMIT {[offset,] row_count | row_count OFFSET offset}]\n"], "Description": ["UNION is used to combine the results from multiple SELECT statements into a single result set.", "The column names from the first SELECT statement are used as the column names for the results returned. Selected columns listed in corresponding positions of each SELECT statement should have the same data type. (For example, the first column selected by the first statement should have the same type as the first column selected by the other statements.)", "If they don't, the type and length of the columns in the result take into account the values returned by all of the SELECTs, so there is no need for explicit casting. Note that currently this is not the case for recursive CTEs - see MDEV-12325.", "Table names can be specified as db_name.tbl_name. This permits writing UNIONs which involve multiple databases. See Identifier Qualifiers for syntax details.", "UNION queries cannot be used with aggregate functions.", "EXCEPT and UNION have the same operation precedence and INTERSECT has a higher precedence, unless running in Oracle mode, in which case all three have the same precedence.", "ALL/DISTINCT", "The ALL keyword causes duplicate rows to be preserved. The DISTINCT keyword (the default if the keyword is omitted) causes duplicate rows to be removed by the results.", "UNION ALL and UNION DISTINCT can both be present in a query. In this case, UNION DISTINCT will override any UNION ALLs to its left.", "The server can in most cases execute UNION ALL without creating a temporary table (see MDEV-334).", "ORDER BY and LIMIT", "Individual SELECTs can contain their own ORDER BY and LIMIT clauses. In this case, the individual queries need to be wrapped between parentheses. However, this does not affect the order of the UNION, so they only are useful to limit the record read by one SELECT.", "The UNION can have global ORDER BY and LIMIT clauses, which affect the whole resultset. If the columns retrieved by individual SELECT statements have an alias (AS), the ORDER BY must use that alias, not the real column names.", "HIGH_PRIORITY", "Specifying a query as HIGH_PRIORITY will not work inside a UNION. If applied to the first SELECT, it will be ignored. Applying to a later SELECT results in a syntax error:", "ERROR 1234 (42000): Incorrect usage/placement of 'HIGH_PRIORITY'\n", "SELECT ... INTO ...", "Individual SELECTs cannot be written INTO DUMPFILE or INTO OUTFILE. If the last SELECT statement specifies INTO DUMPFILE or INTO OUTFILE, the entire result of the UNION will be written. Placing the clause after any other SELECT will result in a syntax error.", "If the result is a single row, SELECT ... INTO @var_name can also be used.\n\n", "Parentheses", "Parentheses can be used to specify precedence. Prior to MariaDB 10.4, a syntax error would be returned."], "Examples": ["(SELECT e_name AS name, email FROM employees)\nUNION\n(SELECT c_name AS name, email FROM customers);\n", "(SELECT name, email FROM employees)\nUNION\n(SELECT name, email FROM customers)\nORDER BY name LIMIT 10;\n", "(SELECT 'John Doe' AS name, 'john.doe@example.net' AS email)\nUNION\n(SELECT name, email FROM customers);\n", "SELECT CAST('x' AS CHAR(1)) UNION SELECT REPEAT('y',4);\n+----------------------+\n| CAST('x' AS CHAR(1)) |\n+----------------------+\n| x                    |\n| yyyy                 |\n+----------------------+\n", "(SELECT 1 AS sort_column, e_name AS name, email FROM employees)\nUNION\n(SELECT 2, c_name AS name, email FROM customers) ORDER BY sort_column;\n", "CREATE TABLE seqs (i INT);\nINSERT INTO seqs VALUES (1),(2),(2),(3),(3),(4),(5),(6);\n\nSELECT i FROM seqs WHERE i <= 3 UNION SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n|    5 |\n|    6 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 UNION ALL SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    2 |\n|    3 |\n|    3 |\n|    3 |\n|    3 |\n|    4 |\n|    5 |\n|    6 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 EXCEPT SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 EXCEPT ALL SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    2 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 INTERSECT SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    3 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 INTERSECT ALL SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    3 |\n|    3 |\n+------+\n", "CREATE OR REPLACE TABLE t1 (a INT);\nCREATE OR REPLACE TABLE t2 (b INT);\nCREATE OR REPLACE TABLE t3 (c INT);\n\nINSERT INTO t1 VALUES (1),(2),(3),(4);\nINSERT INTO t2 VALUES (5),(6);\nINSERT INTO t3 VALUES (1),(6);\n\n((SELECT a FROM t1) UNION (SELECT b FROM t2)) INTERSECT (SELECT c FROM t3);\n+------+\n| a    |\n+------+\n|    1 |\n|    6 |\n+------+\n\n(SELECT a FROM t1) UNION ((SELECT b FROM t2) INTERSECT (SELECT c FROM t3));\n+------+\n| a    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n|    6 |\n+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/update/"], "Title": ["UPDATE"], "Feature": ["Single-table syntax:", "UPDATE [LOW_PRIORITY] [IGNORE] table_reference \n  [PARTITION (partition_list)]\n  [FOR PORTION OF period FROM expr1 TO expr2]\n  SET col1={expr1|DEFAULT} [,col2={expr2|DEFAULT}] ...\n  [WHERE where_condition]\n  [ORDER BY ...]\n  [LIMIT row_count]\n", "Multiple-table syntax:", "UPDATE [LOW_PRIORITY] [IGNORE] table_references\n    SET col1={expr1|DEFAULT} [, col2={expr2|DEFAULT}] ...\n    [WHERE where_condition]\n"], "Description": ["For the single-table syntax, the UPDATE statement updates\ncolumns of existing rows in the named table with new values. The\nSET clause indicates which columns to modify and the values\nthey should be given.  Each value can be given as an expression, or the keyword\nDEFAULT to set a column explicitly to its default value. The\nWHERE clause, if given, specifies the conditions that identify\nwhich rows to update. With no WHERE clause, all rows are\nupdated. If the ORDER BY clause is specified, the rows are\nupdated in the order that is specified. The LIMIT clause\nplaces a limit on the number of rows that can be updated.", "Both clauses can be used with multiple-table updates. Prior to MariaDB 10.3, for the multiple-table syntax, UPDATE updates rows in each table named in table_references that satisfy the conditions. In this case,\nORDER BY and LIMIT could not be used.", "An UPDATE can also reference tables which are located in different databases; see Identifier Qualifiers for the syntax.", "where_condition is an expression that evaluates to true for\neach row to be updated.", "table_references and where_condition are as\nspecified as described in SELECT.", "For single-table updates, assignments are evaluated in left-to-right order, while for multi-table updates, there is no guarantee of a particular order. If the SIMULTANEOUS_ASSIGNMENT sql_mode is set, UPDATE statements evaluate all assignments simultaneously.", "You need the UPDATE privilege only for columns referenced in\nan UPDATE that are actually updated. You need only the\nSELECT privilege for any columns that are read but\nnot modified. See GRANT.", "The UPDATE statement supports the following modifiers:", "If you use the LOW_PRIORITY keyword, execution of\n  the UPDATE is delayed until no other clients are reading from\n  the table. This affects only storage engines that use only table-level\n  locking (MyISAM, MEMORY, MERGE). See HIGH_PRIORITY and LOW_PRIORITY clauses for details.\nIf you use the IGNORE keyword, the update statement does \n  not abort even if errors occur during the update. Rows for which\n  duplicate-key conflicts occur are not updated. Rows for which columns are\n  updated to values that would cause data conversion errors are updated to the\n  closest valid values instead.\n", "PARTITION", "See Partition Pruning and Selection for details.", "FOR PORTION OF", "See Application Time Periods - Updating by Portion.", "UPDATE Statements With the Same Source and Target", "UPDATE statements may have the same source and target.\nFor example, given the following table:", "DROP TABLE t1;\nCREATE TABLE t1 (c1 INT, c2 INT);\nINSERT INTO t1 VALUES (10,10), (20,20);\n\nUPDATE t1 SET c1=c1+1 WHERE c2=(SELECT MAX(c2) FROM t1);\n\nSELECT * FROM t1;\n+------+------+\n| c1   | c2   |\n+------+------+\n|   10 |   10 |\n|   21 |   20 |\n+------+------+\n"], "Examples": ["UPDATE table_name SET column1 = value1, column2 = value2 WHERE id=100;\n", "UPDATE tab1, tab2 SET tab1.column1 = value1, tab1.column2 = value2 WHERE tab1.id = tab2.id;\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/delete/"], "Title": ["DELETE"], "Feature": ["Single-table syntax:", "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] \n  FROM tbl_name [PARTITION (partition_list)]\n  [FOR PORTION OF period FROM expr1 TO expr2]\n  [AS alias]                    -- from MariaDB 11.6\n  [WHERE where_condition]\n  [ORDER BY ...]\n  [LIMIT row_count]\n  [RETURNING select_expr \n    [, select_expr ...]]\n", "Multiple-table syntax:", "DELETE [LOW_PRIORITY] [QUICK] [IGNORE]\n    tbl_name[.*] [, tbl_name[.*]] ...\n    FROM table_references\n    [WHERE where_condition]\n", "Or:", "DELETE [LOW_PRIORITY] [QUICK] [IGNORE]\n    FROM tbl_name[.*] [, tbl_name[.*]] ...\n    USING table_references\n    [WHERE where_condition]\n", "Trimming history:", "DELETE HISTORY\n  FROM tbl_name [PARTITION (partition_list)]\n  [BEFORE SYSTEM_TIME [TIMESTAMP|TRANSACTION] expression]\n"], "Description": ["OptionDescription\nLOW_PRIORITYWait until all SELECT's are done before starting the statement. Used with storage engines that uses table locking (MyISAM, Aria etc). See HIGH_PRIORITY and LOW_PRIORITY clauses for details.\nQUICKSignal the storage engine that it should expect that a lot of rows are deleted. The storage engine engine can do things to speed up the DELETE like ignoring merging of data blocks until all rows are deleted from the block (instead of when a block is half full). This speeds up things at the expanse of lost space in data blocks. At least MyISAM and Aria support this feature.\nIGNOREDon't stop the query even if a not-critical error occurs (like data overflow). See How IGNORE works for a full description.\n\n", "For the single-table syntax, the DELETE statement deletes rows\nfrom tbl_name and returns a count of the number of deleted rows. This count can\nbe obtained by calling the ROW_COUNT() function. The\nWHERE clause, if given, specifies the conditions that identify\nwhich rows to delete. With no WHERE clause, all rows are\ndeleted. If the ORDER BY clause is specified, the rows are\ndeleted in the order that is specified. The LIMIT clause\nplaces a limit on the number of rows that can be deleted.", "For the multiple-table syntax, DELETE deletes from each\ntbl_name the rows that satisfy the conditions. In this case,\nORDER BY and LIMIT> cannot be used. A DELETE can also reference tables which are located in different databases; see Identifier Qualifiers for the syntax.", "where_condition is an expression that evaluates to true for\neach row to be deleted. It is specified as described in SELECT.", "Currently, you cannot delete from a table and select from the same\ntable in a subquery.", "You need the DELETE privilege on a table to delete rows from\nit. You need only the SELECT privilege for any columns that\nare only read, such as those named in the WHERE clause. See\nGRANT.", "As stated, a DELETE statement with no WHERE\nclause deletes all rows. A faster way to do this, when you do not need to know\nthe number of deleted rows, is to use TRUNCATE TABLE. However,\nwithin a transaction or if you have a lock on the table, \nTRUNCATE TABLE cannot be used whereas DELETE\ncan. See TRUNCATE TABLE, and\nLOCK.", "AS", "MariaDB starting with 11.6From MariaDB 11.6, single table DELETEs support aliases. For example:\nCREATE TABLE t1 (c1 INT);\nINSERT INTO t1 VALUES (1), (2);\n\nDELETE FROM t1 AS a1 WHERE a1.c1 = 2;\n", "PARTITION", "See Partition Pruning and Selection for details.", "FOR PORTION OF", "See Application Time Periods - Deletion by Portion.", "RETURNING", "It is possible to return a resultset of the deleted rows for a single table to the client by using the syntax DELETE ... RETURNING select_expr [, select_expr2 ...]]", "Any of SQL expression that can be calculated from a single row fields is allowed. Subqueries are allowed. The AS keyword is allowed, so it is possible to use aliases.", "The use of aggregate functions is not allowed. RETURNING cannot be used in multi-table DELETEs.", "Same Source and Target Table", "It is possible to delete from a table with the same source and target. For example:", "DELETE FROM t1 WHERE c1 IN (SELECT b.c1 FROM t1 b WHERE b.c2=0);\n", "DELETE HISTORY", "One can use DELETE HISTORY to delete historical information from System-versioned tables."], "Examples": ["DELETE FROM page_hit ORDER BY timestamp LIMIT 1000000;\n", "DELETE FROM t RETURNING f1;\n+------+\n| f1   |\n+------+\n|    5 |\n|   50 |\n|  500 |\n+------+ \n", "DELETE post FROM blog INNER JOIN post WHERE blog.id = post.blog_id;\n", "CREATE TABLE t1 (c1 INT, c2 INT);\nDELETE FROM t1 WHERE c1 IN (SELECT b.c1 FROM t1 b WHERE b.c2=0);\n", "ERROR 1093 (HY000): Table 't1' is specified twice, both as a target for 'DELETE' \n  and as a separate source for\n", "Query OK, 0 rows affected (0.00 sec)\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/handler-commands/"], "Title": ["HANDLER Commands"], "Feature": ["HANDLER tbl_name OPEN [ [AS] alias]\nHANDLER tbl_name READ index_name { = | >= | <= | < } (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ { FIRST | NEXT }\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name CLOSE\n"], "Description": ["The HANDLER statement provides direct access to table\nstorage engine interfaces for key lookups and key or table scans. It is available for at least Aria, Memory, MyISAM and InnoDB tables (and should work with most 'normal' storage engines, but not with system tables, MERGE or views).", "HANDLER ... OPEN opens a table, allowing it to be accessible to subsequent HANDLER ... READ statements. The table can either be opened using an alias, or a table name. If opened with an alias, references to this table by further HANDLER statements must use this alias, and not the table name. If opened with a table name qualified by database name, further references to this table must use the unqualified table name. For example, if a table is opened with db1.t1, further references must use t1. ", "The table object is only closed when HANDLER ... CLOSE is called by the session, or the session closes, and is not shared by other sessions.", "Prepared statements work with HANDLER READ, which gives a much higher performance (50% speedup) as there is no parsing and all data is transformed in binary (without conversions to text, as with the normal protocol).", "The HANDLER command does not work with partitioned tables."], "Examples": ["CREATE TABLE t1 (f1 INT);\n\nINSERT INTO t1 VALUES (1),(2),(3);\n\nHANDLER t1 OPEN;\n\nHANDLER t1 READ NEXT;\n+------+\n| f1   |\n+------+\n|    1 |\n+------+\n\nHANDLER t1 READ NEXT;\n+------+\n| f1   |\n+------+\n|    2 |\n+------+\n", "CREATE DATABASE db_new;\n\nCREATE TABLE db_new.t1 (id INT);\n\nINSERT INTO db_new.t1 VALUES (4),(5),(6);\n\nHANDLER db_new.t1 OPEN;\nERROR 1066 (42000): Not unique table/alias: 't1'\n\nHANDLER db_new.t1 OPEN AS db_new_t1;\n\nHANDLER db_new_t1 READ NEXT LIMIT 3;\n+------+\n| id   |\n+------+\n|    4 |\n|    5 |\n|    6 |\n+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/insert-delayed/"], "Title": ["INSERT DELAYED"], "Feature": ["INSERT DELAYED ...\n"], "Description": ["The DELAYED option for the INSERT\nstatement is a MariaDB/MySQL extension to standard SQL that is very useful if you have\nclients that cannot or need not wait for the INSERT to\ncomplete. This is a common situation when you use MariaDB for logging and you\nalso periodically run SELECT and UPDATE\nstatements that take a long time to complete.", "When a client uses INSERT DELAYED, it gets an okay from the\nserver at once, and the row is queued to be inserted when the table is not in\nuse by any other thread.", "Another major benefit of using INSERT DELAYED is that\ninserts from many clients are bundled together and written in one block. This\nis much faster than performing many separate inserts.", "Note that INSERT DELAYED is slower than a normal\n INSERT if the table is not otherwise in use. There is also\nthe additional overhead for the server to handle a separate thread for each\ntable for which there are delayed rows. This means that you should use\nINSERT DELAYED only when you are really sure that you need\nit.", "The queued rows are held only in memory until they are inserted into the table.\nThis means that if you terminate mariadbd forcibly (for example, with kill -9) or\nif mariadbd dies unexpectedly, any queued rows that have not been written to disk\nare lost.", "The number of concurrent INSERT DELAYED threads is limited by the max_delayed_threads server system variables. If it is set to 0, INSERT DELAYED is disabled. The session value can be equal to the global value, or 0 to disable this statement for the current session. If this limit has been reached, the DELAYED clause will be silently ignore for subsequent statements (no error will be produced).", "Limitations", "There are some limitations on the use of DELAYED:", "INSERT DELAYED works only with MyISAM, MEMORY, ARCHIVE,\n  and BLACKHOLE tables. If you execute INSERT DELAYED with another storage engine, you will get an error like this: ERROR 1616 (HY000): DELAYED option not supported for table 'tab_name'\nFor MyISAM tables, if there are no free blocks in the middle of the data\n  file, concurrent SELECT and INSERT statements are supported. Under these\n  circumstances, you very seldom need to use INSERT DELAYED\n  with MyISAM.\nINSERT DELAYED should be used only for\n  INSERT statements that specify value lists. The server\n  ignores DELAYED for INSERT ... SELECT\n  or INSERT ... ON DUPLICATE KEY UPDATE statements.\nBecause the INSERT DELAYED statement returns immediately,\n  before the rows are inserted, you cannot use\n  LAST_INSERT_ID() to get the\n  AUTO_INCREMENT value that the statement might generate.\nDELAYED rows are not visible to SELECT\n  statements until they actually have been inserted.\nAfter INSERT DELAYED, ROW_COUNT() returns the number of the rows you tried to insert, not the number of the successful writes.\nDELAYED is ignored on slave replication servers, so that \n  INSERT DELAYED is treated as a normal\n  INSERT on slaves. This is because\n  DELAYED could cause the slave to have different data than\n  the master. INSERT DELAYED statements are not safe for replication.\nPending INSERT DELAYED statements are lost if a table is\n  write locked and ALTER TABLE is used to modify the table structure.\nINSERT DELAYED is not supported for views. If you try, you will get an error like this: ERROR 1347 (HY000): 'view_name' is not BASE TABLE\nINSERT DELAYED is not supported for partitioned tables.\nINSERT DELAYED is not supported within stored programs.\nINSERT DELAYED does not work with triggers.\nINSERT DELAYED does not work if there is a check constraint in place.\nINSERT DELAYED does not work if skip-new mode is active.\n"], "Examples": [], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/insert-on-duplicate-key-update/"], "Title": ["INSERT ON DUPLICATE KEY UPDATE"], "Feature": ["INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n  [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n  {VALUES | VALUE} ({expr | DEFAULT},...),(...),...\n  [ ON DUPLICATE KEY UPDATE\n    col=expr\n      [, col=expr] ... ]\n", "Or:", "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [PARTITION (partition_list)]\n    SET col={expr | DEFAULT}, ...\n    [ ON DUPLICATE KEY UPDATE\n      col=expr\n        [, col=expr] ... ]\n", "Or:", "INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n    SELECT ...\n    [ ON DUPLICATE KEY UPDATE\n      col=expr\n        [, col=expr] ... ]\n"], "Description": ["INSERT ... ON DUPLICATE KEY UPDATE is a MariaDB/MySQL extension to the INSERT statement that, if it finds a duplicate unique or primary key, will instead perform an UPDATE.", "The row/s affected value is reported as 1 if a row is inserted, and 2 if a row is updated, unless the API's CLIENT_FOUND_ROWS flag is set.", "If more than one unique index is matched, only the first is updated. It is not recommended to use this statement on tables with more than one unique index.", "If the table has an AUTO_INCREMENT primary key and the statement inserts or updates a row, the LAST_INSERT_ID() function returns its AUTO_INCREMENT value.", "The VALUES() function can only be used in a ON DUPLICATE KEY UPDATE clause and has no meaning in any other context. It returns the column values from the INSERT portion of the statement. This function is particularly useful for multi-rows inserts.", "The IGNORE and DELAYED options are ignored when you use ON DUPLICATE KEY UPDATE.", "See Partition Pruning and Selection for details on the PARTITION clause.", "This statement activates INSERT and UPDATE triggers. See Trigger Overview for details.", "See also a similar statement, REPLACE."], "Examples": ["CREATE TABLE ins_duplicate (id INT PRIMARY KEY, animal VARCHAR(30));\nINSERT INTO ins_duplicate VALUES (1,'Aardvark'), (2,'Cheetah'), (3,'Zebra');\n", "INSERT INTO ins_duplicate VALUES (4,'Gorilla') \n  ON DUPLICATE KEY UPDATE animal='Gorilla';\nQuery OK, 1 row affected (0.07 sec)\n", "SELECT * FROM ins_duplicate;\n+----+----------+\n| id | animal   |\n+----+----------+\n|  1 | Aardvark |\n|  2 | Cheetah  |\n|  3 | Zebra    |\n|  4 | Gorilla  |\n+----+----------+\n", "INSERT INTO ins_duplicate VALUES (1,'Antelope');\nERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'\n", "INSERT INTO ins_duplicate VALUES (1,'Antelope') \n  ON DUPLICATE KEY UPDATE animal='Antelope';\nQuery OK, 2 rows affected (0.09 sec)\n", "SELECT * FROM ins_duplicate;\n+----+----------+\n| id | animal   |\n+----+----------+\n|  1 | Antelope |\n|  2 | Cheetah  |\n|  3 | Zebra    |\n|  4 | Gorilla  |\n+----+----------+\n", "ALTER TABLE ins_duplicate ADD id2 INT;\nUPDATE ins_duplicate SET id2=id+10;\nALTER TABLE ins_duplicate ADD UNIQUE KEY(id2);\n", "INSERT INTO ins_duplicate VALUES (2,'Lion',13) \n  ON DUPLICATE KEY UPDATE animal='Lion';\nQuery OK, 2 rows affected (0.004 sec)\n\nSELECT * FROM ins_duplicate;\n+----+----------+------+\n| id | animal   | id2  |\n+----+----------+------+\n|  1 | Antelope |   11 |\n|  2 | Lion     |   12 |\n|  3 | Zebra    |   13 |\n|  4 | Gorilla  |   14 |\n+----+----------+------+\n", "ALTER TABLE `ins_duplicate` CHANGE `id` `id` INT( 11 ) NOT NULL AUTO_INCREMENT;\nALTER TABLE ins_duplicate DROP id2;\nSELECT Auto_increment FROM INFORMATION_SCHEMA.TABLES \n  WHERE TABLE_NAME='ins_duplicate';\n+----------------+\n| Auto_increment |\n+----------------+\n|              5 |\n+----------------+\n\nINSERT INTO ins_duplicate VALUES (2,'Leopard') \n  ON DUPLICATE KEY UPDATE animal='Leopard';\nQuery OK, 2 rows affected (0.00 sec)\n\nSELECT Auto_increment FROM INFORMATION_SCHEMA.TABLES \n  WHERE TABLE_NAME='ins_duplicate';\n+----------------+\n| Auto_increment |\n+----------------+\n|              5 |\n+----------------+\n\nINSERT INTO ins_duplicate VALUES (5,'Wild Dog') \n  ON DUPLICATE KEY UPDATE animal='Wild Dog';\nQuery OK, 1 row affected (0.09 sec)\n\nSELECT * FROM ins_duplicate;\n+----+----------+\n| id | animal   |\n+----+----------+\n|  1 | Antelope |\n|  2 | Leopard  |\n|  3 | Zebra    |\n|  4 | Gorilla  |\n|  5 | Wild Dog |\n+----+----------+\n\nSELECT Auto_increment FROM INFORMATION_SCHEMA.TABLES \n  WHERE TABLE_NAME='ins_duplicate';\n+----------------+\n| Auto_increment |\n+----------------+\n|              6 |\n+----------------+\n", "INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)\n    ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/insert-select/"], "Title": ["INSERT SELECT"], "Feature": ["INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [(col_name,...)]\n    SELECT ...\n    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]\n"], "Description": ["With INSERT ... SELECT, you can quickly insert many rows\ninto a table from one or more other tables. For example:", "INSERT INTO tbl_temp2 (fld_id)\n  SELECT tbl_temp1.fld_order_id\n  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id > 100;\n", "tbl_name can also be specified in the form db_name.tbl_name (see Identifier Qualifiers). This allows to copy rows between different databases.", "If the new table has a primary key or UNIQUE indexes, you can use IGNORE to handle duplicate key errors during the query. The newer values will not be inserted if an identical value already exists.", "REPLACE can be used instead of INSERT to prevent duplicates on UNIQUE indexes by deleting old values. In that case, ON DUPLICATE KEY UPDATE cannot be used.", "INSERT ... SELECT works for tables which already exist. To create a table for a given resultset, you can use CREATE TABLE ... SELECT."], "Examples": [], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/insertreturning/"], "Title": ["INSERT...RETURNING"], "Feature": ["INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n {VALUES | VALUE} ({expr | DEFAULT},...),(...),...\n [ ON DUPLICATE KEY UPDATE\n   col=expr\n     [, col=expr] ... ] [RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [PARTITION (partition_list)]\n    SET col={expr | DEFAULT}, ...\n    [ ON DUPLICATE KEY UPDATE\n      col=expr\n        [, col=expr] ... ] [RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n    SELECT ...\n    [ ON DUPLICATE KEY UPDATE\n      col=expr\n        [, col=expr] ... ] [RETURNING select_expr \n      [, select_expr ...]]\n"], "Description": ["INSERT ... RETURNING returns a resultset of the inserted rows.\nThis returns the listed columns for all the rows that are inserted, or alternatively, the specified SELECT expression. Any SQL expressions which can be calculated can be used in the select expression for the RETURNING clause, including virtual columns and aliases, expressions which use various operators such as bitwise, logical and arithmetic operators, string functions, date-time functions, numeric functions, control flow functions, secondary functions and stored functions. Along with this, statements which have subqueries and prepared statements can also be used.\n"], "Examples": ["CREATE OR REPLACE TABLE t2 (id INT, animal VARCHAR(20), t TIMESTAMP);\n\nINSERT INTO t2 (id) VALUES (2),(3) RETURNING id,t;\n+------+---------------------+\n| id   | t                   |\n+------+---------------------+\n|    2 | 2021-04-28 00:59:32 |\n|    3 | 2021-04-28 00:59:32 |\n+------+---------------------+\n", "INSERT INTO t2(id,animal) VALUES (1,'Dog'),(2,'Lion'),(3,'Tiger'),(4,'Leopard')  \n  RETURNING id,id+id,id&id,id||id;\n+------+-------+-------+--------+\n| id   | id+id | id&id | id||id |\n+------+-------+-------+--------+\n|    1 |     2 |     1 |      1 |\n|    2 |     4 |     2 |      1 |\n|    3 |     6 |     3 |      1 |\n|    4 |     8 |     4 |      1 |\n+------+-------+-------+--------+\n", "DELIMITER |\nCREATE FUNCTION f(arg INT) RETURNS INT\n    BEGIN\n       RETURN (SELECT arg+arg);\n    END|\n\nDELIMITER ;\n\nPREPARE stmt FROM \"INSERT INTO t1 SET id1=1, animal1='Bear' RETURNING f(id1), UPPER(animal1)\";\n\nEXECUTE stmt;\n+---------+----------------+\n| f(id1)  | UPPER(animal1) |\n+---------+----------------+\n|       2 | BEAR           |\n+---------+----------------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/insert/"], "Title": ["INSERT"], "Feature": ["INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n {VALUES | VALUE} ({expr | DEFAULT},...),(...),...\n [ ON DUPLICATE KEY UPDATE\n   col=expr\n     [, col=expr] ... ] [RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [PARTITION (partition_list)]\n    SET col={expr | DEFAULT}, ...\n    [ ON DUPLICATE KEY UPDATE\n      col=expr\n        [, col=expr] ... ] [RETURNING select_expr \n      [, select_expr ...]]\n", "Or:", "INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]\n    SELECT ...\n    [ ON DUPLICATE KEY UPDATE\n      col=expr\n        [, col=expr] ... ] [RETURNING select_expr \n      [, select_expr ...]]\n", "The INSERT statement is used to insert new rows into an existing table. The INSERT ... VALUES\nand INSERT ... SET forms of the statement insert rows based on explicitly specified values. The INSERT ... SELECT form inserts rows selected from another table or tables. INSERT ... SELECT is discussed further in the INSERT ... SELECT article.", "The table name can be specified in the form db_name.tbl_name or, if a default database is selected, in the form tbl_name (see Identifier Qualifiers). This allows to use INSERT ... SELECT to copy rows between different databases.", "The PARTITION clause can be used in both the INSERT and the SELECT part. See Partition Pruning and Selection for details.", "MariaDB starting with 10.5The RETURNING clause was introduced in MariaDB 10.5.\n", "The columns list is optional. It specifies which values are explicitly inserted, and in which order. If this clause is not specified, all values must be explicitly specified, in the same order they are listed in the table definition.", "The list of value follow the VALUES or VALUE keyword (which are interchangeable, regardless how much values you want to insert), and is wrapped by parenthesis. The values must be listed in the same order as the columns list. It is possible to specify more than one list to insert more than one rows with a single statement. If many rows are inserted, this is a speed optimization.", "For one-row statements, the SET clause may be more simple, because you don't need to remember the columns order. All values are specified in the form col = expr.", "Values can also be specified in the form of a SQL expression or subquery. However, the subquery cannot access the same table that is named in the INTO clause.", "If you use the LOW_PRIORITY keyword, execution of the INSERT is delayed until no other clients are reading from the table. If you use the HIGH_PRIORITY keyword, the statement has the same priority as SELECTs. This affects only storage engines that use only table-level locking (MyISAM, MEMORY, MERGE). However, if one of these keywords is specified, concurrent inserts cannot be used. See HIGH_PRIORITY and LOW_PRIORITY clauses for details."], "Description": [], "Examples": ["INSERT INTO person (first_name, last_name) VALUES ('John', 'Doe');\n", "INSERT INTO tbl_name VALUES (1, \"row 1\"), (2, \"row 2\");\n", "INSERT INTO person SET first_name = 'John', last_name = 'Doe';\n", "INSERT INTO contractor SELECT * FROM person WHERE status = 'c';\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/intersect/"], "Title": ["INTERSECT"], "Feature": ["SELECT ...\n(INTERSECT [ALL | DISTINCT] | EXCEPT [ALL | DISTINCT] | UNION [ALL | DISTINCT]) SELECT ...\n[(INTERSECT [ALL | DISTINCT] | EXCEPT [ALL | DISTINCT] | UNION [ALL | DISTINCT]) SELECT ...]\n[ORDER BY [column [, column ...]]]\n[LIMIT {[offset,] row_count | row_count OFFSET offset}]\n"], "Description": ["MariaDB has supported INTERSECT (as well as EXCEPT) in addition to UNION since MariaDB 10.3.", "All behavior for naming columns, ORDER BY and LIMIT is the same as for UNION.", "INTERSECT implicitly supposes a DISTINCT operation.", "The result of an intersect is the intersection of right and left SELECT results, i.e. only records that are present in both result sets will be included in the result of the operation.", "INTERSECT has higher precedence than UNION and EXCEPT (unless running running in Oracle mode, in which case all three have the same precedence). If possible it will be executed linearly but if not it will be translated to a subquery in the FROM clause:", "(select a,b from t1)\nunion\n(select c,d from t2)\nintersect\n(select e,f from t3)\nunion\n(select 4,4);\n", "will be translated to:", "(select a,b from t1)\nunion\nselect c,d from\n  ((select c,d from t2)\n   intersect\n   (select e,f from t3)) dummy_subselect\nunion\n(select 4,4)\n", "\n", "Parentheses", "Parentheses can be used to specify precedence. Prior to MariaDB 10.4, a syntax error would be returned.", "MariaDB starting with 10.5.0ALL/DISTINCT\nINTERSECT ALL and INTERSECT DISTINCT were introduced in MariaDB 10.5.0. The ALL operator leaves duplicates intact, while the DISTINCT operator removes duplicates. DISTINCT is the default behavior if neither operator is supplied, and the only behavior prior to MariaDB 10.5.  \n"], "Examples": ["(SELECT e_name AS name, email FROM employees)\nINTERSECT\n(SELECT c_name AS name, email FROM customers);\n", "CREATE TABLE seqs (i INT);\nINSERT INTO seqs VALUES (1),(2),(2),(3),(3),(4),(5),(6);\n\nSELECT i FROM seqs WHERE i <= 3 UNION SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n|    5 |\n|    6 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 UNION ALL SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    2 |\n|    3 |\n|    3 |\n|    3 |\n|    3 |\n|    4 |\n|    5 |\n|    6 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 EXCEPT SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 EXCEPT ALL SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    1 |\n|    2 |\n|    2 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 INTERSECT SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    3 |\n+------+\n\nSELECT i FROM seqs WHERE i <= 3 INTERSECT ALL SELECT i FROM seqs WHERE i>=3;\n+------+\n| i    |\n+------+\n|    3 |\n|    3 |\n+------+\n", "CREATE OR REPLACE TABLE t1 (a INT);\nCREATE OR REPLACE TABLE t2 (b INT);\nCREATE OR REPLACE TABLE t3 (c INT);\n\nINSERT INTO t1 VALUES (1),(2),(3),(4);\nINSERT INTO t2 VALUES (5),(6);\nINSERT INTO t3 VALUES (1),(6);\n\n((SELECT a FROM t1) UNION (SELECT b FROM t2)) INTERSECT (SELECT c FROM t3);\n+------+\n| a    |\n+------+\n|    1 |\n|    6 |\n+------+\n\n(SELECT a FROM t1) UNION ((SELECT b FROM t2) INTERSECT (SELECT c FROM t3));\n+------+\n| a    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n|    6 |\n+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/load-data-infile/"], "Title": ["LOAD DATA INFILE"], "Feature": ["LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name'\n    [REPLACE | IGNORE]\n    INTO TABLE tbl_name\n    [CHARACTER SET charset_name]\n    [{FIELDS | COLUMNS}\n        [TERMINATED BY 'string']\n        [[OPTIONALLY] ENCLOSED BY 'char']\n        [ESCAPED BY 'char']\n    ]\n    [LINES\n        [STARTING BY 'string']\n        [TERMINATED BY 'string']\n    ]\n    [IGNORE number {LINES|ROWS}]\n    [(col_name_or_user_var,...)]\n    [SET col_name = expr,...]\n"], "Description": ["LOAD DATA INFILE is unsafe for statement-based replication.\n", "Reads rows from a text file into the designated table on the database at a very high speed. The file name must be given as a literal string. ", "Files are written to disk using the SELECT INTO OUTFILE statement.  You can then read the files back into a table using the LOAD DATA INFILE statement.  The FIELDS and LINES clauses are the same in both statements and by default fields are expected to be terminated with tabs (\\t) and lines with newlines (\\n).  These clauses are optional, but if both are specified then the FIELDS clause must precede LINES.", "Executing this statement activates INSERT triggers.", "One must have the FILE privilege to be able to execute LOAD DATA INFILE. This is to ensure normal users cannot read system files. LOAD DATA LOCAL INFILE does not have this requirement.", "If the secure_file_priv system variable is set (by default it is not), the loaded file must be present in the specified directory.", "Note that MariaDB's systemd unit file restricts access to /home, /root, and /run/user by default. See Configuring access to home directories.", "LOAD DATA LOCAL INFILE", "When you execute the LOAD DATA INFILE statement, MariaDB Server attempts to read the input file from its own file system. By contrast, when you execute the LOAD DATA LOCAL INFILE statement, the client attempts to read the input file from its file system, and it sends the contents of the input file to the MariaDB Server. This allows you to load files from the client's local file system into the database.", "If you don't want to permit this operation (perhaps for security reasons), you can disable the LOAD DATA LOCAL INFILE statement on either the server or the client.", "The LOAD DATA LOCAL INFILE statement can be disabled on the server by setting the local_infile system variable to 0.\nThe LOAD DATA LOCAL INFILE statement can be disabled on the client. If you are using MariaDB Connector/C, this can be done by unsetting the CLIENT_LOCAL_FILES capability flag with the mysql_real_connect function or by unsetting the MYSQL_OPT_LOCAL_INFILE option with mysql_optionsv function. If you are using a different client or client library, then see the documentation for your specific client or client library to determine how it handles the LOAD DATA LOCAL INFILE statement.\n", "The LOAD DATA LOCAL INFILE  strict modes like STRICT_TRANS_TABLES are disabled with keyword \"local\". (https://jira.mariadb.org/browse/MDEV-11235)\n", "If the LOAD DATA LOCAL INFILE statement is disabled by either the server or the client and if the user attempts to execute it, then the server will cause the statement to fail with the following error message:", "The used command is not allowed with this MariaDB version\n", "Note that it is not entirely accurate to say that the MariaDB version does not support the command. It would be more accurate to say that the MariaDB configuration does not support the command. See MDEV-20500 for more information.", "From MariaDB 10.5.2, the error message is more accurate:", "The used command is not allowed because the MariaDB server or client \n  has disabled the local infile capability\n", "REPLACE and IGNORE", "If you load data from a file into a table that already contains data and has a primary key, you may encounter issues where the statement attempts to insert a row with a primary key that already exists. When this happens, the statement fails with Error 1064, protecting the data already on the table. If you want MariaDB to overwrite duplicates, use the REPLACE keyword.", "The REPLACE keyword works like the REPLACE statement. Here, the statement attempts to load the data from the file. If the row does not exist, it adds it to the table.  If the row contains an existing primary key, it replaces the table data. That is, in the event of a conflict, it assumes the file contains the desired row. ", "This operation can cause a degradation in load speed by a factor of 20 or more if the part that has already been loaded is larger than the capacity of the InnoDB Buffer Pool.  This happens because it causes a lot of turnaround in the buffer pool.", "Use the IGNORE keyword when you want to skip any rows that contain a conflicting primary key. Here, the statement attempts to load the data from the file. If the row does not exist, it adds it to the table. If the row contains an existing primary key, it ignores the addition request and moves on to the next. That is, in the event of a conflict, it assumes the table contains the desired row.", "IGNORE number {LINES|ROWS}", "The IGNORE number LINES syntax can be used to ignore a number of rows from the beginning of the file. Most often this is needed when the file starts with one row that includes the column headings.", "Character-sets", "When the statement opens the file, it attempts to read the contents using the default character-set, as defined by the character_set_database system variable.  ", "In the cases where the file was written using a character-set other than the default, you can specify the character-set to use with the CHARACTER SET clause in the statement.  It ignores character-sets specified by the SET NAMES statement and by the character_set_client system variable.  Setting the CHARACTER SET clause to a value of binary indicates \"no conversion.\"", "The statement interprets all fields in the file as having the same character-set, regardless of the column data type.  To properly interpret file contents, you must ensure that it was written with the correct character-set.  If you write a data file with mariadb-dump -T or with the SELECT INTO OUTFILE statement with the mariadb client, be sure to use the --default-character-set option, so that the output is written with the desired character-set.", "When using mixed character sets, use the CHARACTER SET clause in both SELECT INTO OUTFILE and LOAD DATA INFILE to ensure that MariaDB correctly interprets the escape sequences.", "The character_set_filesystem system variable controls the interpretation of the filename.\nIt is currently not possible to load data files that use the ucs2 character set.\n", "Preprocessing Inputs", "col_name_or_user_var can be a column name, or a user variable. In the case of a variable, the SET statement can be used to preprocess the value before loading into the table.", "Priority and Concurrency", "In storage engines that perform table-level locking (MyISAM, MEMORY and MERGE), using the LOW_PRIORITY keyword, MariaDB delays insertions until no other clients are reading from the table. Alternatively, when using the MyISAM storage engine, you can use the CONCURRENT keyword to perform concurrent insertion.", "The LOW_PRIORITY and CONCURRENT keywords are mutually exclusive.  They cannot be used in the same statement.\n", "Progress Reporting", "The LOAD DATA INFILE statement supports progress reporting. You may find this useful when dealing with long-running operations. Using another client you can issue a SHOW PROCESSLIST query to check the progress of the data load.", "Using mariadb-import", "MariaDB ships with a separate utility for loading data from files: mariadb-import (or mysqlimport before MariaDB 10.5). It operates by sending LOAD DATA INFILE statements to the server.", "Using mariadb-import you can compress the file using the --compress option, to get better performance over slow networks, providing both the client and server support the compressed protocol.  Use the --local option to load from the local file system.", "Indexing", "In cases where the storage engine supports ALTER TABLE... DISABLE KEYS statements (MyISAM and Aria), the LOAD DATA INFILE statement automatically disables indexes during the execution."], "Examples": ["2,2\n3,3\n4,4\n5,5\n6,8\n", "CREATE TABLE t1 (a int, b int, c int, d int, PRIMARY KEY (a));\nLOAD DATA LOCAL INFILE \n '/tmp/loaddata7.dat' INTO TABLE t1 FIELDS TERMINATED BY ',' (a,b) SET c=a+b;\nSELECT * FROM t1;\n+------+------+------+\n| a    | b    | c    |\n+------+------+------+\n|    2 |    2 |    4 |\n|    3 |    3 |    6 |\n|    4 |    4 |    8 |\n|    5 |    5 |   10 |\n|    6 |    8 |   14 |\n+------+------+------+\n", "1       a\n2       b\n", "LOAD DATA INFILE 'ld.txt' INTO TABLE ld (@i,v) SET i=@i*2;\n\nSELECT * FROM ld;\n+------+------+\n| i    | v    |\n+------+------+\n|    2 | a    |\n|    4 | b    |\n+------+------+\n"], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/load-index/"], "Title": ["LOAD INDEX"], "Feature": ["LOAD INDEX INTO CACHE\n  tbl_index_list [, tbl_index_list] ...\n\ntbl_index_list:\n  tbl_name\n    [[INDEX|KEY] (index_name[, index_name] ...)]\n    [IGNORE LEAVES]\n"], "Description": ["The LOAD INDEX INTO CACHE statement preloads a table index into the key\ncache to which it has been assigned by an explicit CACHE INDEX\nstatement, or into the default key cache otherwise. \nLOAD INDEX INTO CACHE is used only for MyISAM or Aria tables.", "The IGNORE LEAVES modifier causes only blocks for the nonleaf nodes of\nthe index to be preloaded."], "Examples": [], "Category": ["Data Manipulation"]}
{"HTML": ["https://mariadb.com//kb/en/load-xml/"], "Title": ["LOAD XML"], "Feature": ["LOAD XML [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name'\n    [REPLACE | IGNORE]\n    INTO TABLE [db_name.]tbl_name\n    [CHARACTER SET charset_name]\n    [ROWS IDENTIFIED BY '<tagname>']\n    [IGNORE number {LINES | ROWS}]\n    [(column_or_user_var,...)]\n    [SET col_name = expr,...]\n"], "Description": ["The LOAD XML statement reads data from an XML file into a table. The\nfile_name must be given as a literal string. The tagname in the\noptional ROWS IDENTIFIED BY clause must also be given as a literal\nstring, and must be surrounded by angle brackets (< and >).", "LOAD XML acts as the complement of running the mariadb client in XML\noutput mode (that is, starting the client with the --xml option). To\nwrite data from a table to an XML file, use a command such as the\nfollowing one from the system shell:", "shell> mariadb --xml -e 'SELECT * FROM mytable' > file.xml\n", "To read the file back into a table, use LOAD XML INFILE. By default,\nthe <row> element is considered to be the equivalent of a database\ntable row; this can be changed using the ROWS IDENTIFIED BY clause.", "This statement supports three different XML formats:", "Column names as attributes and column values as attribute values:\n", "<row column1=\"value1\" column2=\"value2\" .../>\n", "Column names as tags and column values as the content of these tags:\n", "<row>\n  <column1>value1</column1>\n  <column2>value2</column2>\n</row>\n", "Column names are the name attributes of <field> tags, and values are\n  the contents of these tags:\n", "<row>\n  <field name='column1'>value1</field>\n  <field name='column2'>value2</field>\n</row>\n", "  This is the format used by other tools, such as mariadb-dump.", "All 3 formats can be used in the same XML file; the import routine\nautomatically detects the format for each row and interprets it\ncorrectly. Tags are matched based on the tag or attribute name and the\ncolumn name.", "The following clauses work essentially the same way for LOAD XML as\nthey do for LOAD DATA:", "LOW_PRIORITY or CONCURRENT\nLOCAL\nREPLACE or IGNORE\nCHARACTER SET\n(column_or_user_var,...)\nSET\n", "See LOAD DATA for more information about these clauses.", "The IGNORE number LINES or IGNORE number ROWS clause causes the first\nnumber rows in the XML file to be skipped. It is analogous to the LOAD\nDATA statement's IGNORE ... LINES clause.", "If the LOW_PRIORITY keyword is used, insertions are delayed until no other clients are reading from the table. The CONCURRENT keyword allows the use of concurrent inserts. These clauses cannot be specified together.", "This statement activates INSERT triggers."], "Examples": [], "Category": ["Data Manipulation"]}
