{"HTML": ["https://mariadb.com//kb/en/loop/"], "Title": ["LOOP"], "Feature": ["[begin_label:] LOOP\n    statement_list\nEND LOOP [end_label]\n"], "Description": ["LOOP implements a simple loop construct, enabling repeated execution\nof the statement list, which consists of one or more statements, each\nterminated by a semicolon (i.e., ;) statement delimiter. The statements\nwithin the loop are repeated until the loop is exited; usually this is\naccomplished with a LEAVE statement.", "A LOOP statement can be labeled. end_label cannot be given unless\nbegin_label also is present. If both are present, they must be the\nsame.", "See Delimiters in the mariadb client for more on delimiter usage in the client."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/open/"], "Title": ["OPEN"], "Feature": ["<= MariaDB 10.2", "OPEN cursor_name\n", "From MariaDB 10.3", "OPEN cursor_name [expression[,...]];\n"], "Description": ["This statement opens a cursor which was previously declared with DECLARE CURSOR.", "The query associated to the DECLARE CURSOR is executed when OPEN is executed. It is important to remember this if the query produces an error, or calls functions which have side effects.", "This is necessary in order to FETCH rows from a cursor.", "See Cursor Overview for an example."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/repeat-loop/"], "Title": ["REPEAT LOOP"], "Feature": ["[begin_label:] REPEAT\n    statement_list\nUNTIL search_condition\nEND REPEAT [end_label]\n", "The statement list within a REPEAT statement is repeated until the\nsearch_condition is true. Thus, a REPEAT always enters the loop at\nleast once. statement_list consists of one or more statements, each\nterminated by a semicolon (i.e., ;) statement delimiter.", "A REPEAT statement can be labeled. end_label cannot be given unless\nbegin_label also is present. If both are present, they must be the\nsame.", "See Delimiters in the mariadb client for more on client delimiter usage.", "DELIMITER //\n\nCREATE PROCEDURE dorepeat(p1 INT)\n  BEGIN\n    SET @x = 0;\n    REPEAT SET @x = @x + 1; UNTIL @x > p1 END REPEAT;\n  END\n//\n\nCALL dorepeat(1000)//\n\nSELECT @x//\n+------+\n| @x   |\n+------+\n| 1001 |\n+------+\n"], "Description": [], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/resignal/"], "Title": ["RESIGNAL"], "Feature": ["RESIGNAL [error_condition]\n    [SET error_property\n    [, error_property] ...]\n\nerror_condition:\n    SQLSTATE [VALUE] 'sqlstate_value'\n  | condition_name\n\nerror_property:\n    error_property_name = <error_property_value>\n\nerror_property_name:\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n"], "Description": ["The syntax of RESIGNAL and its semantics are very similar to SIGNAL. This statement can only be used within an error HANDLER. It produces an error, like SIGNAL. RESIGNAL clauses are the same as SIGNAL, except that they all are optional, even SQLSTATE. All the properties which are not specified in RESIGNAL, will be identical to the properties of the error that was received by the error HANDLER. For a description of the clauses, see diagnostics area.", "Note that RESIGNAL does not empty the diagnostics area: it just appends another error condition.", "RESIGNAL, without any clauses, produces an error which is identical to the error that was received by HANDLER.", "If used out of a HANDLER construct, RESIGNAL produces the following error:", "ERROR 1645 (0K000): RESIGNAL when handler not active\n", "In MariaDB 5.5, if a HANDLER contained a CALL to another procedure, that procedure could use RESIGNAL. Since MariaDB 10.0, trying to do this raises the above error.", "For a list of SQLSTATE values and MariaDB error codes, see MariaDB Error Codes.", "The following procedure tries to query two tables which don't exist, producing a 1146 error in both cases. Those errors will trigger the HANDLER. The first time the error will be ignored and the client will not receive it, but the second time, the error is re-signaled, so the client will receive it.", "CREATE PROCEDURE test_error( )\nBEGIN\n   DECLARE CONTINUE HANDLER\n      FOR 1146\n   BEGIN\n   IF @hide_errors IS FALSE THEN\n      RESIGNAL;\n   END IF;\n   END;\n   SET @hide_errors = TRUE;\n   SELECT 'Next error will be ignored' AS msg;\n   SELECT `c` FROM `temptab_one`;\n   SELECT 'Next error won''t be ignored' AS msg;\n   SET @hide_errors = FALSE;\n   SELECT `c` FROM `temptab_two`;\nEND;\n\nCALL test_error( );\n\n+----------------------------+\n| msg                        |\n+----------------------------+\n| Next error will be ignored |\n+----------------------------+\n\n+-----------------------------+\n| msg                         |\n+-----------------------------+\n| Next error won't be ignored |\n+-----------------------------+\n\nERROR 1146 (42S02): Table 'test.temptab_two' doesn't exist\n", "The following procedure re-signals an error, modifying only the error message to clarify the cause of the problem.", "CREATE PROCEDURE test_error()\nBEGIN\n   DECLARE CONTINUE HANDLER\n   FOR 1146\n   BEGIN\n      RESIGNAL SET\n      MESSAGE_TEXT = '`temptab` does not exist';\n   END;\n   SELECT `c` FROM `temptab`;\nEND;\n\nCALL test_error( );\nERROR 1146 (42S02): `temptab` does not exist\n", "As explained above, this works on MariaDB 5.5, but produces a 1645 error since 10.0.", "CREATE PROCEDURE handle_error()\nBEGIN\n  RESIGNAL;\nEND;\nCREATE PROCEDURE p()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION CALL p();\n  SIGNAL SQLSTATE '45000';\nEND;\n"], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/return/"], "Title": ["RETURN"], "Feature": ["RETURN expr \n", "The RETURN statement terminates execution of a stored function and\nreturns the value expr to the function caller. There must be at least\none RETURN statement in a stored function. If the function has multiple exit points, all exit points must have a RETURN.", "This statement is not used in stored procedures, triggers, or events. LEAVE can be used instead.", "The following example shows that RETURN can return the result of a scalar subquery:", "CREATE FUNCTION users_count() RETURNS BOOL\n   READS SQL DATA\nBEGIN\n   RETURN (SELECT COUNT(DISTINCT User) FROM mysql.user);\nEND;\n"], "Description": [], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/selectinto/"], "Title": ["SELECT INTO"], "Feature": ["SELECT col_name [, col_name] ...\n    INTO var_name [, var_name] ...\n    table_expr\n"], "Description": ["SELECT ... INTO enables selected columns to be stored directly\ninto variables. No resultset is produced. The query should return a single row. If the query\nreturns no rows, a warning with error code 1329 occurs (No data), and\nthe variable values remain unchanged. If the query returns multiple\nrows, error 1172 occurs (Result consisted of more than one row). If it\nis possible that the statement may retrieve multiple rows, you can use\nLIMIT 1 to limit the result set to a single row.", "The INTO clause can also be specified at the end of the statement.", "In the context of such statements that occur as part of events\nexecuted by the Event Scheduler, diagnostics messages (not only\nerrors, but also warnings) are written to the error log, and, on\nWindows, to the application event log.", "This statement can be used with both local variables and user-defined variables.", "For the complete syntax, see SELECT.", "Another way to set a variable's value is the SET statement.", "SELECT ... INTO results are not stored in the query cache even if SQL_CACHE is specified."], "Examples": ["SELECT id, data INTO @x,@y \nFROM test.t1 LIMIT 1;\nSELECT * from t1 where t1.a=@x and t1.b=@y\n", "SELECT  * INTO @x FROM (SELECT t1.a FROM t1 UNION SELECT t2.a FROM t2) dt;\n"], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/begin-end/"], "Title": ["BEGIN END"], "Feature": ["[begin_label:] BEGIN [NOT ATOMIC]\n    [statement_list]\nEND [end_label]\n", "NOT ATOMIC is required when used outside of a stored procedure. Inside stored procedures or within an anonymous block, BEGIN alone starts a new anonymous block."], "Description": ["BEGIN ... END syntax is used for writing compound statements. A compound statement can contain multiple statements, enclosed by the BEGIN and END keywords. statement_list represents a list of one or more statements, each\nterminated by a semicolon (i.e., ;) statement delimiter. statement_list is\noptional, which means that the empty compound statement (BEGIN END) is\nlegal.", "Note that END will perform a commit. If you are running in autocommit mode, every statement will be committed separately. If you are not running in autocommit mode, you must execute a COMMIT or ROLLBACK after END to get the database up to date.", "Use of multiple statements requires that a client is able to send statement strings containing the ; statement delimiter. This is handled in the mysql  command-line client with the DELIMITER command.\nChanging the ; end-of-statement delimiter (for example, to\n//) allows ; to be used in a program body.", "A compound statement within a stored program can be\nlabeled. end_label cannot be given unless begin_label also is present. If both are present, they must be the same.", "BEGIN ... END constructs can be nested. Each block can define its own variables, a CONDITION, a HANDLER and a CURSOR, which don't exist in the outer blocks. The most local declarations override the outer objects which use the same name (see example below).", "The declarations order is the following:", "DECLARE local variables;\nDECLARE CONDITIONs;\nDECLARE CURSORs;\nDECLARE HANDLERs;\n", "Note that DECLARE HANDLER contains another BEGIN ... END construct.", "Here is an example of a very simple, anonymous block:", "BEGIN NOT ATOMIC\nSET @a=1;\nCREATE TABLE test.t1(a INT);\nEND|\n", "Below is an example of nested blocks in a stored procedure:", "CREATE PROCEDURE t( )\nBEGIN\n   DECLARE x TINYINT UNSIGNED DEFAULT 1;\n   BEGIN\n      DECLARE x CHAR(2) DEFAULT '02';\n       DECLARE y TINYINT UNSIGNED DEFAULT 10;\n       SELECT x, y;\n   END;\n   SELECT x;\nEND;\n", "In this example, a TINYINT variable, x is declared in the outter block. But in the inner block x is re-declared as a CHAR and an y variable is declared. The inner SELECT  shows the \"new\" value of x, and the value of y. But when x is selected in the outer block, the \"old\" value is returned. The final SELECT doesn't try to read y, because it doesn't exist in that context."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/case-statement/"], "Title": ["CASE Statement"], "Feature": ["CASE case_value\n    WHEN when_value THEN statement_list\n    [WHEN when_value THEN statement_list] ...\n    [ELSE statement_list]\nEND CASE\n", "Or:", "CASE\n    WHEN search_condition THEN statement_list\n    [WHEN search_condition THEN statement_list] ...\n    [ELSE statement_list] \nEND CASE\n"], "Description": ["The text on this page describes the CASE statement for stored programs. See the CASE OPERATOR for details on the CASE operator outside of stored programs.", "The CASE statement for stored programs implements a complex conditional\nconstruct. If a search_condition evaluates to true, the corresponding SQL\nstatement list is executed. If no search condition matches, the statement list\nin the ELSE clause is executed. Each statement_list consists of one or\nmore statements.", "The CASE statement cannot have an ELSE NULL clause, and it is\nterminated with END CASE instead of END. implements a complex conditional\nconstruct. If a search_condition evaluates to true, the corresponding SQL\nstatement list is executed. If no search condition matches, the statement list\nin the ELSE clause is executed. Each statement_list consists of one or\nmore statements.", "If no when_value or search_condition matches the value tested and the CASE\nstatement contains no ELSE clause, a Case not found for CASE statement\nerror results.", "Each statement_list consists of one or more statements; an empty\nstatement_list is not allowed. To handle situations where no value is\nmatched by any WHEN clause, use an ELSE containing an\nempty BEGIN ... END block, as shown in this example:", "DELIMITER |\nCREATE PROCEDURE p()\nBEGIN\n  DECLARE v INT DEFAULT 1;\n  CASE v\n    WHEN 2 THEN SELECT v;\n    WHEN 3 THEN SELECT 0;\n    ELSE BEGIN END;\n  END CASE;\nEND;\n|\n", "The indentation used here in the ELSE clause is for purposes of clarity only,\nand is not otherwise significant. See Delimiters in the mariadb client for more on the use of the delimiter command.", "Note: The syntax of the CASE statement used inside stored programs\ndiffers slightly from that of the SQL CASE expression described in\nCASE OPERATOR.\nThe CASE statement cannot have an ELSE NULL clause, and it is\nterminated with END CASE instead of END."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/signal/"], "Title": ["SIGNAL"], "Feature": ["SIGNAL error_condition\n    [SET error_property\n    [, error_property] ...]\n\nerror_condition:\n    SQLSTATE [VALUE] 'sqlstate_value'\n  | condition_name\n\nerror_property:\n    error_property_name = <error_property_value>\n\nerror_property_name:\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n", "SIGNAL empties the diagnostics area and produces a custom error. This statement can be used anywhere, but is generally useful when used inside a stored program. When the error is produced, it can be caught by a HANDLER. If not, the current stored program, or the current statement, will terminate with the specified error.", "Sometimes an error HANDLER just needs to SIGNAL the same error it received, optionally with some changes. Usually the RESIGNAL statement is the most convenient way to do this.", "error_condition can be an SQLSTATE value or a named error condition defined via DECLARE CONDITION. SQLSTATE must be a constant string consisting of five characters. These codes are standard to ODBC and ANSI SQL. For customized errors, the recommended SQLSTATE is '45000'. For a list of SQLSTATE values used by MariaDB, see the MariaDB Error Codes page. The SQLSTATE can be read via the API method mysql_sqlstate( ). ", "To specify error properties user-defined variables and local variables can be used, as well as character set conversions (but you can't set a collation).", "The error properties, their type and their default values are explained in the diagnostics area page."], "Description": [], "Examples": ["SIGNAL SQLSTATE '01000';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nSHOW WARNINGS;\n\n+---------+------+------------------------------------------+\n| Level   | Code | Message                                  |\n+---------+------+------------------------------------------+\n| Warning | 1642 | Unhandled user-defined warning condition |\n+---------+------+------------------------------------------+\n1 row in set (0.06 sec)\n\nSIGNAL SQLSTATE '02000';\nERROR 1643 (02000): Unhandled user-defined not found condition\n", "SIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=30001, MESSAGE_TEXT='H\nello, world!';\n\nERROR 30001 (45000): Hello, world!\n", "CREATE PROCEDURE test_error(x INT)\nBEGIN\n   DECLARE errno SMALLINT UNSIGNED DEFAULT 31001;\n   SET @errmsg = 'Hello, world!';\n   IF x = 1 THEN\n      SIGNAL SQLSTATE '45000' SET\n      MYSQL_ERRNO = errno,\n      MESSAGE_TEXT = @errmsg;\n   ELSE\n      SIGNAL SQLSTATE '45000' SET\n      MYSQL_ERRNO = errno,\n      MESSAGE_TEXT = _utf8'Hello, world!';\n   END IF;\nEND;\n", "CREATE PROCEDURE test_error(n INT)\nBEGIN\n   DECLARE `too_big` CONDITION FOR SQLSTATE '45000';\n   IF n > 10 THEN\n      SIGNAL `too_big`;\n   END IF;\nEND;\n", "CREATE PROCEDURE test_error()\nBEGIN\n   DECLARE EXIT HANDLER\n   FOR 1146\n   BEGIN\n      SIGNAL SQLSTATE '45000' SET\n      MESSAGE_TEXT = 'Temporary tables not found; did you call init() procedure?';\n   END;\n   -- this will produce a 1146 error\n   SELECT `c` FROM `temptab`;\nEND;\n"], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/while/"], "Title": ["WHILE"], "Feature": ["[begin_label:] WHILE search_condition DO\n    statement_list\nEND WHILE [end_label]\n"], "Description": ["The statement list within a WHILE statement is repeated as long as the\nsearch_condition is true. statement_list consists of one or more\nstatements. If the loop must be executed at least once, REPEAT ... LOOP can be used instead.", "A WHILE statement can be labeled. end_label cannot be given unless\nbegin_label also is present. If both are present, they must be the\nsame."], "Examples": ["CREATE PROCEDURE dowhile()\nBEGIN\n  DECLARE v1 INT DEFAULT 5;\n\n  WHILE v1 > 0 DO\n    ...\n    SET v1 = v1 - 1;\n  END WHILE;\nEND\n"], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/close/"], "Title": ["CLOSE"], "Feature": ["CLOSE cursor_name\n"], "Description": ["This statement closes a previously opened cursor. The cursor must have been previously opened or else an error occurs.", "If not closed explicitly, a cursor is closed at the end of the\ncompound statement in which it was declared.", "See Cursor Overview for an example."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/declare-condition/"], "Title": ["DECLARE CONDITION"], "Feature": ["DECLARE condition_name CONDITION FOR condition_value\n\ncondition_value:\n    SQLSTATE [VALUE] sqlstate_value\n  | mysql_error_code\n"], "Description": ["The DECLARE ... CONDITION statement defines a named error condition.\nIt specifies a condition that needs specific handling and associates a\nname with that condition. Later, the name can be used in a DECLARE ... HANDLER, SIGNAL or RESIGNAL statement (as long as the statement is located in the same BEGIN ... END block).", "Conditions must be declared after local variables, but before CURSORs and HANDLERs.", "A condition_value for DECLARE ... CONDITION can be an SQLSTATE value (a\n5-character string literal) or a MySQL error code (a number). You should not\nuse SQLSTATE value '00000' or MySQL error code 0, because those indicate sucess\nrather than an error condition. If you try, or if you specify an invalid SQLSTATE value, an error like this is produced:", "ERROR 1407 (42000): Bad SQLSTATE: '00000'\n", "For a list of SQLSTATE values and MariaDB error\ncodes, see MariaDB Error Codes."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/declare-cursor/"], "Title": ["DECLARE CURSOR"], "Feature": ["<= MariaDB 10.2", "DECLARE cursor_name CURSOR FOR select_statement\n", "From MariaDB 10.3", "DECLARE cursor_name CURSOR [(cursor_formal_parameter[,...])] FOR select_statement\n\ncursor_formal_parameter:\n    name type [collate clause]\n", "From MariaDB 10.8", "DECLARE cursor_name CURSOR [(cursor_formal_parameter[,...])] FOR select_statement\n\ncursor_formal_parameter:\n    [IN] name type [collate clause]\n"], "Description": ["This statement declares a cursor. Multiple cursors may be declared in a stored program, but each cursor in a given block must have a unique name.", "select_statement is not executed until the OPEN statement is executed. It is important to remember this if the query produces an error, or calls functions which have side effects.", "A SELECT associated to a cursor can use variables, but the query itself cannot be a variable, and cannot be dynamically composed. The SELECT statement cannot have an INTO clause.", "Cursors must be declared before HANDLERs, but after local variables and CONDITIONs.", "Parameters", "From MariaDB 10.3.0, cursors can have parameters. This is a non-standard SQL extension. Cursor parameters can appear in any part of the DECLARE CURSOR select_statement where a stored procedure variable is allowed (select list, WHERE, HAVING, LIMIT etc).", "IN", "MariaDB starting with 10.8.0From MariaDB 10.8.0 preview release, the IN qualifier is supported in the cursor_format_parameter part of the syntax.\n", "See Cursor Overview for an example."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/declare-handler/"], "Title": ["DECLARE HANDLER"], "Feature": ["DECLARE handler_type HANDLER\n    FOR condition_value [, condition_value] ...\n    statement\n\nhandler_type:\n    CONTINUE\n  | EXIT \n  | UNDO\n\ncondition_value:\n    SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n  | SQLWARNING\n  | NOT FOUND\n  | SQLEXCEPTION\n  | mariadb_error_code\n"], "Description": ["The DECLARE ... HANDLER statement specifies handlers that each may\ndeal with one or more conditions. If one of these conditions occurs,\nthe specified statement is executed. statement can be a simple\nstatement (for example, SET var_name = value), or it can be a compound\nstatement written using BEGIN and END.", "Handlers must be declared after local variables, a CONDITION and a CURSOR.", "For a CONTINUE handler, execution of the current program continues\nafter execution of the handler statement. For an EXIT handler,\nexecution terminates for the BEGIN ... END compound statement in which\nthe handler is declared. (This is true even if the condition occurs in\nan inner block.) The UNDO handler type statement is not supported.", "If a condition occurs for which no handler has been declared, the\ndefault action is EXIT.", "A condition_value for DECLARE ... HANDLER can be any of the following\nvalues:", "An SQLSTATE value (a 5-character string literal) or a MariaDB error\ncode (a number). You should not use SQLSTATE value '00000' or MariaDB\nerror code 0, because those indicate sucess rather than an error\ncondition. For a list of SQLSTATE values and MariaDB error codes, see\nMariaDB Error Codes.\nA condition name previously specified with DECLARE ... CONDITION. It must be in the same stored program. See DECLARE CONDITION.\nSQLWARNING is shorthand for the class of SQLSTATE values that begin\nwith '01'.\nNOT FOUND is shorthand for the class of SQLSTATE values that begin\nwith '02'. This is relevant only the context of cursors and is used to\ncontrol what happens when a cursor reaches the end of a data set. If\nno more rows are available, a No Data condition occurs with SQLSTATE\nvalue 02000. To detect this condition, you can set up a handler for it\n(or for a NOT FOUND condition). An example is shown in Cursor Overview. This condition also occurs for SELECT ... INTO var_list statements that retrieve no\nrows.\nSQLEXCEPTION is shorthand for the class of SQLSTATE values that do\nnot begin with '00', '01', or '02'.\n", "When an error raises, in some cases it could be handled by multiple HANDLERs. For example, there may be an handler for 1050 error, a separate handler for the 42S01 SQLSTATE, and another separate handler for the SQLEXCEPTION class: in theory all occurrences of HANDLER may catch the 1050 error, but MariaDB chooses the HANDLER with the highest precedence. Here are the precedence rules:", "Handlers which refer to an error code have the highest precedence.\nHandlers which refer to a SQLSTATE come next.\nHandlers which refer to an error class have the lowest precedence.\n", "In some cases, a statement could produce multiple errors. If this happens, in some cases multiple handlers could have the highest precedence. In such cases, the choice of the handler is indeterminate.", "Note that if an error occurs within a CONTINUE HANDLER block, it can be handled by another HANDLER. However, a HANDLER which is already in the stack (that is, it has been called to handle an error and its execution didn't finish yet) cannot handle new errors\u2014this prevents endless loops. For example, suppose that a stored procedure contains a CONTINUE HANDLER for SQLWARNING and another CONTINUE HANDLER for NOT FOUND. At some point, a NOT FOUND error occurs, and the execution enters the NOT FOUND HANDLER. But within that handler, a warning occurs, and the execution enters the SQLWARNING HANDLER. If another NOT FOUND error occurs, it cannot be handled again by the NOT FOUND HANDLER, because its execution is not finished.", "When a DECLARE HANDLER block can handle more than one error condition, it may be useful to know which errors occurred. To do so, you can use the GET DIAGNOSTICS statement.", "An error that is handled by a DECLARE HANDLER construct can be issued again using the RESIGNAL statement.", "Below is an example using DECLARE HANDLER:", "CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));\n\nDELIMITER //\n\nCREATE PROCEDURE handlerdemo ( )\n     BEGIN\n       DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;\n       SET @x = 1;\n       INSERT INTO test.t VALUES (1);\n       SET @x = 2;\n       INSERT INTO test.t VALUES (1);\n       SET @x = 3;\n     END;\n     //\n\nDELIMITER ;\n\nCALL handlerdemo( );\n\nSELECT @x;\n+------+\n| @x   |\n+------+\n|    3 |\n+------+\n"], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/declare-variable/"], "Title": ["DECLARE Variable"], "Feature": ["DECLARE var_name [, var_name] ... [[ROW] TYPE OF]] type [DEFAULT value]\n"], "Description": ["This statement is used to declare local variables within stored programs. To\nprovide a default value for the variable, include a DEFAULT clause. The\nvalue can be specified as an expression (even subqueries are permitted); it need not be a constant. If the\nDEFAULT clause is missing, the initial value is NULL.", "Local variables are treated like stored routine parameters with respect to data\ntype and overflow checking.  See CREATE PROCEDURE.", "Local variables must be declared before CONDITIONs, CURSORs and HANDLERs.", "Local variable names are not case sensitive.", "The scope of a local variable is within the BEGIN ... END block where it is\ndeclared. The variable can be referred to in blocks nested within the declaring\nblock, except those blocks that declare a variable with the same name.", "TYPE OF / ROW TYPE OF", "Anchored data types allow a data type to be defined based on another object, such as a table row, rather than specifically set in the declaration. If the anchor object changes, so will the anchored data type. This can lead to routines being easier to maintain, so that if the data type in the table is changed, it will automatically be changed in the routine as well.", "Variables declared with ROW TYPE OF will have the same features as implicit ROW variables. It is not possible to use ROW TYPE OF variables in a LIMIT clause.", "The real data type of TYPE OF and ROW TYPE OF table_name will become known at the very beginning of the stored routine call. ALTER TABLE or DROP TABLE statements performed inside the current routine on the tables that appear in anchors won't affect the data type of the anchored variables, even if the variable is declared after an ALTER TABLE or DROP TABLE statement.", "The real data type of a ROW TYPE OF cursor_name variable will become known when execution enters into the block where the variable is declared. Data type instantiation will happen only once. In a cursor ROW TYPE OF variable that is declared inside a loop, its data type will become known on the very first iteration and won't change on further loop iterations.", "The tables referenced in TYPE OF and ROW TYPE OF declarations will be checked for existence at the beginning of the stored routine call. CREATE PROCEDURE or CREATE FUNCTION will not check the referenced tables for existence."], "Examples": ["  DECLARE name VARCHAR(5) DEFAULT 'monty';\n  DECLARE x INT DEFAULT 10;\n  DECLARE Y SMALLINT;\n", "DECLARE tmp TYPE OF t1.a; -- Get the data type from the column {{a}} in the table {{t1}}\n\nDECLARE rec1 ROW TYPE OF t1; -- Get the row data type from the table {{t1}}\n\nDECLARE rec2 ROW TYPE OF cur1; -- Get the row data type from the cursor {{cur1}}\n"], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/fetch/"], "Title": ["FETCH"], "Feature": ["FETCH cursor_name INTO var_name [, var_name] ...\n"], "Description": ["This statement fetches the next row (if a row exists) using the\nspecified open cursor, and advances the cursor pointer.", "var_name can be a local variable, but not a user-defined variable.", "If no more rows are available, a No Data condition occurs with\nSQLSTATE value 02000. To detect this condition, you can set up a\nhandler for it (or for a NOT FOUND condition).", "See Cursor Overview for an example."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/for/"], "Title": ["FOR"], "Feature": ["Integer range FOR loop:", "[begin_label:]\nFOR var_name IN [ REVERSE ] lower_bound .. upper_bound\nDO statement_list\nEND FOR [ end_label ]\n", "Explicit cursor FOR loop", "[begin_label:]\nFOR record_name IN cursor_name [ ( cursor_actual_parameter_list)]\nDO statement_list\nEND FOR [ end_label ]\n", "Explicit cursor FOR loop (Oracle mode)", "[begin_label:]\nFOR record_name IN cursor_name [ ( cursor_actual_parameter_list)]\nLOOP\n  statement_list\nEND LOOP [ end_label ]\n", "Implicit cursor FOR loop", "[begin_label:]\nFOR record_name IN ( select_statement )\nDO statement_list\nEND FOR [ end_label ]\n"], "Description": ["FOR loops allow code to be executed a fixed number of times.", "In an integer range FOR loop, MariaDB will compare the lower bound and upper bound values, and assign the lower bound value to a counter. If REVERSE is not specified, and the upper bound value is greater than or equal to the counter, the counter will be incremented and the statement will continue, after which the loop is entered again. If the upper bound value is greater than the counter, the loop will be exited.", "If REVERSE is specified, the counter is decremented, and the upper bound value needs to be less than or equal for the loop to continue."], "Examples": ["CREATE TABLE t1 (a INT);\n\nDELIMITER //\n\nFOR i IN 1..3\nDO\n  INSERT INTO t1 VALUES (i);\nEND FOR;\n//\n\nDELIMITER ;\n\nSELECT * FROM t1;\n+------+\n| a    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n+------+\n", "CREATE OR REPLACE TABLE t1 (a INT);\n\nDELIMITER //\nFOR i IN REVERSE 4..12\n    DO\n    INSERT INTO t1 VALUES (i);\nEND FOR;\n//\nQuery OK, 9 rows affected (0.422 sec)\n\n\nDELIMITER ;\n\nSELECT * FROM t1;\n+------+\n| a    |\n+------+\n|   12 |\n|   11 |\n|   10 |\n|    9 |\n|    8 |\n|    7 |\n|    6 |\n|    5 |\n|    4 |\n+------+\n", "SET sql_mode=ORACLE;\n\nCREATE OR REPLACE TABLE t1 (a INT, b VARCHAR(32));\n\nINSERT INTO t1 VALUES (10,'b0');\nINSERT INTO t1 VALUES (11,'b1');\nINSERT INTO t1 VALUES (12,'b2');\n\nDELIMITER //\n\nCREATE OR REPLACE PROCEDURE p1(pa INT) AS \n  CURSOR cur(va INT) IS\n    SELECT a, b FROM t1 WHERE a=va;\nBEGIN\n  FOR rec IN cur(pa)\n  LOOP\n    SELECT rec.a, rec.b;\n  END LOOP;\nEND;\n//\n\nDELIMITER ;\n\nCALL p1(10);\n+-------+-------+\n| rec.a | rec.b |\n+-------+-------+\n|    10 | b0    |\n+-------+-------+\n\nCALL p1(11);\n+-------+-------+\n| rec.a | rec.b |\n+-------+-------+\n|    11 | b1    |\n+-------+-------+\n\nCALL p1(12);\n+-------+-------+\n| rec.a | rec.b |\n+-------+-------+\n|    12 | b2    |\n+-------+-------+\n\nCALL p1(13);\nQuery OK, 0 rows affected (0.000 sec)\n"], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/goto/"], "Title": ["GOTO"], "Feature": ["GOTO label\n"], "Description": ["The GOTO statement causes the code to jump to the specified label, and continue operating from there. It is only accepted when in Oracle mode."], "Examples": ["SET sql_mode=ORACLE;\n\nDELIMITER //\n\nCREATE OR REPLACE PROCEDURE p1 AS\n\nBEGIN\n\n  SELECT 1;\n  GOTO label;\n  SELECT 2;\n  <<label>>\n  SELECT 3;\n\nEND;\n\n//\n\nDELIMITER \n\ncall p1();\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n1 row in set (0.000 sec)\n\n+---+\n| 3 |\n+---+\n| 3 |\n+---+\n1 row in set (0.000 sec)\n"], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/if/"], "Title": ["IF"], "Feature": ["IF search_condition THEN statement_list\n    [ELSEIF search_condition THEN statement_list] ...\n    [ELSE statement_list]\nEND IF;\n"], "Description": ["IF implements a basic conditional construct. If the search_condition\nevaluates to true, the corresponding SQL statement list is executed.\nIf no search_condition matches, the statement list in the ELSE clause\nis executed. Each statement_list consists of one or more statements."], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/iterate/"], "Title": ["ITERATE"], "Feature": ["ITERATE label\n", "ITERATE can appear only within LOOP, REPEAT, and WHILE statements.\nITERATE means \"do the loop again\", and uses the statement's label to determine which statements to repeat. The label must be in the same stored program, not in a caller procedure.", "If you try to use ITERATE with a non-existing label, or if the label is associated to a construct which is not a loop, the following error will be produced:", "ERROR 1308 (42000): ITERATE with no matching label: <label_name>\n", "Below is an example of how ITERATE might be used:", "CREATE PROCEDURE doiterate(p1 INT)\nBEGIN\n  label1: LOOP\n    SET p1 = p1 + 1;\n    IF p1 < 10 THEN ITERATE label1; END IF;\n    LEAVE label1;\n  END LOOP label1;\n  SET @x = p1;\nEND\n"], "Description": [], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/labels/"], "Title": ["Labels"], "Feature": ["label: <construct>\n[label]\n", "Labels are MariaDB identifiers which can be used to identify a BEGIN ... END construct or a loop. They have a maximum length of 16 characters and can be quoted with backticks (i.e.., `).", "Labels have a start part and an end part. The start part must precede the portion of code it refers to, must be followed by a colon (:) and can be on the same or different line. The end part is optional and adds nothing, but can make the code more readable. If used, the end part must precede the construct's delimiter (;). Constructs identified by a label can be nested. Each construct can be identified by only one label.", "Labels need not be unique in the stored program they belong to. However, a label for an inner loop cannot be identical to a label for an outer loop. In this case, the following error would be produced:", "ERROR 1309 (42000): Redefining label <label_name>\n", "LEAVE and ITERATE statements can be used to exit or repeat a portion of code identified by a label. They must be in the same Stored Routine, Trigger or Event which contains the target label.", "Below is an example using a simple label that is used to exit a LOOP:", "CREATE PROCEDURE `test_sp`()\nBEGIN\n   `my_label`:\n   LOOP\n      SELECT 'looping';\n      LEAVE `my_label`;\n   END LOOP;\n   SELECT 'out of loop';\nEND;\n", "The following label is used to exit a procedure, and has an end part:", "CREATE PROCEDURE `test_sp`()\n`my_label`:\nBEGIN\n   IF @var = 1 THEN\n      LEAVE `my_label`;\n   END IF;\n   DO something();\nEND `my_label`;\n"], "Description": [], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
{"HTML": ["https://mariadb.com//kb/en/leave/"], "Title": ["LEAVE"], "Feature": ["LEAVE label\n", "This statement is used to exit the flow control construct that has the\ngiven label. The label must be in the same stored program, not in a caller procedure. LEAVE can be used within BEGIN ... END or loop constructs\n(LOOP, REPEAT, WHILE). In Stored Procedures, Triggers and Events, LEAVE can refer to the outmost BEGIN ... END construct; in that case, the program exits the procedure. In Stored Functions, RETURN can be used instead.", "Note that LEAVE cannot be used to exit a DECLARE HANDLER block.", "If you try to LEAVE a non-existing label, or if you try to LEAVE a HANDLER block, the following error will be produced:", "ERROR 1308 (42000): LEAVE with no matching label: <label_name>\n", "The following example uses LEAVE to exit the procedure if a condition is true:", "CREATE PROCEDURE proc(IN p TINYINT)\nCONTAINS SQL\n`whole_proc`:\nBEGIN\n   SELECT 1;\n   IF p < 1 THEN\n      LEAVE `whole_proc`;\n   END IF;\n   SELECT 2;\nEND;\n\nCALL proc(0);\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n"], "Description": [], "Examples": [], "Category": ["Programmatic and Compound Statements"]}
