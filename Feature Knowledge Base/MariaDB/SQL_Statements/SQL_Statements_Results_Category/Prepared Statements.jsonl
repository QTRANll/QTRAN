{"HTML": ["https://mariadb.com//kb/en/prepare-statement/"], "Title": ["PREPARE Statement"], "Feature": ["PREPARE stmt_name FROM preparable_stmt\n"], "Description": ["The PREPARE statement prepares a statement and assigns it a name,\nstmt_name, by which to refer to the statement later. Statement names\nare not case sensitive. preparable_stmt is either a string literal or a user variable (not a local variable, an SQL expression or a subquery) that contains the text of the statement. The text must   \nrepresent a single SQL statement, not multiple statements. Within the\nstatement, \"?\" characters can be used as parameter markers to indicate\nwhere data values are to be bound to the query later when you execute\nit. The \"?\" characters should not be enclosed within quotes, even if\nyou intend to bind them to string values. Parameter markers can be used\nonly where expressions should appear, not for SQL keywords,\nidentifiers, and so forth.", "The scope of a prepared statement is the session within which it is\ncreated. Other sessions cannot see it.", "If a prepared statement with the given name already exists, it is\ndeallocated implicitly before the new statement is prepared. This means\nthat if the new statement contains an error and cannot be prepared, an\nerror is returned and no statement with the given name exists.", "Prepared statements can be PREPAREd and EXECUTEd in a stored procedure, but not in a stored function or trigger. Also, even if the statement is PREPAREd in a procedure, it will not be deallocated when the procedure execution ends.", "A prepared statement can access user-defined variables, but not local variables or procedure's parameters.", "If the prepared statement contains a syntax error, PREPARE will fail. As a side effect, stored procedures can use it to check if a statement is valid. For example:", "CREATE PROCEDURE `test_stmt`(IN sql_text TEXT)\nBEGIN\n        DECLARE EXIT HANDLER FOR SQLEXCEPTION\n        BEGIN\n                SELECT CONCAT(sql_text, ' is not valid');\n        END;\n        SET @SQL := sql_text;\n        PREPARE stmt FROM @SQL;\n        DEALLOCATE PREPARE stmt;\nEND;\n", "The FOUND_ROWS() and ROW_COUNT() functions, if called immediatly after EXECUTE, return the number of rows read or affected by the prepared statements; however, if they are called after DEALLOCATE PREPARE, they provide information about this statement. If the prepared statement produces errors or warnings, GET DIAGNOSTICS return information about them. DEALLOCATE PREPARE shouldn't clear the diagnostics area, unless it produces an error.", "A prepared statement is executed with EXECUTE and released \nwith DEALLOCATE PREPARE.", "The max_prepared_stmt_count server system variable determines the number of allowed prepared statements that can be prepared on the server. If it is set to 0, prepared statements are not allowed. If the limit is reached, an error similar to the following will be produced:", "ERROR 1461 (42000): Can't create more than max_prepared_stmt_count statements \n  (current value: 0)\n", "Oracle Mode", "In Oracle mode, PREPARE stmt FROM 'SELECT :1, :2' is used, instead of ?."], "Examples": ["create table t1 (a int,b char(10));\ninsert into t1 values (1,\"one\"),(2, \"two\"),(3,\"three\");\nprepare test from \"select * from t1 where a=?\";\nset @param=2;\nexecute test using @param;\n+------+------+\n| a    | b    |\n+------+------+\n|    2 | two  |\n+------+------+\nset @param=3;\nexecute test using @param;\n+------+-------+\n| a    | b     |\n+------+-------+\n|    3 | three |\n+------+-------+\ndeallocate prepare test;\n", "CREATE PROCEDURE test.stmt_test(IN tab_name VARCHAR(64))\nBEGIN\n\tSET @sql = CONCAT('SELECT COUNT(*) FROM ', tab_name);\n\tPREPARE stmt FROM @sql;\n\tEXECUTE stmt;\n\tDEALLOCATE PREPARE stmt;\nEND;\n\nCALL test.stmt_test('mysql.user');\n+----------+\n| COUNT(*) |\n+----------+\n|        4 |\n+----------+\n", "PREPARE stmt FROM 'SELECT @x;';\n\nSET @x = 1;\n\nEXECUTE stmt;\n+------+\n| @x   |\n+------+\n|    1 |\n+------+\n\nSET @x = 0;\n\nEXECUTE stmt;\n+------+\n| @x   |\n+------+\n|    0 |\n+------+\n\nDEALLOCATE PREPARE stmt;\n"], "Category": ["Prepared Statements"]}
{"HTML": ["https://mariadb.com//kb/en/deallocate-drop-prepare/"], "Title": ["DEALLOCATE / DROP PREPARE"], "Feature": ["{DEALLOCATE | DROP} PREPARE stmt_name\n"], "Description": ["To deallocate a prepared statement produced with PREPARE, use a\nDEALLOCATE PREPARE statement that refers to the prepared statement\nname.", "A prepared statement is implicitly deallocated when a new PREPARE command is issued. In that case, there is no need to use DEALLOCATE.", "Attempting to execute a prepared statement after deallocating it\nresults in an error, as if it was not prepared at all:", "ERROR 1243 (HY000): Unknown prepared statement handler (stmt_name) given to EXECUTE\n", "If the specified statement has not been PREPAREd, an error similar to the following will be produced:", "ERROR 1243 (HY000): Unknown prepared statement handler (stmt_name) given to DEALLOCATE PREPARE\n"], "Examples": [], "Category": ["Prepared Statements"]}
{"HTML": ["https://mariadb.com//kb/en/execute-immediate/"], "Title": ["EXECUTE IMMEDIATE"], "Feature": ["EXECUTE IMMEDIATE statement\n    [USING param[, param] ...]\n\nparam:\n    expression | IGNORE | DEFAULT\n"], "Description": ["EXECUTE IMMEDIATE executes a dynamic SQL statement created on the fly, which can reduce performance overhead.", "For example:", "EXECUTE IMMEDIATE 'SELECT 1' \n", "which is shorthand for:", "prepare stmt from \"select 1\";\nexecute stmt;\ndeallocate prepare stmt;\n", "EXECUTE IMMEDIATE supports complex expressions as prepare source and parameters:", "EXECUTE IMMEDIATE CONCAT('SELECT COUNT(*) FROM ', 't1', ' WHERE a=?') USING 5+5;\n", "Limitations: subselects and stored function calls are not supported as a prepare source.", "The following examples return an error:", "CREATE OR REPLACE FUNCTION f1() RETURNS VARCHAR(64) RETURN 'SELECT * FROM t1';\nEXECUTE IMMEDIATE f1();\nERROR 1970 (42000): EXECUTE IMMEDIATE does not support subqueries or stored functions\n\nEXECUTE IMMEDIATE (SELECT 'SELECT * FROM t1');\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that \n  corresponds to your MariaDB server version for the right syntax to use near \n  'SELECT 'SELECT * FROM t1')' at line 1\n\nCREATE OR REPLACE FUNCTION f1() RETURNS INT RETURN 10;\nEXECUTE IMMEDIATE 'SELECT * FROM t1 WHERE a=?' USING f1();\nERROR 1970 (42000): EXECUTE..USING does not support subqueries or stored functions\n\nEXECUTE IMMEDIATE 'SELECT * FROM t1 WHERE a=?' USING (SELECT 10);\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that \n  corresponds to your MariaDB server version for the right syntax to use near \n  'SELECT 10)' at line 1\n", "One can use a user or an SP variable as a workaround:", "CREATE OR REPLACE FUNCTION f1() RETURNS VARCHAR(64) RETURN 'SELECT * FROM t1';\nSET @stmt=f1();\nEXECUTE IMMEDIATE @stmt;\n\nSET @stmt=(SELECT 'SELECT 1');\nEXECUTE IMMEDIATE @stmt;\n\nCREATE OR REPLACE FUNCTION f1() RETURNS INT RETURN 10;\nSET @param=f1();\nEXECUTE IMMEDIATE 'SELECT * FROM t1 WHERE a=?' USING @param;\n\nSET @param=(SELECT 10);\nEXECUTE IMMEDIATE 'SELECT * FROM t1 WHERE a=?' USING @param;\n", "EXECUTE IMMEDIATE supports user variables and SP variables as OUT parameters", "DELIMITER $$\nCREATE OR REPLACE PROCEDURE p1(OUT a INT)\nBEGIN\n  SET a:= 10;\nEND;\n$$\nDELIMITER ;\nSET @a=2;\nEXECUTE IMMEDIATE 'CALL p1(?)' USING @a;\nSELECT @a;\n+------+\n| @a   |\n+------+\n|   10 |\n+------+\n", "Similar to PREPARE, EXECUTE IMMEDIATE is allowed in stored procedures but is not allowed in stored functions.", "This example uses EXECUTE IMMEDIATE inside a stored procedure:", "DELIMITER $$\nCREATE OR REPLACE PROCEDURE p1()\nBEGIN\n  EXECUTE IMMEDIATE 'SELECT 1';\nEND;\n$$\nDELIMITER ;\nCALL p1;\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n", "This script returns an error:", "DELIMITER $$\nCREATE FUNCTION f1() RETURNS INT\nBEGIN\n  EXECUTE IMMEDIATE 'DO 1';\n  RETURN 1;\nEND;\n$$\nERROR 1336 (0A000): Dynamic SQL is not allowed in stored function or trigger\n", "EXECUTE IMMEDIATE can use DEFAULT and IGNORE indicators as bind parameters:", "CREATE OR REPLACE TABLE t1 (a INT DEFAULT 10);\nEXECUTE IMMEDIATE 'INSERT INTO t1 VALUES (?)' USING DEFAULT;\nSELECT * FROM t1;\n+------+\n| a    |\n+------+\n|   10 |\n+------+\n", "EXECUTE IMMEDIATE increments the Com_execute_immediate status variable, as well as the Com_stmt_prepare, Com_stmt_execute and Com_stmt_close status variables.", "Note, EXECUTE IMMEDIATE does not increment the Com_execute_sql status variable. Com_execute_sql is used only for PREPARE..EXECUTE.", "This session screenshot demonstrates how EXECUTE IMMEDIATE affects status variables:", "SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS WHERE VARIABLE_NAME RLIKE \n  ('COM_(EXECUTE|STMT_PREPARE|STMT_EXECUTE|STMT_CLOSE)');\n\n+-----------------------+----------------+\n| VARIABLE_NAME         | VARIABLE_VALUE |\n+-----------------------+----------------+\n| COM_EXECUTE_IMMEDIATE | 0              |\n| COM_EXECUTE_SQL       | 0              |\n| COM_STMT_CLOSE        | 0              |\n| COM_STMT_EXECUTE      | 0              |\n| COM_STMT_PREPARE      | 0              |\n+-----------------------+----------------+\n\nEXECUTE IMMEDIATE 'SELECT 1';\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n\nSELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS WHERE VARIABLE_NAME RLIKE \n  ('COM_(EXECUTE|STMT_PREPARE|STMT_EXECUTE|STMT_CLOSE)');\n+-----------------------+----------------+\n| VARIABLE_NAME         | VARIABLE_VALUE |\n+-----------------------+----------------+\n| COM_EXECUTE_IMMEDIATE | 1              |\n| COM_EXECUTE_SQL       | 0              |\n| COM_STMT_CLOSE        | 1              |\n| COM_STMT_EXECUTE      | 1              |\n| COM_STMT_PREPARE      | 1              |\n+-----------------------+----------------+\n"], "Examples": [], "Category": ["Prepared Statements"]}
{"HTML": ["https://mariadb.com//kb/en/execute-statement/"], "Title": ["EXECUTE Statement"], "Feature": ["EXECUTE stmt_name\n    [USING expression[, expression] ...]\n"], "Description": ["After preparing a statement with PREPARE, you execute it with an\nEXECUTE statement that refers to the prepared statement name. If the\nprepared statement contains any parameter markers, you must supply a\nUSING clause that lists user variables containing the values to be\nbound to the parameters. Parameter values can be supplied only by user\nvariables, and the USING clause must name exactly as many variables as\nthe number of parameter markers in the statement.", "You can execute a given prepared statement multiple times, passing\ndifferent variables to it or setting the variables to different values\nbefore each execution.", "If the specified statement has not been PREPAREd, an error similar to the following is produced:", "ERROR 1243 (HY000): Unknown prepared statement handler (stmt_name) given to EXECUTE\n", "EXECUTE with expression as parameters was introduced in MariaDB 10.2.3. Prior to that one could only use variables (@var_name) as parameters."], "Examples": [], "Category": ["Prepared Statements"]}
