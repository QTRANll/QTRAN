{"HTML": ["https://mariadb.com//kb/en/lock-tables/"], "Title": ["LOCK TABLES"], "Feature": ["LOCK TABLE[S]\n    tbl_name [[AS] alias] lock_type\n    [, tbl_name [[AS] alias] lock_type] ...\n    [WAIT n|NOWAIT]\n\nlock_type:\n    READ [LOCAL]\n  | [LOW_PRIORITY] WRITE\n  | WRITE CONCURRENT\n\nUNLOCK TABLES\n"], "Description": ["The lock_type can be one of:", "OptionDescription\nREADRead lock, no writes allowed\nREAD LOCALRead lock, but allow concurrent inserts\nWRITEExclusive write lock. No other connections can read or write to this table\nLOW_PRIORITY WRITEExclusive write lock, but allow new read locks on the table until we get the write lock.\nWRITE CONCURRENTExclusive write lock, but allow READ LOCAL locks to the table.\n\n", "MariaDB enables client sessions to acquire table locks explicitly for the\npurpose of cooperating with other sessions for access to tables, or to\nprevent other sessions from modifying tables during periods when a\nsession requires exclusive access to them. A session can acquire or\nrelease locks only for itself. One session cannot acquire locks for\nanother session or release locks held by another session.", "Locks may be used to emulate transactions or to get more speed when\nupdating tables.", "LOCK TABLES explicitly acquires table locks for the current client session.\nTable locks can be acquired for base tables or views. To use LOCK TABLES,\nyou must have the LOCK TABLES privilege, and the SELECT privilege for\neach object to be locked. See GRANT", "For view locking, LOCK TABLES adds all base tables used in the view to the\nset of tables to be locked and locks them automatically. If you lock a table\nexplicitly with LOCK TABLES, any tables used in triggers are also locked\nimplicitly, as described in Triggers and Implicit Locks.", "UNLOCK TABLES explicitly releases any table locks held by the\ncurrent session.", "Aliases", "Aliases need to correspond to the aliases used in prior SQL statements in the session. For example:", "LOCK TABLE t1 AS t1_alias1 READ;\n\nSELECT * FROM t1;\nERROR 1100 (HY000): Table 't1' was not locked with LOCK TABLES\n\nSELECT * FROM t1 AS t1_alias2;\nERROR 1100 (HY000): Table 't1_alias2' was not locked with LOCK TABLES\n\nSELECT * FROM t1 AS t1_alias1;\n", "WAIT/NOWAIT", "Set the lock wait timeout. See WAIT and NOWAIT."], "Examples": [], "Category": ["Transactions"]}
{"HTML": ["https://mariadb.com//kb/en/savepoint/"], "Title": ["SAVEPOINT"], "Feature": ["SAVEPOINT identifier\nROLLBACK [WORK] TO [SAVEPOINT] identifier\nRELEASE SAVEPOINT identifier\n"], "Description": ["InnoDB supports the SQL statements SAVEPOINT,\nROLLBACK TO SAVEPOINT, RELEASE SAVEPOINT\nand the optional WORK keyword for\nROLLBACK.", "Each savepoint must have a legal MariaDB identifier. A savepoint is a named sub-transaction.", "Normally ROLLBACK undoes the changes performed by the whole transaction. When used with the TO clause, it undoes the changes performed after the specified savepoint, and erases all subsequent savepoints. However, all locks that have been acquired after the save point will survive. RELEASE SAVEPOINT does not rollback or commit any changes, but removes the specified savepoint.", "When the execution of a trigger or a stored function begins, it is not possible to use statements which reference a savepoint which was defined from out of that stored program.", "When a COMMIT (including implicit commits) or a ROLLBACK statement (with no TO clause) is performed, they act on the whole transaction, and all savepoints are removed."], "Examples": [], "Category": ["Transactions"]}
{"HTML": ["https://mariadb.com//kb/en/set-transaction/"], "Title": ["SET TRANSACTION"], "Feature": ["SET [GLOBAL | SESSION] TRANSACTION\n    transaction_property [, transaction_property] ...\n\ntransaction_property:\n    ISOLATION LEVEL level\n  | READ WRITE\n  | READ ONLY\n\nlevel:\n     REPEATABLE READ\n   | READ COMMITTED\n   | READ UNCOMMITTED\n   | SERIALIZABLE\n"], "Description": ["This statement sets the transaction isolation level or the transaction access mode globally, for the current session, or for the next transaction:", "With the GLOBAL keyword, the statement sets the default\n  transaction level globally for all subsequent sessions. Existing sessions are\n  unaffected.\nWith the SESSION keyword, the statement sets the default\n  transaction level for all subsequent transactions performed within the\n  current session.\nWithout any SESSION or GLOBAL keyword,\n  the statement sets the isolation level for only the next (not started) transaction\n  performed within the current session. After that it reverts to using the session value. \n", "A change to the global default isolation level requires the \nSUPER privilege. Any session is free to change its\nsession isolation level (even in the middle of a transaction), or the isolation\nlevel for its next transaction.", "Isolation Level", "To set the global default isolation level at server startup, use the\n--transaction-isolation=level option on the command line or in an option file. Values of level for this option use dashes\nrather than spaces, so the allowable values are READ_UNCOMMITTED,\nREAD-COMMITTED, REPEATABLE-READ, or\nSERIALIZABLE. For example, to set the default isolation\nlevel to REPEATABLE READ, use these lines in the [mariadb]\nsection of an option file:", "[mariadb]\ntransaction-isolation = REPEATABLE-READ", "To determine the global and session transaction isolation levels at\nruntime, check the value of the tx_isolation system variable (note that the variable has been renamed transaction_isolation from MariaDB 11.1.1, to match the option, and the old name deprecated).", "SELECT @@GLOBAL.tx_isolation, @@tx_isolation;\n", "From MariaDB 11.1.1:", "SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;\n", "InnoDB supports each of the translation isolation levels described here\nusing different locking strategies. The default level is \nREPEATABLE READ. For additional information about InnoDB\nrecord-level locks and how it uses them to execute various types of statements,\nsee InnoDB Lock Modes,\nand http://dev.mysql.com/doc/refman/en/innodb-locks-set.html.", "Isolation Levels", "The following sections describe how MariaDB supports the different transaction levels.", "READ UNCOMMITTED", "SELECT statements are performed in a non-locking fashion,\nbut a possible earlier version of a row might be used. Thus, using this\nisolation level, such reads are not consistent. This is also called a \"dirty\nread.\" Otherwise, this isolation level works like \nREAD COMMITTED.", "READ COMMITTED", "A somewhat Oracle-like isolation level with respect to consistent\n(non-locking) reads: Each consistent read, even within the same\ntransaction, sets and reads its own fresh snapshot. See\nhttp://dev.mysql.com/doc/refman/en/innodb-consistent-read.html.", "For locking reads (SELECT with FOR UPDATE\nor LOCK IN SHARE MODE), InnoDB locks only index records, not\nthe gaps before them, and thus allows the free insertion of new records next to\nlocked records. For UPDATE and DELETE\nstatements, locking depends on whether the statement uses a unique index with a\nunique search condition (such as WHERE id = 100), or a\nrange-type search condition (such as WHERE id > 100). For a\nunique index with a unique search condition, InnoDB locks only the index record\nfound, not the gap before it. For range-type searches, InnoDB locks the index\nrange scanned, using gap locks or next-key (gap plus index-record) locks to\nblock insertions by other sessions into the gaps covered by the range. This is\nnecessary because \"phantom rows\" must be blocked for MariaDB replication and\nrecovery to work.", "Note: If the READ COMMITTED isolation\nlevel is used or the innodb_locks_unsafe_for_binlog system variable is enabled,\nthere is no InnoDB gap locking except for foreign-key constraint checking and\nduplicate-key checking. Also, record locks for non-matching rows are released\nafter MariaDB has evaluated the WHERE condition.If you use READ COMMITTED or enable innodb_locks_unsafe_for_binlog, you must use row-based binary logging.", "REPEATABLE READ", "This is the default isolation level for InnoDB. For consistent reads,\nthere is an important difference from the READ COMMITTED\nisolation level: All consistent reads within the same transaction read the\nsnapshot established by the first read. This convention means that if you issue\nseveral plain (non-locking) SELECT statements within the\nsame transaction, these SELECT statements are consistent\nalso with respect to each other. See\nhttp://dev.mysql.com/doc/refman/en/innodb-consistent-read.html.", "For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE),\nUPDATE, and DELETE statements, locking depends on whether the\nstatement uses a unique index with a unique search condition, or a\nrange-type search condition. Prior to MariaDB 10.3.38, MariaDB 10.4.28, MariaDB 10.5.19, MariaDB 10.6.12, MariaDB 10.7.8, MariaDB 10.8.7, MariaDB 10.9.5, MariaDB 10.10.3, MariaDB 10.11.2 and MariaDB 11.0.0, for a unique index with a unique search condition, InnoDB locks only the index record found, not the gap\nbefore it. From these versions, MariaDB no longer relaxes the gap locking for unique indexes.", "For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key (gap plus index-record) locks to block insertions by other sessions into the gaps covered by the range.", "This is the minimum isolation level for non-distributed XA transactions.", "SERIALIZABLE", "This level is like REPEATABLE READ, but InnoDB implicitly converts all\nplain SELECT statements to SELECT ... LOCK IN SHARE MODE if autocommit\nis disabled. If autocommit is enabled, the SELECT is its own\ntransaction. It therefore is known to be read only and can be\nserialized if performed as a consistent (non-locking) read and need\nnot block for other transactions. (This means that to force a plain\nSELECT to block if other transactions have modified the selected rows,\nyou should disable autocommit.)", "Distributed XA transactions should always use this isolation level.", "innodb_snapshop_isolation", "If the innodb_snapshot_isolation system variable is not set to ON, strictly-speaking anything other than READ UNCOMMITTED is not clearly defined. innodb_snapshot_isolation was introduced in MariaDB 10.6.18, MariaDB 10.11.8, MariaDB 11.0.6, MariaDB 11.1.5, MariaDB 11.2.4, MariaDB 11.4.2 to address this, but defaults to OFF for backwards compatibility. Setting to ON will result in attempts to acquire a lock on a record that does not exist in the current read view raising an error, and the transaction being rolled back.", "Access Mode", "The access mode specifies whether the transaction is allowed to write data or not. By default, transactions are in READ WRITE mode (see the tx_read_only system variable). READ ONLY mode allows the storage engine to apply optimizations that cannot be used for transactions which write data. Note that unlike the global read_only mode, READ_ONLY ADMIN (and SUPER before MariaDB 10.11.0) privilege doesn't allow writes and DDL statements on temporary tables are not allowed either.", "It is not permitted to specify both READ WRITE and READ ONLY in the same statement.", "READ WRITE and READ ONLY can also be specified in the START TRANSACTION statement, in which case the specified mode is only valid for one transaction."], "Examples": ["SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n", "START TRANSACTION;\n\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\nERROR 1568 (25001): Transaction characteristics can't be changed while a transaction is in progress\n"], "Category": ["Transactions"]}
{"HTML": ["https://mariadb.com//kb/en/start-transaction/"], "Title": ["START TRANSACTION"], "Feature": ["START TRANSACTION [transaction_property [, transaction_property] ...] | BEGIN [WORK]\nCOMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]\nROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]\nSET autocommit = {0 | 1}\n\ntransaction_property:\n    WITH CONSISTENT SNAPSHOT\n  | READ WRITE\n  | READ ONLY\n"], "Description": ["The START TRANSACTION or BEGIN statement\nbegins a new transaction. COMMIT commits the current\ntransaction, making its changes permanent. ROLLBACK rolls\nback the current transaction, canceling its changes. The SET\nautocommit statement disables or enables the default autocommit mode for the current session.", "START TRANSACTION and SET autocommit = 1 implicitly commit the current transaction, if any.", "The optional WORK keyword is supported for\nCOMMIT and ROLLBACK, as are the\nCHAIN and RELEASE clauses.\nCHAIN and RELEASE can be used for\nadditional control over transaction completion. The value of the\ncompletion_type system variable determines the default completion behavior.", "The AND CHAIN clause causes a new transaction to begin as\nsoon as the current one ends, and the new transaction has the same isolation\nlevel as the just-terminated transaction. The RELEASE clause\ncauses the server to disconnect the current client session after terminating\nthe current transaction. Including the NO keyword suppresses\nCHAIN or RELEASE completion, which can be\nuseful if the completion_type system variable is set to cause chaining or release completion by default.", "Access Mode", "The access mode specifies whether the transaction is allowed to write data or not. By default, transactions are in READ WRITE mode (see the tx_read_only system variable). READ ONLY mode allows the storage engine to apply optimizations that cannot be used for transactions which write data. Note that unlike the global read_only mode, READ_ONLY ADMIN (and SUPER before MariaDB 10.11.0) privilege doesn't allow writes and DDL statements on temporary tables are not allowed either.", "It is not permitted to specify both READ WRITE and READ ONLY in the same statement.", "READ WRITE and READ ONLY can also be specified in the SET TRANSACTION statement, in which case the specified mode is valid for all sessions, or for all subsequent transaction used by the current session.", "autocommit", "By default, MariaDB runs with autocommit mode enabled. This means that as soon as you execute a statement that updates (modifies) a table, MariaDB stores the update on disk to make it permanent. To disable autocommit mode, use the following statement:", "SET autocommit=0;\n", "After disabling autocommit mode by setting the autocommit variable to zero, changes to transaction-safe tables (such as those for InnoDB or\nNDBCLUSTER) are not made permanent immediately. You must use COMMIT to store your changes to disk or ROLLBACK to ignore the changes.", "To disable autocommit mode for a single series of statements, use the START TRANSACTION statement.", "DDL Statements", "DDL statements (CREATE, ALTER, DROP) and administrative statements (FLUSH, RESET, OPTIMIZE, ANALYZE, CHECK, REPAIR, CACHE INDEX), transaction management statements (BEGIN, START TRANSACTION) and LOAD DATA INFILE, cause an implicit COMMIT and start a new transaction. An exception to this rule are the DDL that operate on temporary tables: you can CREATE, ALTER and DROP them without causing any COMMIT, but those actions cannot be rolled back. This means that if you call ROLLBACK, the temporary tables you created in the transaction will remain, while the rest of the transaction will be rolled back.", "Transactions cannot be used in Stored Functions or Triggers. In Stored Procedures and Events BEGIN is not allowed, so you should use START TRANSACTION instead.", "A transaction acquires a metadata lock on every table it accesses to prevent other connections from altering their structure. The lock is released at the end of the transaction. This happens even with non-transactional storage engines (like MEMORY or CONNECT), so it makes sense to use transactions with non-transactional tables.", "in_transaction", "The in_transaction system variable is a session-only, read-only variable that returns 1 inside a transaction, and 0 if not in a transaction.", "WITH CONSISTENT SNAPSHOT", "The WITH CONSISTENT SNAPSHOT option starts a consistent read for storage engines such as InnoDB that can do so, the same as if a START TRANSACTION followed by a SELECT from any InnoDB table was issued. ", "See Enhancements for START TRANSACTION WITH CONSISTENT SNAPSHOT."], "Examples": ["START TRANSACTION;\nSELECT @A:=SUM(salary) FROM table1 WHERE type=1;\nUPDATE table2 SET summary=@A WHERE type=1;\nCOMMIT;\n"], "Category": ["Transactions"]}
{"HTML": ["https://mariadb.com//kb/en/transactions-unlock-tables/"], "Title": ["UNLOCK TABLES"], "Feature": ["UNLOCK TABLES\n"], "Description": ["UNLOCK TABLES explicitly releases any table locks held by the\ncurrent session. See LOCK TABLES for more information.", "In addition to releasing table locks acquired by the LOCK TABLES statement, the UNLOCK TABLES statement also releases the global read lock acquired by the FLUSH TABLES WITH READ LOCK statement.  The FLUSH TABLES WITH READ LOCK statement is very useful for performing backups. See FLUSH for more information about FLUSH TABLES WITH READ LOCK."], "Examples": [], "Category": ["Transactions"]}
{"HTML": ["https://mariadb.com//kb/en/wait-and-nowait/"], "Title": ["WAIT and NOWAIT"], "Feature": ["ALTER TABLE tbl_name [WAIT n|NOWAIT] ...\nCREATE ... INDEX ON tbl_name (index_col_name, ...) [WAIT n|NOWAIT] ...\nDROP INDEX ... [WAIT n|NOWAIT]\nDROP TABLE tbl_name [WAIT n|NOWAIT] ...\nLOCK TABLE ... [WAIT n|NOWAIT]\nOPTIMIZE TABLE tbl_name [WAIT n|NOWAIT]\nRENAME TABLE tbl_name [WAIT n|NOWAIT] ...\nSELECT ... FOR UPDATE [WAIT n|NOWAIT]\nSELECT ... LOCK IN SHARE MODE [WAIT n|NOWAIT]\nTRUNCATE TABLE tbl_name [WAIT n|NOWAIT]\n"], "Description": ["The lock wait timeout can be explicitly set in the statement by using either WAIT n (to set the wait in seconds) or NOWAIT, in which case the statement will immediately fail if the lock cannot be obtained. WAIT 0 is equivalent to NOWAIT."], "Examples": [], "Category": ["Transactions"]}
{"HTML": ["https://mariadb.com//kb/en/xa-transactions/"], "Title": ["XA Transactions"], "Feature": ["XA {START|BEGIN} xid [JOIN|RESUME]\n\nXA END xid [SUSPEND [FOR MIGRATE]]\n\nXA PREPARE xid\n\nXA COMMIT xid [ONE PHASE]\n\nXA ROLLBACK xid\n\nXA RECOVER [FORMAT=['RAW'|'SQL']]\n\nxid: gtrid [, bqual [, formatID ]]\n", "The interface to XA transactions is a set of SQL statements starting with XA. Each statement changes a transaction's state, determining which actions it can perform. A transaction which does not exist is in the NON-EXISTING state.", "XA START (or BEGIN) starts a transaction and defines its xid (a transaction identifier). The JOIN or RESUME keywords have no effect. The new transaction will be in ACTIVE state.", "The xid can have 3 components, though only the first one is mandatory. gtrid is a quoted string representing a global transaction identifier. bqual is a quoted string representing a local transaction identifier. formatID is an unsigned integer indicating the format used for the first two components; if not specified, defaults to 1. MariaDB does not interpret in any way these components, and only uses them to identify a transaction. xids of transactions in effect must be unique.", "XA END declares that the specified ACTIVE transaction is finished and it changes its state to IDLE. SUSPEND [FOR MIGRATE] has no effect.", "XA PREPARE prepares an IDLE transaction for commit, changing its state to PREPARED. This is the first commit.", "XA COMMIT definitely commits and terminates a transaction which has already been PREPARED. If the ONE PHASE clause is specified, this statements performs a 1-phase commit on an IDLE transaction.", "XA ROLLBACK rolls back and terminates an IDLE or PREPARED transaction.", "XA RECOVER shows information about all PREPARED transactions.", "When trying to execute an operation which is not allowed for the transaction's current state, an error is produced:", "XA COMMIT 'test' ONE PHASE;\nERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed when global transaction is in the  ACTIVE state\n\nXA COMMIT 'test2';\nERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed when global transaction is in the  NON-EXISTING state\n"], "Description": [], "Examples": ["XA START 'test';\n\nINSERT INTO t VALUES (1,2);\n\nXA END 'test';\n\nXA PREPARE 'test';\n\nXA COMMIT 'test';\n", "XA START 'test';\n\nINSERT INTO t VALUES (1,2);\n\nXA END 'test';\n\nXA COMMIT 'test' ONE PHASE;\n", "xa start '12\\r34\\t67\\v78', 'abc\\ndef', 3;\n\ninsert t1 values (40);\n\nxa end '12\\r34\\t67\\v78', 'abc\\ndef', 3;\n\nxa prepare '12\\r34\\t67\\v78', 'abc\\ndef', 3;\n\nxa recover format='RAW';\n+----------+--------------+--------------+--------------------+\n| formatID | gtrid_length | bqual_length | data               |\n+----------+--------------+--------------+--------------------+\n34      67v78abc       11 |            7 | 12\ndef |\n+----------+--------------+--------------+--------------------+\n\nxa recover format='SQL';\n+----------+--------------+--------------+-----------------------------------------------+\n| formatID | gtrid_length | bqual_length | data                                          |\n+----------+--------------+--------------+-----------------------------------------------+\n|        3 |           11 |            7 | X'31320d3334093637763738',X'6162630a646566',3 |\n+----------+--------------+--------------+-----------------------------------------------+\n\nxa rollback X'31320d3334093637763738',X'6162630a646566',3;\n"], "Category": ["Transactions"]}
