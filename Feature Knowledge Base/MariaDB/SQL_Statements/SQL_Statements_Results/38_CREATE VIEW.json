{
    "HTML": [
        "https://mariadb.com//kb/en/create-view/"
    ],
    "Title": [
        "CREATE VIEW"
    ],
    "Feature": [
        "CREATE\n    [OR REPLACE]\n    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER | role | CURRENT_ROLE }]\n    [SQL SECURITY { DEFINER | INVOKER }]\n    VIEW [IF NOT EXISTS] view_name [(column_list)]\n    AS select_statement\n    [WITH [CASCADED | LOCAL] CHECK OPTION]\n"
    ],
    "Description": [
        "The CREATE VIEW statement creates a new view, or replaces an existing\none if the OR REPLACE clause is given. If the view does not exist, CREATE OR\nREPLACE VIEW is the same as CREATE VIEW. If the view does exist, CREATE OR\nREPLACE VIEW is the same as ALTER VIEW.",
        "The select_statement is a SELECT statement that provides the definition of\nthe view. (When you select from the view, you select in effect using the SELECT\nstatement.) select_statement can select from base tables or other views.",
        "The view definition is \"frozen\" at creation time, so changes to the underlying\ntables afterwards do not affect the view definition. For example, if a view is\ndefined as SELECT * on a table, new columns added to the table later do not\nbecome part of the view. A SHOW CREATE VIEW shows that\nsuch queries are rewritten and column names are included in the view\ndefinition.",
        "The view definition must be a query that does not return errors at view\ncreation times. However, the base tables used by the views might be altered\nlater and the query may not be valid anymore. In this case, querying the view\nwill result in an error. CHECK TABLE helps in finding this kind\nof problems.",
        "The ALGORITHM clause affects how MariaDB processes the\nview. The DEFINER and SQL SECURITY clauses specify the security context to be\nused when checking access privileges at view invocation time. The WITH CHECK\nOPTION clause can be given to constrain inserts or updates to rows in tables\nreferenced by the view. These clauses are described later in this section.",
        "The CREATE VIEW statement requires the CREATE VIEW privilege for the\nview, and some privilege for each column selected by the SELECT\nstatement. For columns used elsewhere in the SELECT statement you must\nhave the SELECT privilege. If the OR REPLACE clause is present, you\nmust also have the DROP privilege for the view.",
        "A view belongs to a database. By default, a new view is created in the\ndefault database. To create the view explicitly in a given database,\nspecify the name as db_name.view_name when you create it.",
        "CREATE VIEW test.v AS SELECT * FROM t;\n",
        "Base tables and views share the same namespace within a database, so a\ndatabase cannot contain a base table and a view that have the same\nname.",
        "Views must have unique column names with no duplicates, just like base\ntables. By default, the names of the columns retrieved by the SELECT\nstatement are used for the view column names. To define explicit names\nfor the view columns, the optional column_list clause can be given as\na list of comma-separated identifiers. The number of names in\ncolumn_list must be the same as the number of columns retrieved by the\nSELECT statement.",
        "Columns retrieved by the SELECT statement can be simple references to\ntable columns. They can also be expressions that use functions,\nconstant values, operators, and so forth.",
        "Unqualified table or view names in the SELECT statement are\ninterpreted with respect to the default database. A view can refer to\ntables or views in other databases by qualifying the table or view\nname with the proper database name.",
        "A view can be created from many kinds of SELECT statements. It can\nrefer to base tables or other views. It can use joins, UNION, and\nsubqueries. The SELECT need not even refer to any tables. The\nfollowing example defines a view that selects two columns from another\ntable, as well as an expression calculated from those columns:",
        "CREATE TABLE t (qty INT, price INT);\n\nINSERT INTO t VALUES(3, 50);\n\nCREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;\n\nSELECT * FROM v;\n+------+-------+-------+\n| qty  | price | value |\n+------+-------+-------+\n|    3 |    50 |   150 |\n+------+-------+-------+\n",
        "A view definition is subject to the following restrictions:",
        "The SELECT statement cannot contain a subquery in the FROM clause.\nThe SELECT statement cannot refer to system or user variables.\nWithin a stored program, the definition cannot refer to program parameters or local variables.\nThe SELECT statement cannot refer to prepared statement parameters.\nAny table or view referred to in the definition must exist. However, after a view has been created, it is possible to drop a table or view that the definition refers to. In this case, use of the view results in an error. To check a view definition for problems of this kind, use the CHECK TABLE statement.\nThe definition cannot refer to a TEMPORARY table, and you cannot create a TEMPORARY view.\nAny tables named in the view definition must exist at definition time.\nYou cannot associate a trigger with a view.\nFor valid identifiers to use as view names, see Identifier Names.\n",
        "ORDER BY is allowed in a view definition, but it is ignored if you\nselect from a view using a statement that has its own ORDER BY.",
        "For other options or clauses in the definition, they are added to the\noptions or clauses of the statement that references the view, but the\neffect is undefined. For example, if a view definition includes a\nLIMIT clause, and you select from the view using a statement that has\nits own LIMIT clause, it is undefined which limit applies. This same\nprinciple applies to options such as ALL, DISTINCT, or\nSQL_SMALL_RESULT that follow the SELECT keyword, and to clauses such\nas INTO, FOR UPDATE, and LOCK IN SHARE MODE.",
        "The PROCEDURE clause cannot be used in a view definition, and it cannot be used if a view is referenced in the FROM clause.",
        "If you create a view and then change the query processing environment\nby changing system variables, that may affect the results that you get\nfrom the view:",
        "CREATE VIEW v (mycol) AS SELECT 'abc';\n\nSET sql_mode = '';\n\nSELECT \"mycol\" FROM v;\n+-------+\n| mycol |\n+-------+\n| mycol | \n+-------+\n\nSET sql_mode = 'ANSI_QUOTES';\n\nSELECT \"mycol\" FROM v;\n+-------+\n| mycol |\n+-------+\n| abc   | \n+-------+\n",
        "The DEFINER and SQL SECURITY clauses determine which MariaDB account to\nuse when checking access privileges for the view when a statement is\nexecuted that references the view. They were added in MySQL 5.1.2.\nThe legal SQL SECURITY characteristic values are DEFINER and INVOKER.\nThese indicate that the required privileges must be held by the user\nwho defined or invoked the view, respectively. The default SQL\nSECURITY value is DEFINER.",
        "If a user value is given for the DEFINER clause, it should be a MariaDB\naccount in 'user_name'@'host_name' format (the same format used in the\nGRANT statement). The user_name and host_name values both are\nrequired.  The definer can also be given as CURRENT_USER or\nCURRENT_USER(). The default DEFINER value is the user who executes the\nCREATE VIEW statement. This is the same as specifying DEFINER =\nCURRENT_USER explicitly.",
        "If you specify the DEFINER clause, these rules determine the legal\nDEFINER user values:",
        "If you do not have the SUPER privilege, or, from MariaDB 10.5.2, the SET USER privilege, the only legal user value is your own account, either specified literally or by using CURRENT_USER. You cannot set the definer to some other account.\nIf you have the SUPER privilege, or, from MariaDB 10.5.2, the SET USER privilege, you can specify any syntactically legal account name. If the account does not actually exist, a warning is generated.\nIf the SQL SECURITY value is DEFINER but the definer account does not exist when the view is referenced, an error occurs.\n",
        "Within a view definition, CURRENT_USER returns the view's DEFINER\nvalue by default. For views\ndefined with the SQL SECURITY INVOKER characteristic, CURRENT_USER\nreturns the account for the view's invoker. For information about user\nauditing within views, see\nhttp://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html.",
        "Within a stored routine that is defined with the SQL SECURITY DEFINER\ncharacteristic, CURRENT_USER returns the routine's DEFINER value. This\nalso affects a view defined within such a program, if the view\ndefinition contains a DEFINER value of CURRENT_USER.",
        "View privileges are checked like this:",
        "At view definition time, the view creator must have the privileges needed to use the top-level objects accessed by the view. For example, if the view definition refers to table columns, the creator must have privileges for the columns, as described previously. If the definition refers to a stored function, only the privileges needed to invoke the function can be checked. The privileges required when the function runs can be checked only as it executes: For different invocations of the function, different execution paths within the function might be taken.\nWhen a view is referenced, privileges for objects accessed by the view are checked against the privileges held by the view creator or invoker, depending on whether the SQL SECURITY characteristic is DEFINER or INVOKER, respectively.\nIf reference to a view causes execution of a stored function, privilege checking for statements executed within the function depend on whether the function is defined with a SQL SECURITY characteristic of DEFINER or INVOKER. If the security characteristic is DEFINER, the function runs with the privileges of its creator. If the characteristic is INVOKER, the function runs with the privileges determined by the view's SQL SECURITY characteristic.\n",
        "Example: A view might depend on a stored function, and that function\nmight invoke other stored routines. For example, the following view\ninvokes a stored function f():",
        "CREATE VIEW v AS SELECT * FROM t WHERE t.id = f(t.name);\n\nSuppose that f() contains a statement such as this:\n\nIF name IS NULL then\n  CALL p1();\nELSE\n  CALL p2();\nEND IF;\n",
        "The privileges required for executing statements within f() need to be\nchecked when f() executes. This might mean that privileges are needed\nfor p1() or p2(), depending on the execution path within f(). Those\nprivileges must be checked at runtime, and the user who must possess\nthe privileges is determined by the SQL SECURITY values of the view v\nand the function f().",
        "The DEFINER and SQL SECURITY clauses for views are extensions to\nstandard SQL. In standard SQL, views are handled using the rules for\nSQL SECURITY INVOKER.",
        "If you invoke a view that was created before MySQL 5.1.2, it is\ntreated as though it was created with a SQL SECURITY DEFINER clause\nand with a DEFINER value that is the same as your account. However,\nbecause the actual definer is unknown, MySQL issues a warning. To make\nthe warning go away, it is sufficient to re-create the view so that\nthe view definition includes a DEFINER clause.",
        "The optional ALGORITHM clause is an extension to standard SQL. It\naffects how MariaDB processes the view. ALGORITHM takes three values:\nMERGE, TEMPTABLE, or UNDEFINED. The default algorithm is UNDEFINED if\nno ALGORITHM clause is present. See View Algorithms for more information.",
        "Some views are updatable. That is, you can use them in statements such\nas UPDATE, DELETE, or INSERT to update the contents of the underlying\ntable. For a view to be updatable, there must be a one-to-one\nrelationship between the rows in the view and the rows in the\nunderlying table. There are also certain other constructs that make a\nview non-updatable. See Inserting and Updating with Views.",
        "WITH CHECK OPTION",
        "The WITH CHECK OPTION clause can be given for an updatable view to\nprevent inserts or updates to rows except those for which the WHERE\nclause in the select_statement is true.",
        "In a WITH CHECK OPTION clause for an updatable view, the LOCAL and\nCASCADED keywords determine the scope of check testing when the view\nis defined in terms of another view. The LOCAL keyword restricts the\nCHECK OPTION only to the view being defined. CASCADED causes the\nchecks for underlying views to be evaluated as well. When neither\nkeyword is given, the default is CASCADED.",
        "For more information about updatable views and the WITH CHECK OPTION\nclause, see\nInserting and Updating with Views.",
        "IF NOT EXISTS",
        "When the IF NOT EXISTS clause is used, MariaDB will return a warning instead of an error if the specified view already exists. Cannot be used together with the OR REPLACE clause.",
        "Atomic DDL",
        "MariaDB starting with 10.6.1MariaDB 10.6.1 supports Atomic DDL and CREATE VIEW is atomic.\n"
    ],
    "Examples": [
        "CREATE TABLE t (a INT, b INT) ENGINE = InnoDB;\n\nINSERT INTO t VALUES (1,1), (2,2), (3,3);\n\nCREATE VIEW v AS SELECT a, a*2 AS a2 FROM t;\n\nSELECT * FROM v;\n+------+------+\n| a    | a2   |\n+------+------+\n|    1 |    2 |\n|    2 |    4 |\n|    3 |    6 |\n+------+------+\n",
        "CREATE VIEW v AS SELECT a, a*2 AS a2 FROM t;\nERROR 1050 (42S01): Table 'v' already exists\n\nCREATE OR REPLACE VIEW v AS SELECT a, a*2 AS a2 FROM t;\nQuery OK, 0 rows affected (0.04 sec)\n\nCREATE VIEW IF NOT EXISTS v AS SELECT a, a*2 AS a2 FROM t;\nQuery OK, 0 rows affected, 1 warning (0.01 sec)\n\nSHOW WARNINGS;\n+-------+------+--------------------------+\n| Level | Code | Message                  |\n+-------+------+--------------------------+\n| Note  | 1050 | Table 'v' already exists |\n+-------+------+--------------------------+\n"
    ],
    "Category": [
        "Data Definition"
    ]
}