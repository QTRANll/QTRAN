{"HTML": ["https://mariadb.com//kb/en/json_array/"], "Title": ["JSON_ARRAY"], "Feature": ["JSON_ARRAY([value[, value2] ...])\n"], "Description": ["Returns a JSON array containing the listed values. The list can be empty."], "Examples": ["SELECT Json_Array(56, 3.1416, 'My name is \"Foo\"', NULL);\n+--------------------------------------------------+\n| Json_Array(56, 3.1416, 'My name is \"Foo\"', NULL) |\n+--------------------------------------------------+\n| [56, 3.1416, \"My name is \\\"Foo\\\"\", null]         |\n+--------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_array_append/"], "Title": ["JSON_ARRAY_APPEND"], "Feature": ["JSON_ARRAY_APPEND(json_doc, path, value[, path, value] ...)\n"], "Description": ["Appends values to the end of the specified arrays within a JSON document, returning the result, or NULL if any of the arguments are NULL.", "Evaluation is performed from left to right, with the resulting document from the previous pair becoming the new value against which the next pair is evaluated.", "If the json_doc is not a valid JSON document, or if any of the paths are not valid, or contain a * or ** wildcard, an error is returned."], "Examples": ["SET @json = '[1, 2, [3, 4]]';\n\nSELECT JSON_ARRAY_APPEND(@json, '$[0]', 5)\n+-------------------------------------+\n| JSON_ARRAY_APPEND(@json, '$[0]', 5) |\n+-------------------------------------+\n| [[1, 5], 2, [3, 4]]                 |\n+-------------------------------------+\n\nSELECT JSON_ARRAY_APPEND(@json, '$[1]', 6);\n+-------------------------------------+\n| JSON_ARRAY_APPEND(@json, '$[1]', 6) |\n+-------------------------------------+\n| [1, [2, 6], [3, 4]]                 |\n+-------------------------------------+\n\nSELECT JSON_ARRAY_APPEND(@json, '$[1]', 6, '$[2]', 7);\n+------------------------------------------------+\n| JSON_ARRAY_APPEND(@json, '$[1]', 6, '$[2]', 7) |\n+------------------------------------------------+\n| [1, [2, 6], [3, 4, 7]]                         |\n+------------------------------------------------+\n\nSELECT JSON_ARRAY_APPEND(@json, '$', 5);\n+----------------------------------+\n| JSON_ARRAY_APPEND(@json, '$', 5) |\n+----------------------------------+\n| [1, 2, [3, 4], 5]                |\n+----------------------------------+\n\nSET @json = '{\"A\": 1, \"B\": [2], \"C\": [3, 4]}';\n\nSELECT JSON_ARRAY_APPEND(@json, '$.B', 5);\n+------------------------------------+\n| JSON_ARRAY_APPEND(@json, '$.B', 5) |\n+------------------------------------+\n| {\"A\": 1, \"B\": [2, 5], \"C\": [3, 4]} |\n+------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_array_insert/"], "Title": ["JSON_ARRAY_INSERT"], "Feature": ["JSON_ARRAY_INSERT(json_doc, path, value[, path, value] ...)\n"], "Description": ["Inserts a value into a JSON document, returning the modified document, or NULL if any of the arguments are NULL.", "Evaluation is performed from left to right, with the resulting document from the previous pair becoming the new value against which the next pair is evaluated.", "If the json_doc is not a valid JSON document, or if any of the paths are not valid, or contain a * or ** wildcard, an error is returned."], "Examples": ["SET @json = '[1, 2, [3, 4]]';\n\nSELECT JSON_ARRAY_INSERT(@json, '$[0]', 5);\n+-------------------------------------+\n| JSON_ARRAY_INSERT(@json, '$[0]', 5) |\n+-------------------------------------+\n| [5, 1, 2, [3, 4]]                   |\n+-------------------------------------+\n\nSELECT JSON_ARRAY_INSERT(@json, '$[1]', 6);\n+-------------------------------------+\n| JSON_ARRAY_INSERT(@json, '$[1]', 6) |\n+-------------------------------------+\n| [1, 6, 2, [3, 4]]                   |\n+-------------------------------------+\n\nSELECT JSON_ARRAY_INSERT(@json, '$[1]', 6, '$[2]', 7);\n+------------------------------------------------+\n| JSON_ARRAY_INSERT(@json, '$[1]', 6, '$[2]', 7) |\n+------------------------------------------------+\n| [1, 6, 7, 2, [3, 4]]                           |\n+------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_array_intersect/"], "Title": ["JSON_ARRAY_INTERSECT"], "Feature": ["JSON_ARRAY_INTERSECT(arr1, arr2)\n"], "Description": ["Finds intersection between two json arrays and returns an array of items found in both array."], "Examples": ["SET @json1= '[1,2,3]';\nSET @json2= '[1,2,4]';\n\nSELECT json_array_intersect(@json1, @json2); \n+--------------------------------------+\n| json_array_intersect(@json1, @json2) |\n+--------------------------------------+\n| [1, 2]                               |\n+--------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_compact/"], "Title": ["JSON_COMPACT"], "Feature": ["JSON_COMPACT(json_doc)\n"], "Description": ["Removes all unnecessary spaces so the json document is as short as possible."], "Examples": ["SET @j = '{ \"A\": 1, \"B\": [2, 3]}';\n\nSELECT JSON_COMPACT(@j), @j;\n+-------------------+------------------------+\n| JSON_COMPACT(@j)  | @j                     |\n+-------------------+------------------------+\n| {\"A\":1,\"B\":[2,3]} | { \"A\": 1, \"B\": [2, 3]} |\n+-------------------+------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_contains/"], "Title": ["JSON_CONTAINS"], "Feature": ["JSON_CONTAINS(json_doc, val[, path])\n"], "Description": ["Returns whether or not the specified value is found in the given JSON document or, optionally, at the specified path within the document. Returns 1 if it does, 0 if not and NULL if any of the arguments are null. An error occurs if the document or path is not valid, or contains the * or ** wildcards."], "Examples": ["SET @json = '{\"A\": 0, \"B\": {\"C\": 1}, \"D\": 2}';\n\nSELECT JSON_CONTAINS(@json, '2', '$.A');\n+----------------------------------+\n| JSON_CONTAINS(@json, '2', '$.A') |\n+----------------------------------+\n|                                0 |\n+----------------------------------+\n\nSELECT JSON_CONTAINS(@json, '2', '$.D');\n+----------------------------------+\n| JSON_CONTAINS(@json, '2', '$.D') |\n+----------------------------------+\n|                                1 |\n+----------------------------------+\n\nSELECT JSON_CONTAINS(@json, '{\"C\": 1}', '$.A');\n+-----------------------------------------+\n| JSON_CONTAINS(@json, '{\"C\": 1}', '$.A') |\n+-----------------------------------------+\n|                                       0 |\n+-----------------------------------------+\n\nSELECT JSON_CONTAINS(@json, '{\"C\": 1}', '$.B');\n+-----------------------------------------+\n| JSON_CONTAINS(@json, '{\"C\": 1}', '$.B') |\n+-----------------------------------------+\n|                                       1 |\n+-----------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_contains_path/"], "Title": ["JSON_CONTAINS_PATH"], "Feature": ["JSON_CONTAINS_PATH(json_doc, return_arg, path[, path] ...)\n"], "Description": ["Indicates whether the given JSON document contains data at the specified path or paths. Returns 1 if it does, 0 if not and NULL if any of the arguments are null.", "The return_arg can be one or all:", "one - Returns 1 if at least one path exists within the JSON document. \nall - Returns 1 only if all paths exist within the JSON document.\n"], "Examples": ["SET @json = '{\"A\": 1, \"B\": [2], \"C\": [3, 4]}';\n\nSELECT JSON_CONTAINS_PATH(@json, 'one', '$.A', '$.D');\n+------------------------------------------------+\n| JSON_CONTAINS_PATH(@json, 'one', '$.A', '$.D') |\n+------------------------------------------------+\n|                                              1 |\n+------------------------------------------------+\n1 row in set (0.00 sec)\n\nSELECT JSON_CONTAINS_PATH(@json, 'all', '$.A', '$.D');\n+------------------------------------------------+\n| JSON_CONTAINS_PATH(@json, 'all', '$.A', '$.D') |\n+------------------------------------------------+\n|                                              0 |\n+------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_depth/"], "Title": ["JSON_DEPTH"], "Feature": ["JSON_DEPTH(json_doc)\n"], "Description": ["Returns the maximum depth of the given JSON document, or NULL if the argument is null. An error will occur if the argument is an invalid JSON document.", "Scalar values or empty arrays or objects have a depth of 1.\nArrays or objects that are not empty but contain only elements or member values of depth 1 will have a depth of 2.\nIn other cases, the depth will be greater than 2.\n"], "Examples": ["SELECT JSON_DEPTH('[]'), JSON_DEPTH('true'), JSON_DEPTH('{}');\n+------------------+--------------------+------------------+\n| JSON_DEPTH('[]') | JSON_DEPTH('true') | JSON_DEPTH('{}') |\n+------------------+--------------------+------------------+\n|                1 |                  1 |                1 |\n+------------------+--------------------+------------------+\n\nSELECT JSON_DEPTH('[1, 2, 3]'), JSON_DEPTH('[[], {}, []]');\n+-------------------------+----------------------------+\n| JSON_DEPTH('[1, 2, 3]') | JSON_DEPTH('[[], {}, []]') |\n+-------------------------+----------------------------+\n|                       2 |                          2 |\n+-------------------------+----------------------------+\n\nSELECT JSON_DEPTH('[1, 2, [3, 4, 5, 6], 7]');\n+---------------------------------------+\n| JSON_DEPTH('[1, 2, [3, 4, 5, 6], 7]') |\n+---------------------------------------+\n|                                     3 |\n+---------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_detailed/"], "Title": ["JSON_DETAILED"], "Feature": ["JSON_DETAILED(json_doc[, tab_size])\nJSON_PRETTY(json_doc[, tab_size])\n"], "Description": ["Represents JSON in the most understandable way emphasizing nested structures. ", "JSON_PRETTY was added as an alias for JSON_DETAILED in MariaDB 10.10.3, MariaDB 10.9.5, MariaDB 10.8.7, MariaDB 10.7.8, MariaDB 10.6.12, MariaDB 10.5.19 and MariaDB 10.4.28."], "Examples": ["SET @j = '{ \"A\":1,\"B\":[2,3]}';\n\nSELECT @j;\n+--------------------+\n| @j                 |\n+--------------------+\n| { \"A\":1,\"B\":[2,3]} |\n+--------------------+\n\nSELECT JSON_DETAILED(@j);\n+------------------------------------------------------------+\n| JSON_DETAILED(@j)                                          |\n+------------------------------------------------------------+\n| {\n    \"A\": 1,\n    \"B\": \n    [\n        2,\n        3\n    ]\n} |\n+------------------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_equals/"], "Title": ["JSON_EQUALS"], "Feature": ["JSON_EQUALS(json1, json2)\n"], "Description": ["Checks if there is equality between two json objects. Returns 1 if it there is, 0 if not, or NULL if any of the arguments are null."], "Examples": ["SELECT JSON_EQUALS('{\"a\"   :[1, 2, 3],\"b\":[4]}', '{\"b\":[4],\"a\":[1, 2, 3.0]}');\n+------------------------------------------------------------------------+\n| JSON_EQUALS('{\"a\"   :[1, 2, 3],\"b\":[4]}', '{\"b\":[4],\"a\":[1, 2, 3.0]}') |\n+------------------------------------------------------------------------+\n|                                                                      1 |\n+------------------------------------------------------------------------+\n\nSELECT JSON_EQUALS('{\"a\":[1, 2, 3]}', '{\"a\":[1, 2, 3.01]}');\n+------------------------------------------------------+\n| JSON_EQUALS('{\"a\":[1, 2, 3]}', '{\"a\":[1, 2, 3.01]}') |\n+------------------------------------------------------+\n|                                                    0 |\n+------------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_extract/"], "Title": ["JSON_EXTRACT"], "Feature": ["JSON_EXTRACT(json_doc, path[, path] ...)\n"], "Description": ["Extracts data from a JSON document. The extracted data is selected from the parts matching the path arguments. Returns all matched values; either as a single matched value, or, if the arguments could return multiple values, a result autowrapped as an array in the matching order.", "Returns NULL if no paths match or if any of the arguments are NULL. ", "An error will occur if any path argument is not a valid path, or if the json_doc argument is not a valid JSON document.", "The path expression be a JSONPath expression as supported by MariaDB "], "Examples": ["SET @json = '[1, 2, [3, 4]]';\n\nSELECT JSON_EXTRACT(@json, '$[1]');\n+-----------------------------+\n| JSON_EXTRACT(@json, '$[1]') |\n+-----------------------------+\n| 2                           |\n+-----------------------------+\n\nSELECT JSON_EXTRACT(@json, '$[2]');\n+-----------------------------+\n| JSON_EXTRACT(@json, '$[2]') |\n+-----------------------------+\n| [3, 4]                      |\n+-----------------------------+\n\nSELECT JSON_EXTRACT(@json, '$[2][1]');\n+--------------------------------+\n| JSON_EXTRACT(@json, '$[2][1]') |\n+--------------------------------+\n| 4                              |\n+--------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_insert/"], "Title": ["JSON_INSERT"], "Feature": ["JSON_INSERT(json_doc, path, val[, path, val] ...)\n"], "Description": ["Inserts data into a JSON document, returning the resulting document or NULL if either of the json_doc or path arguments are null. ", "An error will occur if the JSON document is invalid, or if any of the paths are invalid or contain a * or ** wildcard.", "JSON_INSERT can only insert data while JSON_REPLACE can only update. JSON_SET can update or insert data. "], "Examples": ["SET @json = '{ \"A\": 0, \"B\": [1, 2]}';\n\nSELECT JSON_INSERT(@json, '$.C', '[3, 4]');\n+--------------------------------------+\n| JSON_INSERT(@json, '$.C', '[3, 4]')  |\n+--------------------------------------+\n| { \"A\": 0, \"B\": [1, 2], \"C\":\"[3, 4]\"} |\n+--------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_keys/"], "Title": ["JSON_KEYS"], "Feature": ["JSON_KEYS(json_doc[, path])\n"], "Description": ["Returns the keys as a JSON array from the top-level value of a JSON object or, if the optional path argument is provided, the top-level keys from the path. ", "Excludes keys from nested sub-objects in the top level value. The resulting array will be empty if the selected object is empty.", "Returns NULL if any of the arguments are null, a given path does not locate an object, or if the json_doc argument is not an object.", "An error will occur if JSON document is invalid, the path is invalid or if the path contains a * or ** wildcard."], "Examples": ["SELECT JSON_KEYS('{\"A\": 1, \"B\": {\"C\": 2}}');\n+--------------------------------------+\n| JSON_KEYS('{\"A\": 1, \"B\": {\"C\": 2}}') |\n+--------------------------------------+\n| [\"A\", \"B\"]                           |\n+--------------------------------------+\n\nSELECT JSON_KEYS('{\"A\": 1, \"B\": 2, \"C\": {\"D\": 3}}', '$.C');\n+-----------------------------------------------------+\n| JSON_KEYS('{\"A\": 1, \"B\": 2, \"C\": {\"D\": 3}}', '$.C') |\n+-----------------------------------------------------+\n| [\"D\"]                                               |\n+-----------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_length/"], "Title": ["JSON_LENGTH"], "Feature": ["JSON_LENGTH(json_doc[, path])\n"], "Description": ["Returns the length of a JSON document, or, if the optional path argument is given, the length of the value within the document specified by the path. ", "Returns NULL if any of the arguments argument are null or the path argument does not identify a value in the document. ", "An error will occur if the JSON document is invalid, the path is invalid or if the path contains a * or ** wildcard.", "Length will be determined as follow:", "A scalar's length is always 1.\nIf an array, the number of elements in the array.\nIf an object, the number of members in the object.\n", "The length of nested arrays or objects are not counted."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_loose/"], "Title": ["JSON_LOOSE"], "Feature": ["JSON_LOOSE(json_doc)\n"], "Description": ["Adds spaces to a JSON document to make it look more readable."], "Examples": ["SET @j = '{ \"A\":1,\"B\":[2,3]}';\n\nSELECT JSON_LOOSE(@j), @j;\n+-----------------------+--------------------+\n| JSON_LOOSE(@j)        | @j                 |\n+-----------------------+--------------------+\n| {\"A\": 1, \"B\": [2, 3]} | { \"A\":1,\"B\":[2,3]} |\n+-----------------------+--------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_merge/"], "Title": ["JSON_MERGE"], "Feature": ["JSON_MERGE(json_doc, json_doc[, json_doc] ...)\n"], "Description": ["Merges the given JSON documents.", "Returns the merged result,or NULL if any argument is NULL.", "An error occurs if any of the arguments are not valid JSON documents.", "JSON_MERGE has been deprecated since MariaDB 10.2.25, MariaDB 10.3.16 and MariaDB 10.4.5. JSON_MERGE_PATCH is an RFC 7396-compliant replacement, and JSON_MERGE_PRESERVE is a synonym."], "Examples": ["SET @json1 = '[1, 2]';\nSET @json2 = '[3, 4]';\n\nSELECT JSON_MERGE(@json1,@json2);\n+---------------------------+\n| JSON_MERGE(@json1,@json2) |\n+---------------------------+\n| [1, 2, 3, 4]              |\n+---------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_normalize/"], "Title": ["JSON_NORMALIZE"], "Feature": ["JSON_NORMALIZE(json)\n"], "Description": ["Recursively sorts keys and removes spaces, allowing comparison of json documents for equality."], "Examples": ["CREATE TABLE t1 (\n id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,\n val JSON,\n /* other columns here */\n PRIMARY KEY (id)\n);\n", "ALTER TABLE t1\n   ADD COLUMN jnorm JSON AS (JSON_NORMALIZE(val)) VIRTUAL,\n   ADD UNIQUE KEY (jnorm);\n", "INSERT INTO t1 (val) VALUES ('{\"name\":\"alice\",\"color\":\"blue\"}');\n", "INSERT INTO t1 (val) VALUES ('{ \"color\": \"blue\", \"name\": \"alice\" }');\nERROR 1062 (23000): Duplicate entry '{\"color\":\"blue\",\"name\":\"alice\"}' for key 'jnorm'\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_object/"], "Title": ["JSON_OBJECT"], "Feature": ["JSON_OBJECT([key, value[, key, value] ...])\n"], "Description": ["Returns a JSON object containing the given key/value pairs. The key/value list can be empty.", "An error will occur if there are an odd number of arguments, or any key name is NULL."], "Examples": ["SELECT JSON_OBJECT(\"id\", 1, \"name\", \"Monty\");\n+---------------------------------------+\n| JSON_OBJECT(\"id\", 1, \"name\", \"Monty\") |\n+---------------------------------------+\n| {\"id\": 1, \"name\": \"Monty\"}            |\n+---------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_objectagg/"], "Title": ["JSON_OBJECTAGG"], "Feature": ["JSON_OBJECTAGG(key, value)\n"], "Description": ["JSON_OBJECTAGG returns a JSON object containing key-value pairs. It takes two expressions that evaluate to a single value, or two column names, as arguments, the first used as a key, and the second as a value. ", "The maximum returned length in bytes is determined by the group_concat_max_len server system variable.", "Returns NULL in the case of an error, or if the result contains no rows.", "JSON_OBJECTAGG cannot currently be used as a window function."], "Examples": ["select * from t1;\n+------+-------+\n| a    | b     |\n+------+-------+\n|    1 | Hello |\n|    1 | World |\n|    2 | This  |\n+------+-------+\n\nSELECT JSON_OBJECTAGG(a, b) FROM t1;\n+----------------------------------------+\n| JSON_OBJECTAGG(a, b)                   |\n+----------------------------------------+\n| {\"1\":\"Hello\", \"1\":\"World\", \"2\":\"This\"} |\n+----------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_object_filter_keys/"], "Title": ["JSON_OBJECT_FILTER_KEYS"], "Feature": ["JSON_OBJECT_FILTER_KEYS(obj, array_keys)\n"], "Description": ["JSON_OBJECT_FILTER_KEYS returns a JSON object with keys from the object that are also present in the array as string. It is used when one wants to get key-value pair such that the keys are common but the values may not be common."], "Examples": ["SET @obj1= '{ \"a\": 1, \"b\": 2, \"c\": 3}';\nSET @obj2= '{\"b\" : 10, \"c\": 20, \"d\": 30}';\nSELECT JSON_OBJECT_FILTER_KEYS (@obj1, JSON_ARRAY_INTERSECT(JSON_KEYS(@obj1), JSON_KEYS(@obj2)));\n+-------------------------------------------------------------------------------------------+\n| JSON_OBJECT_FILTER_KEYS (@obj1, JSON_ARRAY_INTERSECT(JSON_KEYS(@obj1), JSON_KEYS(@obj2))) |\n+-------------------------------------------------------------------------------------------+\n| {\"b\": 2, \"c\": 3}                                                                          |\n+-------------------------------------------------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_object_to_array/"], "Title": ["JSON_OBJECT_TO_ARRAY"], "Feature": ["JSON_OBJECT_TO_ARRAY(Obj)\n"], "Description": ["It is used to convert all JSON objects found in a JSON document to JSON arrays where each item in the outer array represents a single key-value pair from the object. It is used when we want not just common keys, but also common values. It can be used in conjunction with JSON_ARRAY_INTERSECT()."], "Examples": ["SET @obj1= '{ \"a\": [1, 2, 3], \"b\": { \"key1\":\"val1\", \"key2\": {\"key3\":\"val3\"} }}';\n\nSELECT JSON_OBJECT_TO_ARRAY(@obj1);\n+-----------------------------------------------------------------------+\n| JSON_OBJECT_TO_ARRAY(@obj1)                                           |\n+-----------------------------------------------------------------------+\n| [[\"a\", [1, 2, 3]], [\"b\", {\"key1\": \"val1\", \"key2\": {\"key3\": \"val3\"}}]] |\n+-----------------------------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_overlaps/"], "Title": ["JSON_OVERLAPS"], "Feature": ["JSON_OVERLAPS(json_doc1, json_doc2)\n"], "Description": ["JSON_OVERLAPS() compares two json documents and returns true if they have at least one common\nkey-value pair between two objects, array element common between two arrays,\nor array element common with scalar if one of the arguments is a scalar and other is an array.\nIf two json documents are scalars, it returns true if they have same type and value.", "If none of the above conditions are satisfied then it returns false."], "Examples": ["SELECT JSON_OVERLAPS('false', 'false');\n+---------------------------------+\n| JSON_OVERLAPS('false', 'false') |\n+---------------------------------+\n| 1                               |\n+---------------------------------+\n\nSELECT JSON_OVERLAPS('true', '[\"abc\", 1, 2, true, false]');\n+----------------------------------------------------+\n| JSON_OVERLAPS('true','[\"abc\", 1, 2, true, false]') |\n+----------------------------------------------------+\n| 1                                                  |\n+----------------------------------------------------+\n\nSELECT JSON_OVERLAPS('{\"A\": 1, \"B\": {\"C\":2}}', '{\"A\": 2, \"B\": {\"C\":2}}') AS is_overlap;\n+---------------------+\n| is_overlap          |\n+---------------------+\n| 1                   |\n+---------------------+\n", "SELECT JSON_OVERLAPS('[1, 2, true, false, null]', '[3, 4, [1]]') AS is_overlap;\n+--------------------- +\n| is_overlap           |\n+----------------------+\n| 0                    |\n+----------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_query/"], "Title": ["JSON_QUERY"], "Feature": ["JSON_QUERY(json_doc, path)\n"], "Description": ["Given a JSON document, returns an object or array specified by the path. Returns NULL if not given a valid JSON document, or if there is no match."], "Examples": ["select json_query('{\"key1\":{\"a\":1, \"b\":[1,2]}}', '$.key1');\n+-----------------------------------------------------+\n| json_query('{\"key1\":{\"a\":1, \"b\":[1,2]}}', '$.key1') |\n+-----------------------------------------------------+\n| {\"a\":1, \"b\":[1,2]}                                  |\n+-----------------------------------------------------+\n\nselect json_query('{\"key1\":123, \"key1\": [1,2,3]}', '$.key1');\n+-------------------------------------------------------+\n| json_query('{\"key1\":123, \"key1\": [1,2,3]}', '$.key1') |\n+-------------------------------------------------------+\n| [1,2,3]                                               |\n+-------------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_quote/"], "Title": ["JSON_QUOTE"], "Feature": ["JSON_QUOTE(json_value)\n"], "Description": ["Quotes a string as a JSON value, usually for producing valid JSON string literals for inclusion in JSON documents. Wraps the string with double quote characters and escapes interior quotes and other special characters, returning a utf8mb4 string. ", "Returns NULL if the argument is NULL."], "Examples": ["SELECT JSON_QUOTE('A'), JSON_QUOTE(\"B\"), JSON_QUOTE('\"C\"');\n+-----------------+-----------------+-------------------+\n| JSON_QUOTE('A') | JSON_QUOTE(\"B\") | JSON_QUOTE('\"C\"') |\n+-----------------+-----------------+-------------------+\n| \"A\"             | \"B\"             | \"\\\"C\\\"\"           |\n+-----------------+-----------------+-------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_remove/"], "Title": ["JSON_REMOVE"], "Feature": ["JSON_REMOVE(json_doc, path[, path] ...)\n"], "Description": ["Removes data from a JSON document returning the result, or NULL if any of the arguments are null. If the element does not exist in the document, no changes are made.", "The function returns NULL and throws a warning if the JSON document is invalid, the path is invalid, contains a range, or  contains a * or ** wildcard.", "Path arguments are evaluated from left to right, with the result from the earlier evaluation being used as the value for the next."], "Examples": ["SELECT JSON_REMOVE('{\"A\": 1, \"B\": 2, \"C\": {\"D\": 3}}', '$.C');\n+-------------------------------------------------------+\n| JSON_REMOVE('{\"A\": 1, \"B\": 2, \"C\": {\"D\": 3}}', '$.C') |\n+-------------------------------------------------------+\n| {\"A\": 1, \"B\": 2}                                      |\n+-------------------------------------------------------+\n\nSELECT JSON_REMOVE('[\"A\", \"B\", [\"C\", \"D\"], \"E\"]', '$[1]');\n+----------------------------------------------------+\n| JSON_REMOVE('[\"A\", \"B\", [\"C\", \"D\"], \"E\"]', '$[1]') |\n+----------------------------------------------------+\n| [\"A\", [\"C\", \"D\"], \"E\"]                             |\n+----------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_replace/"], "Title": ["JSON_REPLACE"], "Feature": ["JSON_REPLACE(json_doc, path, val[, path, val] ...)\n"], "Description": ["Replaces existing values in a JSON document, returning the result, or NULL if any of the arguments are NULL. ", "An error will occur if the JSON document is invalid, the path is invalid or if the path contains a * or ** wildcard.", "Paths and values are evaluated from left to right, with the result from the earlier evaluation being used as the value for the next.", "JSON_REPLACE can only update data, while JSON_INSERT can only insert. JSON_SET can update or insert data. "], "Examples": ["SELECT JSON_REPLACE('{ \"A\": 1, \"B\": [2, 3]}', '$.B[1]', 4);\n+-----------------------------------------------------+\n| JSON_REPLACE('{ \"A\": 1, \"B\": [2, 3]}', '$.B[1]', 4) |\n+-----------------------------------------------------+\n| { \"A\": 1, \"B\": [2, 4]}                              |\n+-----------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_search/"], "Title": ["JSON_SEARCH"], "Feature": ["JSON_SEARCH(json_doc, return_arg, search_str[, escape_char[, path] ...])\n"], "Description": ["Returns the path to the given string within a JSON document, or NULL if any of json_doc, search_str or a path argument is NULL; if the search string is not found, or if no path exists within the document. ", "A warning will occur if the JSON document is not valid, any of the path arguments are not valid, if return_arg is neither one nor all, or if the escape character is not a constant. NULL will be returned.", "return_arg can be one of two values:", "'one: Terminates after finding the first match, so will return one path string. If there is more than one match, it is undefined which is considered first.\nall: Returns all matching path strings, without duplicates. Multiple strings are autowrapped as an array. The order is undefined.\n"], "Examples": ["SET @json = '[\"A\", [{\"B\": \"1\"}], {\"C\":\"AB\"}, {\"D\":\"BC\"}]';\n\nSELECT JSON_SEARCH(@json, 'one', 'AB');\n+---------------------------------+\n| JSON_SEARCH(@json, 'one', 'AB') |\n+---------------------------------+\n| \"$[2].C\"                        |\n+---------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_set/"], "Title": ["JSON_SET"], "Feature": ["JSON_SET(json_doc, path, val[, path, val] ...)\n"], "Description": ["Updates or inserts data into a JSON document, returning the result, or NULL if any of the arguments are NULL or the optional path fails to find an object.", "An error will occur if the JSON document is invalid, the path is invalid or if the path contains a * or  wildcard.", "JSON_SET can update or insert data, while JSON_REPLACE can only update, and JSON_INSERT only insert. "], "Examples": ["SELECT JSON_SET(Priv, '$.locked', 'true') FROM mysql.global_priv\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_table/"], "Title": ["JSON_TABLE"], "Feature": ["JSON_TABLE(json_doc, \n          context_path COLUMNS (column_list)\n) [AS] alias\n", "column_list:\n    column[, column][, ...]\n", "column:\n    name FOR ORDINALITY\n    |  name type PATH path_str [on_empty] [on_error]\n    |  name type EXISTS PATH path_str\n    |  NESTED PATH path_str COLUMNS (column_list)\n", "on_empty:\n    {NULL | DEFAULT string | ERROR} ON EMPTY\n", "on_error:\n    {NULL | DEFAULT string | ERROR} ON ERROR\n"], "Description": ["JSON_TABLE can be used in contexts where a table reference can be used; in the FROM clause of a SELECT statement, and in multi-table UPDATE/DELETE statements.", "json_doc is the JSON document to extract data from.  In the simplest case, it is a string literal containing JSON.  In more complex cases it can be an arbitrary expression returning JSON.  The expression may have references to columns of other tables. However, one can only refer to tables that precede this JSON_TABLE invocation. For RIGHT JOIN, it is assumed that its outer side precedes the inner.   All tables in outer selects are also considered preceding.", "context_path is a JSON Path expression pointing to a collection of nodes in json_doc that will be used as the source of rows.", "The COLUMNS clause declares the names and types of the columns that JSON_TABLE returns, as well as how the values of the columns are produced.", "Column Definitions", "The following types of columns are supported:", "Path Columns", "name type PATH path_str [on_empty] [on_error]\n", "Locates the JSON node pointed to by path_str and returns its value. The path_str is evaluated using the current row source node as the context node.", "set @json='\n[\n  {\"name\":\"Laptop\", \"color\":\"black\", \"price\":\"1000\"},\n  {\"name\":\"Jeans\",  \"color\":\"blue\"}\n]';\n\nselect * from json_table(@json, '$[*]' \n  columns(\n   name  varchar(10) path '$.name', \n   color varchar(10) path '$.color',\n   price decimal(8,2) path '$.price' ) \n) as jt;\n+--------+-------+---------+\n| name   | color | price   |\n+--------+-------+---------+\n| Laptop | black | 1000.00 |\n| Jeans  | blue  |    NULL |\n+--------+-------+---------+\n", "The on_empty and on_error clauses specify the actions to be performed when the value was not found or there was an error condition. See the ON EMPTY and ON ERROR clauses section for details.", "ORDINALITY Columns", "name FOR ORDINALITY\n", "Counts the rows, starting from 1. ", "Example:", "set @json='\n[\n  {\"name\":\"Laptop\", \"color\":\"black\"},\n  {\"name\":\"Jeans\",  \"color\":\"blue\"}\n]';\n\nselect * from json_table(@json, '$[*]' \n  columns(\n   id for ordinality, \n   name  varchar(10) path '$.name')\n) as jt;\n+------+--------+\n| id   | name   |\n+------+--------+\n|    1 | Laptop |\n|    2 | Jeans  |\n+------+--------+\n", "EXISTS PATH Columns", "name type EXISTS PATH path_str\n", "Checks whether the node pointed to by value_path exists. The value_path is evaluated using the current row source node as the context node.", "set @json='\n[\n  {\"name\":\"Laptop\", \"color\":\"black\", \"price\":1000},\n  {\"name\":\"Jeans\",  \"color\":\"blue\"}\n]';\n\nselect * from json_table(@json, '$[*]' \n  columns(\n   name  varchar(10) path '$.name',\n   has_price integer exists path '$.price')\n) as jt;\n+--------+-----------+\n| name   | has_price |\n+--------+-----------+\n| Laptop |         1 |\n| Jeans  |         0 |\n+--------+-----------+\n", "NESTED PATHs", "NESTED PATH converts nested JSON structures into multiple rows.", "NESTED PATH path COLUMNS (column_list)\n", "It finds the sequence of JSON nodes pointed to by path and uses it to produce rows.  For each found node, a row is generated with column values as specified by the NESTED PATH's COLUMNS clause.  If path finds no nodes, only one row is generated with all columns having NULL values.", "For example, consider a  JSON document that contains an array of items, and each item, in turn, is expected to have an array of its available sizes:", "set @json='\n[\n  {\"name\":\"Jeans\",  \"sizes\": [32, 34, 36]},\n  {\"name\":\"T-Shirt\", \"sizes\":[\"Medium\", \"Large\"]},\n  {\"name\":\"Cellphone\"}\n]';\n", "NESTED PATH allows one to produce a separate row for each size each item has:", "select * from json_table(@json, '$[*]' \n  columns(\n    name  varchar(10) path '$.name', \n    nested path '$.sizes[*]' columns (\n      size varchar(32) path '$'\n    )\n  )\n) as jt;\n+-----------+--------+\n| name      | size   |\n+-----------+--------+\n| Jeans     | 32     |\n| Jeans     | 34     |\n| Jeans     | 36     |\n| T-Shirt   | Medium |\n| T-Shirt   | Large  |\n| Cellphone | NULL   |\n+-----------+--------+\n", "NESTED PATH clauses can be nested within one another.\nThey can also be located next to each other.  In that case, the nested path clauses will produce records one at a time. The ones that are not producing records will have all columns set to NULL.", "Example:", "set @json='\n[\n  {\"name\":\"Jeans\",  \"sizes\": [32, 34, 36], \"colors\":[\"black\", \"blue\"]}\n]';\n\nselect * from json_table(@json, '$[*]' \n  columns(\n    name  varchar(10) path '$.name', \n    nested path '$.sizes[*]' columns (\n      size varchar(32) path '$'\n    ),\n    nested path '$.colors[*]' columns (\n      color varchar(32) path '$'\n    )\n  )\n) as jt;\n\n+-------+------+-------+\n| name  | size | color |\n+-------+------+-------+\n| Jeans | 32   | NULL  |\n| Jeans | 34   | NULL  |\n| Jeans | 36   | NULL  |\n| Jeans | NULL | black |\n| Jeans | NULL | blue  |\n+-------+------+-------+\n", "ON EMPTY and ON ERROR Clauses", "The ON EMPTY clause specifies what will be done when the element specified by the search path is missing in the JSON document.", "on_empty:\n    {NULL | DEFAULT string | ERROR} ON EMPTY\n", "When ON EMPTY  clause is not present, NULL ON EMPTY is implied.", "on_error:\n    {NULL | DEFAULT string | ERROR} ON ERROR\n", "The ON ERROR clause specifies what should be done if a JSON structure error occurs when trying to extract the value pointed to by the path expression. A JSON structure error here occurs only when one attempts to convert a JSON non-scalar (array or object) into a scalar value.\nWhen the ON ERROR clause is not present, NULL ON ERROR is implied.", "Note: A datatype conversion error (e.g. attempt to store a non-integer value into an integer field, or a varchar column being truncated) is not considered a JSON error and so will not trigger the ON ERROR behavior. It will produce warnings, in the same way as  CAST(value AS datatype) would.", "Replication", "In the current code, evaluation of JSON_TABLE is deterministic, that is, for a given input string JSON_TABLE will always produce the same set of rows in the same order. However, one can think of JSON documents that one can consider identical which will produce different output. In order to be future-proof and withstand changes like:", "sorting JSON object members by name (like MySQL does)\nchanging the way duplicate object members are handled\nthe function is marked as unsafe for statement-based replication.\n", "Extracting a Subdocument into a Column", "MariaDB starting with 10.6.9Prior to MariaDB 10.6.9, JSON_TABLE did not allow one to extract a JSON \"subdocument\" into a JSON column. \nSELECT * FROM JSON_TABLE('{\"foo\": [1,2,3,4]}','$' columns( jscol json path '$.foo') ) AS T;\n+-------+\n| jscol |\n+-------+\n| NULL  |\n+-------+\nThis is supported from MariaDB 10.6.9:\nSELECT * FROM JSON_TABLE('{\"foo\": [1,2,3,4]}','$' columns( jscol json path '$.foo') ) AS T;\n+-----------+\n| jscol     |\n+-----------+\n| [1,2,3,4] |\n+-----------+\n"], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_type/"], "Title": ["JSON_TYPE"], "Feature": ["JSON_TYPE(json_val)\n"], "Description": ["Returns the type of a JSON value (as a string), or NULL if the argument is null.", "An error will occur if the argument is an invalid JSON value.", "The following is a complete list of the possible return types:", "Return typeValueExample\nARRAYJSON array[1, 2, {\"key\": \"value\"}]\nOBJECTJSON object{\"key\":\"value\"}\nBOOLEANJSON true/false literalstrue, false\nDOUBLEA number with at least one floating point decimal.1.2\nINTEGERA number without a floating point decimal.1\nNULLJSON null literal (this is returned as a string, not to be confused with the SQL NULL value!)null\nSTRINGJSON String\"a sample string\"\n\n"], "Examples": ["SELECT JSON_TYPE('{\"A\": 1, \"B\": 2, \"C\": 3}');\n+---------------------------------------+\n| JSON_TYPE('{\"A\": 1, \"B\": 2, \"C\": 3}') |\n+---------------------------------------+\n| OBJECT                                |\n+---------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_unquote/"], "Title": ["JSON_UNQUOTE"], "Feature": ["JSON_UNQUOTE(val)\n"], "Description": ["Unquotes a JSON value, returning a string, or NULL if the argument is null. ", "An error will occur if the given value begins and ends with double quotes and is an invalid JSON string literal.", "If the given value is not a JSON string, value is passed through unmodified.", "Certain character sequences have special meanings within a string. Usually, a backslash is ignored, but the escape sequences in the table below are recognised by MariaDB, unless the SQL Mode is set to NO_BACKSLASH_ESCAPES SQL.", "Escape sequenceCharacter\n\\\"Double quote (\")\n\\bBackslash\n\\fFormfeed\n\\nNewline (linefeed)\n\\rCarriage return\n\\tTab\n\\\\Backslash (\\)\n\\uXXXXUTF-8 bytes for Unicode value XXXX\n\n"], "Examples": ["SELECT JSON_UNQUOTE('\"Monty\"');\n+-------------------------+\n| JSON_UNQUOTE('\"Monty\"') |\n+-------------------------+\n| Monty                   |\n+-------------------------+\n", "SELECT JSON_UNQUOTE('Si\\bng\\ting');\n+-----------------------------+\n| JSON_UNQUOTE('Si\\bng\\ting') |\n+-----------------------------+\n| Sng\ting                   |\n+-----------------------------+\n", "SET @@sql_mode = 'NO_BACKSLASH_ESCAPES';\n\nSELECT JSON_UNQUOTE('Si\\bng\\ting');\n+-----------------------------+\n| JSON_UNQUOTE('Si\\bng\\ting') |\n+-----------------------------+\n| Si\\bng\\ting                 |\n+-----------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_valid/"], "Title": ["JSON_VALID"], "Feature": ["JSON_VALID(value)\n"], "Description": ["Indicates whether the given value is a valid JSON document or not. Returns 1 if valid, 0 if not, and NULL if the argument is NULL.", "From MariaDB 10.4.3, the JSON_VALID function is automatically used as a CHECK constraint for the JSON data type alias in order to ensure that a valid json document is inserted. "], "Examples": ["SELECT JSON_VALID('{\"id\": 1, \"name\": \"Monty\"}');\n+------------------------------------------+\n| JSON_VALID('{\"id\": 1, \"name\": \"Monty\"}') |\n+------------------------------------------+\n|                                        1 |\n+------------------------------------------+\n\nSELECT JSON_VALID('{\"id\": 1, \"name\": \"Monty\", \"oddfield\"}');\n+------------------------------------------------------+\n| JSON_VALID('{\"id\": 1, \"name\": \"Monty\", \"oddfield\"}') |\n+------------------------------------------------------+\n|                                                    0 |\n+------------------------------------------------------+\n"], "Category": ["JSON Functions"]}
{"HTML": ["https://mariadb.com//kb/en/json_value/"], "Title": ["JSON_VALUE"], "Feature": ["JSON_VALUE(json_doc, path)\n"], "Description": ["Given a JSON document, returns the scalar specified by the path. Returns NULL if not given a valid JSON document, or if there is no match."], "Examples": ["select json_value('{\"key1\":123}', '$.key1');\n+--------------------------------------+\n| json_value('{\"key1\":123}', '$.key1') |\n+--------------------------------------+\n| 123                                  |\n+--------------------------------------+\n\nselect json_value('{\"key1\": [1,2,3], \"key1\":123}', '$.key1');\n+-------------------------------------------------------+\n| json_value('{\"key1\": [1,2,3], \"key1\":123}', '$.key1') |\n+-------------------------------------------------------+\n| 123                                                   |\n+-------------------------------------------------------+\n", "SET @json = '{\"key1\":\"60\\\\\" Table\", \"key2\":\"1\"}';\n\nSELECT JSON_VALUE(@json,'$.key1') AS Name , json_value(@json,'$.key2') as ID;\n+-----------+------+\n| Name      | ID   |\n+-----------+------+\n| 60\" Table | 1    |\n+-----------+------+\n"], "Category": ["JSON Functions"]}
