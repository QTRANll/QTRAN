{"HTML": ["https://mariadb.com//kb/en/get_lock/"], "Title": ["GET_LOCK"], "Feature": ["GET_LOCK(str,timeout)\n"], "Description": ["Tries to obtain a lock with a name given by the string str, using a timeout of timeout seconds. Returns 1 if the lock was obtained successfully, 0 if the attempt timed out (for example, because another client has previously locked the name), or  NULL if an error occurred (such as running out of memory or the thread was killed with mariadb-admin kill).", "A lock is released with RELEASE_LOCK(), when the connection terminates (either normally or abnormally). A connection can hold multiple locks at the same time, so a lock that is no longer needed needs to be explicitly released.", "The IS_FREE_LOCK function returns whether a specified lock a free or not, and the IS_USED_LOCK whether the function is in use or not.", "Locks obtained with GET_LOCK() do not interact with transactions. That is, committing a transaction does not release any such locks obtained during the transaction.", "It is also possible to recursively set the same lock. If a lock with the same name is set n times, it needs to be released n times as well. ", "str is case insensitive for GET_LOCK() and related functions. If str is an empty string or NULL, GET_LOCK() returns NULL and does nothing. timeout supports microseconds.", "If the metadata_lock_info plugin is installed, locks acquired with this function are visible in the Information Schema METADATA_LOCK_INFO table.", "This function can be used to implement application locks or to simulate record locks. Names are locked on a server-wide basis. If a name has been locked by one client, GET_LOCK() blocks any request by another client for a lock with the same name. This allows clients that agree on a given lock name to use the name to perform cooperative advisory locking. But be aware that it also allows a client that is not among the set of cooperating clients to lock a name, either inadvertently or deliberately, and thus prevent any of the cooperating clients from locking that name. One way to reduce the likelihood of this is to use lock names that are database-specific or application-specific. For example, use lock names of the form db_name.str or app_name.str.", "Statements using the GET_LOCK function are not safe for statement-based replication.", "The patch to permit multiple locks was contributed by Konstantin \"Kostja\" Osipov (MDEV-3917)."], "Examples": ["SELECT GET_LOCK('lock1',10);\n+----------------------+\n| GET_LOCK('lock1',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n\nSELECT IS_FREE_LOCK('lock1'), IS_USED_LOCK('lock1');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK('lock1') | IS_USED_LOCK('lock1') |\n+-----------------------+-----------------------+\n|                     0 |                    46 |\n+-----------------------+-----------------------+\n\nSELECT IS_FREE_LOCK('lock2'), IS_USED_LOCK('lock2');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK('lock2') | IS_USED_LOCK('lock2') |\n+-----------------------+-----------------------+\n|                     1 |                  NULL |\n+-----------------------+-----------------------+\n", "SELECT GET_LOCK('lock2',10);\n+----------------------+\n| GET_LOCK('lock2',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n\nSELECT IS_FREE_LOCK('lock1'), IS_FREE_LOCK('lock2');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK('lock1') | IS_FREE_LOCK('lock2') |\n+-----------------------+-----------------------+\n|                     0 |                     0 |\n+-----------------------+-----------------------+\n\nSELECT RELEASE_LOCK('lock1'), RELEASE_LOCK('lock2');\n+-----------------------+-----------------------+\n| RELEASE_LOCK('lock1') | RELEASE_LOCK('lock2') |\n+-----------------------+-----------------------+\n|                     1 |                     1 |\n+-----------------------+-----------------------+\n", "SELECT GET_LOCK('lock3',10);\n+----------------------+\n| GET_LOCK('lock3',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n\nSELECT GET_LOCK('lock3',10);\n+----------------------+\n| GET_LOCK('lock3',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n\nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE           | LOCK_DURATION | LOCK_TYPE | TABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n|        46 | MDL_SHARED_NO_WRITE | NULL          | User lock | lock3        |            |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n\nSELECT RELEASE_LOCK('lock3');\n+-----------------------+\n| RELEASE_LOCK('lock3') |\n+-----------------------+\n|                     1 |\n+-----------------------+\n\nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE           | LOCK_DURATION | LOCK_TYPE | TABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n|        46 | MDL_SHARED_NO_WRITE | NULL          | User lock | lock3        |            |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n\nSELECT RELEASE_LOCK('lock3');\n+-----------------------+\n| RELEASE_LOCK('lock3') |\n+-----------------------+\n|                     1 |\n+-----------------------+\n\nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\nEmpty set (0.000 sec)\n", "SELECT GET_LOCK('lock4',10);\n+----------------------+\n| GET_LOCK('lock4',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n", "SELECT GET_LOCK('lock4',10);\n", "+----------------------+\n| GET_LOCK('lock4',10) |\n+----------------------+\n|                    0 |\n+----------------------+\n", "SELECT GET_LOCK('lock5',10); \n+----------------------+\n| GET_LOCK('lock5',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n", "SELECT GET_LOCK('lock6',10);\n+----------------------+\n| GET_LOCK('lock6',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n", "SELECT GET_LOCK('lock6',10); \n+----------------------+\n| GET_LOCK('lock6',10) |\n+----------------------+\n|                    0 |\n+----------------------+\n", "SELECT GET_LOCK('lock5',10);\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/inet6_aton/"], "Title": ["INET6_ATON"], "Feature": ["INET6_ATON(expr)\n"], "Description": ["Given an IPv6 or IPv4 network address as a string, returns a binary string that represents the numeric value of the address.", "No trailing zone ID's or traling network masks are permitted. For IPv4 addresses, or IPv6 addresses with IPv4 address parts, no classful addresses or trailing port numbers are permitted and octal numbers are not supported.", "The returned binary string will be VARBINARY(16) or VARBINARY(4) for IPv6 and IPv4 addresses respectively.", "Returns NULL if the argument is not understood.", "MariaDB starting with 10.5.0From MariaDB 10.5.0, INET6_ATON can take INET6 as an argument.\n"], "Examples": ["SELECT HEX(INET6_ATON('10.0.1.1'));\n+-----------------------------+\n| HEX(INET6_ATON('10.0.1.1')) |\n+-----------------------------+\n| 0A000101                    |\n+-----------------------------+\n\nSELECT HEX(INET6_ATON('48f3::d432:1431:ba23:846f'));\n+----------------------------------------------+\n| HEX(INET6_ATON('48f3::d432:1431:ba23:846f')) |\n+----------------------------------------------+\n| 48F3000000000000D4321431BA23846F             |\n+----------------------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/inet6_ntoa/"], "Title": ["INET6_NTOA"], "Feature": ["INET6_NTOA(expr)\n"], "Description": ["Given an IPv6 or IPv4 network address as a numeric binary string, returns the address as a nonbinary string in the connection character set.", "The return string is lowercase, and is platform independent, since it does not use functions specific to the operating system. It has a maximum length of 39 characters.", "Returns NULL if the argument is not understood."], "Examples": ["SELECT INET6_NTOA(UNHEX('0A000101'));\n+-------------------------------+\n| INET6_NTOA(UNHEX('0A000101')) |\n+-------------------------------+\n| 10.0.1.1                      |\n+-------------------------------+\n\nSELECT INET6_NTOA(UNHEX('48F3000000000000D4321431BA23846F'));\n+-------------------------------------------------------+\n| INET6_NTOA(UNHEX('48F3000000000000D4321431BA23846F')) |\n+-------------------------------------------------------+\n| 48f3::d432:1431:ba23:846f                             |\n+-------------------------------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/inet_aton/"], "Title": ["INET_ATON"], "Feature": ["INET_ATON(expr)\n"], "Description": ["Given the dotted-quad representation of an IPv4 network address as a string,\nreturns an integer that represents the numeric value of the address.\nAddresses may be 4- or 8-byte addresses.", "Returns NULL if the argument is not understood."], "Examples": ["SELECT INET_ATON('192.168.1.1');\n+--------------------------+\n| INET_ATON('192.168.1.1') |\n+--------------------------+\n|               3232235777 |\n+--------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/inet_ntoa/"], "Title": ["INET_NTOA"], "Feature": ["INET_NTOA(expr)\n"], "Description": ["Given a numeric IPv4 network address in network byte order (4 or 8 byte),\nreturns the dotted-quad representation of the address as a string."], "Examples": ["SELECT INET_NTOA(3232235777);\n+-----------------------+\n| INET_NTOA(3232235777) |\n+-----------------------+\n| 192.168.1.1           |\n+-----------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/is_free_lock/"], "Title": ["IS_FREE_LOCK"], "Feature": ["IS_FREE_LOCK(str)\n"], "Description": ["Checks whether the lock named str is free to use (that is, not locked).\nReturns 1 if the lock is free (no one is using the lock),\n 0 if the lock is in use, and NULL if an\nerror occurs (such as an incorrect argument, like an empty string or NULL). str is case insensitive.", "If the metadata_lock_info plugin is installed, the Information Schema metadata_lock_info table contains information about locks of this kind (as well as metadata locks).", "Statements using the IS_FREE_LOCK function are not safe for statement-based replication."], "Examples": [], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/is_ipv4/"], "Title": ["IS_IPV4"], "Feature": ["IS_IPV4(expr)\n"], "Description": ["If the expression is a valid IPv4 address, returns 1, otherwise returns 0.", "IS_IPV4() is stricter than INET_ATON(), but as strict as INET6_ATON(), in determining the validity of an IPv4 address. This implies that if IS_IPV4 returns 1, the same expression will always return a non-NULL result when passed to INET_ATON(), but that the reverse may not apply."], "Examples": ["SELECT IS_IPV4('1110.0.1.1');\n+-----------------------+\n| IS_IPV4('1110.0.1.1') |\n+-----------------------+\n|                     0 |\n+-----------------------+\n\nSELECT IS_IPV4('48f3::d432:1431:ba23:846f');\n+--------------------------------------+\n| IS_IPV4('48f3::d432:1431:ba23:846f') |\n+--------------------------------------+\n|                                    0 |\n+--------------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/is_ipv4_compat/"], "Title": ["IS_IPV4_COMPAT"], "Feature": ["IS_IPV4_COMPAT(expr)\n"], "Description": ["Returns 1 if a given numeric binary string IPv6 address, such as returned by INET6_ATON(), is IPv4-compatible, otherwise returns 0. ", "MariaDB starting with 10.5.0From MariaDB 10.5.0, when the argument is not INET6, automatic implicit CAST to INET6 is applied. As a consequence, IS_IPV4_COMPAT now understands arguments in both text representation and binary(16) representation. Before MariaDB 10.5.0, the function understood only binary(16) representation.\n"], "Examples": ["SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.1.1'));\n+------------------------------------------+\n| IS_IPV4_COMPAT(INET6_ATON('::10.0.1.1')) |\n+------------------------------------------+\n|                                        1 |\n+------------------------------------------+\n\nSELECT IS_IPV4_COMPAT(INET6_ATON('::48f3::d432:1431:ba23:846f'));\n+-----------------------------------------------------------+\n| IS_IPV4_COMPAT(INET6_ATON('::48f3::d432:1431:ba23:846f')) |\n+-----------------------------------------------------------+\n|                                                         0 |\n+-----------------------------------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/is_ipv4_mapped/"], "Title": ["IS_IPV4_MAPPED"], "Feature": ["IS_IPV4_MAPPED(expr)\n"], "Description": ["Returns 1 if a given a numeric binary string IPv6 address, such as returned by INET6_ATON(), is a valid IPv4-mapped address, otherwise returns 0.", "MariaDB starting with 10.5.0From MariaDB 10.5.0, when the argument is not INET6, automatic implicit CAST to INET6 is applied. As a consequence, IS_IPV4_MAPPED now understands arguments in both text representation and binary(16) representation. Before MariaDB 10.5.0, the function understood only binary(16) representation.\n"], "Examples": ["SELECT IS_IPV4_MAPPED(INET6_ATON('::10.0.1.1'));\n+------------------------------------------+\n| IS_IPV4_MAPPED(INET6_ATON('::10.0.1.1')) |\n+------------------------------------------+\n|                                        0 |\n+------------------------------------------+\n\nSELECT IS_IPV4_MAPPED(INET6_ATON('::ffff:10.0.1.1'));\n+-----------------------------------------------+\n| IS_IPV4_MAPPED(INET6_ATON('::ffff:10.0.1.1')) |\n+-----------------------------------------------+\n|                                             1 |\n+-----------------------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/is_ipv6/"], "Title": ["IS_IPV6"], "Feature": ["IS_IPV6(expr)\n"], "Description": ["Returns 1 if the expression is a valid IPv6 address specified as a string, otherwise returns 0. Does not consider IPv4 addresses to be valid IPv6 addresses."], "Examples": [" SELECT IS_IPV6('48f3::d432:1431:ba23:846f');\n+--------------------------------------+\n| IS_IPV6('48f3::d432:1431:ba23:846f') |\n+--------------------------------------+\n|                                    1 |\n+--------------------------------------+\n1 row in set (0.02 sec)\n\nSELECT IS_IPV6('10.0.1.1');\n+---------------------+\n| IS_IPV6('10.0.1.1') |\n+---------------------+\n|                   0 |\n+---------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/is_used_lock/"], "Title": ["IS_USED_LOCK"], "Feature": ["IS_USED_LOCK(str)\n"], "Description": ["Checks whether the lock named str is in use (that is, locked). If so,\nit returns the connection identifier of the client that holds the\nlock. Otherwise, it returns NULL. str is case insensitive.", "If the metadata_lock_info plugin is installed, the Information Schema metadata_lock_info table contains information about locks of this kind (as well as metadata locks).", "Statements using the IS_USED_LOCK function are not safe for statement-based replication."], "Examples": [], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/master_gtid_wait/"], "Title": ["MASTER_GTID_WAIT"], "Feature": ["MASTER_GTID_WAIT(gtid-list[, timeout)\n"], "Description": ["This function takes a string containing a comma-separated list of global transaction id's\n(similar to the value of, for example, gtid_binlog_pos). It waits until the value of gtid_slave_pos has the same or higher seq_no within all replication domains specified in the gtid-list; in other words, it waits until the slave has\nreached the specified GTID position.", "An optional second argument gives a timeout in seconds. If the timeout\nexpires before the specified GTID position is reached, then the function\nreturns -1. Passing NULL or a negative number for the timeout means no timeout, and the function will wait indefinitely.", " If the wait completes without a timeout, 0 is returned. Passing NULL for the\n gtid-list makes the function return NULL immediately, without waiting.", "The gtid-list may be the empty string, in which case MASTER_GTID_WAIT()\nreturns immediately. If the gtid-list contains fewer domains than\ngtid_slave_pos, then only those domains are waited upon. If gtid-list\ncontains a domain that is not present in @@gtid_slave_pos, then\nMASTER_GTID_WAIT() will wait until an event containing such domain_id arrives\non the slave (or until timed out or killed).", "MASTER_GTID_WAIT() can be useful to ensure that a slave has caught up to\na master. Simply take the value of gtid_binlog_pos on the master, and use it in a MASTER_GTID_WAIT() call on the slave; when the call completes, the slave\nwill have caught up with that master position.", "MASTER_GTID_WAIT() can also be used in client applications together with the\nlast_gtid session variable. This is useful in a read-scaleout replication setup, where the application writes to a single master but divides the\nreads out to a number of slaves to distribute the load. In such a setup, there\nis a risk that an application could first do an update on the master, and then\na bit later do a read on a slave, and if the slave is not fast enough, the\ndata read from the slave might not include the update just made, possibly\nconfusing the application and/or the end-user. One way to avoid this is to\nrequest the value of last_gtid on the master just after the update. Then\nbefore doing the read on the slave, do a MASTER_GTID_WAIT() on the value\nobtained from the master; this will ensure that the read is not performed\nuntil the slave has replicated sufficiently far for the update to have become\nvisible.", "Note that MASTER_GTID_WAIT() can be used even if the slave is configured not\nto use GTID for connections (CHANGE MASTER TO master_use_gtid=no). This is\nbecause from MariaDB 10, GTIDs are always logged on the master server, and\nalways recorded on the slave servers."], "Examples": [], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/master_pos_wait/"], "Title": ["MASTER_POS_WAIT"], "Feature": ["MASTER_POS_WAIT(log_name,log_pos[,timeout,[\"connection_name\"]])\n"], "Description": ["This function is useful in replication for controlling primary/replica synchronization.  It blocks until the replica has read and applied all updates up to the specified position (log_name,log_pos) in the primary log. The return value is the number of log events the replica had to wait for to advance to the specified position. The function returns NULL if\nthe replica SQL thread is not started, the replica's primary information is not\ninitialized, the arguments are incorrect, or an error occurs. It returns -1 if\nthe timeout has been exceeded. If the replica SQL thread stops while\n MASTER_POS_WAIT() is waiting, the function returns NULL. If\nthe replica is past the specified position, the function returns immediately.", "If a timeout value is specified, MASTER_POS_WAIT() stops\nwaiting when timeout seconds have elapsed. timeout must be greater than 0; a\nzero or negative timeout means no timeout.", "The connection_name is used when you are using multi-source-replication.  If you don't specify it, it's set to the value of the default_master_connection system variable.", "Statements using the MASTER_POS_WAIT() function are not safe for statement-based replication."], "Examples": [], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/name_const/"], "Title": ["NAME_CONST"], "Feature": ["NAME_CONST(name,value)\n"], "Description": ["Returns the given value. When used to produce a result set column,\n NAME_CONST() causes the column to have the given name. The\narguments should be constants.", "This function is used internally when replicating stored procedures. It makes little sense to use it explicitly in SQL statements, and it was not supposed to be used like that.", "SELECT NAME_CONST('myname', 14);\n+--------+\n| myname |\n+--------+\n|     14 |\n+--------+\n"], "Examples": [], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/release_lock/"], "Title": ["RELEASE_LOCK"], "Feature": ["RELEASE_LOCK(str)\n"], "Description": ["Releases the lock named by the string str that was obtained with GET_LOCK(). Returns 1 if the lock was released, 0 if the lock was not established by this thread (in which case the lock is not\nreleased), and NULL if the named lock did not exist. The lock does not exist if it was never obtained by a call to GET_LOCK() or if it has previously been released.", "str is case insensitive. If str is an empty string or NULL, RELEASE_LOCK() returns NULL and does nothing.", "Statements using the RELEASE_LOCK function are not safe for statement-based replication.", "The DO statement is convenient to use with RELEASE_LOCK()."], "Examples": ["SELECT GET_LOCK('lock1',10);\n+----------------------+\n| GET_LOCK('lock1',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n", "SELECT GET_LOCK('lock2',10);\n+----------------------+\n| GET_LOCK('lock2',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n", "SELECT RELEASE_LOCK('lock1'), RELEASE_LOCK('lock2'), RELEASE_LOCK('lock3');\n+-----------------------+-----------------------+-----------------------+\n| RELEASE_LOCK('lock1') | RELEASE_LOCK('lock2') | RELEASE_LOCK('lock3') |\n+-----------------------+-----------------------+-----------------------+\n|                     1 |                     0 |                  NULL |\n+-----------------------+-----------------------+-----------------------+\n", "SELECT GET_LOCK('lock3',10);\n+----------------------+\n| GET_LOCK('lock3',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n\nSELECT GET_LOCK('lock3',10);\n+----------------------+\n| GET_LOCK('lock3',10) |\n+----------------------+\n|                    1 |\n+----------------------+\n\nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE           | LOCK_DURATION | LOCK_TYPE | TABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n|        46 | MDL_SHARED_NO_WRITE | NULL          | User lock | lock3        |            |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n\nSELECT RELEASE_LOCK('lock3');\n+-----------------------+\n| RELEASE_LOCK('lock3') |\n+-----------------------+\n|                     1 |\n+-----------------------+\n\nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE           | LOCK_DURATION | LOCK_TYPE | TABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n|        46 | MDL_SHARED_NO_WRITE | NULL          | User lock | lock3        |            |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n\nSELECT RELEASE_LOCK('lock3');\n+-----------------------+\n| RELEASE_LOCK('lock3') |\n+-----------------------+\n|                     1 |\n+-----------------------+\n\nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\nEmpty set (0.000 sec)\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/sleep/"], "Title": ["SLEEP"], "Feature": ["SLEEP(duration)\n"], "Description": ["Sleeps (pauses) for the number of seconds given by the duration argument, then\nreturns 0. If SLEEP() is interrupted, it\nreturns 1. The duration may have a fractional part given in\nmicroseconds.", "Statements using the SLEEP() function are not safe for statement-based replication."], "Examples": ["SELECT SLEEP(5.5);\n+------------+\n| SLEEP(5.5) |\n+------------+\n|          0 |\n+------------+\n1 row in set (5.50 sec)\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/sys_guid/"], "Title": ["SYS_GUID"], "Feature": ["SYS_GUID()\n"], "Description": ["Returns a 16-byte globally unique identifier (GUID), similar to the UUID function, but without the - character."], "Examples": ["SELECT SYS_GUID();\n+----------------------------------+\n| SYS_GUID()                       |\n+----------------------------------+\n| 2C574E45BA2811EBB265F859713E4BE4 |\n+----------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/uuid/"], "Title": ["UUID"], "Feature": ["UUID()\n"], "Description": ["Returns a Universally Unique Identifier (UUID).", "A UUID is designed as a number that is globally unique in space and time. Two\ncalls to UUID() are expected to generate two different\nvalues, even if these calls are performed on two separate computers that are\nnot connected to each other.", "UUID() results are intended to be unique, but cannot always be relied upon to be unpredictable and unguessable.\n", "A UUID is a 128-bit number represented by a utf8 string of five\nhexadecimal numbers in aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\nformat:", "The first three numbers are generated from a timestamp.\nThe fourth number preserves temporal uniqueness in case the timestamp value\n  loses monotonicity (for example, due to daylight saving time).\nThe fifth number is an IEEE 802 node number that provides spatial uniqueness.\n  A random number is substituted if the latter is not available (for example,\n  because the host computer has no Ethernet card, or we do not know how to find\n  the hardware address of an interface on your operating system). In this case,\n  spatial uniqueness cannot be guaranteed. Nevertheless, a collision should\n  have very low probability.\n", "Currently, the MAC address of an interface is taken into account only on FreeBSD and Linux. On other operating systems, MariaDB uses a randomly generated 48-bit number.", "Statements using the UUID() function are not safe for statement-based replication.", "The function generates a UUIDv1 and the results are generated according to the \"DCE 1.1:Remote Procedure Call\" (Appendix A) CAE (Common Applications Environment) Specifications published by The Open Group in October 1997 (Document Number C706)."], "Examples": ["SELECT UUID();\n+--------------------------------------+\n| UUID()                               |\n+--------------------------------------+\n| cd41294a-afb0-11df-bc9b-00241dd75637 |\n+--------------------------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/uuid_short/"], "Title": ["UUID_SHORT"], "Feature": ["UUID_SHORT()\n"], "Description": ["Returns a \"short\" universally unique identifier as a 64-bit unsigned integer (rather\nthan a string-form 128-bit identifier as returned by the UUID() function).", "The value of UUID_SHORT() is guaranteed to be unique if the\nfollowing conditions hold:", "The server_id of the current host is unique among your set of master and\n  slave servers\nserver_id is between 0 and 255\nYou don't set back your system time for your server between mariadbd restarts\nYou do not invoke UUID_SHORT() on average more than 16\n  million times per second between mariadbd restarts\n", "The UUID_SHORT() return value is constructed this way:", "  (server_id & 255) << 56\n+ (server_startup_time_in_seconds << 24)\n+ incremented_variable++;\n", "Statements using the UUID_SHORT() function are not safe for statement-based replication."], "Examples": ["SELECT UUID_SHORT();\n+-------------------+\n| UUID_SHORT()      |\n+-------------------+\n| 21517162376069120 |\n+-------------------+\n", "create table t1 (a bigint unsigned default(uuid_short()) primary key);\ninsert into t1 values(),();\nselect * from t1;\n+-------------------+\n| a                 |\n+-------------------+\n| 98113699159474176 |\n| 98113699159474177 |\n+-------------------+\n"], "Category": ["Miscellaneous Functions"]}
{"HTML": ["https://mariadb.com//kb/en/values-value/"], "Title": ["VALUES / VALUE"], "Feature": ["MariaDB starting with 10.3.3VALUE(col_name) \n", "MariaDB until 10.3.2VALUES(col_name) \n"], "Description": ["In an INSERT ... ON DUPLICATE KEY UPDATE statement, you can use the VALUES(col_name) function in the  UPDATE clause to refer to column values from the  INSERT portion of the statement. In other words,  VALUES(col_name) in the UPDATE clause refers to the value of col_name that would be inserted, had no duplicate-key conflict occurred. This function is especially useful in multiple-row inserts.", "The VALUES() function is meaningful only in INSERT ... ON DUPLICATE KEY UPDATE statements and returns NULL otherwise.", "In MariaDB 10.3.3 this function was renamed to VALUE(), because it's incompatible with the standard Table Value Constructors syntax, implemented in MariaDB 10.3.3.", "The VALUES() function can still be used even from MariaDB 10.3.3, but only in INSERT ... ON DUPLICATE KEY UPDATE statements; it's a syntax error otherwise."], "Examples": [], "Category": ["Miscellaneous Functions"]}
