{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["map"], "Feature": ["map(key1, value1[, key2, value2, ...])"], "Description": ["map", "Creates a value of type Map(key, value) from key-value pairs.", "Syntax", "map(key1, value1[, key2, value2, ...])", "Arguments", "key_n \u2014 The keys of the map entries. Any type supported as key type of Map.value_n \u2014 The values of the map entries. Any type supported as value type of Map.", "Returned value", "A map containing key:value pairs. Map(key, value)."], "Examples": ["SELECT map('key1', number, 'key2', number * 2) FROM numbers(3);"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapFromArrays"], "Feature": ["mapFromArrays(keys, values)"], "Description": ["mapFromArrays", "Creates a map from an array or map of keys and an array or map of values.", "The function is a convenient alternative to syntax CAST([...], 'Map(key_type, value_type)').\nFor example, instead of writing", "CAST((['aa', 'bb'], [4, 5]), 'Map(String, UInt32)'), orCAST([('aa',4), ('bb',5)], 'Map(String, UInt32)')", "you can write mapFromArrays(['aa', 'bb'], [4, 5]).", "Syntax", "mapFromArrays(keys, values)", "Alias: MAP_FROM_ARRAYS(keys, values)", "Arguments", "keys \u2014  Array or map of keys to create the map from Array or Map. If keys is an array, we accept Array(Nullable(T)) or Array(LowCardinality(Nullable(T))) as its type as long as it doesn't contain NULL value.values  - Array or map of values to create the map from Array or Map.", "Returned value", "A map with keys and values constructed from the key array and value array/map."], "Examples": ["select mapFromArrays(['a', 'b', 'c'], [1, 2, 3])", "SELECT mapFromArrays([1, 2, 3], map('a', 1, 'b', 2, 'c', 3))", "SELECT mapFromArrays(map('a', 1, 'b', 2, 'c', 3), [1, 2, 3])"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["extractKeyValuePairs"], "Feature": ["extractKeyValuePairs(data[, key_value_delimiter[, pair_delimiter[, quoting_character]]])"], "Description": ["extractKeyValuePairs", "Converts a string of key-value pairs to a Map(String, String).\nParsing is tolerant towards noise (e.g. log files).\nKey-value pairs in the input string consist of a key, followed by a key-value delimiter, and a value.\nKey value pairs are separated by a pair delimiter.\nKeys and values can be quoted.", "Syntax", "extractKeyValuePairs(data[, key_value_delimiter[, pair_delimiter[, quoting_character]]])", "Alias:", "str_to_mapmapFromString", "Arguments", "data - String to extract key-value pairs from. String or FixedString.key_value_delimiter - Single character delimiting keys and values. Defaults to :. String or FixedString.pair_delimiters - Set of character delimiting pairs. Defaults to  , , and ;. String or FixedString.quoting_character - Single character used as quoting character. Defaults to \". String or FixedString.", "Returned values", "A of key-value pairs. Type: Map(String, String) "], "Examples": ["SELECT extractKeyValuePairs('name:neymar, age:31 team:psg,nationality:brazil') as kv", "SELECT extractKeyValuePairs('name:\\'neymar\\';\\'age\\':31;team:psg;nationality:brazil,last_key:last_value', ':', ';,', '\\'') as kv", "SELECT extractKeyValuePairs('age:a\\\\x0A\\\\n\\\\0') AS kv", "SELECT    map('John', '33', 'Paula', '31') AS m,    toString(m) as map_serialized,    extractKeyValuePairs(map_serialized, ':', ',', '\\'') AS map_restoredFORMAT Vertical;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["extractKeyValuePairsWithEscaping"], "Feature": ["extractKeyValuePairsWithEscaping"], "Description": ["extractKeyValuePairsWithEscaping", "Same as extractKeyValuePairs but supports escaping.", "Supported escape sequences: \\x, \\N, \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v and \\0.\nNon standard escape sequences are returned as it is (including the backslash) unless they are one of the following:\n\\\\, ', \", backtick, /, = or ASCII control characters (c <= 31).", "This function will satisfy the use case where pre-escaping and post-escaping are not suitable. For instance, consider the following\ninput string: a: \"aaaa\\\"bbb\". The expected output is: a: aaaa\\\"bbbb.", "Pre-escaping: Pre-escaping it will output: a: \"aaaa\"bbb\" and extractKeyValuePairs will then output: a: aaaaPost-escaping: extractKeyValuePairs will output a: aaaa\\ and post-escaping will keep it as it is.", "Leading escape sequences will be skipped in keys and will be considered invalid for values."], "Examples": ["SELECT extractKeyValuePairsWithEscaping('age:a\\\\x0A\\\\n\\\\0') AS kv"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapAdd"], "Feature": ["mapAdd(arg1, arg2 [, ...])"], "Description": ["mapAdd", "Collect all the keys and sum corresponding values.", "Syntax", "mapAdd(arg1, arg2 [, ...])", "Arguments", "Arguments are maps or tuples of two arrays, where items in the first array represent keys, and the second array contains values for the each key. All key arrays should have same type, and all value arrays should contain items which are promoted to the one type (Int64, UInt64 or Float64). The common promoted type is used as a type for the result array.", "Returned value", "Depending on the arguments returns one map or tuple, where the first array contains the sorted keys and the second array contains values."], "Examples": ["SELECT mapAdd(map(1,1), map(1,1));", "SELECT mapAdd(([toUInt8(1), 2], [1, 1]), ([toUInt8(1), 2], [1, 1])) as res, toTypeName(res) as type;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapSubtract"], "Feature": ["mapSubtract(Tuple(Array, Array), Tuple(Array, Array) [, ...])"], "Description": ["mapSubtract", "Collect all the keys and subtract corresponding values.", "Syntax", "mapSubtract(Tuple(Array, Array), Tuple(Array, Array) [, ...])", "Arguments", "Arguments are maps or tuples of two arrays, where items in the first array represent keys, and the second array contains values for the each key. All key arrays should have same type, and all value arrays should contain items which are promote to the one type (Int64, UInt64 or Float64). The common promoted type is used as a type for the result array.", "Returned value", "Depending on the arguments returns one map or tuple, where the first array contains the sorted keys and the second array contains values."], "Examples": ["SELECT mapSubtract(map(1,1), map(1,1));", "SELECT mapSubtract(([toUInt8(1), 2], [toInt32(1), 1]), ([toUInt8(1), 2], [toInt32(2), 1])) as res, toTypeName(res) as type;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapPopulateSeries"], "Feature": ["mapPopulateSeries(map[, max])mapPopulateSeries(keys, values[, max])"], "Description": ["mapPopulateSeries", "Fills missing key-value pairs in a map with integer keys.\nTo support extending the keys beyond the largest value, a maximum key can be specified.\nMore specifically, the function returns a map in which the the keys form a series from the smallest to the largest key (or max argument if it specified) with step size of 1, and corresponding values.\nIf no value is specified for a key, a default value is used as value.\nIn case keys repeat, only the first value (in order of appearance) is associated with the key.", "Syntax", "mapPopulateSeries(map[, max])mapPopulateSeries(keys, values[, max])", "For array arguments the number of elements in keys and values must be the same for each row.", "Arguments", "Arguments are Maps or two Arrays, where the first and second array contains keys and values for the each key.", "Mapped arrays:", "map \u2014 Map with integer keys. Map.", "or", "keys \u2014 Array of keys. Array(Int).values \u2014 Array of values. Array(Int).max \u2014 Maximum key value. Optional. Int8, Int16, Int32, Int64, Int128, Int256.", "Returned value", "Depending on the arguments a Map or a Tuple of two Arrays: keys in sorted order, and values the corresponding keys."], "Examples": ["SELECT mapPopulateSeries(map(1, 10, 5, 20), 6);", "SELECT mapPopulateSeries([1,2,4], [11,22,44], 5) AS res, toTypeName(res) AS type;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapContains"], "Feature": ["mapContains(map, key)"], "Description": ["mapContains", "Returns if a given key is contained in a given map.", "Syntax", "mapContains(map, key)", "Arguments", "map \u2014 Map. Map.key \u2014 Key. Type must match the key type of map.", "Returned value", "1 if map contains key, 0 if not. UInt8."], "Examples": ["CREATE TABLE tab (a Map(String, String)) ENGINE = Memory;INSERT INTO tab VALUES ({'name':'eleven','age':'11'}), ({'number':'twelve','position':'6.0'});SELECT mapContains(a, 'name') FROM tab;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapKeys"], "Feature": ["mapKeys(map)"], "Description": ["mapKeys", "Returns the keys of a given map.", "This function can be optimized by enabling setting optimize_functions_to_subcolumns.\nWith enabled setting, the function only reads the keys subcolumn instead the whole map.\nThe query SELECT mapKeys(m) FROM table is transformed to SELECT m.keys FROM table.", "Syntax", "mapKeys(map)", "Arguments", "map \u2014 Map. Map.", "Returned value", "Array containing all keys from the map. Array."], "Examples": ["CREATE TABLE tab (a Map(String, String)) ENGINE = Memory;INSERT INTO tab VALUES ({'name':'eleven','age':'11'}), ({'number':'twelve','position':'6.0'});SELECT mapKeys(a) FROM tab;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapValues"], "Feature": ["mapValues(map)"], "Description": ["mapValues", "Returns the values of a given map.", "This function can be optimized by enabling setting optimize_functions_to_subcolumns.\nWith enabled setting, the function only reads the values subcolumn instead the whole map.\nThe query SELECT mapValues(m) FROM table is transformed to SELECT m.values FROM table.", "Syntax", "mapValues(map)", "Arguments", "map \u2014 Map. Map.", "Returned value", "Array containing all the values from map. Array."], "Examples": ["CREATE TABLE tab (a Map(String, String)) ENGINE = Memory;INSERT INTO tab VALUES ({'name':'eleven','age':'11'}), ({'number':'twelve','position':'6.0'});SELECT mapValues(a) FROM tab;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapContainsKeyLike"], "Feature": ["mapContainsKeyLike(map, pattern)"], "Description": ["mapContainsKeyLike", "Syntax", "mapContainsKeyLike(map, pattern)", "Arguments", "map \u2014 Map. Map.pattern  - String pattern to match.", "Returned value", "1 if map contains key like specified pattern, 0 if not."], "Examples": ["CREATE TABLE tab (a Map(String, String)) ENGINE = Memory;INSERT INTO tab VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});SELECT mapContainsKeyLike(a, 'a%') FROM tab;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapExtractKeyLike"], "Feature": ["mapExtractKeyLike(map, pattern)"], "Description": ["mapExtractKeyLike", "Give a map with string keys and a LIKE pattern, this function returns a map with elements where the key matches the pattern.", "Syntax", "mapExtractKeyLike(map, pattern)", "Arguments", "map \u2014 Map. Map.pattern  - String pattern to match.", "Returned value", "A map containing elements the key matching the specified pattern. If no elements match the pattern, an empty map is returned."], "Examples": ["CREATE TABLE tab (a Map(String, String)) ENGINE = Memory;INSERT INTO tab VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});SELECT mapExtractKeyLike(a, 'a%') FROM tab;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapApply"], "Feature": ["mapApply(func, map)"], "Description": ["mapApply", "Applies a function to each element of a map.", "Syntax", "mapApply(func, map)", "Arguments", "func \u2014 Lambda function.map \u2014 Map.", "Returned value", "Returns a map obtained from the original map by application of func(map1[i], ..., mapN[i]) for each element."], "Examples": ["SELECT mapApply((k, v) -> (k, v * 10), _map) AS rFROM(    SELECT map('key1', number, 'key2', number * 2) AS _map    FROM numbers(3))"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapFilter"], "Feature": ["mapFilter(func, map)"], "Description": ["mapFilter", "Filters a map by applying a function to each map element.", "Syntax", "mapFilter(func, map)", "Arguments", "func  - Lambda function.map \u2014 Map.", "Returned value", "Returns a map containing only the elements in map for which func(map1[i], ..., mapN[i]) returns something other than 0."], "Examples": ["SELECT mapFilter((k, v) -> ((v % 2) = 0), _map) AS rFROM(    SELECT map('key1', number, 'key2', number * 2) AS _map    FROM numbers(3))"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapUpdate"], "Feature": ["mapUpdate(map1, map2)"], "Description": ["mapUpdate", "Syntax", "mapUpdate(map1, map2)", "Arguments", "map1 Map.map2 Map.", "Returned value", "Returns a map1 with values updated of values for the corresponding keys in map2."], "Examples": ["SELECT mapUpdate(map('key1', 0, 'key3', 0), map('key1', 10, 'key2', 10)) AS map;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapConcat"], "Feature": ["mapConcat(maps)"], "Description": ["mapConcat", "Concatenates multiple maps based on the equality of their keys.\nIf elements with the same key exist in more than one input map, all elements are added to the result map, but only the first one is accessible via operator []", "Syntax", "mapConcat(maps)", "Arguments", "maps \u2013 Arbitrarily many Maps.", "Returned value", "Returns a map with concatenated maps passed as arguments."], "Examples": ["SELECT mapConcat(map('key1', 1, 'key3', 3), map('key2', 2)) AS map;", "SELECT mapConcat(map('key1', 1, 'key2', 2), map('key1', 3)) AS map, map['key1'];"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapExists([func,], map)"], "Feature": ["mapExists([func,], map)"], "Description": ["mapExists([func,], map)", "Returns 1 if at least one key-value pair in map exists for which func(key, value) returns something other than 0. Otherwise, it returns 0.", "NotemapExists is a higher-order function.\nYou can pass a lambda function to it as the first argument."], "Examples": ["SELECT mapExists((k, v) -> (v = 1), map('k1', 1, 'k2', 2)) AS res"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapAll([func,] map)"], "Feature": ["mapAll([func,] map)"], "Description": ["mapAll([func,] map)", "Returns 1 if func(key, value) returns something other than 0 for all key-value pairs in map. Otherwise, it returns 0.", "NoteNote that the mapAll is a higher-order function.\nYou can pass a lambda function to it as the first argument."], "Examples": ["SELECT mapAll((k, v) -> (v = 1), map('k1', 1, 'k2', 2)) AS res"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapSort([func,], map)"], "Feature": ["mapSort([func,], map)"], "Description": ["mapSort([func,], map)", "Sorts the elements of a map in ascending order.\nIf the func function is specified, the sorting order is determined by the result of the func function applied to the keys and values of the map."], "Examples": ["SELECT mapSort(map('key2', 2, 'key3', 1, 'key1', 3)) AS map;", "SELECT mapSort((k, v) -> v, map('key2', 2, 'key3', 1, 'key1', 3)) AS map;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapPartialSort"], "Feature": ["mapPartialSort([func,] limit, map)"], "Description": ["mapPartialSort", "Sorts the elements of a map in ascending order with additional limit argument allowing partial sorting.\nIf the func function is specified, the sorting order is determined by the result of the func function applied to the keys and values of the map.", "Syntax", "mapPartialSort([func,] limit, map)", "Arguments", "func \u2013 Optional function to apply to the keys and values of the map. Lambda function.limit \u2013 Elements in range [1..limit] are sorted. (U)Int.map \u2013 Map to sort. Map.", "Returned value", "Partially sorted map. Map."], "Examples": ["SELECT mapPartialSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2));"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapReverseSort([func,], map)"], "Feature": ["mapReverseSort([func,], map)"], "Description": ["mapReverseSort([func,], map)", "Sorts the elements of a map in descending order.\nIf the func function is specified, the sorting order is determined by the result of the func function applied to the keys and values of the map."], "Examples": ["SELECT mapReverseSort(map('key2', 2, 'key3', 1, 'key1', 3)) AS map;", "SELECT mapReverseSort((k, v) -> v, map('key2', 2, 'key3', 1, 'key1', 3)) AS map;"], "Category": ["Maps Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions"], "Title": ["mapPartialReverseSort"], "Feature": ["mapPartialReverseSort([func,] limit, map)"], "Description": ["mapPartialReverseSort", "Sorts the elements of a map in descending order with additional limit argument allowing partial sorting.\nIf the func function is specified, the sorting order is determined by the result of the func function applied to the keys and values of the map.", "Syntax", "mapPartialReverseSort([func,] limit, map)", "Arguments", "func \u2013 Optional function to apply to the keys and values of the map. Lambda function.limit \u2013 Elements in range [1..limit] are sorted. (U)Int.map \u2013 Map to sort. Map.", "Returned value", "Partially sorted map. Map."], "Examples": ["SELECT mapPartialReverseSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2));"], "Category": ["Maps Functions"]}
