{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["char"], "Feature": ["char(number_1, [number_2, ..., number_n]);"], "Description": ["char", "Returns the string with the length as the number of passed arguments and each byte has the value of corresponding argument. Accepts multiple arguments of numeric types. If the value of argument is out of range of UInt8 data type, it is converted to UInt8 with possible rounding and overflow.", "Syntax", "char(number_1, [number_2, ..., number_n]);", "Arguments", "number_1, number_2, ..., number_n \u2014 Numerical arguments interpreted as integers. Types: Int, Float.", "Returned value", "a string of given bytes. String."], "Examples": ["SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;", "SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;", "SELECT char(0xE4, 0xBD, 0xA0, 0xE5, 0xA5, 0xBD) AS hello;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["hex"], "Feature": ["hex(arg)"], "Description": ["hex", "Returns a string containing the argument\u2019s hexadecimal representation.", "Alias: HEX.", "Syntax", "hex(arg)", "The function is using uppercase letters A-F and not using any prefixes (like 0x) or suffixes (like h).", "For integer arguments, it prints hex digits (\u201cnibbles\u201d) from the most significant to least significant (big-endian or \u201chuman-readable\u201d order). It starts with the most significant non-zero byte (leading zero bytes are omitted) but always prints both digits of every byte even if the leading digit is zero.", "Values of type Date and DateTime are formatted as corresponding integers (the number of days since Epoch for Date and the value of Unix Timestamp for DateTime).", "For String and FixedString, all bytes are simply encoded as two hexadecimal numbers. Zero bytes are not omitted.", "Values of Float and Decimal types are encoded as their representation in memory. As we support little-endian architecture, they are encoded in little-endian. Zero leading/trailing bytes are not omitted.", "Values of UUID type are encoded as big-endian order string.", "Arguments", "arg \u2014 A value to convert to hexadecimal. Types: String, UInt, Float, Decimal, Date or DateTime.", "Returned value", "A string with the hexadecimal representation of the argument. String."], "Examples": ["SELECT hex(1);", "SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2);", "SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2);", "SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) as uuid_hex"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["unhex"], "Feature": ["unhex(arg)"], "Description": ["unhex", "Performs the opposite operation of hex. It interprets each pair of hexadecimal digits (in the argument) as a number and converts it to the byte represented by the number. The return value is a binary string (BLOB).", "If you want to convert the result to a number, you can use the reverse and reinterpretAs<Type> functions.", "NoteIf unhex is invoked from within the clickhouse-client, binary strings display using UTF-8.", "Alias: UNHEX.", "Syntax", "unhex(arg)", "Arguments", "arg \u2014 A string containing any number of hexadecimal digits. String, FixedString.", "Supports both uppercase and lowercase letters A-F. The number of hexadecimal digits does not have to be even. If it is odd, the last digit is interpreted as the least significant half of the 00-0F byte. If the argument string contains anything other than hexadecimal digits, some implementation-defined result is returned (an exception isn\u2019t thrown). For a numeric argument the inverse of hex(N) is not performed by unhex().", "Returned value", "A binary string (BLOB). String."], "Examples": ["SELECT unhex('303132'), UNHEX('4D7953514C');", "SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["bin"], "Feature": ["bin(arg)"], "Description": ["bin", "Returns a string containing the argument\u2019s binary representation.", "Syntax", "bin(arg)", "Alias: BIN.", "For integer arguments, it prints bin digits from the most significant to least significant (big-endian or \u201chuman-readable\u201d order). It starts with the most significant non-zero byte (leading zero bytes are omitted) but always prints eight digits of every byte if the leading digit is zero.", "Values of type Date and DateTime are formatted as corresponding integers (the number of days since Epoch for Date and the value of Unix Timestamp for DateTime).", "For String and FixedString, all bytes are simply encoded as eight binary numbers. Zero bytes are not omitted.", "Values of Float and Decimal types are encoded as their representation in memory. As we support little-endian architecture, they are encoded in little-endian. Zero leading/trailing bytes are not omitted.", "Values of UUID type are encoded as big-endian order string.", "Arguments", "arg \u2014 A value to convert to binary. String, FixedString, UInt, Float, Decimal, Date, or DateTime.", "Returned value", "A string with the binary representation of the argument. String."], "Examples": ["SELECT bin(14);", "SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2);", "SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2);", "SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) as bin_uuid"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["unbin"], "Feature": ["unbin(arg)"], "Description": ["unbin", "Interprets each pair of binary digits (in the argument) as a number and converts it to the byte represented by the number. The functions performs the opposite operation to bin.", "Syntax", "unbin(arg)", "Alias: UNBIN.", "For a numeric argument unbin() does not return the inverse of bin(). If you want to convert the result to a number, you can use the reverse and reinterpretAs<Type> functions.", "NoteIf unbin is invoked from within the clickhouse-client, binary strings are displayed using UTF-8.", "Supports binary digits 0 and 1. The number of binary digits does not have to be multiples of eight. If the argument string contains anything other than binary digits, some implementation-defined result is returned (an exception isn\u2019t thrown).", "Arguments", "arg \u2014 A string containing any number of binary digits. String.", "Returned value", "A binary string (BLOB). String."], "Examples": ["SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100');", "SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["bitmaskToList(num)"], "Feature": ["bitmaskToList(num)"], "Description": ["bitmaskToList(num)", "Accepts an integer. Returns a string containing the list of powers of two that total the source number when summed. They are comma-separated without spaces in text format, in ascending order."], "Examples": [], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["bitmaskToArray(num)"], "Feature": ["bitmaskToArray(num)"], "Description": ["bitmaskToArray(num)", "Accepts an integer. Returns an array of UInt64 numbers containing the list of powers of two that total the source number when summed. Numbers in the array are in ascending order."], "Examples": [], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["bitPositionsToArray(num)"], "Feature": ["bitPositionsToArray(arg)"], "Description": ["bitPositionsToArray(num)", "Accepts an integer and converts it to an unsigned integer. Returns an array of UInt64 numbers containing the list of positions of bits of arg that equal 1, in ascending order.", "Syntax", "bitPositionsToArray(arg)", "Arguments", "arg \u2014 Integer value. Int/UInt.", "Returned value", "An array containing a list of positions of bits that equal 1, in ascending order. Array(UInt64)."], "Examples": ["SELECT bitPositionsToArray(toInt8(1)) AS bit_positions;", "SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["mortonEncode"], "Feature": ["mortonEncode(args)"], "Description": ["mortonEncode", "Calculates the Morton encoding (ZCurve) for a list of unsigned integers.", "The function has two modes of operation:", "SimpleExpanded", "Simple mode", "Accepts up to 8 unsigned integers as arguments and produces a UInt64 code.", "Syntax", "mortonEncode(args)", "Parameters", "args: up to 8 unsigned integers or columns of the aforementioned type.", "Returned value", "A UInt64 code. UInt64"], "Examples": ["SELECT mortonEncode(1, 2, 3);", "mortonEncode(range_mask, args)", "SELECT mortonEncode((1,2), 1024, 16);", "SELECT mortonEncode(1);", "SELECT mortonEncode(tuple(2), 128);", "create table morton_numbers(    n1 UInt32,    n2 UInt32,    n3 UInt16,    n4 UInt16,    n5 UInt8,    n6 UInt8,    n7 UInt8,    n8 UInt8)Engine=MergeTree()ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';insert into morton_numbers (*) values(1,2,3,4,5,6,7,8);", "SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["mortonDecode"], "Feature": ["mortonDecode(tuple_size, code)"], "Description": ["mortonDecode", "Decodes a Morton encoding (ZCurve) into the corresponding unsigned integer tuple.", "As with the mortonEncode function, this function has two modes of operation:", "SimpleExpanded", "Simple mode", "Accepts a resulting tuple size as the first argument and the code as the second argument.", "Syntax", "mortonDecode(tuple_size, code)", "Parameters", "tuple_size: integer value no more than 8.code: UInt64 code.", "Returned value", "tuple of the specified size. UInt64"], "Examples": ["SELECT mortonDecode(3, 53);", "SELECT mortonDecode(1, 1);", "SELECT mortonDecode(tuple(2), 32768);", "create table morton_numbers(    n1 UInt32,    n2 UInt32,    n3 UInt16,    n4 UInt16,    n5 UInt8,    n6 UInt8,    n7 UInt8,    n8 UInt8)Engine=MergeTree()ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';insert into morton_numbers (*) values(1,2,3,4,5,6,7,8);", "select untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) from morton_numbers;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["hilbertEncode"], "Feature": ["hilbertEncode(args)"], "Description": ["hilbertEncode", "Calculates code for Hilbert Curve for a list of unsigned integers.", "The function has two modes of operation:", "SimpleExpanded", "Simple mode", "Simple: accepts up to 2 unsigned integers as arguments and produces a UInt64 code.", "Syntax", "hilbertEncode(args)", "Parameters", "args: up to 2 unsigned integers or columns of the aforementioned type.", "Returned value", "A UInt64 code", "Type: UInt64"], "Examples": ["SELECT hilbertEncode(3, 4);", "hilbertEncode(range_mask, args)", "SELECT hilbertEncode((10,6), 1024, 16);", "SELECT hilbertEncode(1);", "SELECT hilbertEncode(tuple(2), 128);", "create table hilbert_numbers(    n1 UInt32,    n2 UInt32)Engine=MergeTree()ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';insert into hilbert_numbers (*) values(1,2);", "SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;"], "Category": ["Encoding Functions"]}
{"HTML": ["https://clickhouse.com/docs/en/sql-reference/functions/encoding-functions"], "Title": ["hilbertDecode"], "Feature": ["hilbertDecode(tuple_size, code)"], "Description": ["hilbertDecode", "Decodes a Hilbert curve index back into a tuple of unsigned integers, representing coordinates in multi-dimensional space.", "As with the hilbertEncode function, this function has two modes of operation:", "SimpleExpanded", "Simple mode", "Accepts up to 2 unsigned integers as arguments and produces a UInt64 code.", "Syntax", "hilbertDecode(tuple_size, code)", "Parameters", "tuple_size: integer value no more than 2.code: UInt64 code.", "Returned value", "tuple of the specified size.", "Type: UInt64"], "Examples": ["SELECT hilbertDecode(2, 31);", "SELECT hilbertDecode(1, 1);", "SELECT hilbertDecode(tuple(2), 32768);", "create table hilbert_numbers(    n1 UInt32,    n2 UInt32)Engine=MergeTree()ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';insert into hilbert_numbers (*) values(1,2);", "select untuple(hilbertDecode(2, hilbertEncode(n1, n2))) from hilbert_numbers;"], "Category": ["Encoding Functions"]}
