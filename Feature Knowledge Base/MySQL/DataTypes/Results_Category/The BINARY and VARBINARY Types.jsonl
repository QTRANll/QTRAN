{"HTML": ["https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"], "Title": ["13.3.3 The BINARY and VARBINARY Types"], "Feature": ["13.3.3 The BINARY and VARBINARY Types"], "Description": ["\n\n\n\n13.3.3\u00a0The BINARY and VARBINARY Types\n\n\n\n\n        The BINARY and VARBINARY\n        types are similar to CHAR and\n        VARCHAR, except that they store\n        binary strings rather than nonbinary strings. That is, they\n        store byte strings rather than character strings. This means\n        they have the binary character set and\n        collation, and comparison and sorting are based on the numeric\n        values of the bytes in the values.\n      \n        The permissible maximum length is the same for\n        BINARY and VARBINARY as it\n        is for CHAR and\n        VARCHAR, except that the length\n        for BINARY and VARBINARY\n        is measured in bytes rather than characters.\n      \n        The BINARY and VARBINARY\n        data types are distinct from the CHAR BINARY\n        and VARCHAR BINARY data types. For the latter\n        types, the BINARY attribute does not cause\n        the column to be treated as a binary string column. Instead, it\n        causes the binary (_bin) collation for the\n        column character set (or the table default character set if no\n        column character set is specified) to be used, and the column\n        itself stores nonbinary character strings rather than binary\n        byte strings. For example, if the default character set is\n        utf8mb4, CHAR(5) BINARY is\n        treated as CHAR(5) CHARACTER SET utf8mb4 COLLATE\n        utf8mb4_bin. This differs from\n        BINARY(5), which stores 5-byte binary strings\n        that have the binary character set and\n        collation. For information about the differences between the\n        binary collation of the\n        binary character set and the\n        _bin collations of nonbinary character sets,\n        see Section\u00a012.8.5, \u201cThe binary Collation Compared to _bin Collations\u201d.\n      \n        If strict SQL mode is not enabled and you assign a value to a\n        BINARY or VARBINARY column\n        that exceeds the column's maximum length, the value is truncated\n        to fit and a warning is generated. For cases of truncation, to\n        cause an error to occur (rather than a warning) and suppress\n        insertion of the value, use strict SQL mode. See\n        Section\u00a07.1.11, \u201cServer SQL Modes\u201d.\n      \n        When BINARY values are stored, they are\n        right-padded with the pad value to the specified length. The pad\n        value is 0x00 (the zero byte). Values are\n        right-padded with 0x00 for inserts, and no\n        trailing bytes are removed for retrievals. All bytes are\n        significant in comparisons, including ORDER\n        BY and DISTINCT operations.\n        0x00 and space differ in comparisons, with\n        0x00 sorting before space.\n      \n        Example: For a BINARY(3) column,\n        'a\u00a0' becomes\n        'a\u00a0\\0' when inserted.\n        'a\\0' becomes 'a\\0\\0' when\n        inserted. Both inserted values remain unchanged for retrievals.\n      \n        For VARBINARY, there is no padding for\n        inserts and no bytes are stripped for retrievals. All bytes are\n        significant in comparisons, including ORDER\n        BY and DISTINCT operations.\n        0x00 and space differ in comparisons, with\n        0x00 sorting before space.\n      \n        For those cases where trailing pad bytes are stripped or\n        comparisons ignore them, if a column has an index that requires\n        unique values, inserting values into the column that differ only\n        in number of trailing pad bytes results in a duplicate-key\n        error. For example, if a table contains 'a',\n        an attempt to store 'a\\0' causes a\n        duplicate-key error.\n      \n        You should consider the preceding padding and stripping\n        characteristics carefully if you plan to use the\n        BINARY data type for storing binary data and\n        you require that the value retrieved be exactly the same as the\n        value stored. The following example illustrates how\n        0x00-padding of BINARY\n        values affects column value comparisons:\n      Press CTRL+C to copy mysql> CREATE TABLE t (c BINARY(3));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> INSERT INTO t SET c = 'a';\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> SELECT HEX(c), c = 'a', c = 'a\\0\\0' from t;\n+--------+---------+-------------+\n| HEX(c) | c = 'a' | c = 'a\\0\\0' |\n+--------+---------+-------------+\n| 610000 |       0 |           1 |\n+--------+---------+-------------+\n1 row in set (0.09 sec)\n        If the value retrieved must be the same as the value specified\n        for storage with no padding, it might be preferable to use\n        VARBINARY or one of the\n        BLOB data types instead.\n\n\n\nNote\n\n\n          Within the mysql client, binary strings\n          display using hexadecimal notation, depending on the value of\n          the --binary-as-hex. For more\n          information about that option, see Section\u00a06.5.1, \u201cmysql \u2014 The MySQL Command-Line Client\u201d.\n\n\n"], "Examples": ["mysql> CREATE TABLE t (c BINARY(3));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> INSERT INTO t SET c = 'a';\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> SELECT HEX(c), c = 'a', c = 'a\\0\\0' from t;\n+--------+---------+-------------+\n| HEX(c) | c = 'a' | c = 'a\\0\\0' |\n+--------+---------+-------------+\n| 610000 |       0 |           1 |\n+--------+---------+-------------+\n1 row in set (0.09 sec)"], "Category": ["The BINARY and VARBINARY Types"]}
