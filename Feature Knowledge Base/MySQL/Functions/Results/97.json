{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html"
    ],
    "Title": [
        "14.1 Built-In Function and Operator Reference"
    ],
    "Name": "GET_LOCK()",
    "Description": [
        "\nGET_LOCK(str,timeout)\n",
        "\n          Tries to obtain a lock with a name given by the string\n          str, using a timeout of\n          timeout seconds. A negative\n          timeout value means infinite\n          timeout. The lock is exclusive. While held by one session,\n          other sessions cannot obtain a lock of the same name.\n        ",
        "\n          Returns 1 if the lock was obtained\n          successfully, 0 if the attempt timed out\n          (for example, because another client has previously locked the\n          name), or NULL if an error occurred (such\n          as running out of memory or the thread was killed with\n          mysqladmin kill).\n        ",
        "\n          A lock obtained with GET_LOCK()\n          is released explicitly by executing\n          RELEASE_LOCK() or implicitly\n          when your session terminates (either normally or abnormally).\n          Locks obtained with GET_LOCK()\n          are not released when transactions commit or roll back.\n        ",
        "\nGET_LOCK() is implemented using\n          the metadata locking (MDL) subsystem. Multiple simultaneous\n          locks can be acquired and\n          GET_LOCK() does not release any\n          existing locks. For example, suppose that you execute these\n          statements:\n        ",
        "Press CTRL+C to copy SELECT GET_LOCK('lock1',10);\nSELECT GET_LOCK('lock2',10);\nSELECT RELEASE_LOCK('lock2');\nSELECT RELEASE_LOCK('lock1');",
        "\n          The second GET_LOCK() acquires\n          a second lock and both\n          RELEASE_LOCK() calls return 1\n          (success).\n        ",
        "\n          It is even possible for a given session to acquire multiple\n          locks for the same name. Other sessions cannot acquire a lock\n          with that name until the acquiring session releases all its\n          locks for the name.\n        ",
        "\n          Uniquely named locks acquired with\n          GET_LOCK() appear in the\n          Performance Schema metadata_locks\n          table. The OBJECT_TYPE column says\n          USER LEVEL LOCK and the\n          OBJECT_NAME column indicates the lock name.\n          In the case that multiple locks are acquired for the\n          same name, only the first lock for the\n          name registers a row in the\n          metadata_locks table. Subsequent\n          locks for the name increment a counter in the lock but do not\n          acquire additional metadata locks. The\n          metadata_locks row for the lock\n          is deleted when the last lock instance on the name is\n          released.\n        ",
        "\n          The capability of acquiring multiple locks means there is the\n          possibility of deadlock among clients. When this happens, the\n          server chooses a caller and terminates its lock-acquisition\n          request with an\n          ER_USER_LOCK_DEADLOCK error.\n          This error does not cause transactions to roll back.\n        ",
        "\n          MySQL enforces a maximum length on lock names of 64\n          characters.\n        ",
        "\nGET_LOCK() can be used to\n          implement application locks or to simulate record locks. Names\n          are locked on a server-wide basis. If a name has been locked\n          within one session, GET_LOCK()\n          blocks any request by another session for a lock with the same\n          name. This enables clients that agree on a given lock name to\n          use the name to perform cooperative advisory locking. But be\n          aware that it also enables a client that is not among the set\n          of cooperating clients to lock a name, either inadvertently or\n          deliberately, and thus prevent any of the cooperating clients\n          from locking that name. One way to reduce the likelihood of\n          this is to use lock names that are database-specific or\n          application-specific. For example, use lock names of the form\n          db_name.str or\n          app_name.str.\n        ",
        "\n          If multiple clients are waiting for a lock, the order in which\n          they acquire it is undefined. Applications should not assume\n          that clients acquire the lock in the same order that they\n          issued the lock requests.\n        ",
        "\nGET_LOCK() is unsafe for\n          statement-based replication. A warning is logged if you use\n          this function when\n          binlog_format is set to\n          STATEMENT.\n        ",
        "\n          Since GET_LOCK() establishes a lock only on\n          a single mysqld, it is not suitable for use\n          with NDB Cluster, which has no way of enforcing an SQL lock\n          across multiple MySQL servers. See\n          Section\u00a025.2.7.10, \u201cLimitations Relating to Multiple NDB Cluster Nodes\u201d,\n          for more information.\n",
        "\n\nCaution\n\n\n            With the capability of acquiring multiple named locks, it is\n            possible for a single statement to acquire a large number of\n            locks. For example:\n          Press CTRL+C to copy INSERT INTO ... SELECT GET_LOCK(t1.col_name) FROM t1;\n            These types of statements may have certain adverse effects.\n            For example, if the statement fails part way through and\n            rolls back, locks acquired up to the point of failure still\n            exist. If the intent is for there to be a correspondence\n            between rows inserted and locks acquired, that intent is not\n            satisfied. Also, if it is important that locks are granted\n            in a certain order, be aware that result set order may\n            differ depending on which execution plan the optimizer\n            chooses. For these reasons, it may be best to limit\n            applications to a single lock-acquisition call per\n            statement.\n\n",
        "\n          A different locking interface is available as either a plugin\n          service or a set of loadable functions. This interface\n          provides lock namespaces and distinct read and write locks,\n          unlike the interface provided by\n          GET_LOCK() and related\n          functions. For details, see Section\u00a07.6.9.1, \u201cThe Locking Service\u201d.\n        "
    ],
    "Reference HTML": "https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html#function_get-lock",
    "Feature": [
        "GET_LOCK(str,timeout)"
    ],
    "Examples": [
        "SELECT GET_LOCK('lock1',10);\nSELECT GET_LOCK('lock2',10);\nSELECT RELEASE_LOCK('lock2');\nSELECT RELEASE_LOCK('lock1');",
        "INSERT INTO ... SELECT GET_LOCK(t1.col_name) FROM t1;"
    ],
    "Category": [
        "Built-In Functions and Operators",
        "Locking Functions"
    ]
}