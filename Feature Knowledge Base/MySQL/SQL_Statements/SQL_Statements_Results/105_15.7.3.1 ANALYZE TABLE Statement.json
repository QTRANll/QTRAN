{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/analyze-table.html"
    ],
    "Title": [
        "15.7.3.1 ANALYZE TABLE Statement"
    ],
    "Feature": [
        "ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]\n    TABLE tbl_name [, tbl_name] ...\n\nANALYZE [NO_WRITE_TO_BINLOG | LOCAL]\n    TABLE tbl_name\n    UPDATE HISTOGRAM ON col_name [, col_name] ...\n        [WITH N BUCKETS]\n    [{MANUAL | AUTO} UPDATE]\n\nANALYZE [NO_WRITE_TO_BINLOG | LOCAL] \n    TABLE tbl_name\n    UPDATE HISTOGRAM ON col_name [USING DATA 'json_data']\n\nANALYZE [NO_WRITE_TO_BINLOG | LOCAL]\n    TABLE tbl_name\n    DROP HISTOGRAM ON col_name [, col_name] ...",
        "mysql> TABLE information_schema.column_statistics\\G\n*************************** 1. row ***************************\nSCHEMA_NAME: h\n TABLE_NAME: t\nCOLUMN_NAME: c1\n  HISTOGRAM: {\"buckets\": [], \"data-type\": \"int\", \"auto-update\": false,\n\"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-03-26\n16:54:43.674995\", \"sampling-rate\": 1.0, \"histogram-type\": \"singleton\",\n\"number-of-buckets-specified\": 100}   \n1 row in set (0.00 sec)"
    ],
    "Description": [
        "\nANALYZE TABLE generates table\n        statistics:\n",
        "\n\nANALYZE TABLE without any\n            HISTOGRAM clause performs a key\n            distribution analysis and stores the distribution for the\n            named table or tables. For MyISAM tables,\n            ANALYZE TABLE for key\n            distribution analysis is equivalent to using\n            myisamchk --analyze.\n          \nANALYZE TABLE with the\n            UPDATE HISTOGRAM clause generates\n            histogram statistics for the named table columns and stores\n            them in the data dictionary. Only one table name is\n            permitted with this syntax. MySQL also supports setting the\n            histogram of a single column to a user-defined JSON value.\n          \nANALYZE TABLE with the\n            DROP HISTOGRAM clause removes histogram\n            statistics for the named table columns from the data\n            dictionary. Only one table name is permitted for this\n            syntax.\n\n",
        "\n        This statement requires SELECT\n        and INSERT privileges for the\n        table.\n      ",
        "\nANALYZE TABLE works with\n        InnoDB, NDB, and\n        MyISAM tables. It does not work with views.\n      ",
        "\n        If the innodb_read_only system\n        variable is enabled, ANALYZE\n        TABLE may fail because it cannot update statistics\n        tables in the data dictionary, which use\n        InnoDB. For ANALYZE\n        TABLE operations that update the key distribution,\n        failure may occur even if the operation updates the table itself\n        (for example, if it is a MyISAM table). To\n        obtain the updated distribution statistics, set\n        information_schema_stats_expiry=0.\n      ",
        "\nANALYZE TABLE is supported for\n        partitioned tables, and you can use ALTER TABLE ...\n        ANALYZE PARTITION to analyze one or more partitions;\n        for more information, see Section\u00a015.1.9, \u201cALTER TABLE Statement\u201d, and\n        Section\u00a026.3.4, \u201cMaintenance of Partitions\u201d.\n      ",
        "\n        During the analysis, the table is locked with a read lock for\n        InnoDB and MyISAM.\n      ",
        "\n        By default, the server writes ANALYZE\n        TABLE statements to the binary log so that they\n        replicate to replicas. To suppress logging, specify the optional\n        NO_WRITE_TO_BINLOG keyword or its alias\n        LOCAL.\n",
        "\nANALYZE TABLE OutputKey Distribution AnalysisHistogram Statistics AnalysisOther Considerations\n",
        "\n\n\n\nANALYZE TABLE Output\n\n\n\n\nANALYZE TABLE returns a result\n          set with the columns shown in the following table.\n\n\n\nColumn\nValue\n\nTable\nThe table name\n\nOp\nanalyze or histogram\n\nMsg_type\nstatus, error,\n                info, note, or\n                warning\n\nMsg_text\nAn informational message\n\n\n",
        "\n\n\n\nKey Distribution Analysis\n\n\n\n\nANALYZE TABLE without either\n          HISTOGRAM clause performs a key\n          distribution analysis and stores the distribution for the\n          table or tables. Any existing histogram statistics remain\n          unaffected.\n        \n          If the table has not changed since the last key distribution\n          analysis, the table is not analyzed again.\n        \n          MySQL uses the stored key distribution to decide the order in\n          which tables should be joined for joins on something other\n          than a constant. In addition, key distributions can be used\n          when deciding which indexes to use for a specific table within\n          a query.\n        \n          To check the stored key distribution cardinality, use the\n          SHOW INDEX statement or the\n          INFORMATION_SCHEMA\nSTATISTICS table. See\n          Section\u00a015.7.7.23, \u201cSHOW INDEX Statement\u201d, and\n          Section\u00a028.3.34, \u201cThe INFORMATION_SCHEMA STATISTICS Table\u201d.\n        \n          For InnoDB tables,\n          ANALYZE TABLE determines index\n          cardinality by performing random dives on each of the index\n          trees and updating index cardinality estimates accordingly.\n          Because these are only estimates, repeated runs of\n          ANALYZE TABLE could produce\n          different numbers. This makes ANALYZE\n          TABLE fast on InnoDB tables but\n          not 100% accurate because it does not take all rows into\n          account.\n        \n          You can make the\n          statistics collected by\n          ANALYZE TABLE more precise and\n          more stable by enabling\n          innodb_stats_persistent, as\n          explained in Section\u00a017.8.10.1, \u201cConfiguring Persistent Optimizer Statistics Parameters\u201d. When\n          innodb_stats_persistent is\n          enabled, it is important to run ANALYZE\n          TABLE after major changes to index column data, as\n          statistics are not recalculated periodically (such as after a\n          server restart).\n        \n          If innodb_stats_persistent is\n          enabled, you can change the number of random dives by\n          modifying the\n          innodb_stats_persistent_sample_pages\n          system variable. If\n          innodb_stats_persistent is\n          disabled, modify\n          innodb_stats_transient_sample_pages\n          instead.\n        \n          For more information about key distribution analysis in\n          InnoDB, see\n          Section\u00a017.8.10.1, \u201cConfiguring Persistent Optimizer Statistics Parameters\u201d, and\n          Section\u00a017.8.10.3, \u201cEstimating ANALYZE TABLE Complexity for InnoDB Tables\u201d.\n        \n          MySQL uses index cardinality estimates in join optimization.\n          If a join is not optimized in the right way, try running\n          ANALYZE TABLE. In the few cases\n          that ANALYZE TABLE does not\n          produce values good enough for your particular tables, you can\n          use FORCE INDEX with your queries to force\n          the use of a particular index, or set the\n          max_seeks_for_key system\n          variable to ensure that MySQL prefers index lookups over table\n          scans. See Section\u00a0B.3.5, \u201cOptimizer-Related Issues\u201d.\n\n",
        "\n\n\n\nHistogram Statistics Analysis\n\n\n\n\nANALYZE TABLE with the\n          HISTOGRAM clause enables management of\n          histogram statistics for table column values. For information\n          about histogram statistics, see\n          Section\u00a010.9.6, \u201cOptimizer Statistics\u201d.\n        \n          These histogram operations are available:\n\n\n\nANALYZE TABLE with an\n              UPDATE HISTOGRAM clause generates\n              histogram statistics for the named table columns and\n              stores them in the data dictionary. Only one table name is\n              permitted for this syntax.\n            \n              The optional WITH N\n              BUCKETS clause specifies the number of buckets\n              for the histogram. The value of\n              N must be an integer in the\n              range from 1 to 1024. If this clause is omitted, the\n              number of buckets is 100.\n            \n              The optional AUTO UPDATE clause enables\n              automatic updates of histograms on the table. When\n              enabled, an ANALYZE TABLE statement on\n              this table automatically updates the histogram, using the\n              same number of buckets as last specified by WITH\n              ... BUCKETS if this was previously set for this\n              table. In addition, when recalculating persistent\n              statistics for the table (see\n              Section\u00a017.8.10.1, \u201cConfiguring Persistent Optimizer Statistics Parameters\u201d), the\n              InnoDB background statistics\n              thread also updates the histogram. MANUAL\n              UPDATE disables automatic updates, and is the\n              default setting if not specified.\n            \nANALYZE TABLE with a\n              DROP HISTOGRAM clause removes histogram\n              statistics for the named table columns from the data\n              dictionary. Only one table name is permitted for this\n              syntax.\n\n\n\n          Stored histogram management statements affect only the named\n          columns. Consider these statements:\n        Press CTRL+C to copy ANALYZE TABLE t UPDATE HISTOGRAM ON c1, c2, c3 WITH 10 BUCKETS;\nANALYZE TABLE t UPDATE HISTOGRAM ON c1, c3 WITH 10 BUCKETS;\nANALYZE TABLE t DROP HISTOGRAM ON c2;\n          The first statement updates the histograms for columns\n          c1, c2, and\n          c3, replacing any existing histograms for\n          those columns. The second statement updates the histograms for\n          c1 and c3, leaving the\n          c2 histogram unaffected. The third\n          statement removes the histogram for c2,\n          leaving those for c1 and\n          c3 unaffected.\n        \n          When sampling user data as part of building a histogram, not\n          all values are read; this may lead to missing some values\n          considered important. In such cases, it might be useful to\n          modify the histogram, or to set your own histogram explicitly\n          based on your own criteria, such as the complete data set.\n          ANALYZE TABLE tbl_name\n          UPDATE HISTOGRAM ON col_name USING\n          DATA 'json_data' updates\n          a column of the histogram table with data supplied in the same\n          JSON format used to display HISTOGRAM\n          column values from the Information Schema\n          COLUMN_STATISTICS table. Only one\n          column can be modified when updating the histogram with JSON\n          data.\n        \n          We can illustrate the use of USING DATA by\n          first generating a histogram on column c1\n          of table t, like this:\n        Press CTRL+C to copy mysql> ANALYZE TABLE t UPDATE HISTOGRAM ON c1;\n+-------+-----------+----------+-----------------------------------------------+\n| Table | Op        | Msg_type | Msg_text                                      |\n+-------+-----------+----------+-----------------------------------------------+\n| h.t   | histogram | status   | Histogram statistics created for column 'c1'. |\n+-------+-----------+----------+-----------------------------------------------+\n1 row in set (0.00 sec)\n          We can see the histogram generated in the\n          COLUMN_STATISTICS table:\n        Press CTRL+C to copy mysql> TABLE information_schema.column_statistics\\G\n*************************** 1. row ***************************\nSCHEMA_NAME: h\n TABLE_NAME: t\nCOLUMN_NAME: c1\n  HISTOGRAM: {\"buckets\": [], \"data-type\": \"int\", \"auto-update\": false,\n\"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-03-26\n16:54:43.674995\", \"sampling-rate\": 1.0, \"histogram-type\": \"singleton\",\n\"number-of-buckets-specified\": 100}   \n1 row in set (0.00 sec)\n          Now we drop the histogram, and when we check\n          COLUMN_STATISTICS, it is empty:\n        Press CTRL+C to copy mysql> ANALYZE TABLE t DROP HISTOGRAM ON c1;\n+-------+-----------+----------+-----------------------------------------------+\n| Table | Op        | Msg_type | Msg_text                                      |\n+-------+-----------+----------+-----------------------------------------------+\n| h.t   | histogram | status   | Histogram statistics removed for column 'c1'. |\n+-------+-----------+----------+-----------------------------------------------+\n1 row in set (0.01 sec)\n\nmysql> TABLE information_schema.column_statistics\\G\nEmpty set (0.00 sec)\n          We can restore the dropped histogram by inserting its JSON\n          representation obtained previously from the\n          HISTOGRAM column of the\n          COLUMN_STATISTICS table, and when we query\n          that table again, we can see that the histogram has been\n          restored to its previous state:\n        Press CTRL+C to copy mysql> ANALYZE TABLE t UPDATE HISTOGRAM ON c1 \n    ->     USING DATA '{\"buckets\": [], \"data-type\": \"int\", \"auto-update\": false,\n    ->               \"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-03-26\n    ->               16:54:43.674995\", \"sampling-rate\": 1.0, \"histogram-type\": \"singleton\",\n    ->               \"number-of-buckets-specified\": 100}';   \n+-------+-----------+----------+-----------------------------------------------+\n| Table | Op        | Msg_type | Msg_text                                      |\n+-------+-----------+----------+-----------------------------------------------+\n| h.t   | histogram | status   | Histogram statistics created for column 'c1'. |\n+-------+-----------+----------+-----------------------------------------------+\n\nmysql> TABLE information_schema.column_statistics\\G\n*************************** 1. row ***************************\nSCHEMA_NAME: h\n TABLE_NAME: t\nCOLUMN_NAME: c1\n  HISTOGRAM: {\"buckets\": [], \"data-type\": \"int\", \"auto-update\": false,\n\"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-03-26\n16:54:43.674995\", \"sampling-rate\": 1.0, \"histogram-type\": \"singleton\",\n\"number-of-buckets-specified\": 100}\n          Histogram generation is not supported for encrypted tables (to\n          avoid exposing data in the statistics) or\n          TEMPORARY tables.\n        \n          Histogram generation applies to columns of all data types\n          except geometry types (spatial data) and\n          JSON.\n        \n          Histograms can be generated for stored and virtual generated\n          columns.\n        \n          Histograms cannot be generated for columns that are covered by\n          single-column unique indexes.\n        \n          Histogram management statements attempt to perform as much of\n          the requested operation as possible, and report diagnostic\n          messages for the remainder. For example, if an UPDATE\n          HISTOGRAM statement names multiple columns, but some\n          of them do not exist or have an unsupported data type,\n          histograms are generated for the other columns, and messages\n          are produced for the invalid columns.\n        \n          Histograms are affected by these DDL statements:\n\n\n\nDROP TABLE removes\n              histograms for columns in the dropped table.\n            \nDROP DATABASE removes\n              histograms for any table in the dropped database because\n              the statement drops all tables in the database.\n            \nRENAME TABLE does not\n              remove histograms. Instead, it renames histograms for the\n              renamed table to be associated with the new table name.\n            \nALTER TABLE statements that\n              remove or modify a column remove histograms for that\n              column.\n            \nALTER TABLE\n              ... CONVERT TO CHARACTER SET removes histograms\n              for character columns because they are affected by the\n              change of character set. Histograms for noncharacter\n              columns remain unaffected.\n\n\n\n          The\n          histogram_generation_max_mem_size\n          system variable controls the maximum amount of memory\n          available for histogram generation. The global and session\n          values may be set at runtime.\n        \n          Changing the global\n          histogram_generation_max_mem_size\n          value requires privileges sufficient to set global system\n          variables. Changing the session\n          histogram_generation_max_mem_size\n          value requires privileges sufficient to set restricted session\n          system variables. See\n          Section\u00a07.1.9.1, \u201cSystem Variable Privileges\u201d.\n        \n          If the estimated amount of data to be read into memory for\n          histogram generation exceeds the limit defined by\n          histogram_generation_max_mem_size,\n          MySQL samples the data rather than reading all of it into\n          memory. Sampling is evenly distributed over the entire table.\n          MySQL uses SYSTEM sampling, which is a\n          page-level sampling method.\n        \n          The sampling-rate value in the\n          HISTOGRAM column of the Information Schema\n          COLUMN_STATISTICS table can be\n          queried to determine the fraction of data that was sampled to\n          create the histogram. The sampling-rate is\n          a number between 0.0 and 1.0. A value of 1 means that all of\n          the data was read (no sampling).\n        \n          The following example demonstrates sampling. To ensure that\n          the amount of data exceeds the\n          histogram_generation_max_mem_size\n          limit for the purpose of the example, the limit is set to a\n          low value (2000000 bytes) prior to generating histogram\n          statistics for the birth_date column of the\n          employees table.\n        Press CTRL+C to copy mysql> SET histogram_generation_max_mem_size = 2000000;\n\nmysql> USE employees;\n\nmysql> ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\\G\n*************************** 1. row ***************************\n   Table: employees.employees\n      Op: histogram\nMsg_type: status\nMsg_text: Histogram statistics created for column 'birth_date'.\n\nmysql> SELECT HISTOGRAM->>'$.\"sampling-rate\"'\n       FROM INFORMATION_SCHEMA.COLUMN_STATISTICS\n       WHERE TABLE_NAME = \"employees\"\n       AND COLUMN_NAME = \"birth_date\";\n+---------------------------------+\n| HISTOGRAM->>'$.\"sampling-rate\"' |\n+---------------------------------+\n| 0.0491431208869665              |\n+---------------------------------+\n          A sampling-rate value of 0.0491431208869665\n          means that approximately 4.9% of the data from the\n          birth_date column was read into memory for\n          generating histogram statistics.\n        \n          The InnoDB storage engine\n          provides its own sampling implementation for data stored in\n          InnoDB tables. The default sampling\n          implementation used by MySQL when storage engines do not\n          provide their own requires a full table scan, which is costly\n          for large tables. The InnoDB sampling\n          implementation improves sampling performance by avoiding full\n          table scans.\n        \n          The sampled_pages_read and\n          sampled_pages_skipped\nINNODB_METRICS counters can be\n          used to monitor sampling of InnoDB data\n          pages. (For general\n          INNODB_METRICS counter usage\n          information, see\n          Section\u00a028.4.21, \u201cThe INFORMATION_SCHEMA INNODB_METRICS Table\u201d.)\n        \n          The following example demonstrates sampling counter usage,\n          which requires enabling the counters prior to generating\n          histogram statistics.\n        Press CTRL+C to copy mysql> SET GLOBAL innodb_monitor_enable = 'sampled%';\n\nmysql> USE employees;\n\nmysql> ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\\G\n*************************** 1. row ***************************\n   Table: employees.employees\n      Op: histogram\nMsg_type: status\nMsg_text: Histogram statistics created for column 'birth_date'.\n\nmysql> USE INFORMATION_SCHEMA;\n\nmysql> SELECT NAME, COUNT FROM INNODB_METRICS WHERE NAME LIKE 'sampled%'\\G\n*************************** 1. row ***************************\n NAME: sampled_pages_read\nCOUNT: 43\n*************************** 2. row ***************************\n NAME: sampled_pages_skipped\nCOUNT: 843\n          This formula approximates a sampling rate based on the\n          sampling counter data:\n        Press CTRL+C to copy sampling rate = sampled_page_read/(sampled_pages_read + sampled_pages_skipped)\n          A sampling rate based on sampling counter data is roughly the\n          same as the sampling-rate value in the\n          HISTOGRAM column of the Information Schema\n          COLUMN_STATISTICS table.\n        \n          For information about memory allocations performed for\n          histogram generation, monitor the Performance Schema\n          memory/sql/histograms instrument. See\n          Section\u00a029.12.20.10, \u201cMemory Summary Tables\u201d.\n\n",
        "\n\n\n\nOther Considerations\n\n\n\n\nANALYZE TABLE clears table statistics from\n          the Information Schema\n          INNODB_TABLESTATS table and sets\n          the STATS_INITIALIZED column to\n          Uninitialized. Statistics are collected\n          again the next time the table is accessed.\n\n"
    ],
    "Examples": [
        "ANALYZE TABLE t UPDATE HISTOGRAM ON c1, c2, c3 WITH 10 BUCKETS;\nANALYZE TABLE t UPDATE HISTOGRAM ON c1, c3 WITH 10 BUCKETS;\nANALYZE TABLE t DROP HISTOGRAM ON c2;",
        "mysql> ANALYZE TABLE t UPDATE HISTOGRAM ON c1;\n+-------+-----------+----------+-----------------------------------------------+\n| Table | Op        | Msg_type | Msg_text                                      |\n+-------+-----------+----------+-----------------------------------------------+\n| h.t   | histogram | status   | Histogram statistics created for column 'c1'. |\n+-------+-----------+----------+-----------------------------------------------+\n1 row in set (0.00 sec)",
        "mysql> ANALYZE TABLE t DROP HISTOGRAM ON c1;\n+-------+-----------+----------+-----------------------------------------------+\n| Table | Op        | Msg_type | Msg_text                                      |\n+-------+-----------+----------+-----------------------------------------------+\n| h.t   | histogram | status   | Histogram statistics removed for column 'c1'. |\n+-------+-----------+----------+-----------------------------------------------+\n1 row in set (0.01 sec)\n\nmysql> TABLE information_schema.column_statistics\\G\nEmpty set (0.00 sec)",
        "mysql> ANALYZE TABLE t UPDATE HISTOGRAM ON c1 \n    ->     USING DATA '{\"buckets\": [], \"data-type\": \"int\", \"auto-update\": false,\n    ->               \"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-03-26\n    ->               16:54:43.674995\", \"sampling-rate\": 1.0, \"histogram-type\": \"singleton\",\n    ->               \"number-of-buckets-specified\": 100}';   \n+-------+-----------+----------+-----------------------------------------------+\n| Table | Op        | Msg_type | Msg_text                                      |\n+-------+-----------+----------+-----------------------------------------------+\n| h.t   | histogram | status   | Histogram statistics created for column 'c1'. |\n+-------+-----------+----------+-----------------------------------------------+\n\nmysql> TABLE information_schema.column_statistics\\G\n*************************** 1. row ***************************\nSCHEMA_NAME: h\n TABLE_NAME: t\nCOLUMN_NAME: c1\n  HISTOGRAM: {\"buckets\": [], \"data-type\": \"int\", \"auto-update\": false,\n\"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-03-26\n16:54:43.674995\", \"sampling-rate\": 1.0, \"histogram-type\": \"singleton\",\n\"number-of-buckets-specified\": 100}",
        "mysql> SET histogram_generation_max_mem_size = 2000000;\n\nmysql> USE employees;\n\nmysql> ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\\G\n*************************** 1. row ***************************\n   Table: employees.employees\n      Op: histogram\nMsg_type: status\nMsg_text: Histogram statistics created for column 'birth_date'.\n\nmysql> SELECT HISTOGRAM->>'$.\"sampling-rate\"'\n       FROM INFORMATION_SCHEMA.COLUMN_STATISTICS\n       WHERE TABLE_NAME = \"employees\"\n       AND COLUMN_NAME = \"birth_date\";\n+---------------------------------+\n| HISTOGRAM->>'$.\"sampling-rate\"' |\n+---------------------------------+\n| 0.0491431208869665              |\n+---------------------------------+",
        "mysql> SET GLOBAL innodb_monitor_enable = 'sampled%';\n\nmysql> USE employees;\n\nmysql> ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\\G\n*************************** 1. row ***************************\n   Table: employees.employees\n      Op: histogram\nMsg_type: status\nMsg_text: Histogram statistics created for column 'birth_date'.\n\nmysql> USE INFORMATION_SCHEMA;\n\nmysql> SELECT NAME, COUNT FROM INNODB_METRICS WHERE NAME LIKE 'sampled%'\\G\n*************************** 1. row ***************************\n NAME: sampled_pages_read\nCOUNT: 43\n*************************** 2. row ***************************\n NAME: sampled_pages_skipped\nCOUNT: 843"
    ],
    "Category": [
        "Database Administration Statements"
    ]
}