{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/get-diagnostics.html"
    ],
    "Title": [
        "15.6.7.3 GET DIAGNOSTICS Statement"
    ],
    "Feature": [
        "GET [CURRENT | STACKED] DIAGNOSTICS {\n    statement_information_item\n    [, statement_information_item] ...\n  | CONDITION condition_number\n    condition_information_item\n    [, condition_information_item] ...\n}\n\nstatement_information_item:\n    target = statement_information_item_name\n\ncondition_information_item:\n    target = condition_information_item_name\n\nstatement_information_item_name: {\n    NUMBER\n  | ROW_COUNT\n}\n\ncondition_information_item_name: {\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | RETURNED_SQLSTATE\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n}\n\ncondition_number, target:\n    (see following discussion)"
    ],
    "Description": [
        "\n        SQL statements produce diagnostic information that populates the\n        diagnostics area. The GET\n        DIAGNOSTICS statement enables applications to inspect\n        this information. (You can also use SHOW\n        WARNINGS or SHOW ERRORS\n        to see conditions or errors.)\n      ",
        "\n        No special privileges are required to execute\n        GET DIAGNOSTICS.\n      ",
        "\n        The keyword CURRENT means to retrieve\n        information from the current diagnostics area. The keyword\n        STACKED means to retrieve information from\n        the second diagnostics area, which is available only if the\n        current context is a condition handler. If neither keyword is\n        given, the default is to use the current diagnostics area.\n      ",
        "\n        The GET DIAGNOSTICS statement is\n        typically used in a handler within a stored program. It is a\n        MySQL extension that\n        GET [CURRENT]\n        DIAGNOSTICS is permitted outside handler context to\n        check the execution of any SQL statement. For example, if you\n        invoke the mysql client program, you can\n        enter these statements at the prompt:\n      ",
        "Press CTRL+C to copy mysql> DROP TABLE test.no_such_table;\nERROR 1051 (42S02): Unknown table 'test.no_such_table'\nmysql> GET DIAGNOSTICS CONDITION 1\n         @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;\nmysql> SELECT @p1, @p2;\n+-------+------------------------------------+\n| @p1   | @p2                                |\n+-------+------------------------------------+\n| 42S02 | Unknown table 'test.no_such_table' |\n+-------+------------------------------------+",
        "\n        This extension applies only to the current diagnostics area. It\n        does not apply to the second diagnostics area because\n        GET STACKED DIAGNOSTICS is permitted only if\n        the current context is a condition handler. If that is not the\n        case, a GET STACKED DIAGNOSTICS when handler not\n        active error occurs.\n      ",
        "\n        For a description of the diagnostics area, see\n        Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d. Briefly, it contains two\n        kinds of information:\n",
        "\n\n            Statement information, such as the number of conditions that\n            occurred or the affected-rows count.\n          \n            Condition information, such as the error code and message.\n            If a statement raises multiple conditions, this part of the\n            diagnostics area has a condition area for each one. If a\n            statement raises no conditions, this part of the diagnostics\n            area is empty.\n\n",
        "\n        For a statement that produces three conditions, the diagnostics\n        area contains statement and condition information like this:\n      ",
        "\nGET DIAGNOSTICS can obtain either\n        statement or condition information, but not both in the same\n        statement:\n",
        "\n\n            To obtain statement information, retrieve the desired\n            statement items into target variables. This instance of\n            GET DIAGNOSTICS assigns the\n            number of available conditions and the rows-affected count\n            to the user variables @p1 and\n            @p2:\n          Press CTRL+C to copy GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;\n            To obtain condition information, specify the condition\n            number and retrieve the desired condition items into target\n            variables. This instance of GET\n            DIAGNOSTICS assigns the SQLSTATE value and error\n            message to the user variables @p3 and\n            @p4:\n          Press CTRL+C to copy GET DIAGNOSTICS CONDITION 1\n  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;\n",
        "\n        The retrieval list specifies one or more\n        target =\n        item_name assignments,\n        separated by commas. Each assignment names a target variable and\n        either a\n        statement_information_item_name or\n        condition_information_item_name\n        designator, depending on whether the statement retrieves\n        statement or condition information.\n      ",
        "\n        Valid target designators for storing\n        item information can be stored procedure or function parameters,\n        stored program local variables declared with\n        DECLARE, or user-defined\n        variables.\n      ",
        "\n        Valid condition_number designators\n        can be stored procedure or function parameters, stored program\n        local variables declared with\n        DECLARE, user-defined variables,\n        system variables, or literals. A character literal may include a\n        _charset introducer. A warning occurs\n        if the condition number is not in the range from 1 to the number\n        of condition areas that have information. In this case, the\n        warning is added to the diagnostics area without clearing it.\n      ",
        "\n        When a condition occurs, MySQL does not populate all condition\n        items recognized by GET\n        DIAGNOSTICS. For example:\n      ",
        "Press CTRL+C to copy mysql> GET DIAGNOSTICS CONDITION 1\n         @p5 = SCHEMA_NAME, @p6 = TABLE_NAME;\nmysql> SELECT @p5, @p6;\n+------+------+\n| @p5  | @p6  |\n+------+------+\n|      |      |\n+------+------+",
        "\n        In standard SQL, if there are multiple conditions, the first\n        condition relates to the SQLSTATE value\n        returned for the previous SQL statement. In MySQL, this is not\n        guaranteed. To get the main error, you cannot do this:\n      ",
        "Press CTRL+C to copy GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;",
        "\n        Instead, retrieve the condition count first, then use it to\n        specify which condition number to inspect:\n      ",
        "Press CTRL+C to copy GET DIAGNOSTICS @cno = NUMBER;\nGET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;",
        "\n        For information about permissible statement and condition\n        information items, and which ones are populated when a condition\n        occurs, see\n        Diagnostics Area Information Items.\n      ",
        "\n        Here is an example that uses GET\n        DIAGNOSTICS and an exception handler in stored\n        procedure context to assess the outcome of an insert operation.\n        If the insert was successful, the procedure uses\n        GET DIAGNOSTICS to get the\n        rows-affected count. This shows that you can use\n        GET DIAGNOSTICS multiple times to\n        retrieve information about a statement as long as the current\n        diagnostics area has not been cleared.\n      ",
        "Press CTRL+C to copy CREATE PROCEDURE do_insert(value INT)\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE code CHAR(5) DEFAULT '00000';\n  DECLARE msg TEXT;\n  DECLARE nrows INT;\n  DECLARE result TEXT;\n  -- Declare exception handler for failed insert\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n      GET DIAGNOSTICS CONDITION 1\n        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;\n    END;\n\n  -- Perform the insert\n  INSERT INTO t1 (int_col) VALUES(value);\n  -- Check whether the insert was successful\n  IF code = '00000' THEN\n    GET DIAGNOSTICS nrows = ROW_COUNT;\n    SET result = CONCAT('insert succeeded, row count = ',nrows);\n  ELSE\n    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);\n  END IF;\n  -- Say what happened\n  SELECT result;\nEND;",
        "\n        Suppose that t1.int_col is an integer column\n        that is declared as NOT NULL. The procedure\n        produces these results when invoked to insert\n        non-NULL and NULL values,\n        respectively:\n      ",
        "Press CTRL+C to copy mysql> CALL do_insert(1);\n+---------------------------------+\n| result                          |\n+---------------------------------+\n| insert succeeded, row count = 1 |\n+---------------------------------+\n\nmysql> CALL do_insert(NULL);\n+-------------------------------------------------------------------------+\n| result                                                                  |\n+-------------------------------------------------------------------------+\n| insert failed, error = 23000, message = Column 'int_col' cannot be null |\n+-------------------------------------------------------------------------+",
        "\n        When a condition handler activates, a push to the diagnostics\n        area stack occurs:\n",
        "\n\n            The first (current) diagnostics area becomes the second\n            (stacked) diagnostics area and a new current diagnostics\n            area is created as a copy of it.\n          \nGET\n            [CURRENT] DIAGNOSTICS and\n            GET STACKED\n            DIAGNOSTICS can be used within the handler to\n            access the contents of the current and stacked diagnostics\n            areas.\n          \n            Initially, both diagnostics areas return the same result, so\n            it is possible to get information from the current\n            diagnostics area about the condition that activated the\n            handler, as long as you execute no\n            statements within the handler that change its current\n            diagnostics area.\n          \n            However, statements executing within the handler can modify\n            the current diagnostics area, clearing and setting its\n            contents according to the normal rules (see\n            How the Diagnostics Area is Cleared and Populated).\n          \n            A more reliable way to obtain information about the\n            handler-activating condition is to use the stacked\n            diagnostics area, which cannot be modified by statements\n            executing within the handler except\n            RESIGNAL. For information\n            about when the current diagnostics area is set and cleared,\n            see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n\n",
        "\n        The next example shows how GET STACKED\n        DIAGNOSTICS can be used within a handler to obtain\n        information about the handled exception, even after the current\n        diagnostics area has been modified by handler statements.\n      ",
        "\n        Within a stored procedure p(), we attempt to\n        insert two values into a table that contains a TEXT NOT\n        NULL column. The first value is a\n        non-NULL string and the second is\n        NULL. The column prohibits\n        NULL values, so the first insert succeeds but\n        the second causes an exception. The procedure includes an\n        exception handler that maps attempts to insert\n        NULL into inserts of the empty string:\n      ",
        "Press CTRL+C to copy DROP TABLE IF EXISTS t1;\nCREATE TABLE t1 (c1 TEXT NOT NULL);\nDROP PROCEDURE IF EXISTS p;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE errcount INT;\n  DECLARE errno INT;\n  DECLARE msg TEXT;\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- Here the current DA is nonempty because no prior statements\n    -- executing within the handler have cleared it\n    GET CURRENT DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'current DA before mapped insert' AS op, errno, msg;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA before mapped insert' AS op, errno, msg;\n\n    -- Map attempted NULL insert to empty string insert\n    INSERT INTO t1 (c1) VALUES('');\n\n    -- Here the current DA should be empty (if the INSERT succeeded),\n    -- so check whether there are conditions before attempting to\n    -- obtain condition information\n    GET CURRENT DIAGNOSTICS errcount = NUMBER;\n    IF errcount = 0\n    THEN\n      SELECT 'mapped insert succeeded, current DA is empty' AS op;\n    ELSE\n      GET CURRENT DIAGNOSTICS CONDITION 1\n        errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n      SELECT 'current DA after mapped insert' AS op, errno, msg;\n    END IF ;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA after mapped insert' AS op, errno, msg;\n  END;\n  INSERT INTO t1 (c1) VALUES('string 1');\n  INSERT INTO t1 (c1) VALUES(NULL);\nEND;\n//\ndelimiter ;\nCALL p();\nSELECT * FROM t1;",
        "\n        When the handler activates, a copy of the current diagnostics\n        area is pushed to the diagnostics area stack. The handler first\n        displays the contents of the current and stacked diagnostics\n        areas, which are both the same initially:\n      ",
        "\n        Statements executing after the GET\n        DIAGNOSTICS statements may reset the current\n        diagnostics area. statements may reset the current diagnostics\n        area. For example, the handler maps the NULL\n        insert to an empty-string insert and displays the result. The\n        new insert succeeds and clears the current diagnostics area, but\n        the stacked diagnostics area remains unchanged and still\n        contains information about the condition that activated the\n        handler:\n      ",
        "\n        When the condition handler ends, its current diagnostics area is\n        popped from the stack and the stacked diagnostics area becomes\n        the current diagnostics area in the stored procedure.\n      ",
        "\n        After the procedure returns, the table contains two rows. The\n        empty row results from the attempt to insert\n        NULL that was mapped to an empty-string\n        insert:\n      "
    ],
    "Examples": [
        "mysql> DROP TABLE test.no_such_table;\nERROR 1051 (42S02): Unknown table 'test.no_such_table'\nmysql> GET DIAGNOSTICS CONDITION 1\n         @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;\nmysql> SELECT @p1, @p2;\n+-------+------------------------------------+\n| @p1   | @p2                                |\n+-------+------------------------------------+\n| 42S02 | Unknown table 'test.no_such_table' |\n+-------+------------------------------------+",
        "GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;",
        "GET DIAGNOSTICS CONDITION 1\n  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;",
        "mysql> GET DIAGNOSTICS CONDITION 1\n         @p5 = SCHEMA_NAME, @p6 = TABLE_NAME;\nmysql> SELECT @p5, @p6;\n+------+------+\n| @p5  | @p6  |\n+------+------+\n|      |      |\n+------+------+",
        "GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;",
        "GET DIAGNOSTICS @cno = NUMBER;\nGET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;",
        "CREATE PROCEDURE do_insert(value INT)\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE code CHAR(5) DEFAULT '00000';\n  DECLARE msg TEXT;\n  DECLARE nrows INT;\n  DECLARE result TEXT;\n  -- Declare exception handler for failed insert\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n      GET DIAGNOSTICS CONDITION 1\n        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;\n    END;\n\n  -- Perform the insert\n  INSERT INTO t1 (int_col) VALUES(value);\n  -- Check whether the insert was successful\n  IF code = '00000' THEN\n    GET DIAGNOSTICS nrows = ROW_COUNT;\n    SET result = CONCAT('insert succeeded, row count = ',nrows);\n  ELSE\n    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);\n  END IF;\n  -- Say what happened\n  SELECT result;\nEND;",
        "mysql> CALL do_insert(1);\n+---------------------------------+\n| result                          |\n+---------------------------------+\n| insert succeeded, row count = 1 |\n+---------------------------------+\n\nmysql> CALL do_insert(NULL);\n+-------------------------------------------------------------------------+\n| result                                                                  |\n+-------------------------------------------------------------------------+\n| insert failed, error = 23000, message = Column 'int_col' cannot be null |\n+-------------------------------------------------------------------------+",
        "DROP TABLE IF EXISTS t1;\nCREATE TABLE t1 (c1 TEXT NOT NULL);\nDROP PROCEDURE IF EXISTS p;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE errcount INT;\n  DECLARE errno INT;\n  DECLARE msg TEXT;\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- Here the current DA is nonempty because no prior statements\n    -- executing within the handler have cleared it\n    GET CURRENT DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'current DA before mapped insert' AS op, errno, msg;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA before mapped insert' AS op, errno, msg;\n\n    -- Map attempted NULL insert to empty string insert\n    INSERT INTO t1 (c1) VALUES('');\n\n    -- Here the current DA should be empty (if the INSERT succeeded),\n    -- so check whether there are conditions before attempting to\n    -- obtain condition information\n    GET CURRENT DIAGNOSTICS errcount = NUMBER;\n    IF errcount = 0\n    THEN\n      SELECT 'mapped insert succeeded, current DA is empty' AS op;\n    ELSE\n      GET CURRENT DIAGNOSTICS CONDITION 1\n        errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n      SELECT 'current DA after mapped insert' AS op, errno, msg;\n    END IF ;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA after mapped insert' AS op, errno, msg;\n  END;\n  INSERT INTO t1 (c1) VALUES('string 1');\n  INSERT INTO t1 (c1) VALUES(NULL);\nEND;\n//\ndelimiter ;\nCALL p();\nSELECT * FROM t1;"
    ],
    "Category": [
        "Compound Statement Syntax"
    ]
}