{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/explain.html"
    ],
    "Title": [
        "15.8.2 EXPLAIN Statement"
    ],
    "Feature": [
        "{EXPLAIN | DESCRIBE | DESC}\n    tbl_name [col_name | wild]\n\n{EXPLAIN | DESCRIBE | DESC}\n    [explain_type] [INTO variable]\n    {[schema_spec] explainable_stmt | FOR CONNECTION connection_id}\n\n{EXPLAIN | DESCRIBE | DESC} ANALYZE [FORMAT = TREE] [schema_spec] select_statement\n\nexplain_type: {\n    FORMAT = format_name\n}\n\nformat_name: {\n    TRADITIONAL\n  | JSON\n  | TREE\n}\n\nexplainable_stmt: {\n    SELECT statement\n  | TABLE statement\n  | DELETE statement\n  | INSERT statement\n  | REPLACE statement\n  | UPDATE statement\n}\n\nschema_spec:\nFOR {SCHEMA | DATABASE} schema_name",
        "mysql> EXPLAIN ANALYZE SELECT * FROM t1 JOIN t2 ON (t1.c1 = t2.c2)\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Inner hash join (t2.c2 = t1.c1)  (cost=4.70 rows=6)\n(actual time=0.032..0.035 rows=6 loops=1)\n    -> Table scan on t2  (cost=0.06 rows=6)\n(actual time=0.003..0.005 rows=6 loops=1)\n    -> Hash\n        -> Table scan on t1  (cost=0.85 rows=6)\n(actual time=0.018..0.022 rows=6 loops=1)\n\nmysql> EXPLAIN ANALYZE SELECT * FROM t3 WHERE i > 8\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t3.i > 8)  (cost=1.75 rows=5)\n(actual time=0.019..0.021 rows=6 loops=1)\n    -> Table scan on t3  (cost=1.75 rows=15)\n(actual time=0.017..0.019 rows=15 loops=1)\n\nmysql> EXPLAIN ANALYZE SELECT * FROM t3 WHERE pk > 17\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t3.pk > 17)  (cost=1.26 rows=5)\n(actual time=0.013..0.016 rows=5 loops=1)\n    -> Index range scan on t3 using PRIMARY  (cost=1.26 rows=5)\n(actual time=0.012..0.014 rows=5 loops=1)"
    ],
    "Description": [
        "\n      The DESCRIBE and\n      EXPLAIN statements are synonyms. In\n      practice, the DESCRIBE keyword is\n      more often used to obtain information about table structure,\n      whereas EXPLAIN is used to obtain a\n      query execution plan (that is, an explanation of how MySQL would\n      execute a query).\n    ",
        "\n      The following discussion uses the\n      DESCRIBE and\n      EXPLAIN keywords in accordance with\n      those uses, but the MySQL parser treats them as completely\n      synonymous.\n",
        "\nObtaining Table Structure InformationObtaining Execution Plan InformationObtaining Information with EXPLAIN ANALYZE\n",
        "\n\n\n\nObtaining Table Structure Information\n\n\n\n\nDESCRIBE provides information\n        about the columns in a table:\n      Press CTRL+C to copy mysql> DESCRIBE City;\n+------------+----------+------+-----+---------+----------------+\n| Field      | Type     | Null | Key | Default | Extra          |\n+------------+----------+------+-----+---------+----------------+\n| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |\n| Name       | char(35) | NO   |     |         |                |\n| Country    | char(3)  | NO   | UNI |         |                |\n| District   | char(20) | YES  | MUL |         |                |\n| Population | int(11)  | NO   |     | 0       |                |\n+------------+----------+------+-----+---------+----------------+\nDESCRIBE is a shortcut for\n        SHOW COLUMNS. These statements\n        also display information for views. The description for\n        SHOW COLUMNS provides more\n        information about the output columns. See\n        Section\u00a015.7.7.6, \u201cSHOW COLUMNS Statement\u201d.\n      \n        By default, DESCRIBE displays\n        information about all columns in the table.\n        col_name, if given, is the name of a\n        column in the table. In this case, the statement displays\n        information only for the named column.\n        wild, if given, is a pattern string.\n        It can contain the SQL % and\n        _ wildcard characters. In this case, the\n        statement displays output only for the columns with names\n        matching the string. There is no need to enclose the string\n        within quotation marks unless it contains spaces or other\n        special characters.\n      \n        The DESCRIBE statement is\n        provided for compatibility with Oracle.\n      \n        The SHOW CREATE TABLE,\n        SHOW TABLE STATUS, and\n        SHOW INDEX statements also\n        provide information about tables. See Section\u00a015.7.7, \u201cSHOW Statements\u201d.\n      \n        The explain_format system\n        variable has no effect on the output of\n        EXPLAIN when used to obtain information about\n        table columns.\n\n",
        "\n\n\n\nObtaining Execution Plan Information\n\n\n\n\n        The EXPLAIN statement provides\n        information about how MySQL executes statements:\n\n\n\nEXPLAIN works with\n            SELECT,\n            DELETE,\n            INSERT,\n            REPLACE,\n            UPDATE, and\n            TABLE statements.\n          \n            When EXPLAIN is used with an\n            explainable statement, MySQL displays information from the\n            optimizer about the statement execution plan. That is, MySQL\n            explains how it would process the statement, including\n            information about how tables are joined and in which order.\n            For information about using\n            EXPLAIN to obtain execution\n            plan information, see Section\u00a010.8.2, \u201cEXPLAIN Output Format\u201d.\n          \n            When EXPLAIN is used with\n            FOR CONNECTION\n            connection_id rather\n            than an explainable statement, it displays the execution\n            plan for the statement executing in the named connection.\n            See Section\u00a010.8.4, \u201cObtaining Execution Plan Information for a Named Connection\u201d.\n          \n            For explainable statements,\n            EXPLAIN produces additional\n            execution plan information that can be displayed using\n            SHOW WARNINGS. See\n            Section\u00a010.8.3, \u201cExtended EXPLAIN Output Format\u201d.\n          \nEXPLAIN is useful for\n            examining queries involving partitioned tables. See\n            Section\u00a026.3.5, \u201cObtaining Information About Partitions\u201d.\n          \n            The FORMAT option can be used to select\n            the output format. TRADITIONAL presents\n            the output in tabular format. This is the default if no\n            FORMAT option is present.\n            JSON format displays the information in\n            JSON format. TREE provides tree-like\n            output with more precise descriptions of query handling than\n            the TRADITIONAL format; it is the only\n            format which shows hash join usage (see\n            Section\u00a010.2.1.4, \u201cHash Join Optimization\u201d) and is always used for\n            EXPLAIN ANALYZE.\n          \n            In MySQL 8.4, the default output format used by\n            EXPLAIN (that is, when it has no\n            FORMAT option) is determined by the value\n            of the explain_format\n            system variable. The precise effects of this variable are\n            described later in this section.\n          \n            MySQL 8.4 supports an additional\n            INTO option with EXPLAIN\n            FORMAT=JSON, which enables saving the JSON\n            formatted output into a user variable, like this:\n          Press CTRL+C to copy mysql> EXPLAIN FORMAT=JSON INTO @myselect \n    ->     SELECT name FROM a WHERE id = 2;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @myselect\\G\n*************************** 1. row ***************************\n@myex: {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"cost_info\": {\n      \"query_cost\": \"1.00\"\n    },\n    \"table\": {\n      \"table_name\": \"a\",\n      \"access_type\": \"const\",\n      \"possible_keys\": [\n        \"PRIMARY\"\n      ],\n      \"key\": \"PRIMARY\",\n      \"used_key_parts\": [\n        \"id\"\n      ],\n      \"key_length\": \"4\",\n      \"ref\": [\n        \"const\"\n      ],\n      \"rows_examined_per_scan\": 1,\n      \"rows_produced_per_join\": 1,\n      \"filtered\": \"100.00\",\n      \"cost_info\": {\n        \"read_cost\": \"0.00\",\n        \"eval_cost\": \"0.10\",\n        \"prefix_cost\": \"0.00\",\n        \"data_read_per_join\": \"408\"\n      },\n      \"used_columns\": [\n        \"id\",\n        \"name\"\n      ]\n    }\n  }\n}\n1 row in set (0.00 sec)\n            This works with any explainable statement\n            (SELECT,\n            TABLE,\n            INSERT,\n            UPDATE,\n            REPLACE, or\n            DELETE). Examples using\n            UPDATE and DELETE\n            statements are shown here:\n          Press CTRL+C to copy mysql> EXPLAIN FORMAT=JSON INTO @myupdate \n    ->   UPDATE a SET name2 = \"garcia\" WHERE id = 3;              \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> EXPLAIN FORMAT=JSON INTO @mydelete \n    ->     DELETE FROM a WHERE name1 LIKE '%e%';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @myupdate, @mydelete\\G\n*************************** 1. row ***************************\n@myupdate: {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"table\": {\n      \"update\": true,\n      \"table_name\": \"a\",\n      \"access_type\": \"range\",\n      \"possible_keys\": [\n        \"PRIMARY\"\n      ],\n      \"key\": \"PRIMARY\",\n      \"used_key_parts\": [\n        \"id\"\n      ],\n      \"key_length\": \"4\",\n      \"ref\": [\n        \"const\"\n      ],\n      \"rows_examined_per_scan\": 1,\n      \"filtered\": \"100.00\",\n      \"attached_condition\": \"(`db`.`a`.`id` = 3)\"\n    }\n  }\n}\n@mydelete: {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"table\": {\n      \"delete\": true,\n      \"table_name\": \"a\",\n      \"access_type\": \"ALL\",\n      \"rows_examined_per_scan\": 2,\n      \"filtered\": \"100.00\",\n      \"attached_condition\": \"(`db`.`a`.`name1` like '%e%')\"\n    }\n  }\n}\n1 row in set (0.00 sec)\n            You can work with this value using MySQL JSON functions as\n            you would with any other JSON value, as in these examples\n            using JSON_EXTRACT():\n          Press CTRL+C to copy mysql> SELECT JSON_EXTRACT(@myselect, \"$.query_block.table.key\");\n+----------------------------------------------------+\n| JSON_EXTRACT(@myselect, \"$.query_block.table.key\") |\n+----------------------------------------------------+\n| \"PRIMARY\"                                          |\n+----------------------------------------------------+\n1 row in set (0.01 sec)\n\nmysql> SELECT JSON_EXTRACT(@myupdate, \"$.query_block.table.access_type\") AS U_acc,\n    ->        JSON_EXTRACT(@mydelete, \"$.query_block.table.access_type\") AS D_acc;\n+---------+-------+\n| U_acc   | D_acc |\n+---------+-------+\n| \"range\" | \"ALL\" |\n+---------+-------+\n1 row in set (0.00 sec)\n            See also Section\u00a014.17, \u201cJSON Functions\u201d.\n          \n            Trying to use an INTO clause without\n            explicitly including FORMAT=JSON causes\n            EXPLAIN to be rejected with\n            ER_EXPLAIN_INTO_IMPLICIT_FORMAT_NOT_SUPPORTED.\n            This is true regardless of the current value of the\n            explain_format system\n            variable.\n          \n            The INTO clause is not supported with\n            EXPLAIN ANALYZE; it is also not supported\n            with FOR CONNECTION.\n\n\n\nImportant\n\n\n              If, for any reason, the statement to be analyzed is\n              rejected, the user variable is not updated.\n\n\n\n            MySQL 8.4 supports a FOR\n            SCHEMA clause, which causes\n            EXPLAIN to behave as if the statement to\n            be analyzed had been executed in the named database;\n            FOR DATABASE is supported as a synonym. A\n            simple example of use is shown here:\n          Press CTRL+C to copy mysql> USE b;\nDatabase changed\nmysql> CREATE SCHEMA s1;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> CREATE SCHEMA s2;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> USE s1;\nDatabase changed\nmysql> CREATE TABLE t (c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY, c2 INT NOT NULL);\nQuery OK, 0 rows affected (0.04 sec)\n\nmysql> USE s2;\nDatabase changed\nmysql> CREATE TABLE t (c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY, c2 INT NOT NULL, KEY i1 (c2));\nQuery OK, 0 rows affected (0.04 sec)\n\nmysql> USE b;\nDatabase changed\nmysql> EXPLAIN FORMAT=TREE FOR SCHEMA s1 SELECT * FROM t WHERE c2 > 50\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t.c2 > 50)  (cost=0.35 rows=1)\n    -> Table scan on t  (cost=0.35 rows=1)\n\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN FORMAT=TREE FOR SCHEMA s2 SELECT * FROM t WHERE c2 > 50\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t.c2 > 50)  (cost=0.35 rows=1)\n    -> Covering index scan on t using i1  (cost=0.35 rows=1)\n\n1 row in set (0.00 sec)\n            If the database does not exist, the statement is rejected\n            with ER_BAD_DB_ERROR. If the\n            user does not have the necessary privileges to run the\n            statement, it is rejected with\n            ER_DBACCESS_DENIED_ERROR.\n          \nFOR SCHEMA is not compatible with\n            FOR CONNECTION.\n\n\n\nEXPLAIN requires the same\n        privileges required to execute the explained statement.\n        Additionally, EXPLAIN also\n        requires the SHOW VIEW privilege\n        for any explained view.\n        EXPLAIN ... FOR\n        CONNECTION also requires the\n        PROCESS privilege if the\n        specified connection belongs to a different user.\n      \n        The explain_format system\n        variable determines the format of the output from\n        EXPLAIN when used to display a query\n        execution plan. This variable can take any of the values used\n        with the FORMAT option, with the addition of\n        DEFAULT as a synonym for\n        TRADITIONAL. The following example uses the\n        country table from the\n        world database which can be obtained from\n        MySQL: Other\n        Downloads:\n      Press CTRL+C to copy mysql> USE world; # Make world the current database\nDatabase changed\n        Checking the value of explain_format, we see\n        that it has the default value, and that\n        EXPLAIN (with no FORMAT\n        option) therefore uses the traditional tabular output:\n      Press CTRL+C to copy mysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| TRADITIONAL      |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN SELECT Name FROM country WHERE Code Like 'A%';\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | country | NULL       | range | PRIMARY       | PRIMARY | 12      | NULL |   17 |   100.00 | Using where |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n        If we set the value of explain_format to\n        TREE, then rerun the same\n        EXPLAIN statement, the output uses the\n        tree-like format:\n      Press CTRL+C to copy mysql> SET @@explain_format=TREE;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| TREE             |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN SELECT Name FROM country WHERE Code LIKE 'A%';\n+--------------------------------------------------------------------------------------------------------------+\n| EXPLAIN                                                                                                      |\n+--------------------------------------------------------------------------------------------------------------+\n| -> Filter: (country.`Code` like 'A%')  (cost=3.67 rows=17)\n    -> Index range scan on country using PRIMARY over ('A' <= Code <= 'A????????')  (cost=3.67 rows=17)  |\n+--------------------------------------------------------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n        As stated previously, the FORMAT option\n        overrides this setting. Executing the same\n        EXPLAIN statement using\n        FORMAT=JSON instead of\n        FORMAT=TREE shows that this is the case:\n      Press CTRL+C to copy mysql> EXPLAIN FORMAT=JSON SELECT Name FROM country WHERE Code LIKE 'A%';\n+------------------------------------------------------------------------------+\n| EXPLAIN                                                                      |\n+------------------------------------------------------------------------------+\n| {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"cost_info\": {\n      \"query_cost\": \"3.67\"\n    },\n    \"table\": {\n      \"table_name\": \"country\",\n      \"access_type\": \"range\",\n      \"possible_keys\": [\n        \"PRIMARY\"\n      ],\n      \"key\": \"PRIMARY\",\n      \"used_key_parts\": [\n        \"Code\"\n      ],\n      \"key_length\": \"12\",\n      \"rows_examined_per_scan\": 17,\n      \"rows_produced_per_join\": 17,\n      \"filtered\": \"100.00\",\n      \"cost_info\": {\n        \"read_cost\": \"1.97\",\n        \"eval_cost\": \"1.70\",\n        \"prefix_cost\": \"3.67\",\n        \"data_read_per_join\": \"16K\"\n      },\n      \"used_columns\": [\n        \"Code\",\n        \"Name\"\n      ],\n      \"attached_condition\": \"(`world`.`country`.`Code` like 'A%')\"\n    }\n  }\n}                                                                              |\n+------------------------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n        To return the default output of EXPLAIN to\n        the tabular format, set explain_format to\n        TRADITIONAL. Alternatively, you can set it to\n        DEFAULT, which has the same effect, as shown\n        here:\n      Press CTRL+C to copy mysql> SET @@explain_format=DEFAULT;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| TRADITIONAL      |\n+------------------+\n1 row in set (0.00 sec)\n        MySQL 8.4 supports two versions of the JSON output\n        format. Version 1 is the linear format always used in MySQL 8.2\n        and earlier; this remains the default in MySQL 8.4,\n        and is used in the examples already shown in this section.\n        Version 2 of the JSON output format is based on access paths,\n        and is intended to provide compatibility with future versions of\n        the MySQL Optimizer. You can switch to the Version 2 format by\n        setting the value of the\n        explain_json_format_version\n        server system variable to 2, as shown here\n        for the same EXPLAIN statement used in the\n        previous example:\n      Press CTRL+C to copy mysql> SELECT @@explain_json_format_version;\n+-------------------------------+\n| @@explain_json_format_version |\n+-------------------------------+\n|                             1 |\n+-------------------------------+\n1 row in set (0.00 sec)\n\nmysql> SET @@explain_json_format_version = 2;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_json_format_version;\n+-------------------------------+\n| @@explain_json_format_version |\n+-------------------------------+\n|                             2 |\n+-------------------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN FORMAT=JSON SELECT Name FROM country WHERE Code LIKE 'A%';\n+------------------------------------------------------------------------------+\n| EXPLAIN                                                                      |\n+------------------------------------------------------------------------------+\n| {\n  \"query\": \"/* select#1 */ select `world`.`country`.`Name` AS `Name` from `world`.`country` where (`world`.`country`.`Code` like 'A%')\",\n  \"inputs\": [\n    {\n      \"ranges\": [\n        \"('A' &lt;= Code &lt;= 'A????????')\"\n      ],\n      \"covering\": false,\n      \"operation\": \"Index range scan on country using PRIMARY over ('A' &lt;= Code &lt;= 'A????????')\",\n      \"index_name\": \"PRIMARY\",\n      \"table_name\": \"country\",\n      \"access_type\": \"index\",\n      \"estimated_rows\": 17.0,\n      \"index_access_type\": \"index_range_scan\",\n      \"estimated_total_cost\": 3.668778400708174\n    }\n  ],\n  \"condition\": \"(country.`Code` like 'A%')\",\n  \"operation\": \"Filter: (country.`Code` like 'A%')\",\n  \"access_type\": \"filter\",\n  \"estimated_rows\": 17.0,\n  \"estimated_total_cost\": 3.668778400708174\n}                                                                              |\n+------------------------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n        After using the Version 2 format, you can cause the JSON output\n        from all subsequent EXPLAIN FORMAT=JSON\n        statements to revert to the Version 1 format by setting\n        explain_json_format_version back to\n        1 (the default).\n      \n        The value of explain_json_format_version\n        determines the version of the JSON output format employed by all\n        EXPLAIN statements which use it, whether the\n        JSON format is used because a given EXPLAIN\n        statement includes an explicit FORMAT=JSON\n        option, or because the JSON format is used automatically due to\n        the explain_format system\n        variable being set to JSON.\n      \n        With the help of EXPLAIN, you can\n        see where you should add indexes to tables so that the statement\n        executes faster by using indexes to find rows. You can also use\n        EXPLAIN to check whether the\n        optimizer joins the tables in an optimal order. To give a hint\n        to the optimizer to use a join order corresponding to the order\n        in which the tables are named in a\n        SELECT statement, begin the\n        statement with SELECT STRAIGHT_JOIN rather\n        than just SELECT. (See\n        Section\u00a015.2.13, \u201cSELECT Statement\u201d.)\n      \n        The optimizer trace may sometimes provide information\n        complementary to that of EXPLAIN.\n        However, the optimizer trace format and content are subject to\n        change between versions. For details, see\n        MySQL\n        Internals: Tracing the Optimizer.\n      \n        If you have a problem with indexes not being used when you\n        believe that they should be, run ANALYZE\n        TABLE to update table statistics, such as cardinality\n        of keys, that can affect the choices the optimizer makes. See\n        Section\u00a015.7.3.1, \u201cANALYZE TABLE Statement\u201d.\n\n\n\nNote\n\n\n          MySQL Workbench has a Visual Explain capability that provides a\n          visual representation of\n          EXPLAIN output. See\n          Tutorial: Using Explain to Improve Query Performance.\n\n\n",
        "\n\n\n\nObtaining Information with EXPLAIN ANALYZE\n\n\n\n\nEXPLAIN ANALYZE runs a statement and produces\n        EXPLAIN\n        output along with timing and additional, iterator-based,\n        information about how the optimizer's expectations matched\n        the actual execution. For each iterator, the following\n        information is provided:\n\n\n\n            Estimated execution cost\n          \n            (Some iterators are not accounted for by the cost model, and\n            so are not included in the estimate.)\n          \n            Estimated number of returned rows\n          \n            Time to return first row\n          \n            Time spent executing this iterator (including child\n            iterators, but not parent iterators), in milliseconds.\n          \n            (When there are multiple loops, this figure shows the\n            average time per loop.)\n          \n            Number of rows returned by the iterator\n          \n            Number of loops\n\n\n\n        The query execution information is displayed using the\n        TREE output format, in which nodes represent\n        iterators. EXPLAIN ANALYZE always uses the\n        TREE output format. This can optionally be\n        specified explicitly using FORMAT=TREE;\n        formats other than TREE remain unsupported.\n      \nEXPLAIN ANALYZE can be used with\n        SELECT statements, multi-table\n        UPDATE and\n        DELETE statements, and\n        TABLE statements.\n      \n        You can terminate this statement using\n        KILL QUERY or\n        CTRL-C.\n      \nEXPLAIN ANALYZE cannot be used with\n        FOR CONNECTION.\n      \n        Example output:\n      Press CTRL+C to copy mysql> EXPLAIN ANALYZE SELECT * FROM t1 JOIN t2 ON (t1.c1 = t2.c2)\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Inner hash join (t2.c2 = t1.c1)  (cost=4.70 rows=6)\n(actual time=0.032..0.035 rows=6 loops=1)\n    -> Table scan on t2  (cost=0.06 rows=6)\n(actual time=0.003..0.005 rows=6 loops=1)\n    -> Hash\n        -> Table scan on t1  (cost=0.85 rows=6)\n(actual time=0.018..0.022 rows=6 loops=1)\n\nmysql> EXPLAIN ANALYZE SELECT * FROM t3 WHERE i > 8\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t3.i > 8)  (cost=1.75 rows=5)\n(actual time=0.019..0.021 rows=6 loops=1)\n    -> Table scan on t3  (cost=1.75 rows=15)\n(actual time=0.017..0.019 rows=15 loops=1)\n\nmysql> EXPLAIN ANALYZE SELECT * FROM t3 WHERE pk > 17\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t3.pk > 17)  (cost=1.26 rows=5)\n(actual time=0.013..0.016 rows=5 loops=1)\n    -> Index range scan on t3 using PRIMARY  (cost=1.26 rows=5)\n(actual time=0.012..0.014 rows=5 loops=1)\n        The tables used in the example output were created by the\n        statements shown here:\n      Press CTRL+C to copy CREATE TABLE t1 (\n    c1 INTEGER DEFAULT NULL,\n    c2 INTEGER DEFAULT NULL\n);\n\nCREATE TABLE t2 (\n    c1 INTEGER DEFAULT NULL,\n    c2 INTEGER DEFAULT NULL\n);\n\nCREATE TABLE t3 (\n    pk INTEGER NOT NULL PRIMARY KEY,\n    i INTEGER DEFAULT NULL\n);\n        Values shown for actual time in the output of\n        this statement are expressed in milliseconds.\n      \nexplain_format has the\n        following effects on EXPLAIN ANALYZE:\n\n\n\n            If the value of this variable is\n            TRADITIONAL or TREE\n            (or the synonym DEFAULT),\n            EXPLAIN ANALYZE uses the\n            TREE format. This ensures that this\n            statement continues to use the TREE\n            format by default, as it did prior to the introduction of\n            explain_format.\n          \n            If the value of explain_format is\n            JSON, EXPLAIN ANALYZE\n            returns an error unless FORMAT=TREE is\n            specified as part of the statement. This is due to the fact\n            that EXPLAIN ANALYZE supports only the\n            TREE output format.\n\n\n\n        We illustrate the behavior described in the second point here,\n        re-using the last EXPLAIN ANALYZE statement\n        from the previous example:\n      Press CTRL+C to copy mysql> SET @@explain_format=JSON;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| JSON             |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN ANALYZE SELECT * FROM t3 WHERE pk > 17\\G\nERROR 1235 (42000): This version of MySQL doesn't yet support 'EXPLAIN ANALYZE with JSON format'\n\nmysql> EXPLAIN ANALYZE FORMAT=TRADITIONAL SELECT * FROM t3 WHERE pk > 17\\G\nERROR 1235 (42000): This version of MySQL doesn't yet support 'EXPLAIN ANALYZE with TRADITIONAL format'\n\nmysql> EXPLAIN ANALYZE FORMAT=TREE SELECT * FROM t3 WHERE pk > 17\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t3.pk > 17)  (cost=1.26 rows=5)\n(actual time=0.013..0.016 rows=5 loops=1)\n    -> Index range scan on t3 using PRIMARY  (cost=1.26 rows=5)\n(actual time=0.012..0.014 rows=5 loops=1)\n        Using FORMAT=TRADITIONAL or\n        FORMAT=JSON with EXPLAIN\n        ANALYZE always raises an error, regardless of the\n        value of explain_format.\n      \n        In MySQL 8.4, numbers in the output of\n        EXPLAIN ANALYZE and EXPLAIN\n        FORMAT=TREE are formatted according to the following\n        rules:\n\n\n\n            Numbers in the range 0.001-999999.5 are printed as decimal\n            numbers.\n          \n            Decimal numbers less than 1000 have three significant\n            digits; the remainder have four, five, or six.\n          \n            Numbers outside the range 0.001-999999.5 are printed in\n            engineering format. Examples of such values are\n            1.23e+9 and 934e-6.\n          \n            No trailing zeros are printed. For example, we print\n            2.3 rather than 2.30,\n            and 1.2e+6 rather than\n            1.20e+6.\n          \n            Numbers less than 1e-12 are printed as\n            0.\n\n\n"
    ],
    "Examples": [
        "mysql> DESCRIBE City;\n+------------+----------+------+-----+---------+----------------+\n| Field      | Type     | Null | Key | Default | Extra          |\n+------------+----------+------+-----+---------+----------------+\n| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |\n| Name       | char(35) | NO   |     |         |                |\n| Country    | char(3)  | NO   | UNI |         |                |\n| District   | char(20) | YES  | MUL |         |                |\n| Population | int(11)  | NO   |     | 0       |                |\n+------------+----------+------+-----+---------+----------------+",
        "mysql> EXPLAIN FORMAT=JSON INTO @myselect \n    ->     SELECT name FROM a WHERE id = 2;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @myselect\\G\n*************************** 1. row ***************************\n@myex: {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"cost_info\": {\n      \"query_cost\": \"1.00\"\n    },\n    \"table\": {\n      \"table_name\": \"a\",\n      \"access_type\": \"const\",\n      \"possible_keys\": [\n        \"PRIMARY\"\n      ],\n      \"key\": \"PRIMARY\",\n      \"used_key_parts\": [\n        \"id\"\n      ],\n      \"key_length\": \"4\",\n      \"ref\": [\n        \"const\"\n      ],\n      \"rows_examined_per_scan\": 1,\n      \"rows_produced_per_join\": 1,\n      \"filtered\": \"100.00\",\n      \"cost_info\": {\n        \"read_cost\": \"0.00\",\n        \"eval_cost\": \"0.10\",\n        \"prefix_cost\": \"0.00\",\n        \"data_read_per_join\": \"408\"\n      },\n      \"used_columns\": [\n        \"id\",\n        \"name\"\n      ]\n    }\n  }\n}\n1 row in set (0.00 sec)",
        "mysql> EXPLAIN FORMAT=JSON INTO @myupdate \n    ->   UPDATE a SET name2 = \"garcia\" WHERE id = 3;              \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> EXPLAIN FORMAT=JSON INTO @mydelete \n    ->     DELETE FROM a WHERE name1 LIKE '%e%';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @myupdate, @mydelete\\G\n*************************** 1. row ***************************\n@myupdate: {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"table\": {\n      \"update\": true,\n      \"table_name\": \"a\",\n      \"access_type\": \"range\",\n      \"possible_keys\": [\n        \"PRIMARY\"\n      ],\n      \"key\": \"PRIMARY\",\n      \"used_key_parts\": [\n        \"id\"\n      ],\n      \"key_length\": \"4\",\n      \"ref\": [\n        \"const\"\n      ],\n      \"rows_examined_per_scan\": 1,\n      \"filtered\": \"100.00\",\n      \"attached_condition\": \"(`db`.`a`.`id` = 3)\"\n    }\n  }\n}\n@mydelete: {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"table\": {\n      \"delete\": true,\n      \"table_name\": \"a\",\n      \"access_type\": \"ALL\",\n      \"rows_examined_per_scan\": 2,\n      \"filtered\": \"100.00\",\n      \"attached_condition\": \"(`db`.`a`.`name1` like '%e%')\"\n    }\n  }\n}\n1 row in set (0.00 sec)",
        "mysql> SELECT JSON_EXTRACT(@myselect, \"$.query_block.table.key\");\n+----------------------------------------------------+\n| JSON_EXTRACT(@myselect, \"$.query_block.table.key\") |\n+----------------------------------------------------+\n| \"PRIMARY\"                                          |\n+----------------------------------------------------+\n1 row in set (0.01 sec)\n\nmysql> SELECT JSON_EXTRACT(@myupdate, \"$.query_block.table.access_type\") AS U_acc,\n    ->        JSON_EXTRACT(@mydelete, \"$.query_block.table.access_type\") AS D_acc;\n+---------+-------+\n| U_acc   | D_acc |\n+---------+-------+\n| \"range\" | \"ALL\" |\n+---------+-------+\n1 row in set (0.00 sec)",
        "mysql> USE b;\nDatabase changed\nmysql> CREATE SCHEMA s1;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> CREATE SCHEMA s2;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> USE s1;\nDatabase changed\nmysql> CREATE TABLE t (c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY, c2 INT NOT NULL);\nQuery OK, 0 rows affected (0.04 sec)\n\nmysql> USE s2;\nDatabase changed\nmysql> CREATE TABLE t (c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY, c2 INT NOT NULL, KEY i1 (c2));\nQuery OK, 0 rows affected (0.04 sec)\n\nmysql> USE b;\nDatabase changed\nmysql> EXPLAIN FORMAT=TREE FOR SCHEMA s1 SELECT * FROM t WHERE c2 > 50\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t.c2 > 50)  (cost=0.35 rows=1)\n    -> Table scan on t  (cost=0.35 rows=1)\n\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN FORMAT=TREE FOR SCHEMA s2 SELECT * FROM t WHERE c2 > 50\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t.c2 > 50)  (cost=0.35 rows=1)\n    -> Covering index scan on t using i1  (cost=0.35 rows=1)\n\n1 row in set (0.00 sec)",
        "mysql> USE world; # Make world the current database\nDatabase changed",
        "mysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| TRADITIONAL      |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN SELECT Name FROM country WHERE Code Like 'A%';\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | country | NULL       | range | PRIMARY       | PRIMARY | 12      | NULL |   17 |   100.00 | Using where |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)",
        "mysql> SET @@explain_format=TREE;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| TREE             |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN SELECT Name FROM country WHERE Code LIKE 'A%';\n+--------------------------------------------------------------------------------------------------------------+\n| EXPLAIN                                                                                                      |\n+--------------------------------------------------------------------------------------------------------------+\n| -> Filter: (country.`Code` like 'A%')  (cost=3.67 rows=17)\n    -> Index range scan on country using PRIMARY over ('A' <= Code <= 'A????????')  (cost=3.67 rows=17)  |\n+--------------------------------------------------------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)",
        "mysql> EXPLAIN FORMAT=JSON SELECT Name FROM country WHERE Code LIKE 'A%';\n+------------------------------------------------------------------------------+\n| EXPLAIN                                                                      |\n+------------------------------------------------------------------------------+\n| {\n  \"query_block\": {\n    \"select_id\": 1,\n    \"cost_info\": {\n      \"query_cost\": \"3.67\"\n    },\n    \"table\": {\n      \"table_name\": \"country\",\n      \"access_type\": \"range\",\n      \"possible_keys\": [\n        \"PRIMARY\"\n      ],\n      \"key\": \"PRIMARY\",\n      \"used_key_parts\": [\n        \"Code\"\n      ],\n      \"key_length\": \"12\",\n      \"rows_examined_per_scan\": 17,\n      \"rows_produced_per_join\": 17,\n      \"filtered\": \"100.00\",\n      \"cost_info\": {\n        \"read_cost\": \"1.97\",\n        \"eval_cost\": \"1.70\",\n        \"prefix_cost\": \"3.67\",\n        \"data_read_per_join\": \"16K\"\n      },\n      \"used_columns\": [\n        \"Code\",\n        \"Name\"\n      ],\n      \"attached_condition\": \"(`world`.`country`.`Code` like 'A%')\"\n    }\n  }\n}                                                                              |\n+------------------------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)",
        "mysql> SET @@explain_format=DEFAULT;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| TRADITIONAL      |\n+------------------+\n1 row in set (0.00 sec)",
        "mysql> SELECT @@explain_json_format_version;\n+-------------------------------+\n| @@explain_json_format_version |\n+-------------------------------+\n|                             1 |\n+-------------------------------+\n1 row in set (0.00 sec)\n\nmysql> SET @@explain_json_format_version = 2;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_json_format_version;\n+-------------------------------+\n| @@explain_json_format_version |\n+-------------------------------+\n|                             2 |\n+-------------------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN FORMAT=JSON SELECT Name FROM country WHERE Code LIKE 'A%';\n+------------------------------------------------------------------------------+\n| EXPLAIN                                                                      |\n+------------------------------------------------------------------------------+\n| {\n  \"query\": \"/* select#1 */ select `world`.`country`.`Name` AS `Name` from `world`.`country` where (`world`.`country`.`Code` like 'A%')\",\n  \"inputs\": [\n    {\n      \"ranges\": [\n        \"('A' &lt;= Code &lt;= 'A????????')\"\n      ],\n      \"covering\": false,\n      \"operation\": \"Index range scan on country using PRIMARY over ('A' &lt;= Code &lt;= 'A????????')\",\n      \"index_name\": \"PRIMARY\",\n      \"table_name\": \"country\",\n      \"access_type\": \"index\",\n      \"estimated_rows\": 17.0,\n      \"index_access_type\": \"index_range_scan\",\n      \"estimated_total_cost\": 3.668778400708174\n    }\n  ],\n  \"condition\": \"(country.`Code` like 'A%')\",\n  \"operation\": \"Filter: (country.`Code` like 'A%')\",\n  \"access_type\": \"filter\",\n  \"estimated_rows\": 17.0,\n  \"estimated_total_cost\": 3.668778400708174\n}                                                                              |\n+------------------------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)",
        "CREATE TABLE t1 (\n    c1 INTEGER DEFAULT NULL,\n    c2 INTEGER DEFAULT NULL\n);\n\nCREATE TABLE t2 (\n    c1 INTEGER DEFAULT NULL,\n    c2 INTEGER DEFAULT NULL\n);\n\nCREATE TABLE t3 (\n    pk INTEGER NOT NULL PRIMARY KEY,\n    i INTEGER DEFAULT NULL\n);",
        "mysql> SET @@explain_format=JSON;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @@explain_format;\n+------------------+\n| @@explain_format |\n+------------------+\n| JSON             |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN ANALYZE SELECT * FROM t3 WHERE pk > 17\\G\nERROR 1235 (42000): This version of MySQL doesn't yet support 'EXPLAIN ANALYZE with JSON format'\n\nmysql> EXPLAIN ANALYZE FORMAT=TRADITIONAL SELECT * FROM t3 WHERE pk > 17\\G\nERROR 1235 (42000): This version of MySQL doesn't yet support 'EXPLAIN ANALYZE with TRADITIONAL format'\n\nmysql> EXPLAIN ANALYZE FORMAT=TREE SELECT * FROM t3 WHERE pk > 17\\G\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (t3.pk > 17)  (cost=1.26 rows=5)\n(actual time=0.013..0.016 rows=5 loops=1)\n    -> Index range scan on t3 using PRIMARY  (cost=1.26 rows=5)\n(actual time=0.012..0.014 rows=5 loops=1)"
    ],
    "Category": [
        "Utility Statements"
    ]
}