{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/replace.html"
    ],
    "Title": [
        "15.2.12 REPLACE Statement"
    ],
    "Feature": [
        "REPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    [(col_name [, col_name] ...)]\n    { {VALUES | VALUE} (value_list) [, (value_list)] ...\n      |\n      VALUES row_constructor_list\n    }\n\nREPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    SET assignment_list\n\nREPLACE [LOW_PRIORITY | DELAYED]\n    [INTO] tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    [(col_name [, col_name] ...)]\n    {SELECT ... | TABLE table_name}\n\nvalue:\n    {expr | DEFAULT}\n\nvalue_list:\n    value [, value] ...\n\nrow_constructor_list:\n    ROW(value_list)[, ROW(value_list)][, ...]\n\nassignment:\n    col_name = value\n\nassignment_list:\n    assignment [, assignment] ..."
    ],
    "Description": [
        "\nREPLACE works exactly like\n      INSERT, except that if an old row\n      in the table has the same value as a new row for a\n      PRIMARY KEY or a UNIQUE\n      index, the old row is deleted before the new row is inserted. See\n      Section\u00a015.2.7, \u201cINSERT Statement\u201d.\n    ",
        "\nREPLACE is a MySQL extension to the\n      SQL standard. It either inserts, or deletes\n      and inserts. For another MySQL extension to standard\n      SQL\u2014that either inserts or\n      updates\u2014see\n      Section\u00a015.2.7.2, \u201cINSERT ... ON DUPLICATE KEY UPDATE Statement\u201d.\n    ",
        "\nDELAYED inserts and replaces were deprecated in\n      MySQL 5.6. In MySQL 8.4, DELAYED\n      is not supported. The server recognizes but ignores the\n      DELAYED keyword, handles the replace as a\n      nondelayed replace, and generates an\n      ER_WARN_LEGACY_SYNTAX_CONVERTED\n      warning: REPLACE DELAYED is no longer supported. The\n      statement was converted to REPLACE. The\n      DELAYED keyword is scheduled for removal in a\n      future release. release.\n",
        "\n\nNote\n\n\nREPLACE makes sense only if a\n        table has a PRIMARY KEY or\n        UNIQUE index. Otherwise, it becomes\n        equivalent to INSERT, because\n        there is no index to be used to determine whether a new row\n        duplicates another.\n\n",
        "\n      Values for all columns are taken from the values specified in the\n      REPLACE statement. Any missing\n      columns are set to their default values, just as happens for\n      INSERT. You cannot refer to values\n      from the current row and use them in the new row. If you use an\n      assignment such as SET\n      col_name =\n      col_name + 1, the reference\n      to the column name on the right hand side is treated as\n      DEFAULT(col_name),\n      so the assignment is equivalent to SET\n      col_name =\n      DEFAULT(col_name) + 1.\n    ",
        "\n      You can specify the column values that REPLACE\n      attempts to insert using\n      VALUES ROW().\n    ",
        "\n      To use REPLACE, you must have both\n      the INSERT and\n      DELETE privileges for the table.\n    ",
        "\n      If a generated column is replaced explicitly, the only permitted\n      value is DEFAULT. For information about\n      generated columns, see\n      Section\u00a015.1.20.8, \u201cCREATE TABLE and Generated Columns\u201d.\n    ",
        "\nREPLACE supports explicit partition selection\n      using the PARTITION clause with a list of\n      comma-separated names of partitions, subpartitions, or both. As\n      with INSERT, if it is not possible\n      to insert the new row into any of these partitions or\n      subpartitions, the REPLACE statement fails with\n      the error Found a row not matching the given partition\n      set. For more information and examples, see\n      Section\u00a026.5, \u201cPartition Selection\u201d.\n    ",
        "\n      The REPLACE statement returns a\n      count to indicate the number of rows affected. This is the sum of\n      the rows deleted and inserted. If the count is 1 for a single-row\n      REPLACE, a row was inserted and no\n      rows were deleted. If the count is greater than 1, one or more old\n      rows were deleted before the new row was inserted. It is possible\n      for a single row to replace more than one old row if the table\n      contains multiple unique indexes and the new row duplicates values\n      for different old rows in different unique indexes.\n    ",
        "\n      The affected-rows count makes it easy to determine whether\n      REPLACE only added a row or whether\n      it also replaced any rows: Check whether the count is 1 (added) or\n      greater (replaced).\n    ",
        "\n      If you are using the C API, the affected-rows count can be\n      obtained using the\n      mysql_affected_rows() function.\n    ",
        "\n      You cannot replace into a table and select from the same table in\n      a subquery.\n    ",
        "\n      MySQL uses the following algorithm for\n      REPLACE (and\n      LOAD DATA ...\n      REPLACE):\n",
        "\n\n          Try to insert the new row into the table\n        \n          While the insertion fails because a duplicate-key error occurs\n          for a primary key or unique index:\n\n\n\n              Delete from the table the conflicting row that has the\n              duplicate key value\n            \n              Try again to insert the new row into the table\n\n\n\n",
        "\n      It is possible that in the case of a duplicate-key error, a\n      storage engine may perform the REPLACE as an\n      update rather than a delete plus insert, but the semantics are the\n      same. There are no user-visible effects other than a possible\n      difference in how the storage engine increments\n      Handler_xxx status\n      variables.\n    ",
        "\n      Because the results of REPLACE ... SELECT\n      statements depend on the ordering of rows from the\n      SELECT and this order cannot always\n      be guaranteed, it is possible when logging these statements for\n      the source and the replica to diverge. For this reason,\n      REPLACE ... SELECT statements are flagged as\n      unsafe for statement-based replication. such statements produce a\n      warning in the error log when using statement-based mode and are\n      written to the binary log using the row-based format when using\n      MIXED mode. See also\n      Section\u00a019.2.1.1, \u201cAdvantages and Disadvantages of Statement-Based and Row-Based\n        Replication\u201d.\n    ",
        "\n      MySQL 8.4 supports\n      TABLE as well as\n      SELECT with\n      REPLACE, just as it does with\n      INSERT. See\n      Section\u00a015.2.7.1, \u201cINSERT ... SELECT Statement\u201d, for more information and\n      examples.\n    ",
        "\n      When modifying an existing table that is not partitioned to\n      accommodate partitioning, or, when modifying the partitioning of\n      an already partitioned table, you may consider altering the\n      table's primary key (see\n      Section\u00a026.6.1, \u201cPartitioning Keys, Primary Keys, and Unique Keys\u201d).\n      You should be aware that, if you do this, the results of\n      REPLACE statements may be affected, just as\n      they would be if you modified the primary key of a nonpartitioned\n      table. Consider the table created by the following\n      CREATE TABLE statement:\n    ",
        "Press CTRL+C to copy CREATE TABLE test (\n  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  data VARCHAR(64) DEFAULT NULL,\n  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (id)\n);",
        "\n      When we create this table and run the statements shown in the\n      mysql client, the result is as follows:\n    ",
        "Press CTRL+C to copy mysql> REPLACE INTO test VALUES (1, 'Old', '2014-08-20 18:47:00');\nQuery OK, 1 row affected (0.04 sec)\n\nmysql> REPLACE INTO test VALUES (1, 'New', '2014-08-20 18:47:42');\nQuery OK, 2 rows affected (0.04 sec)\n\nmysql> SELECT * FROM test;\n+----+------+---------------------+\n| id | data | ts                  |\n+----+------+---------------------+\n|  1 | New  | 2014-08-20 18:47:42 |\n+----+------+---------------------+\n1 row in set (0.00 sec)",
        "\n      Now we create a second table almost identical to the first, except\n      that the primary key now covers 2 columns, as shown here\n      (emphasized text):\n    ",
        "Press CTRL+C to copy CREATE TABLE test2 (\n  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  data VARCHAR(64) DEFAULT NULL,\n  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (id, ts)\n);",
        "\n      When we run on test2 the same two\n      REPLACE statements as we did on the original\n      test table, we obtain a different result:\n    ",
        "Press CTRL+C to copy mysql> REPLACE INTO test2 VALUES (1, 'Old', '2014-08-20 18:47:00');\nQuery OK, 1 row affected (0.05 sec)\n\nmysql> REPLACE INTO test2 VALUES (1, 'New', '2014-08-20 18:47:42');\nQuery OK, 1 row affected (0.06 sec)\n\nmysql> SELECT * FROM test2;\n+----+------+---------------------+\n| id | data | ts                  |\n+----+------+---------------------+\n|  1 | Old  | 2014-08-20 18:47:00 |\n|  1 | New  | 2014-08-20 18:47:42 |\n+----+------+---------------------+\n2 rows in set (0.00 sec)",
        "\n      This is due to the fact that, when run on\n      test2, both the id and\n      ts column values must match those of an\n      existing row for the row to be replaced; otherwise, a row is\n      inserted.\n"
    ],
    "Examples": [
        "CREATE TABLE test (\n  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  data VARCHAR(64) DEFAULT NULL,\n  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (id)\n);",
        "mysql> REPLACE INTO test VALUES (1, 'Old', '2014-08-20 18:47:00');\nQuery OK, 1 row affected (0.04 sec)\n\nmysql> REPLACE INTO test VALUES (1, 'New', '2014-08-20 18:47:42');\nQuery OK, 2 rows affected (0.04 sec)\n\nmysql> SELECT * FROM test;\n+----+------+---------------------+\n| id | data | ts                  |\n+----+------+---------------------+\n|  1 | New  | 2014-08-20 18:47:42 |\n+----+------+---------------------+\n1 row in set (0.00 sec)",
        "CREATE TABLE test2 (\n  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  data VARCHAR(64) DEFAULT NULL,\n  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (id, ts)\n);",
        "mysql> REPLACE INTO test2 VALUES (1, 'Old', '2014-08-20 18:47:00');\nQuery OK, 1 row affected (0.05 sec)\n\nmysql> REPLACE INTO test2 VALUES (1, 'New', '2014-08-20 18:47:42');\nQuery OK, 1 row affected (0.06 sec)\n\nmysql> SELECT * FROM test2;\n+----+------+---------------------+\n| id | data | ts                  |\n+----+------+---------------------+\n|  1 | Old  | 2014-08-20 18:47:00 |\n|  1 | New  | 2014-08-20 18:47:42 |\n+----+------+---------------------+\n2 rows in set (0.00 sec)"
    ],
    "Category": [
        "Data Manipulation Statements"
    ]
}