{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/lock-tables.html"
    ],
    "Title": [
        "15.3.6 LOCK TABLES and UNLOCK TABLES Statements"
    ],
    "Feature": [
        "LOCK {TABLE | TABLES}\n    tbl_name [[AS] alias] lock_type\n    [, tbl_name [[AS] alias] lock_type] ...\n\nlock_type: {\n    READ [LOCAL]\n  | WRITE\n}\n\nUNLOCK {TABLE | TABLES}"
    ],
    "Description": [
        "\n      MySQL enables client sessions to acquire table locks explicitly\n      for the purpose of cooperating with other sessions for access to\n      tables, or to prevent other sessions from modifying tables during\n      periods when a session requires exclusive access to them. A\n      session can acquire or release locks only for itself. One session\n      cannot acquire locks for another session or release locks held by\n      another session.\n    ",
        "\n      Locks may be used to emulate transactions or to get more speed\n      when updating tables. This is explained in more detail in\n      Table-Locking Restrictions and Conditions.\n    ",
        "\nLOCK TABLES explicitly acquires\n      table locks for the current client session. Table locks can be\n      acquired for base tables or views. You must have the\n      LOCK TABLES privilege, and the\n      SELECT privilege for each object to\n      be locked.\n    ",
        "\n      For view locking, LOCK TABLES adds\n      all base tables used in the view to the set of tables to be locked\n      and locks them automatically. For tables underlying any view being\n      locked, LOCK TABLES checks that the\n      view definer (for SQL SECURITY DEFINER views)\n      or invoker (for all views) has the proper privileges on the\n      tables.\n    ",
        "\n      If you lock a table explicitly with LOCK\n      TABLES, any tables used in triggers are also locked\n      implicitly, as described in\n      LOCK TABLES and Triggers.\n    ",
        "\n      If you lock a table explicitly with LOCK\n      TABLES, any tables related by a foreign key constraint\n      are opened and locked implicitly. For foreign key checks, a shared\n      read-only lock (LOCK\n      TABLES READ) is taken on related tables. For cascading\n      updates, a shared-nothing write lock\n      (LOCK TABLES\n      WRITE) is taken on related tables that are involved in\n      the operation.\n    ",
        "\nUNLOCK\n      TABLES explicitly releases any table locks held by the\n      current session. LOCK TABLES\n      implicitly releases any table locks held by the current session\n      before acquiring new locks.\n    ",
        "\n      Another use for\n      UNLOCK\n      TABLES is to release the global read lock acquired with\n      the FLUSH TABLES WITH READ LOCK\n      statement, which enables you to lock all tables in all databases.\n      See Section\u00a015.7.8.3, \u201cFLUSH Statement\u201d. (This is a very convenient way to get\n      backups if you have a file system such as Veritas that can take\n      snapshots in time.)\n    ",
        "\nLOCK TABLE is a synonym for LOCK\n      TABLES; UNLOCK TABLE is a synonym for\n      UNLOCK TABLES.\n    ",
        "\n      A table lock protects only against inappropriate reads or writes\n      by other sessions. A session holding a WRITE\n      lock can perform table-level operations such as\n      DROP TABLE or\n      TRUNCATE TABLE. For sessions\n      holding a READ lock, DROP\n      TABLE and TRUNCATE TABLE\n      operations are not permitted.\n    ",
        "\n      The following discussion applies only to\n      non-TEMPORARY tables. LOCK\n      TABLES is permitted (but ignored) for a\n      TEMPORARY table. The table can be accessed\n      freely by the session within which it was created, regardless of\n      what other locking may be in effect. No lock is necessary because\n      no other session can see the table.\n",
        "\nTable Lock AcquisitionTable Lock ReleaseInteraction of Table Locking and TransactionsLOCK TABLES and TriggersTable-Locking Restrictions and Conditions\n",
        "\n\n\n\nTable Lock Acquisition\n\n\n\n\n        To acquire table locks within the current session, use the\n        LOCK TABLES statement, which\n        acquires metadata locks (see\n        Section\u00a010.11.4, \u201cMetadata Locking\u201d).\n      \n        The following lock types are available:\n      \nREAD [LOCAL] lock:\n\n\n\n            The session that holds the lock can read the table (but not\n            write it).\n          \n            Multiple sessions can acquire a READ lock\n            for the table at the same time.\n          \n            Other sessions can read the table without explicitly\n            acquiring a READ lock.\n          \n            The LOCAL modifier enables nonconflicting\n            INSERT statements (concurrent\n            inserts) by other sessions to execute while the lock is\n            held. (See Section\u00a010.11.3, \u201cConcurrent Inserts\u201d.) However,\n            READ LOCAL cannot be used if you are\n            going to manipulate the database using processes external to\n            the server while you hold the lock. For\n            InnoDB tables, READ\n            LOCAL is the same as READ.\n\n\n\nWRITE lock:\n\n\n\n            The session that holds the lock can read and write the\n            table.\n          \n            Only the session that holds the lock can access the table.\n            No other session can access it until the lock is released.\n          \n            Lock requests for the table by other sessions block while\n            the WRITE lock is held.\n\n\n\nWRITE locks normally have higher priority\n        than READ locks to ensure that updates are\n        processed as soon as possible. This means that if one session\n        obtains a READ lock and then another session\n        requests a WRITE lock, subsequent\n        READ lock requests wait until the session\n        that requested the WRITE lock has obtained\n        the lock and released it. (An exception to this policy can occur\n        for small values of the\n        max_write_lock_count system\n        variable; see Section\u00a010.11.4, \u201cMetadata Locking\u201d.)\n      \n        If the LOCK TABLES statement must\n        wait due to locks held by other sessions on any of the tables,\n        it blocks until all locks can be acquired.\n      \n        A session that requires locks must acquire all the locks that it\n        needs in a single LOCK TABLES\n        statement. While the locks thus obtained are held, the session\n        can access only the locked tables. For example, in the following\n        sequence of statements, an error occurs for the attempt to\n        access t2 because it was not locked in the\n        LOCK TABLES statement:\n      Press CTRL+C to copy mysql> LOCK TABLES t1 READ;\nmysql> SELECT COUNT(*) FROM t1;\n+----------+\n| COUNT(*) |\n+----------+\n|        3 |\n+----------+\nmysql> SELECT COUNT(*) FROM t2;\nERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES\n        Tables in the INFORMATION_SCHEMA database are\n        an exception. They can be accessed without being locked\n        explicitly even while a session holds table locks obtained with\n        LOCK TABLES.\n      \n        You cannot refer to a locked table multiple times in a single\n        query using the same name. Use aliases instead, and obtain a\n        separate lock for the table and each alias:\n      Press CTRL+C to copy mysql> LOCK TABLE t WRITE, t AS t1 READ;\nmysql> INSERT INTO t SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> INSERT INTO t SELECT * FROM t AS t1;\n        The error occurs for the first\n        INSERT because there are two\n        references to the same name for a locked table. The second\n        INSERT succeeds because the\n        references to the table use different names.\n      \n        If your statements refer to a table by means of an alias, you\n        must lock the table using that same alias. It does not work to\n        lock the table without specifying the alias:\n      Press CTRL+C to copy mysql> LOCK TABLE t READ;\nmysql> SELECT * FROM t AS myalias;\nERROR 1100: Table 'myalias' was not locked with LOCK TABLES\n        Conversely, if you lock a table using an alias, you must refer\n        to it in your statements using that alias:\n      Press CTRL+C to copy mysql> LOCK TABLE t AS myalias READ;\nmysql> SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> SELECT * FROM t AS myalias;\n",
        "\n\n\n\nTable Lock Release\n\n\n\n\n        When the table locks held by a session are released, they are\n        all released at the same time. A session can release its locks\n        explicitly, or locks may be released implicitly under certain\n        conditions.\n\n\n\n            A session can release its locks explicitly with\n            UNLOCK\n            TABLES.\n          \n            If a session issues a LOCK\n            TABLES statement to acquire a lock while already\n            holding locks, its existing locks are released implicitly\n            before the new locks are granted.\n          \n            If a session begins a transaction (for example, with\n            START\n            TRANSACTION), an implicit\n            UNLOCK\n            TABLES is performed, which causes existing locks\n            to be released. (For additional information about the\n            interaction between table locking and transactions, see\n            Interaction of Table Locking and Transactions.)\n\n\n\n        If the connection for a client session terminates, whether\n        normally or abnormally, the server implicitly releases all table\n        locks held by the session (transactional and nontransactional).\n        If the client reconnects, the locks are no longer in effect. In\n        addition, if the client had an active transaction, the server\n        rolls back the transaction upon disconnect, and if reconnect\n        occurs, the new session begins with autocommit enabled. For this\n        reason, clients may wish to disable auto-reconnect. With\n        auto-reconnect in effect, the client is not notified if\n        reconnect occurs but any table locks or current transaction are\n        lost. With auto-reconnect disabled, if the connection drops, an\n        error occurs for the next statement issued. The client can\n        detect the error and take appropriate action such as reacquiring\n        the locks or redoing the transaction. See\n        Automatic Reconnection Control.\n\n\n\nNote\n\n\n          If you use ALTER TABLE on a\n          locked table, it may become unlocked. For example, if you\n          attempt a second ALTER TABLE\n          operation, the result may be an error Table\n          'tbl_name' was not locked with LOCK\n          TABLES. To handle this, lock the table again prior\n          to the second alteration. See also\n          Section\u00a0B.3.6.1, \u201cProblems with ALTER TABLE\u201d.\n\n\n",
        "\n\n\n\nInteraction of Table Locking and Transactions\n\n\n\n\nLOCK TABLES and\n        UNLOCK\n        TABLES interact with the use of transactions as\n        follows:\n\n\n\nLOCK TABLES is not\n            transaction-safe and implicitly commits any active\n            transaction before attempting to lock the tables.\n          \nUNLOCK\n            TABLES implicitly commits any active transaction,\n            but only if LOCK TABLES has\n            been used to acquire table locks. For example, in the\n            following set of statements,\n            UNLOCK\n            TABLES releases the global read lock but does not\n            commit the transaction because no table locks are in effect:\n          Press CTRL+C to copy FLUSH TABLES WITH READ LOCK;\nSTART TRANSACTION;\nSELECT ... ;\nUNLOCK TABLES;\n            Beginning a transaction (for example, with\n            START\n            TRANSACTION) implicitly commits any current\n            transaction and releases existing table locks.\n          \nFLUSH TABLES WITH READ LOCK\n            acquires a global read lock and not table locks, so it is\n            not subject to the same behavior as\n            LOCK TABLES and\n            UNLOCK\n            TABLES with respect to table locking and implicit\n            commits. For example,\n            START\n            TRANSACTION does not release the global read lock.\n            See Section\u00a015.7.8.3, \u201cFLUSH Statement\u201d.\n          \n            Other statements that implicitly cause transactions to be\n            committed do not release existing table locks. For a list of\n            such statements, see Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n          \n            The correct way to use LOCK\n            TABLES and\n            UNLOCK\n            TABLES with transactional tables, such as\n            InnoDB tables, is to begin a transaction\n            with SET autocommit = 0 (not\n            START\n            TRANSACTION) followed by LOCK\n            TABLES, and to not call\n            UNLOCK\n            TABLES until you commit the transaction\n            explicitly. For example, if you need to write to table\n            t1 and read from table\n            t2, you can do this:\n          Press CTRL+C to copy SET autocommit=0;\nLOCK TABLES t1 WRITE, t2 READ, ...;\n... do something with tables t1 and t2 here ...\nCOMMIT;\nUNLOCK TABLES;\n            When you call LOCK TABLES,\n            InnoDB internally takes its own table\n            lock, and MySQL takes its own table lock.\n            InnoDB releases its internal table lock\n            at the next commit, but for MySQL to release its table lock,\n            you have to call\n            UNLOCK\n            TABLES. You should not have\n            autocommit = 1, because\n            then InnoDB releases its internal table\n            lock immediately after the call of LOCK\n            TABLES, and deadlocks can very easily happen.\n            InnoDB does not acquire the internal\n            table lock at all if autocommit =\n            1, to help old applications avoid unnecessary\n            deadlocks.\n          \nROLLBACK\n            does not release table locks.\n\n\n",
        "\n\n\n\nLOCK TABLES and Triggers\n\n\n\n\n        If you lock a table explicitly with LOCK\n        TABLES, any tables used in triggers are also locked\n        implicitly:\n\n\n\n            The locks are taken as the same time as those acquired\n            explicitly with the LOCK\n            TABLES statement.\n          \n            The lock on a table used in a trigger depends on whether the\n            table is used only for reading. If so, a read lock suffices.\n            Otherwise, a write lock is used.\n          \n            If a table is locked explicitly for reading with\n            LOCK TABLES, but needs to be\n            locked for writing because it might be modified within a\n            trigger, a write lock is taken rather than a read lock.\n            (That is, an implicit write lock needed due to the table's\n            appearance within a trigger causes an explicit read lock\n            request for the table to be converted to a write lock\n            request.)\n\n\n\n        Suppose that you lock two tables, t1 and\n        t2, using this statement:\n      Press CTRL+C to copy LOCK TABLES t1 WRITE, t2 READ;\n        If t1 or t2 have any\n        triggers, tables used within the triggers are also locked.\n        Suppose that t1 has a trigger defined like\n        this:\n      Press CTRL+C to copy CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW\nBEGIN\n  UPDATE t4 SET count = count+1\n      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);\n  INSERT INTO t2 VALUES(1, 2);\nEND;\n        The result of the LOCK TABLES\n        statement is that t1 and\n        t2 are locked because they appear in the\n        statement, and t3 and t4\n        are locked because they are used within the trigger:\n\n\n\nt1 is locked for writing per the\n            WRITE lock request.\n          \nt2 is locked for writing, even though the\n            request is for a READ lock. This occurs\n            because t2 is inserted into within the\n            trigger, so the READ request is converted\n            to a WRITE request.\n          \nt3 is locked for reading because it is\n            only read from within the trigger.\n          \nt4 is locked for writing because it might\n            be updated within the trigger.\n\n\n",
        "\n\n\n\nTable-Locking Restrictions and Conditions\n\n\n\n\n        You can safely use KILL to\n        terminate a session that is waiting for a table lock. See\n        Section\u00a015.7.8.4, \u201cKILL Statement\u201d.\n      \nLOCK TABLES and\n        UNLOCK\n        TABLES cannot be used within stored programs.\n      \n        Tables in the performance_schema database\n        cannot be locked with LOCK\n        TABLES, except the\n        setup_xxx tables.\n      \n        The scope of a lock generated by LOCK TABLES\n        is a single MySQL server. It is not compatible with NDB Cluster,\n        which has no way of enforcing an SQL-level lock across multiple\n        instances of mysqld. You can enforce locking\n        in an API application instead. See\n        Section\u00a025.2.7.10, \u201cLimitations Relating to Multiple NDB Cluster Nodes\u201d, for\n        more information.\n      \n        The following statements are prohibited while a\n        LOCK TABLES statement is in\n        effect: CREATE TABLE,\n        CREATE TABLE ...\n        LIKE, CREATE VIEW,\n        DROP VIEW, and DDL statements on\n        stored functions and procedures and events.\n      \n        For some operations, system tables in the\n        mysql database must be accessed. For example,\n        the HELP statement requires the\n        contents of the server-side help tables, and\n        CONVERT_TZ() might need to read\n        the time zone tables. The server implicitly locks the system\n        tables for reading as necessary so that you need not lock them\n        explicitly. These tables are treated as just described:\n      Press CTRL+C to copy mysql.help_category\nmysql.help_keyword\nmysql.help_relation\nmysql.help_topic\nmysql.time_zone\nmysql.time_zone_leap_second\nmysql.time_zone_name\nmysql.time_zone_transition\nmysql.time_zone_transition_type\n        If you want to explicitly place a WRITE lock\n        on any of those tables with a LOCK\n        TABLES statement, the table must be the only one\n        locked; no other table can be locked with the same statement.\n      \n        Normally, you do not need to lock tables, because all single\n        UPDATE statements are atomic; no\n        other session can interfere with any other currently executing\n        SQL statement. However, there are a few cases when locking\n        tables may provide an advantage:\n\n\n\n            If you are going to run many operations on a set of\n            MyISAM tables, it is much faster to lock\n            the tables you are going to use. Locking\n            MyISAM tables speeds up inserting,\n            updating, or deleting on them because MySQL does not flush\n            the key cache for the locked tables until\n            UNLOCK\n            TABLES is called. Normally, the key cache is\n            flushed after each SQL statement.\n          \n            The downside to locking the tables is that no session can\n            update a READ-locked table (including the\n            one holding the lock) and no session can access a\n            WRITE-locked table other than the one\n            holding the lock.\n          \n            If you are using tables for a nontransactional storage\n            engine, you must use LOCK\n            TABLES if you want to ensure that no other session\n            modifies the tables between a\n            SELECT and an\n            UPDATE. The example shown\n            here requires LOCK TABLES to\n            execute safely:\n          Press CTRL+C to copy LOCK TABLES trans READ, customer WRITE;\nSELECT SUM(value) FROM trans WHERE customer_id=some_id;\nUPDATE customer\n  SET total_value=sum_from_previous_statement\n  WHERE customer_id=some_id;\nUNLOCK TABLES;\n            Without LOCK TABLES, it is\n            possible that another session might insert a new row in the\n            trans table between execution of the\n            SELECT and\n            UPDATE statements.\n\n\n\n        You can avoid using LOCK TABLES\n        in many cases by using relative updates (UPDATE\n        customer SET\n        value=value+new_value)\n        or the LAST_INSERT_ID() function.\n      \n        You can also avoid locking tables in some cases by using the\n        user-level advisory lock functions\n        GET_LOCK() and\n        RELEASE_LOCK(). These locks are\n        saved in a hash table in the server and implemented with\n        pthread_mutex_lock() and\n        pthread_mutex_unlock() for high speed. See\n        Section\u00a014.14, \u201cLocking Functions\u201d.\n      \n        See Section\u00a010.11.1, \u201cInternal Locking Methods\u201d, for more information on\n        locking policy.\n\n"
    ],
    "Examples": [
        "mysql> LOCK TABLES t1 READ;\nmysql> SELECT COUNT(*) FROM t1;\n+----------+\n| COUNT(*) |\n+----------+\n|        3 |\n+----------+\nmysql> SELECT COUNT(*) FROM t2;\nERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES",
        "mysql> LOCK TABLE t WRITE, t AS t1 READ;\nmysql> INSERT INTO t SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> INSERT INTO t SELECT * FROM t AS t1;",
        "mysql> LOCK TABLE t READ;\nmysql> SELECT * FROM t AS myalias;\nERROR 1100: Table 'myalias' was not locked with LOCK TABLES",
        "mysql> LOCK TABLE t AS myalias READ;\nmysql> SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> SELECT * FROM t AS myalias;",
        "FLUSH TABLES WITH READ LOCK;\nSTART TRANSACTION;\nSELECT ... ;\nUNLOCK TABLES;",
        "SET autocommit=0;\nLOCK TABLES t1 WRITE, t2 READ, ...;\n... do something with tables t1 and t2 here ...\nCOMMIT;\nUNLOCK TABLES;",
        "LOCK TABLES t1 WRITE, t2 READ;",
        "CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW\nBEGIN\n  UPDATE t4 SET count = count+1\n      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);\n  INSERT INTO t2 VALUES(1, 2);\nEND;",
        "LOCK TABLES trans READ, customer WRITE;\nSELECT SUM(value) FROM trans WHERE customer_id=some_id;\nUPDATE customer\n  SET total_value=sum_from_previous_statement\n  WHERE customer_id=some_id;\nUNLOCK TABLES;"
    ],
    "Category": [
        "Transactional and Locking Statements"
    ]
}