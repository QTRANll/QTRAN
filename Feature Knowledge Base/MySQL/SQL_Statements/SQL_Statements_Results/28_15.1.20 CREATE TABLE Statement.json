{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/create-table.html"
    ],
    "Title": [
        "15.1.20 CREATE TABLE Statement"
    ],
    "Feature": [
        "CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name\n    (create_definition,...)\n    [table_options]\n    [partition_options]\n\nCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name\n    [(create_definition,...)]\n    [table_options]\n    [partition_options]\n    [IGNORE | REPLACE]\n    [AS] query_expression\n\nCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name\n    { LIKE old_tbl_name | (LIKE old_tbl_name) }\n\ncreate_definition: {\n    col_name column_definition\n  | {INDEX | KEY} [index_name] [index_type] (key_part,...)\n      [index_option] ...\n  | {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name] (key_part,...)\n      [index_option] ...\n  | [CONSTRAINT [symbol]] PRIMARY KEY\n      [index_type] (key_part,...)\n      [index_option] ...\n  | [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]\n      [index_name] [index_type] (key_part,...)\n      [index_option] ...\n  | [CONSTRAINT [symbol]] FOREIGN KEY\n      [index_name] (col_name,...)\n      reference_definition\n  | check_constraint_definition\n}\n\ncolumn_definition: {\n    data_type [NOT NULL | NULL] [DEFAULT {literal | (expr)} ]\n      [VISIBLE | INVISIBLE]\n      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]\n      [COMMENT 'string']\n      [COLLATE collation_name]\n      [COLUMN_FORMAT {FIXED | DYNAMIC | DEFAULT}]\n      [ENGINE_ATTRIBUTE [=] 'string']\n      [SECONDARY_ENGINE_ATTRIBUTE [=] 'string']\n      [STORAGE {DISK | MEMORY}]\n      [reference_definition]\n      [check_constraint_definition]\n  | data_type\n      [COLLATE collation_name]\n      [GENERATED ALWAYS] AS (expr)\n      [VIRTUAL | STORED] [NOT NULL | NULL]\n      [VISIBLE | INVISIBLE]\n      [UNIQUE [KEY]] [[PRIMARY] KEY]\n      [COMMENT 'string']\n      [reference_definition]\n      [check_constraint_definition]\n}\n\ndata_type:\n    (see Chapter 13, Data Types)\n\nkey_part: {col_name [(length)] | (expr)} [ASC | DESC]\n\nindex_type:\n    USING {BTREE | HASH}\n\nindex_option: {\n    KEY_BLOCK_SIZE [=] value\n  | index_type\n  | WITH PARSER parser_name\n  | COMMENT 'string'\n  | {VISIBLE | INVISIBLE}\n  |ENGINE_ATTRIBUTE [=] 'string'\n  |SECONDARY_ENGINE_ATTRIBUTE [=] 'string'\n}\n\ncheck_constraint_definition:\n    [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]\n\nreference_definition:\n    REFERENCES tbl_name (key_part,...)\n      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]\n      [ON DELETE reference_option]\n      [ON UPDATE reference_option]\n\nreference_option:\n    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT\n\ntable_options:\n    table_option [[,] table_option] ...\n\ntable_option: {\n    AUTOEXTEND_SIZE [=] value\n  | AUTO_INCREMENT [=] value\n  | AVG_ROW_LENGTH [=] value\n  | [DEFAULT] CHARACTER SET [=] charset_name\n  | CHECKSUM [=] {0 | 1}\n  | [DEFAULT] COLLATE [=] collation_name\n  | COMMENT [=] 'string'\n  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}\n  | CONNECTION [=] 'connect_string'\n  | {DATA | INDEX} DIRECTORY [=] 'absolute path to directory'\n  | DELAY_KEY_WRITE [=] {0 | 1}\n  | ENCRYPTION [=] {'Y' | 'N'}\n  | ENGINE [=] engine_name\n  | ENGINE_ATTRIBUTE [=] 'string'\n  | INSERT_METHOD [=] { NO | FIRST | LAST }\n  | KEY_BLOCK_SIZE [=] value\n  | MAX_ROWS [=] value\n  | MIN_ROWS [=] value\n  | PACK_KEYS [=] {0 | 1 | DEFAULT}\n  | PASSWORD [=] 'string'\n  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}\n  | START TRANSACTION \n  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'\n  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}\n  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}\n  | STATS_SAMPLE_PAGES [=] value\n  | tablespace_option\n  | UNION [=] (tbl_name[,tbl_name]...)\n}\n\npartition_options:\n    PARTITION BY\n        { [LINEAR] HASH(expr)\n        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)\n        | RANGE{(expr) | COLUMNS(column_list)}\n        | LIST{(expr) | COLUMNS(column_list)} }\n    [PARTITIONS num]\n    [SUBPARTITION BY\n        { [LINEAR] HASH(expr)\n        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list) }\n      [SUBPARTITIONS num]\n    ]\n    [(partition_definition [, partition_definition] ...)]\n\npartition_definition:\n    PARTITION partition_name\n        [VALUES\n            {LESS THAN {(expr | value_list) | MAXVALUE}\n            |\n            IN (value_list)}]\n        [[STORAGE] ENGINE [=] engine_name]\n        [COMMENT [=] 'string' ]\n        [DATA DIRECTORY [=] 'data_dir']\n        [INDEX DIRECTORY [=] 'index_dir']\n        [MAX_ROWS [=] max_number_of_rows]\n        [MIN_ROWS [=] min_number_of_rows]\n        [TABLESPACE [=] tablespace_name]\n        [(subpartition_definition [, subpartition_definition] ...)]\n\nsubpartition_definition:\n    SUBPARTITION logical_name\n        [[STORAGE] ENGINE [=] engine_name]\n        [COMMENT [=] 'string' ]\n        [DATA DIRECTORY [=] 'data_dir']\n        [INDEX DIRECTORY [=] 'index_dir']\n        [MAX_ROWS [=] max_number_of_rows]\n        [MIN_ROWS [=] min_number_of_rows]\n        [TABLESPACE [=] tablespace_name]\n\ntablespace_option:\n    TABLESPACE tablespace_name [STORAGE DISK]\n  | [TABLESPACE tablespace_name] STORAGE MEMORY\n\nquery_expression:\n    SELECT ...   (Some valid select or union statement)",
        "SELECT * FROM tbl_name WHERE auto_col IS NULL",
        "CREATE TABLE tbl_name ... TABLESPACE [=] tablespace_name",
        "CREATE TABLE tbl_name ... TABLESPACE [=] innodb_system",
        "CREATE TABLE tbl_name ... TABLESPACE [=] innodb_file_per_table",
        "COMMENT = 'Data for the years previous to 1999'"
    ],
    "Description": [
        "\nCREATE TABLE creates a table with\n      the given name. You must have the\n      CREATE privilege for the table.\n    ",
        "\n      By default, tables are created in the default database, using the\n      InnoDB storage engine. An error\n      occurs if the table exists, if there is no default database, or if\n      the database does not exist.\n    ",
        "\n      MySQL has no limit on the number of tables. The underlying file\n      system may have a limit on the number of files that represent\n      tables. Individual storage engines may impose engine-specific\n      constraints. InnoDB permits up to 4 billion\n      tables.\n    ",
        "\n      For information about the physical representation of a table, see\n      Section\u00a015.1.20.1, \u201cFiles Created by CREATE TABLE\u201d.\n    ",
        "\n      There are several aspects to the CREATE\n      TABLE statement, described under the following topics in\n      this section:\n",
        "\nTable NameTemporary TablesTable Cloning and CopyingColumn Data Types and AttributesIndexes, Foreign Keys, and CHECK ConstraintsTable OptionsTable Partitioning\n",
        {
            "Sub-title": "Table Name",
            "Illustration": [
                "\n\ntbl_name\n\n          The table name can be specified as\n          db_name.tbl_name to create the\n          table in a specific database. This works regardless of whether\n          there is a default database, assuming that the database\n          exists. If you use quoted identifiers, quote the database and\n          table names separately. For example, write\n          `mydb`.`mytbl`, not\n          `mydb.mytbl`.\n        \n          Rules for permissible table names are given in\n          Section\u00a011.2, \u201cSchema Object Names\u201d.\n        \nIF NOT EXISTS\n\n          Prevents an error from occurring if the table exists. However,\n          there is no verification that the existing table has a\n          structure identical to that indicated by the\n          CREATE TABLE statement.\n\n"
            ]
        },
        {
            "Sub-title": "Temporary Tables",
            "Illustration": [
                "\n      You can use the TEMPORARY keyword when creating\n      a table. A TEMPORARY table is visible only\n      within the current session, and is dropped automatically when the\n      session is closed. For more information, see\n      Section\u00a015.1.20.2, \u201cCREATE TEMPORARY TABLE Statement\u201d.\n"
            ]
        },
        {
            "Sub-title": "Table Cloning and Copying",
            "Illustration": [
                "\n\nLIKE\n\n          Use CREATE TABLE ... LIKE to create an\n          empty table based on the definition of another table,\n          including any column attributes and indexes defined in the\n          original table:\n        Press CTRL+C to copy CREATE TABLE new_tbl LIKE orig_tbl;\n          For more information, see Section\u00a015.1.20.3, \u201cCREATE TABLE ... LIKE Statement\u201d.\n        \n[AS]\n          query_expression\n\n          To create one table from another, add a\n          SELECT statement at the end of\n          the CREATE TABLE statement:\n        Press CTRL+C to copy CREATE TABLE new_tbl AS SELECT * FROM orig_tbl;\n          For more information, see\n          Section\u00a015.1.20.4, \u201cCREATE TABLE ... SELECT Statement\u201d.\n        \nIGNORE | REPLACE\n\n          The IGNORE and REPLACE\n          options indicate how to handle rows that duplicate unique key\n          values when copying a table using a\n          SELECT statement.\n        \n          For more information, see\n          Section\u00a015.1.20.4, \u201cCREATE TABLE ... SELECT Statement\u201d.\n\n"
            ]
        },
        {
            "Sub-title": "Column Data Types and Attributes",
            "Illustration": [
                "\n      There is a hard limit of 4096 columns per table, but the effective\n      maximum may be less for a given table and depends on the factors\n      discussed in Section\u00a010.4.7, \u201cLimits on Table Column Count and Row Size\u201d.\n",
                "\n\ndata_type\n\ndata_type represents the data type\n          in a column definition. For a full description of the syntax\n          available for specifying column data types, as well as\n          information about the properties of each type, see\n          Chapter\u00a013, Data Types.\n\n\n\nAUTO_INCREMENT applies only to integer\n              types.\n            \n              Character data types (CHAR,\n              VARCHAR, the\n              TEXT types,\n              ENUM,\n              SET, and any synonyms) can\n              include CHARACTER SET to specify the\n              character set for the column. CHARSET\n              is a synonym for CHARACTER SET. A\n              collation for the character set can be specified with the\n              COLLATE attribute, along with any other\n              attributes. For details, see Chapter\u00a012, Character Sets, Collations, Unicode.\n              Example:\n            Press CTRL+C to copy CREATE TABLE t (c CHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin);\n              MySQL 8.4 interprets length specifications in\n              character column definitions in characters. Lengths for\n              BINARY and\n              VARBINARY are in bytes.\n            \n              For CHAR,\n              VARCHAR,\n              BINARY, and\n              VARBINARY columns, indexes\n              can be created that use only the leading part of column\n              values, using\n              col_name(length)\n              syntax to specify an index prefix length.\n              BLOB and\n              TEXT columns also can be\n              indexed, but a prefix length must be\n              given. Prefix lengths are given in characters for\n              nonbinary string types and in bytes for binary string\n              types. That is, index entries consist of the first\n              length characters of each\n              column value for CHAR,\n              VARCHAR, and\n              TEXT columns, and the first\n              length bytes of each column\n              value for BINARY,\n              VARBINARY, and\n              BLOB columns. Indexing only\n              a prefix of column values like this can make the index\n              file much smaller. For additional information about index\n              prefixes, see Section\u00a015.1.15, \u201cCREATE INDEX Statement\u201d.\n            \n              Only the InnoDB and\n              MyISAM storage engines support indexing\n              on BLOB and\n              TEXT columns. For example:\n            Press CTRL+C to copy CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));\n              If a specified index prefix exceeds the maximum column\n              data type size, CREATE\n              TABLE handles the index as follows:\n\n\n\n                  For a nonunique index, either an error occurs (if\n                  strict SQL mode is enabled), or the index length is\n                  reduced to lie within the maximum column data type\n                  size and a warning is produced (if strict SQL mode is\n                  not enabled).\n                \n                  For a unique index, an error occurs regardless of SQL\n                  mode because reducing the index length might enable\n                  insertion of nonunique entries that do not meet the\n                  specified uniqueness requirement.\n\n\n\nJSON columns cannot be\n              indexed. You can work around this restriction by creating\n              an index on a generated column that extracts a scalar\n              value from the JSON column. See\n              Indexing a Generated Column to Provide a JSON Column Index, for a\n              detailed example.\n\n\n\nNOT NULL | NULL\n\n          If neither NULL nor NOT\n          NULL is specified, the column is treated as though\n          NULL had been specified.\n        \n          In MySQL 8.4, only the InnoDB,\n          MyISAM, and MEMORY\n          storage engines support indexes on columns that can have\n          NULL values. In other cases, you must\n          declare indexed columns as NOT NULL or an\n          error results.\n        \nDEFAULT\n\n          Specifies a default value for a column. For more information\n          about default value handling, including the case that a column\n          definition includes no explicit DEFAULT\n          value, see Section\u00a013.6, \u201cData Type Default Values\u201d.\n        \n          If the NO_ZERO_DATE or\n          NO_ZERO_IN_DATE SQL mode is\n          enabled and a date-valued default is not correct according to\n          that mode, CREATE TABLE\n          produces a warning if strict SQL mode is not enabled and an\n          error if strict mode is enabled. For example, with\n          NO_ZERO_IN_DATE enabled,\n          c1 DATE DEFAULT '2010-00-00' produces a\n          warning.\n        \nVISIBLE, INVISIBLE\n\n          Specify column visibility. The default is\n          VISIBLE if neither keyword is present. A\n          table must have at least one visible column. Attempting to\n          make all columns invisible produces an error. For more\n          information, see Section\u00a015.1.20.10, \u201cInvisible Columns\u201d.\n        \nAUTO_INCREMENT\n\n          An integer column can have the additional attribute\n          AUTO_INCREMENT. When you insert a value of\n          NULL (recommended) or 0\n          into an indexed AUTO_INCREMENT column, the\n          column is set to the next sequence value. Typically this is\n          value+1, where\n          value is the largest value for the\n          column currently in the table.\n          AUTO_INCREMENT sequences begin with\n          1.\n        \n          To retrieve an AUTO_INCREMENT value after\n          inserting a row, use the\n          LAST_INSERT_ID() SQL function\n          or the mysql_insert_id() C API\n          function. See Section\u00a014.15, \u201cInformation Functions\u201d, and\n          mysql_insert_id().\n        \n          If the NO_AUTO_VALUE_ON_ZERO\n          SQL mode is enabled, you can store 0 in\n          AUTO_INCREMENT columns as\n          0 without generating a new sequence value.\n          See Section\u00a07.1.11, \u201cServer SQL Modes\u201d.\n        \n          There can be only one AUTO_INCREMENT column\n          per table, it must be indexed, and it cannot have a\n          DEFAULT value. An\n          AUTO_INCREMENT column works properly only\n          if it contains only positive values. Inserting a negative\n          number is regarded as inserting a very large positive number.\n          This is done to avoid precision problems when numbers\n          \u201cwrap\u201d over from positive to negative and also to\n          ensure that you do not accidentally get an\n          AUTO_INCREMENT column that contains\n          0.\n        \n          For MyISAM tables, you can specify an\n          AUTO_INCREMENT secondary column in a\n          multiple-column key. See\n          Section\u00a05.6.9, \u201cUsing AUTO_INCREMENT\u201d.\n        \n          To make MySQL compatible with some ODBC applications, you can\n          find the AUTO_INCREMENT value for the last\n          inserted row with the following query:\n        Press CTRL+C to copy SELECT * FROM tbl_name WHERE auto_col IS NULL\n          This method requires that\n          sql_auto_is_null variable is\n          not set to 0. See Section\u00a07.1.8, \u201cServer System Variables\u201d.\n        \n          For information about InnoDB and\n          AUTO_INCREMENT, see\n          Section\u00a017.6.1.6, \u201cAUTO_INCREMENT Handling in InnoDB\u201d. For\n          information about AUTO_INCREMENT and MySQL\n          Replication, see\n          Section\u00a019.5.1.1, \u201cReplication and AUTO_INCREMENT\u201d.\n        \nCOMMENT\n\n          A comment for a column can be specified with the\n          COMMENT option, up to 1024 characters long.\n          The comment is displayed by the SHOW\n          CREATE TABLE and\n          SHOW FULL\n          COLUMNS statements. It is also shown in the\n          COLUMN_COMMENT column of the Information\n          Schema COLUMNS table.\n        \nCOLUMN_FORMAT\n\n          In NDB Cluster, it is also possible to specify a data storage\n          format for individual columns of\n          NDB tables using\n          COLUMN_FORMAT. Permissible column formats\n          are FIXED, DYNAMIC, and\n          DEFAULT. FIXED is used\n          to specify fixed-width storage, DYNAMIC\n          permits the column to be variable-width, and\n          DEFAULT causes the column to use\n          fixed-width or variable-width storage as determined by the\n          column's data type (possibly overridden by a\n          ROW_FORMAT specifier).\n        \n          For NDB tables, the default value\n          for COLUMN_FORMAT is\n          FIXED.\n        \n          In NDB Cluster, the maximum possible offset for a column\n          defined with COLUMN_FORMAT=FIXED is 8188\n          bytes. For more information and possible workarounds, see\n          Section\u00a025.2.7.5, \u201cLimits Associated with Database Objects in NDB Cluster\u201d.\n        \nCOLUMN_FORMAT currently has no effect on\n          columns of tables using storage engines other than\n          NDB. MySQL 8.4\n          silently ignores COLUMN_FORMAT.\n        \nENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE options are used\n          to specify column attributes for primary and secondary storage\n          engines. The options are reserved for future use.\n        \n          The value assigned to this option is a string literal\n          containing a valid JSON document or an empty string ('').\n          Invalid JSON is rejected.\n        Press CTRL+C to copy CREATE TABLE t1 (c1 INT ENGINE_ATTRIBUTE='{\"key\":\"value\"}');\nENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE values can be\n          repeated without error. In this case, the last specified value\n          is used.\n        \nENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE values are not\n          checked by the server, nor are they cleared when the\n          table's storage engine is changed.\n        \nSTORAGE\n\n          For NDB tables, it is possible to\n          specify whether the column is stored on disk or in memory by\n          using a STORAGE clause. STORAGE\n          DISK causes the column to be stored on disk, and\n          STORAGE MEMORY causes in-memory storage to\n          be used. The CREATE TABLE\n          statement used must still include a\n          TABLESPACE clause:\n        Press CTRL+C to copy mysql> CREATE TABLE t1 (\n    ->     c1 INT STORAGE DISK,\n    ->     c2 INT STORAGE MEMORY\n    -> ) ENGINE NDB;\nERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)\n\nmysql> CREATE TABLE t1 (\n    ->     c1 INT STORAGE DISK,\n    ->     c2 INT STORAGE MEMORY\n    -> ) TABLESPACE ts_1 ENGINE NDB;\nQuery OK, 0 rows affected (1.06 sec)\n          For NDB tables, STORAGE\n          DEFAULT is equivalent to STORAGE\n          MEMORY.\n        \n          The STORAGE clause has no effect on tables\n          using storage engines other than\n          NDB. The\n          STORAGE keyword is supported only in the\n          build of mysqld that is supplied with NDB\n          Cluster; it is not recognized in any other version of MySQL,\n          where any attempt to use the STORAGE\n          keyword causes a syntax error.\n        \nGENERATED ALWAYS\n\n          Used to specify a generated column expression. For information\n          about generated\n          columns, see\n          Section\u00a015.1.20.8, \u201cCREATE TABLE and Generated Columns\u201d.\n        \nStored generated\n          columns can be indexed. InnoDB\n          supports secondary indexes on\n          virtual\n          generated columns. See\n          Section\u00a015.1.20.9, \u201cSecondary Indexes and Generated Columns\u201d.\n\n"
            ]
        },
        {
            "Sub-title": "Indexes, Foreign Keys, and CHECK Constraints",
            "Illustration": [
                "\n      Several keywords apply to creation of indexes, foreign keys, and\n      CHECK constraints. For general background in\n      addition to the following descriptions, see\n      Section\u00a015.1.15, \u201cCREATE INDEX Statement\u201d,\n      Section\u00a015.1.20.5, \u201cFOREIGN KEY Constraints\u201d, and\n      Section\u00a015.1.20.6, \u201cCHECK Constraints\u201d.\n",
                "\n\nCONSTRAINT\n          symbol\n\n          The CONSTRAINT\n          symbol clause may be\n          given to name a constraint. If the clause is not given, or a\n          symbol is not included following\n          the CONSTRAINT keyword, MySQL automatically\n          generates a constraint name, with the exception noted below.\n          The symbol value, if used, must be\n          unique per schema (database), per constraint type. A duplicate\n          symbol results in an error. See\n          also the discussion about length limits of generated\n          constraint identifiers at Section\u00a011.2.1, \u201cIdentifier Length Limits\u201d.\n\n\n\nNote\n\n\n            If the CONSTRAINT\n            symbol clause is not\n            given in a foreign key definition, or a\n            symbol is not included following\n            the CONSTRAINT keyword, MySQL\n            automatically generates a constraint name.\n\n\n\n          The SQL standard specifies that all types of constraints\n          (primary key, unique index, foreign key, check) belong to the\n          same namespace. In MySQL, each constraint type has its own\n          namespace per schema. Consequently, names for each type of\n          constraint must be unique per schema, but constraints of\n          different types can have the same name.\n        \nPRIMARY KEY\n\n          A unique index where all key columns must be defined as\n          NOT NULL. If they are not explicitly\n          declared as NOT NULL, MySQL declares them\n          so implicitly (and silently). A table can have only one\n          PRIMARY KEY. The name of a PRIMARY\n          KEY is always PRIMARY, which thus\n          cannot be used as the name for any other kind of index.\n        \n          If you do not have a PRIMARY KEY and an\n          application asks for the PRIMARY KEY in\n          your tables, MySQL returns the first UNIQUE\n          index that has no NULL columns as the\n          PRIMARY KEY.\n        \n          In InnoDB tables, keep the PRIMARY\n          KEY short to minimize storage overhead for secondary\n          indexes. Each secondary index entry contains a copy of the\n          primary key columns for the corresponding row. (See\n          Section\u00a017.6.2.1, \u201cClustered and Secondary Indexes\u201d.)\n        \n          In the created table, a PRIMARY KEY is\n          placed first, followed by all UNIQUE\n          indexes, and then the nonunique indexes. This helps the MySQL\n          optimizer to prioritize which index to use and also more\n          quickly to detect duplicated UNIQUE keys.\n        \n          A PRIMARY KEY can be a multiple-column\n          index. However, you cannot create a multiple-column index\n          using the PRIMARY KEY key attribute in a\n          column specification. Doing so only marks that single column\n          as primary. You must use a separate PRIMARY\n          KEY(key_part, ...)\n          clause.\n        \n          If a table has a PRIMARY KEY or\n          UNIQUE NOT NULL index that consists of a\n          single column that has an integer type, you can use\n          _rowid to refer to the indexed column in\n          SELECT statements, as described\n          in Unique Indexes.\n        \n          In MySQL, the name of a PRIMARY KEY is\n          PRIMARY. For other indexes, if you do not\n          assign a name, the index is assigned the same name as the\n          first indexed column, with an optional suffix\n          (_2, _3,\n          ...) to make it unique. You can see index\n          names for a table using SHOW INDEX FROM\n          tbl_name. See\n          Section\u00a015.7.7.23, \u201cSHOW INDEX Statement\u201d.\n        \nKEY | INDEX\n\nKEY is normally a synonym for\n          INDEX. The key attribute PRIMARY\n          KEY can also be specified as just\n          KEY when given in a column definition. This\n          was implemented for compatibility with other database systems.\n        \nUNIQUE\n\n          A UNIQUE index creates a constraint such\n          that all values in the index must be distinct. An error occurs\n          if you try to add a new row with a key value that matches an\n          existing row. For all engines, a UNIQUE\n          index permits multiple NULL values for\n          columns that can contain NULL. If you\n          specify a prefix value for a column in a\n          UNIQUE index, the column values must be\n          unique within the prefix length.\n        \n          If a table has a PRIMARY KEY or\n          UNIQUE NOT NULL index that consists of a\n          single column that has an integer type, you can use\n          _rowid to refer to the indexed column in\n          SELECT statements, as described\n          in Unique Indexes.\n        \nFULLTEXT\n\n          A FULLTEXT index is a special type of index\n          used for full-text searches. Only the\n          InnoDB and\n          MyISAM storage engines support\n          FULLTEXT indexes. They can be created only\n          from CHAR,\n          VARCHAR, and\n          TEXT columns. Indexing always\n          happens over the entire column; column prefix indexing is not\n          supported and any prefix length is ignored if specified. See\n          Section\u00a014.9, \u201cFull-Text Search Functions\u201d, for details of operation. A\n          WITH PARSER clause can be specified as an\n          index_option value to associate a\n          parser plugin with the index if full-text indexing and\n          searching operations need special handling. This clause is\n          valid only for FULLTEXT indexes.\n          InnoDB and\n          MyISAM support full-text parser\n          plugins. See Full-Text Parser Plugins and\n          Writing Full-Text Parser Plugins for more\n          information.\n        \nSPATIAL\n\n          You can create SPATIAL indexes on spatial\n          data types. Spatial types are supported only for\n          InnoDB and MyISAM\n          tables, and indexed columns must be declared as NOT\n          NULL. See Section\u00a013.4, \u201cSpatial Data Types\u201d.\n        \nFOREIGN KEY\n\n          MySQL supports foreign keys, which let you cross-reference\n          related data across tables, and foreign key constraints, which\n          help keep this spread-out data consistent. For definition and\n          option information, see\n          reference_definition,\n          and\n          reference_option.\n        \n          Partitioned tables employing the\n          InnoDB storage engine do not\n          support foreign keys. See\n          Section\u00a026.6, \u201cRestrictions and Limitations on Partitioning\u201d, for more\n          information.\n        \nCHECK\n\n          The CHECK clause enables the creation of\n          constraints to be checked for data values in table rows. See\n          Section\u00a015.1.20.6, \u201cCHECK Constraints\u201d.\n        \nkey_part\n\n\n\n              A key_part specification can\n              end with ASC or DESC\n              to specify whether index values are stored in ascending or\n              descending order. The default is ascending if no order\n              specifier is given.\n            \n              Prefixes, defined by the length\n              attribute, can be up to 767 bytes long for\n              InnoDB tables that use the\n              REDUNDANT\n              or\n              COMPACT\n              row format. The prefix length limit is 3072 bytes for\n              InnoDB tables that use the\n              DYNAMIC\n              or\n              COMPRESSED\n              row format. For MyISAM tables, the\n              prefix length limit is 1000 bytes.\n            \n              Prefix limits are measured in bytes.\n              However, prefix lengths for index\n              specifications in CREATE\n              TABLE, ALTER\n              TABLE, and CREATE\n              INDEX statements are interpreted as number of\n              characters for nonbinary string types\n              (CHAR,\n              VARCHAR,\n              TEXT) and number of bytes\n              for binary string types\n              (BINARY,\n              VARBINARY,\n              BLOB). Take this into\n              account when specifying a prefix length for a nonbinary\n              string column that uses a multibyte character set.\n            \n              The expr for a\n              key_part specification can take\n              the form (CAST\n              json_path AS\n              type ARRAY) to create\n              a multi-valued index on a\n              JSON column.\n              Multi-Valued Indexes, provides\n              detailed information regarding creation of, usage of, and\n              restrictions and limitations on multi-valued indexes.\n\n\n\nindex_type\n\n          Some storage engines permit you to specify an index type when\n          creating an index. The syntax for the\n          index_type specifier is\n          USING type_name.\n        \n          Example:\n        Press CTRL+C to copy CREATE TABLE lookup\n  (id INT, INDEX USING BTREE (id)\n) ENGINE = MEMORY;\n          The preferred position for USING is after\n          the index column list. It can be given before the column list,\n          but support for use of the option in that position is\n          deprecated and you should expect it to be removed in a future\n          MySQL release.\n        \nindex_option\n\nindex_option values specify\n          additional options for an index.\n\n\n\nKEY_BLOCK_SIZE\n\n              For MyISAM tables,\n              KEY_BLOCK_SIZE optionally specifies the\n              size in bytes to use for index key blocks. The value is\n              treated as a hint; a different size could be used if\n              necessary. A KEY_BLOCK_SIZE value\n              specified for an individual index definition overrides the\n              table-level KEY_BLOCK_SIZE value.\n            \n              For information about the table-level\n              KEY_BLOCK_SIZE attribute, see\n              Table Options.\n            \nWITH PARSER\n\n              The WITH PARSER option can be used only\n              with FULLTEXT indexes. It associates a\n              parser plugin with the index if full-text indexing and\n              searching operations need special handling.\n              InnoDB and\n              MyISAM support full-text\n              parser plugins. If you have a\n              MyISAM table with an\n              associated full-text parser plugin, you can convert the\n              table to InnoDB using ALTER\n              TABLE.\n            \nCOMMENT\n\n              Index definitions can include an optional comment of up to\n              1024 characters.\n            \n              You can set the InnoDB\nMERGE_THRESHOLD value for an individual\n              index using the\n              index_option\nCOMMENT clause. See\n              Section\u00a017.8.11, \u201cConfiguring the Merge Threshold for Index Pages\u201d.\n            \nVISIBLE, INVISIBLE\n\n              Specify index visibility. Indexes are visible by default.\n              An invisible index is not used by the optimizer.\n              Specification of index visibility applies to indexes other\n              than primary keys (either explicit or implicit). For more\n              information, see Section\u00a010.3.12, \u201cInvisible Indexes\u201d.\n            \nENGINE_ATTRIBUTE and\n              SECONDARY_ENGINE_ATTRIBUTE options are\n              used to specify index attributes for primary and secondary\n              storage engines. The options are reserved for future use.\n\n\n\n          For more information about permissible\n          index_option values, see\n          Section\u00a015.1.15, \u201cCREATE INDEX Statement\u201d. For more information about\n          indexes, see Section\u00a010.3.1, \u201cHow MySQL Uses Indexes\u201d.\n        \nreference_definition\n\n          For reference_definition syntax\n          details and examples, see\n          Section\u00a015.1.20.5, \u201cFOREIGN KEY Constraints\u201d.\n        \nInnoDB and\n          NDB tables support checking of\n          foreign key constraints. The columns of the referenced table\n          must always be explicitly named. Both ON\n          DELETE and ON UPDATE actions on\n          foreign keys are supported. For more detailed information and\n          examples, see Section\u00a015.1.20.5, \u201cFOREIGN KEY Constraints\u201d.\n        \n          For other storage engines, MySQL Server parses and ignores the\n          FOREIGN KEY syntax in\n          CREATE TABLE statements.\n\n\n\nImportant\n\n\n            For users familiar with the ANSI/ISO SQL Standard, please\n            note that no storage engine, including\n            InnoDB, recognizes or enforces the\n            MATCH clause used in referential\n            integrity constraint definitions. Use of an explicit\n            MATCH clause does not have the specified\n            effect, and also causes ON DELETE and\n            ON UPDATE clauses to be ignored. For\n            these reasons, specifying MATCH should be\n            avoided.\n          \n            The MATCH clause in the SQL standard\n            controls how NULL values in a composite\n            (multiple-column) foreign key are handled when comparing to\n            a primary key. InnoDB essentially\n            implements the semantics defined by MATCH\n            SIMPLE, which permit a foreign key to be all or\n            partially NULL. In that case, the (child\n            table) row containing such a foreign key is permitted to be\n            inserted, and does not match any row in the referenced\n            (parent) table. It is possible to implement other semantics\n            using triggers.\n          \n            Additionally, MySQL requires that the referenced columns be\n            indexed for performance. However, InnoDB\n            does not enforce any requirement that the referenced columns\n            be declared UNIQUE or NOT\n            NULL. The handling of foreign key references to\n            nonunique keys or keys that contain NULL\n            values is not well defined for operations such as\n            UPDATE or DELETE\n            CASCADE. You are advised to use foreign keys that\n            reference only keys that are both UNIQUE\n            (or PRIMARY) and NOT\n            NULL.\n          \n            MySQL parses but ignores \u201cinline\n            REFERENCES specifications\u201d (as\n            defined in the SQL standard) where the references are\n            defined as part of the column specification. MySQL accepts\n            REFERENCES clauses only when specified as\n            part of a separate FOREIGN KEY\n            specification. For more information, see\n            Section\u00a01.7.2.3, \u201cFOREIGN KEY Constraint Differences\u201d.\n\n\n\nreference_option\n\n          For information about the RESTRICT,\n          CASCADE, SET NULL,\n          NO ACTION, and SET\n          DEFAULT options, see\n          Section\u00a015.1.20.5, \u201cFOREIGN KEY Constraints\u201d.\n\n"
            ]
        },
        {
            "Sub-title": "Table Options",
            "Illustration": [
                "\n      Table options are used to optimize the behavior of the table. In\n      most cases, you do not have to specify any of them. These options\n      apply to all storage engines unless otherwise indicated. Options\n      that do not apply to a given storage engine may be accepted and\n      remembered as part of the table definition. Such options then\n      apply if you later use ALTER TABLE\n      to convert the table to use a different storage engine.\n",
                "\n\nENGINE\n\n          Specifies the storage engine for the table, using one of the\n          names shown in the following table. The engine name can be\n          unquoted or quoted. The quoted name\n          'DEFAULT' is recognized but ignored.\n\n\n\nStorage Engine\nDescription\n\nInnoDB\nTransaction-safe tables with row locking and foreign keys. The default\n                storage engine for new tables. See\n                Chapter\u00a017, The InnoDB Storage Engine, and in\n                particular Section\u00a017.1, \u201cIntroduction to InnoDB\u201d if you\n                have MySQL experience but are new to\n                InnoDB.\n\nMyISAM\nThe binary portable storage engine that is primarily used for read-only\n                or read-mostly workloads. See\n                Section\u00a018.2, \u201cThe MyISAM Storage Engine\u201d.\n\nMEMORY\nThe data for this storage engine is stored only in memory. See\n                Section\u00a018.3, \u201cThe MEMORY Storage Engine\u201d.\n\nCSV\nTables that store rows in comma-separated values format. See\n                Section\u00a018.4, \u201cThe CSV Storage Engine\u201d.\n\nARCHIVE\nThe archiving storage engine. See\n                Section\u00a018.5, \u201cThe ARCHIVE Storage Engine\u201d.\n\nEXAMPLE\nAn example engine. See Section\u00a018.9, \u201cThe EXAMPLE Storage Engine\u201d.\n\nFEDERATED\nStorage engine that accesses remote tables. See\n                Section\u00a018.8, \u201cThe FEDERATED Storage Engine\u201d.\n\nHEAP\nThis is a synonym for MEMORY.\n\nMERGE\nA collection of MyISAM tables used as one table. Also\n                known as MRG_MyISAM. See\n                Section\u00a018.7, \u201cThe MERGE Storage Engine\u201d.\n\nNDB\nClustered, fault-tolerant, memory-based tables, supporting transactions\n                and foreign keys. Also known as\n                NDBCLUSTER. See\n                Chapter\u00a025, MySQL NDB Cluster 8.4.\n\n\nStorage Engine\nDescription\n\n\n          By default, if a storage engine is specified that is not\n          available, the statement fails with an error. You can override\n          this behavior by removing\n          NO_ENGINE_SUBSTITUTION from\n          the server SQL mode (see Section\u00a07.1.11, \u201cServer SQL Modes\u201d) so that\n          MySQL allows substitution of the specified engine with the\n          default storage engine instead. Normally in such cases, this\n          is InnoDB, which is the default value for\n          the default_storage_engine\n          system variable. When\n          NO_ENGINE_SUBSTITUTION is disabled, a\n          warning occurs if the storage engine specification is not\n          honored.\n        \nAUTOEXTEND_SIZE\n\n          Defines the amount by which InnoDB extends\n          the size of the tablespace when it becomes full. The setting\n          must be a multiple of 4MB. The default setting is 0, which\n          causes the tablespace to be extended according to the implicit\n          default behavior. For more information, see\n          Section\u00a017.6.3.9, \u201cTablespace AUTOEXTEND_SIZE Configuration\u201d.\n        \nAUTO_INCREMENT\n\n          The initial AUTO_INCREMENT value for the\n          table. In MySQL 8.4, this works for\n          MyISAM, MEMORY,\n          InnoDB, and ARCHIVE\n          tables. To set the first auto-increment value for engines that\n          do not support the AUTO_INCREMENT table\n          option, insert a \u201cdummy\u201d row with a value one\n          less than the desired value after creating the table, and then\n          delete the dummy row.\n        \n          For engines that support the AUTO_INCREMENT\n          table option in CREATE TABLE\n          statements, you can also use ALTER TABLE\n          tbl_name AUTO_INCREMENT =\n          N to reset the\n          AUTO_INCREMENT value. The value cannot be\n          set lower than the maximum value currently in the column.\n        \nAVG_ROW_LENGTH\n\n          An approximation of the average row length for your table. You\n          need to set this only for large tables with variable-size\n          rows.\n        \n          When you create a MyISAM table, MySQL uses\n          the product of the MAX_ROWS and\n          AVG_ROW_LENGTH options to decide how big\n          the resulting table is. If you don't specify either option,\n          the maximum size for MyISAM data and index\n          files is 256TB by default. (If your operating system does not\n          support files that large, table sizes are constrained by the\n          file size limit.) If you want to keep down the pointer sizes\n          to make the index smaller and faster and you don't really need\n          big files, you can decrease the default pointer size by\n          setting the\n          myisam_data_pointer_size\n          system variable. (See\n          Section\u00a07.1.8, \u201cServer System Variables\u201d.) If you want all\n          your tables to be able to grow above the default limit and are\n          willing to have your tables slightly slower and larger than\n          necessary, you can increase the default pointer size by\n          setting this variable. Setting the value to 7 permits table\n          sizes up to 65,536TB.\n        \n[DEFAULT] CHARACTER SET\n\n          Specifies a default character set for the table.\n          CHARSET is a synonym for CHARACTER\n          SET. If the character set name is\n          DEFAULT, the database character set is\n          used.\n        \nCHECKSUM\n\n          Set this to 1 if you want MySQL to maintain a live checksum\n          for all rows (that is, a checksum that MySQL updates\n          automatically as the table changes). This makes the table a\n          little slower to update, but also makes it easier to find\n          corrupted tables. The CHECKSUM\n          TABLE statement reports the checksum.\n          (MyISAM only.)\n        \n[DEFAULT] COLLATE\n\n          Specifies a default collation for the table.\n        \nCOMMENT\n\n          A comment for the table, up to 2048 characters long.\n        \n          You can set the InnoDB\nMERGE_THRESHOLD value for a table using the\n          table_option\nCOMMENT clause. See\n          Section\u00a017.8.11, \u201cConfiguring the Merge Threshold for Index Pages\u201d.\n        Setting NDB_TABLE options.\u00a0\n\n\n            The table comment in a CREATE TABLE that\n            creates an NDB table or an\n            ALTER TABLE statement which\n            alters one can also be used to specify one to four of the\n            NDB_TABLE options\n            NOLOGGING,\n            READ_BACKUP,\n            PARTITION_BALANCE, or\n            FULLY_REPLICATED as a set of name-value\n            pairs, separated by commas if need be, immediately following\n            the string NDB_TABLE= that begins the\n            quoted comment text. An example statement using this syntax\n            is shown here (emphasized text):\n          Press CTRL+C to copy CREATE TABLE t1 (\n    c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    c2 VARCHAR(100),\n    c3 VARCHAR(100) )\nENGINE=NDB\nCOMMENT=\"NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE\";\n          Spaces are not permitted within the quoted string. The string\n          is case-insensitive.\n        \n          The comment is displayed as part of the output of\n          SHOW CREATE TABLE. The text of\n          the comment is also available as the TABLE_COMMENT column of\n          the MySQL Information Schema\n          TABLES table.\n        \n          This comment syntax is also supported with\n          ALTER TABLE statements for\n          NDB tables. Keep in mind that a table\n          comment used with ALTER TABLE replaces any\n          existing comment which the table might have had previously.\n        \n          Setting the MERGE_THRESHOLD option in table\n          comments is not supported for NDB\n          tables (it is ignored).\n        \n          For complete syntax information and examples, see\n          Section\u00a015.1.20.12, \u201cSetting NDB Comment Options\u201d.\n        \nCOMPRESSION\n\n          The compression algorithm used for page level compression for\n          InnoDB tables. Supported values include\n          Zlib, LZ4, and\n          None. The COMPRESSION\n          attribute was introduced with the transparent page compression\n          feature. Page compression is only supported with\n          InnoDB tables that reside in\n          file-per-table\n          tablespaces, and is only available on Linux and Windows\n          platforms that support sparse files and hole punching. For\n          more information, see\n          Section\u00a017.9.2, \u201cInnoDB Page Compression\u201d.\n        \nCONNECTION\n\n          The connection string for a FEDERATED\n          table.\n\n\n\nNote\n\n\n            Older versions of MySQL used a COMMENT\n            option for the connection string.\n\n\n\nDATA DIRECTORY, INDEX\n          DIRECTORY\n\n          For InnoDB, the DATA\n          DIRECTORY='directory'\n          clause permits creating tables outside of the data directory.\n          The innodb_file_per_table\n          variable must be enabled to use the DATA\n          DIRECTORY clause. The full directory path must be\n          specified, and known to InnoDB. For more\n          information, see\n          Section\u00a017.6.1.2, \u201cCreating Tables Externally\u201d.\n        \n          When creating MyISAM tables, you can use\n          the DATA\n          DIRECTORY='directory'\n          clause, the INDEX\n          DIRECTORY='directory'\n          clause, or both. They specify where to put a\n          MyISAM table's data file and index file,\n          respectively. Unlike InnoDB tables, MySQL\n          does not create subdirectories that correspond to the database\n          name when creating a MyISAM table with a\n          DATA DIRECTORY or INDEX\n          DIRECTORY option. Files are created in the directory\n          that is specified.\n        \n          You must have the FILE\n          privilege to use the DATA DIRECTORY or\n          INDEX DIRECTORY table option.\n\n\n\nImportant\n\n\n            Table-level DATA DIRECTORY and\n            INDEX DIRECTORY options are ignored for\n            partitioned tables. (Bug #32091)\n\n\n\n          These options work only when you are not using the\n          --skip-symbolic-links\n          option. Your operating system must also have a working,\n          thread-safe realpath() call. See\n          Section\u00a010.12.2.2, \u201cUsing Symbolic Links for MyISAM Tables on Unix\u201d, for more complete\n          information.\n        \n          If a MyISAM table is created with no\n          DATA DIRECTORY option, the\n          .MYD file is created in the database\n          directory. By default, if MyISAM finds an\n          existing .MYD file in this case, it\n          overwrites it. The same applies to .MYI\n          files for tables created with no INDEX\n          DIRECTORY option. To suppress this behavior, start\n          the server with the\n          --keep_files_on_create option,\n          in which case MyISAM does not overwrite\n          existing files and returns an error instead.\n        \n          If a MyISAM table is created with a\n          DATA DIRECTORY or INDEX\n          DIRECTORY option and an existing\n          .MYD or .MYI file is\n          found, MyISAM always returns an error, and\n          does not overwrite a file in the specified directory.\n\n\n\nImportant\n\n\n            You cannot use path names that contain the MySQL data\n            directory with DATA DIRECTORY or\n            INDEX DIRECTORY. This includes\n            partitioned tables and individual table partitions. (See Bug\n            #32167.)\n\n\n\nDELAY_KEY_WRITE\n\n          Set this to 1 if you want to delay key updates for the table\n          until the table is closed. See the description of the\n          delay_key_write system\n          variable in Section\u00a07.1.8, \u201cServer System Variables\u201d.\n          (MyISAM only.)\n        \nENCRYPTION\n\n          The ENCRYPTION clause enables or disables\n          page-level data encryption for an InnoDB\n          table. A keyring plugin must be installed and configured\n          before encryption can be enabled. The\n          ENCRYPTION clause can be specified when\n          creating a table in an a file-per-table tablespace, or when\n          creating a table in a general tablespace.\n        \n          A table inherits the default schema encryption if an\n          ENCRYPTION clause is not specified. If the\n          table_encryption_privilege_check\n          variable is enabled, the\n          TABLE_ENCRYPTION_ADMIN\n          privilege is required to create a table with an\n          ENCRYPTION clause setting that differs from\n          the default schema encryption. When creating a table in a\n          general tablespace, table and tablespace encryption must\n          match.\n        \n          Specifying an ENCRYPTION clause with a\n          value other than 'N' or\n          '' is not permitted when using a storage\n          engine that does not support encryption.\n        \n          For more information, see\n          Section\u00a017.13, \u201cInnoDB Data-at-Rest Encryption\u201d.\n        \n          The ENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE options are used\n          to specify table attributes for primary and secondary storage\n          engines. The options are reserved for future use.\n        \n          The value assigned to either of these options must be a string\n          literal containing a valid JSON document or an empty string\n          (''). Invalid JSON is rejected.\n        Press CTRL+C to copy CREATE TABLE t1 (c1 INT) ENGINE_ATTRIBUTE='{\"key\":\"value\"}';\nENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE values can be\n          repeated without error. In this case, the last specified value\n          is used.\n        \nENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE values are not\n          checked by the server, nor are they cleared when the\n          table's storage engine is changed.\n        \nINSERT_METHOD\n\n          If you want to insert data into a MERGE\n          table, you must specify with INSERT_METHOD\n          the table into which the row should be inserted.\n          INSERT_METHOD is an option useful for\n          MERGE tables only. Use a value of\n          FIRST or LAST to have\n          inserts go to the first or last table, or a value of\n          NO to prevent inserts. See\n          Section\u00a018.7, \u201cThe MERGE Storage Engine\u201d.\n        \nKEY_BLOCK_SIZE\n\n          For MyISAM tables,\n          KEY_BLOCK_SIZE optionally specifies the\n          size in bytes to use for index key blocks. The value is\n          treated as a hint; a different size could be used if\n          necessary. A KEY_BLOCK_SIZE value specified\n          for an individual index definition overrides the table-level\n          KEY_BLOCK_SIZE value.\n        \n          For InnoDB tables,\n          KEY_BLOCK_SIZE specifies the\n          page size in kilobytes to use\n          for compressed\nInnoDB tables. The\n          KEY_BLOCK_SIZE value is treated as a hint;\n          a different size could be used by InnoDB if\n          necessary. KEY_BLOCK_SIZE can only be less\n          than or equal to the\n          innodb_page_size value. A\n          value of 0 represents the default compressed page size, which\n          is half of the\n          innodb_page_size value.\n          Depending on\n          innodb_page_size, possible\n          KEY_BLOCK_SIZE values include 0, 1, 2, 4,\n          8, and 16. See Section\u00a017.9.1, \u201cInnoDB Table Compression\u201d for\n          more information.\n        \n          Oracle recommends enabling\n          innodb_strict_mode when\n          specifying KEY_BLOCK_SIZE for\n          InnoDB tables. When\n          innodb_strict_mode is\n          enabled, specifying an invalid\n          KEY_BLOCK_SIZE value returns an error. If\n          innodb_strict_mode is\n          disabled, an invalid KEY_BLOCK_SIZE value\n          results in a warning, and the\n          KEY_BLOCK_SIZE option is ignored.\n        \n          The Create_options column in response to\n          SHOW TABLE STATUS reports the\n          actual KEY_BLOCK_SIZE used by the table, as\n          does SHOW CREATE TABLE.\n        \nInnoDB only supports\n          KEY_BLOCK_SIZE at the table level.\n        \nKEY_BLOCK_SIZE is not supported with 32KB\n          and 64KB innodb_page_size\n          values. InnoDB table compression does not\n          support these pages sizes.\n        \nInnoDB does not support the\n          KEY_BLOCK_SIZE option when creating\n          temporary tables.\n        \nMAX_ROWS\n\n          The maximum number of rows you plan to store in the table.\n          This is not a hard limit, but rather a hint to the storage\n          engine that the table must be able to store at least this many\n          rows.\n\n\n\nImportant\n\n\n            The use of MAX_ROWS with\n            NDB tables to control the number of table\n            partitions is deprecated. It remains supported in later\n            versions for backward compatibility, but is subject to\n            removal in a future release. Use PARTITION_BALANCE instead;\n            see\n            Setting NDB_TABLE options.\n\n\n\n          The NDB storage engine treats\n          this value as a maximum. If you plan to create very large NDB\n          Cluster tables (containing millions of rows), you should use\n          this option to insure that NDB\n          allocates sufficient number of index slots in the hash table\n          used for storing hashes of the table's primary keys by\n          setting MAX_ROWS = 2 *\n          rows, where\n          rows is the number of rows that you\n          expect to insert into the table.\n        \n          The maximum MAX_ROWS value is 4294967295;\n          larger values are truncated to this limit.\n        \nMIN_ROWS\n\n          The minimum number of rows you plan to store in the table. The\n          MEMORY storage engine uses this\n          option as a hint about memory use.\n        \nPACK_KEYS\n\n          Takes effect only with MyISAM tables. Set\n          this option to 1 if you want to have smaller indexes. This\n          usually makes updates slower and reads faster. Setting the\n          option to 0 disables all packing of keys. Setting it to\n          DEFAULT tells the storage engine to pack\n          only long CHAR,\n          VARCHAR,\n          BINARY, or\n          VARBINARY columns.\n        \n          If you do not use PACK_KEYS, the default is\n          to pack strings, but not numbers. If you use\n          PACK_KEYS=1, numbers are packed as well.\n        \n          When packing binary number keys, MySQL uses prefix\n          compression:\n\n\n\n              Every key needs one extra byte to indicate how many bytes\n              of the previous key are the same for the next key.\n            \n              The pointer to the row is stored in high-byte-first order\n              directly after the key, to improve compression.\n\n\n\n          This means that if you have many equal keys on two consecutive\n          rows, all following \u201csame\u201d keys usually only take\n          two bytes (including the pointer to the row). Compare this to\n          the ordinary case where the following keys takes\n          storage_size_for_key + pointer_size (where\n          the pointer size is usually 4). Conversely, you get a\n          significant benefit from prefix compression only if you have\n          many numbers that are the same. If all keys are totally\n          different, you use one byte more per key, if the key is not a\n          key that can have NULL values. (In this\n          case, the packed key length is stored in the same byte that is\n          used to mark if a key is NULL.)\n        \nPASSWORD\n\n          This option is unused.\n        \nROW_FORMAT\n\n          Defines the physical format in which the rows are stored.\n        \n          When creating a table with\n          strict mode disabled,\n          the storage engine's default row format is used if the\n          specified row format is not supported. The actual row format\n          of the table is reported in the Row_format\n          column in response to SHOW TABLE\n          STATUS. The Create_options column\n          shows the row format that was specified in the\n          CREATE TABLE statement, as does\n          SHOW CREATE TABLE.\n        \n          Row format choices differ depending on the storage engine used\n          for the table.\n        \n          For InnoDB tables:\n\n\n\n              The default row format is defined by\n              innodb_default_row_format,\n              which has a default setting of DYNAMIC.\n              The default row format is used when the\n              ROW_FORMAT option is not defined or\n              when ROW_FORMAT=DEFAULT is used.\n            \n              If the ROW_FORMAT option is not\n              defined, or if ROW_FORMAT=DEFAULT is\n              used, operations that rebuild a table also silently change\n              the row format of the table to the default defined by\n              innodb_default_row_format.\n              For more information, see\n              Defining the Row Format of a Table.\n            \n              For more efficient InnoDB storage of\n              data types, especially BLOB\n              types, use the DYNAMIC. See\n              DYNAMIC Row Format for\n              requirements associated with the\n              DYNAMIC row format.\n            \n              To enable compression for InnoDB\n              tables, specify ROW_FORMAT=COMPRESSED.\n              The ROW_FORMAT=COMPRESSED option is not\n              supported when creating temporary tables. See\n              Section\u00a017.9, \u201cInnoDB Table and Page Compression\u201d for requirements\n              associated with the COMPRESSED row\n              format.\n            \n              The row format used in older versions of MySQL can still\n              be requested by specifying the\n              REDUNDANT row format.\n            \n              When you specify a non-default\n              ROW_FORMAT clause, consider also\n              enabling the\n              innodb_strict_mode\n              configuration option.\n            \nROW_FORMAT=FIXED is not supported. If\n              ROW_FORMAT=FIXED is specified while\n              innodb_strict_mode is\n              disabled, InnoDB issues a warning and\n              assumes ROW_FORMAT=DYNAMIC. If\n              ROW_FORMAT=FIXED is specified while\n              innodb_strict_mode is\n              enabled, which is the default, InnoDB\n              returns an error.\n            \n              For additional information about InnoDB\n              row formats, see Section\u00a017.10, \u201cInnoDB Row Formats\u201d.\n\n\n\n          For MyISAM tables, the option value can be\n          FIXED or DYNAMIC for\n          static or variable-length row format.\n          myisampack sets the type to\n          COMPRESSED. See\n          Section\u00a018.2.3, \u201cMyISAM Table Storage Formats\u201d.\n        \n          For NDB tables, the default\n          ROW_FORMAT is DYNAMIC.\n        \nSTART TRANSACTION\n\n          This is an internal-use table option, used to permit\n          CREATE TABLE ... SELECT to be logged as a\n          single, atomic transaction in the binary log when using\n          row-based replication with a storage engine that supports\n          atomic DDL. Only BINLOG,\n          COMMIT, and\n          ROLLBACK\n          statements are permitted after CREATE TABLE ... START\n          TRANSACTION. For related information, see\n          Section\u00a015.1.1, \u201cAtomic Data Definition Statement Support\u201d.\n        \nSTATS_AUTO_RECALC\n\n          Specifies whether to automatically recalculate\n          persistent\n          statistics for an InnoDB table. The\n          value DEFAULT causes the persistent\n          statistics setting for the table to be determined by the\n          innodb_stats_auto_recalc\n          configuration option. The value 1 causes\n          statistics to be recalculated when 10% of the data in the\n          table has changed. The value 0 prevents\n          automatic recalculation for this table; with this setting,\n          issue an ANALYZE TABLE\n          statement to recalculate the statistics after making\n          substantial changes to the table. For more information about\n          the persistent statistics feature, see\n          Section\u00a017.8.10.1, \u201cConfiguring Persistent Optimizer Statistics Parameters\u201d.\n        \nSTATS_PERSISTENT\n\n          Specifies whether to enable\n          persistent\n          statistics for an InnoDB table. The\n          value DEFAULT causes the persistent\n          statistics setting for the table to be determined by the\n          innodb_stats_persistent\n          configuration option. The value 1 enables\n          persistent statistics for the table, while the value\n          0 turns off this feature. After enabling\n          persistent statistics through a CREATE\n          TABLE or ALTER TABLE statement,\n          issue an ANALYZE TABLE\n          statement to calculate the statistics, after loading\n          representative data into the table. For more information about\n          the persistent statistics feature, see\n          Section\u00a017.8.10.1, \u201cConfiguring Persistent Optimizer Statistics Parameters\u201d.\n        \nSTATS_SAMPLE_PAGES\n\n          The number of index pages to sample when estimating\n          cardinality and other statistics for an indexed column, such\n          as those calculated by ANALYZE\n          TABLE. For more information, see\n          Section\u00a017.8.10.1, \u201cConfiguring Persistent Optimizer Statistics Parameters\u201d.\n        \nTABLESPACE\n\n          The TABLESPACE clause can be used to create\n          an InnoDB table in an existing\n          general tablespace, a file-per-table tablespace, or the system\n          tablespace.\n        Press CTRL+C to copy CREATE TABLE tbl_name ... TABLESPACE [=] tablespace_name\n          The general tablespace that you specify must exist prior to\n          using the TABLESPACE clause. For\n          information about general tablespaces, see\n          Section\u00a017.6.3.3, \u201cGeneral Tablespaces\u201d.\n        \n          The\n          tablespace_name\n          is a case-sensitive identifier. It may be quoted or unquoted.\n          The forward slash character (\u201c/\u201d) is not\n          permitted. Names beginning with \u201cinnodb_\u201d are\n          reserved for special use.\n        \n          To create a table in the system tablespace, specify\n          innodb_system as the tablespace name.\n        Press CTRL+C to copy CREATE TABLE tbl_name ... TABLESPACE [=] innodb_system\n          Using TABLESPACE [=] innodb_system, you can\n          place a table of any uncompressed row format in the system\n          tablespace regardless of the\n          innodb_file_per_table\n          setting. For example, you can add a table with\n          ROW_FORMAT=DYNAMIC to the system tablespace\n          using TABLESPACE [=] innodb_system.\n        \n          To create a table in a file-per-table tablespace, specify\n          innodb_file_per_table as the tablespace\n          name.\nPress CTRL+C to copy CREATE TABLE tbl_name ... TABLESPACE [=] innodb_file_per_table\n\n\nNote\n\n\n            If innodb_file_per_table is\n            enabled, you need not specify\n            TABLESPACE=innodb_file_per_table to\n            create an InnoDB file-per-table\n            tablespace. InnoDB tables are created in\n            file-per-table tablespaces by default when\n            innodb_file_per_table is\n            enabled.\n\n\n\n          The DATA DIRECTORY clause is permitted with\n          CREATE TABLE ...\n          TABLESPACE=innodb_file_per_table but is otherwise\n          not supported for use in combination with the\n          TABLESPACE clause. The directory specified\n          in a DATA DIRECTORY clause must be known to\n          InnoDB. For more information, see\n          Using the DATA DIRECTORY Clause.\n\n\n\nNote\n\n\n            Support for TABLESPACE =\n            innodb_file_per_table and TABLESPACE =\n            innodb_temporary clauses with\n            CREATE\n            TEMPORARY TABLE is deprecated; expect it to be\n            removed in a future version of MySQL.\n\n\n\n          The STORAGE table option is employed only\n          with NDB tables.\n          STORAGE determines the type of storage\n          used, and can be either of DISK or\n          MEMORY.\n        \nTABLESPACE ... STORAGE DISK assigns a table\n          to an NDB Cluster Disk Data tablespace. STORAGE\n          DISK cannot be used in CREATE\n          TABLE unless preceded by\n          TABLESPACE\ntablespace_name.\n        \n          For STORAGE MEMORY, the tablespace name is\n          optional, thus, you can use TABLESPACE\n          tablespace_name STORAGE\n          MEMORY or simply STORAGE MEMORY\n          to specify explicitly that the table is in-memory.\n        \n          See Section\u00a025.6.11, \u201cNDB Cluster Disk Data Tables\u201d, for more\n          information.\n        \nUNION\n\n          Used to access a collection of identical\n          MyISAM tables as one. This works only with\n          MERGE tables. See\n          Section\u00a018.7, \u201cThe MERGE Storage Engine\u201d.\n        \n          You must have SELECT,\n          UPDATE, and\n          DELETE privileges for the\n          tables you map to a MERGE table.\n\n\n\nNote\n\n\n            Formerly, all tables used had to be in the same database as\n            the MERGE table itself. This restriction\n            no longer applies.\n\n\n\n"
            ]
        },
        {
            "Sub-title": "Table Partitioning",
            "Illustration": [
                "\npartition_options can be used to\n      control partitioning of the table created with\n      CREATE TABLE.\n    ",
                "\n      Not all options shown in the syntax for\n      partition_options at the beginning of\n      this section are available for all partitioning types. Please see\n      the listings for the following individual types for information\n      specific to each type, and see Chapter\u00a026, Partitioning, for\n      more complete information about the workings of and uses for\n      partitioning in MySQL, as well as additional examples of table\n      creation and other statements relating to MySQL partitioning.\n    ",
                "\n      Partitions can be modified, merged, added to tables, and dropped\n      from tables. For basic information about the MySQL statements to\n      accomplish these tasks, see Section\u00a015.1.9, \u201cALTER TABLE Statement\u201d. For\n      more detailed descriptions and examples, see\n      Section\u00a026.3, \u201cPartition Management\u201d.\n",
                "\n\nPARTITION BY\n\n          If used, a partition_options clause\n          begins with PARTITION BY. This clause\n          contains the function that is used to determine the partition;\n          the function returns an integer value ranging from 1 to\n          num, where\n          num is the number of partitions.\n          (The maximum number of user-defined partitions which a table\n          may contain is 1024; the number of\n          subpartitions\u2014discussed later in this section\u2014is\n          included in this maximum.)\n\n\n\nNote\n\n\n            The expression (expr) used in a\n            PARTITION BY clause cannot refer to any\n            columns not in the table being created; such references are\n            specifically not permitted and cause the statement to fail\n            with an error. (Bug #29444)\n\n\n\nHASH(expr)\n\n          Hashes one or more columns to create a key for placing and\n          locating rows. expr is an\n          expression using one or more table columns. This can be any\n          valid MySQL expression (including MySQL functions) that yields\n          a single integer value. For example, these are both valid\n          CREATE TABLE statements using\n          PARTITION BY HASH:\n        Press CTRL+C to copy CREATE TABLE t1 (col1 INT, col2 CHAR(5))\n    PARTITION BY HASH(col1);\n\nCREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)\n    PARTITION BY HASH ( YEAR(col3) );\n          You may not use either VALUES LESS THAN or\n          VALUES IN clauses with PARTITION\n          BY HASH.\n        \nPARTITION BY HASH uses the remainder of\n          expr divided by the number of\n          partitions (that is, the modulus). For examples and additional\n          information, see Section\u00a026.2.4, \u201cHASH Partitioning\u201d.\n        \n          The LINEAR keyword entails a somewhat\n          different algorithm. In this case, the number of the partition\n          in which a row is stored is calculated as the result of one or\n          more logical AND operations. For\n          discussion and examples of linear hashing, see\n          Section\u00a026.2.4.1, \u201cLINEAR HASH Partitioning\u201d.\n        \nKEY(column_list)\n\n          This is similar to HASH, except that MySQL\n          supplies the hashing function so as to guarantee an even data\n          distribution. The column_list\n          argument is simply a list of 1 or more table columns (maximum:\n          16). This example shows a simple table partitioned by key,\n          with 4 partitions:\n        Press CTRL+C to copy CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)\n    PARTITION BY KEY(col3)\n    PARTITIONS 4;\n          For tables that are partitioned by key, you can employ linear\n          partitioning by using the LINEAR keyword.\n          This has the same effect as with tables that are partitioned\n          by HASH. That is, the partition number is\n          found using the\n          &\n          operator rather than the modulus (see\n          Section\u00a026.2.4.1, \u201cLINEAR HASH Partitioning\u201d, and\n          Section\u00a026.2.5, \u201cKEY Partitioning\u201d, for details). This example\n          uses linear partitioning by key to distribute data between 5\n          partitions:\n        Press CTRL+C to copy CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)\n    PARTITION BY LINEAR KEY(col3)\n    PARTITIONS 5;\n          The ALGORITHM={1 | 2} option is supported\n          with [SUB]PARTITION BY [LINEAR] KEY.\n          ALGORITHM=1 causes the server to use the\n          same key-hashing functions as MySQL 5.1;\n          ALGORITHM=2 means that the server employs\n          the key-hashing functions implemented and used by default for\n          new KEY partitioned tables in MySQL 5.5 and\n          later. (Partitioned tables created with the key-hashing\n          functions employed in MySQL 5.5 and later cannot be used by a\n          MySQL 5.1 server.) Not specifying the option has the same\n          effect as using ALGORITHM=2. This option is\n          intended for use chiefly when upgrading or downgrading\n          [LINEAR] KEY partitioned tables between\n          MySQL 5.1 and later MySQL versions, or for creating tables\n          partitioned by KEY or LINEAR\n          KEY on a MySQL 5.5 or later server which can be used\n          on a MySQL 5.1 server. For more information, see\n          Section\u00a015.1.9.1, \u201cALTER TABLE Partition Operations\u201d.\n        \nmysqldump writes this option encased in\n          versioned comments.\n        \nALGORITHM=1 is shown when necessary in the\n          output of SHOW CREATE TABLE\n          using versioned comments in the same manner as\n          mysqldump. ALGORITHM=2\n          is always omitted from SHOW CREATE TABLE\n          output, even if this option was specified when creating the\n          original table.\n        \n          You may not use either VALUES LESS THAN or\n          VALUES IN clauses with PARTITION\n          BY KEY.\n        \nRANGE(expr)\n\n          In this case, expr shows a range of\n          values using a set of VALUES LESS THAN\n          operators. When using range partitioning, you must define at\n          least one partition using VALUES LESS THAN.\n          You cannot use VALUES IN with range\n          partitioning.\n\n\n\nNote\n\n\n            For tables partitioned by RANGE,\n            VALUES LESS THAN must be used with either\n            an integer literal value or an expression that evaluates to\n            a single integer value. In MySQL 8.4, you can\n            overcome this limitation in a table that is defined using\n            PARTITION BY RANGE COLUMNS, as described\n            later in this section.\n\n\n\n          Suppose that you have a table that you wish to partition on a\n          column containing year values, according to the following\n          scheme.\n\n\n\nPartition Number:\nYears Range:\n\n0\n1990 and earlier\n\n1\n1991 to 1994\n\n2\n1995 to 1998\n\n3\n1999 to 2002\n\n4\n2003 to 2005\n\n5\n2006 and later\n\n\n\n          A table implementing such a partitioning scheme can be\n          realized by the CREATE TABLE\n          statement shown here:\n        Press CTRL+C to copy CREATE TABLE t1 (\n    year_col  INT,\n    some_data INT\n)\nPARTITION BY RANGE (year_col) (\n    PARTITION p0 VALUES LESS THAN (1991),\n    PARTITION p1 VALUES LESS THAN (1995),\n    PARTITION p2 VALUES LESS THAN (1999),\n    PARTITION p3 VALUES LESS THAN (2002),\n    PARTITION p4 VALUES LESS THAN (2006),\n    PARTITION p5 VALUES LESS THAN MAXVALUE\n);\nPARTITION ... VALUES LESS THAN ...\n          statements work in a consecutive fashion. VALUES LESS\n          THAN MAXVALUE works to specify\n          \u201cleftover\u201d values that are greater than the\n          maximum value otherwise specified.\n        \nVALUES LESS THAN clauses work sequentially\n          in a manner similar to that of the case\n          portions of a switch ... case block (as\n          found in many programming languages such as C, Java, and PHP).\n          That is, the clauses must be arranged in such a way that the\n          upper limit specified in each successive VALUES LESS\n          THAN is greater than that of the previous one, with\n          the one referencing MAXVALUE coming last of\n          all in the list.\n        \nRANGE\n          COLUMNS(column_list)\n\n          This variant on RANGE facilitates partition\n          pruning for queries using range conditions on multiple columns\n          (that is, having conditions such as WHERE a = 1 AND b\n          < 10 or WHERE a = 1 AND b = 10 AND c\n          < 10). It enables you to specify value ranges in\n          multiple columns by using a list of columns in the\n          COLUMNS clause and a set of column values\n          in each PARTITION ... VALUES LESS THAN\n          (value_list) partition\n          definition clause. (In the simplest case, this set consists of\n          a single column.) The maximum number of columns that can be\n          referenced in the column_list and\n          value_list is 16.\n        \n          The column_list used in the\n          COLUMNS clause may contain only names of\n          columns; each column in the list must be one of the following\n          MySQL data types: the integer types; the string types; and\n          time or date column types. Columns using\n          BLOB, TEXT,\n          SET, ENUM,\n          BIT, or spatial data types are not\n          permitted; columns that use floating-point number types are\n          also not permitted. You also may not use functions or\n          arithmetic expressions in the COLUMNS\n          clause.\n        \n          The VALUES LESS THAN clause used in a\n          partition definition must specify a literal value for each\n          column that appears in the COLUMNS()\n          clause; that is, the list of values used for each\n          VALUES LESS THAN clause must contain the\n          same number of values as there are columns listed in the\n          COLUMNS clause. An attempt to use more or\n          fewer values in a VALUES LESS THAN clause\n          than there are in the COLUMNS clause causes\n          the statement to fail with the error Inconsistency\n          in usage of column lists for partitioning.... You\n          cannot use NULL for any value appearing in\n          VALUES LESS THAN. It is possible to use\n          MAXVALUE more than once for a given column\n          other than the first, as shown in this example:\n        Press CTRL+C to copy CREATE TABLE rc (\n    a INT NOT NULL,\n    b INT NOT NULL\n)\nPARTITION BY RANGE COLUMNS(a,b) (\n    PARTITION p0 VALUES LESS THAN (10,5),\n    PARTITION p1 VALUES LESS THAN (20,10),\n    PARTITION p2 VALUES LESS THAN (50,MAXVALUE),\n    PARTITION p3 VALUES LESS THAN (65,MAXVALUE),\n    PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)\n);\n          Each value used in a VALUES LESS THAN value\n          list must match the type of the corresponding column exactly;\n          no conversion is made. For example, you cannot use the string\n          '1' for a value that matches a column that\n          uses an integer type (you must use the numeral\n          1 instead), nor can you use the numeral\n          1 for a value that matches a column that\n          uses a string type (in such a case, you must use a quoted\n          string: '1').\n        \n          For more information, see\n          Section\u00a026.2.1, \u201cRANGE Partitioning\u201d, and\n          Section\u00a026.4, \u201cPartition Pruning\u201d.\n        \nLIST(expr)\n\n          This is useful when assigning partitions based on a table\n          column with a restricted set of possible values, such as a\n          state or country code. In such a case, all rows pertaining to\n          a certain state or country can be assigned to a single\n          partition, or a partition can be reserved for a certain set of\n          states or countries. It is similar to\n          RANGE, except that only VALUES\n          IN may be used to specify permissible values for\n          each partition.\n        \nVALUES IN is used with a list of values to\n          be matched. For instance, you could create a partitioning\n          scheme such as the following:\n        Press CTRL+C to copy CREATE TABLE client_firms (\n    id   INT,\n    name VARCHAR(35)\n)\nPARTITION BY LIST (id) (\n    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),\n    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),\n    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),\n    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)\n);\n          When using list partitioning, you must define at least one\n          partition using VALUES IN. You cannot use\n          VALUES LESS THAN with PARTITION BY\n          LIST.\n\n\n\nNote\n\n\n            For tables partitioned by LIST, the value\n            list used with VALUES IN must consist of\n            integer values only. In MySQL 8.4, you can\n            overcome this limitation using partitioning by LIST\n            COLUMNS, which is described later in this section.\n\n\n\nLIST\n          COLUMNS(column_list)\n\n          This variant on LIST facilitates partition\n          pruning for queries using comparison conditions on multiple\n          columns (that is, having conditions such as WHERE a =\n          5 AND b = 5 or WHERE a = 1 AND b = 10 AND c\n          = 5). It enables you to specify values in multiple\n          columns by using a list of columns in the\n          COLUMNS clause and a set of column values\n          in each PARTITION ... VALUES IN\n          (value_list) partition\n          definition clause.\n        \n          The rules governing regarding data types for the column list\n          used in LIST\n          COLUMNS(column_list) and\n          the value list used in VALUES\n          IN(value_list) are the\n          same as those for the column list used in RANGE\n          COLUMNS(column_list) and\n          the value list used in VALUES LESS\n          THAN(value_list),\n          respectively, except that in the VALUES IN\n          clause, MAXVALUE is not permitted, and you\n          may use NULL.\n        \n          There is one important difference between the list of values\n          used for VALUES IN with PARTITION\n          BY LIST COLUMNS as opposed to when it is used with\n          PARTITION BY LIST. When used with\n          PARTITION BY LIST COLUMNS, each element in\n          the VALUES IN clause must be a\n          set of column values; the number of\n          values in each set must be the same as the number of columns\n          used in the COLUMNS clause, and the data\n          types of these values must match those of the columns (and\n          occur in the same order). In the simplest case, the set\n          consists of a single column. The maximum number of columns\n          that can be used in the column_list\n          and in the elements making up the\n          value_list is 16.\n        \n          The table defined by the following CREATE\n          TABLE statement provides an example of a table using\n          LIST COLUMNS partitioning:\n        Press CTRL+C to copy CREATE TABLE lc (\n    a INT NULL,\n    b INT NULL\n)\nPARTITION BY LIST COLUMNS(a,b) (\n    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),\n    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),\n    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),\n    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )\n);\nPARTITIONS num\n\n          The number of partitions may optionally be specified with a\n          PARTITIONS num\n          clause, where num is the number of\n          partitions. If both this clause and any\n          PARTITION clauses are used,\n          num must be equal to the total\n          number of any partitions that are declared using\n          PARTITION clauses.\n\n\n\nNote\n\n\n            Whether or not you use a PARTITIONS\n            clause in creating a table that is partitioned by\n            RANGE or LIST, you\n            must still include at least one PARTITION\n            VALUES clause in the table definition (see below).\n\n\n\nSUBPARTITION BY\n\n          A partition may optionally be divided into a number of\n          subpartitions. This can be indicated by using the optional\n          SUBPARTITION BY clause. Subpartitioning may\n          be done by HASH or KEY.\n          Either of these may be LINEAR. These work\n          in the same way as previously described for the equivalent\n          partitioning types. (It is not possible to subpartition by\n          LIST or RANGE.)\n        \n          The number of subpartitions can be indicated using the\n          SUBPARTITIONS keyword followed by an\n          integer value.\n        \n          Rigorous checking of the value used in\n          PARTITIONS or\n          SUBPARTITIONS clauses is applied and this\n          value must adhere to the following rules:\n\n\n\n              The value must be a positive, nonzero integer.\n            \n              No leading zeros are permitted.\n            \n              The value must be an integer literal, and cannot not be an\n              expression. For example, PARTITIONS\n              0.2E+01 is not permitted, even though\n              0.2E+01 evaluates to\n              2. (Bug #15890)\n\n\n\npartition_definition\n\n          Each partition may be individually defined using a\n          partition_definition clause. The\n          individual parts making up this clause are as follows:\n\n\n\nPARTITION\n              partition_name\n\n              Specifies a logical name for the partition.\n            \nVALUES\n\n              For range partitioning, each partition must include a\n              VALUES LESS THAN clause; for list\n              partitioning, you must specify a VALUES\n              IN clause for each partition. This is used to\n              determine which rows are to be stored in this partition.\n              See the discussions of partitioning types in\n              Chapter\u00a026, Partitioning, for syntax examples.\n            \n[STORAGE] ENGINE\n\n              MySQL accepts a [STORAGE] ENGINE option\n              for both PARTITION and\n              SUBPARTITION. Currently, the only way\n              in which this option can be used is to set all partitions\n              or all subpartitions to the same storage engine, and an\n              attempt to set different storage engines for partitions or\n              subpartitions in the same table raises the error\n              ERROR 1469 (HY000): The mix of handlers in the\n              partitions is not permitted in this version of\n              MySQL.\n            \nCOMMENT\n\n              An optional COMMENT clause may be used\n              to specify a string that describes the partition. Example:\n            Press CTRL+C to copy COMMENT = 'Data for the years previous to 1999'\n              The maximum length for a partition comment is 1024\n              characters.\n            \nDATA DIRECTORY and INDEX\n              DIRECTORY\n\nDATA DIRECTORY and INDEX\n              DIRECTORY may be used to indicate the directory\n              where, respectively, the data and indexes for this\n              partition are to be stored. Both the\n              data_dir\n              and the\n              index_dir\n              must be absolute system path names.\n            \n              The directory specified in a DATA\n              DIRECTORY clause must be known to\n              InnoDB. For more information, see\n              Using the DATA DIRECTORY Clause.\n            \n              You must have the FILE\n              privilege to use the DATA DIRECTORY or\n              INDEX DIRECTORY partition option.\n            \n              Example:\n            Press CTRL+C to copy CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)\nPARTITION BY LIST(YEAR(adate))\n(\n  PARTITION p1999 VALUES IN (1995, 1999, 2003)\n    DATA DIRECTORY = '/var/appdata/95/data'\n    INDEX DIRECTORY = '/var/appdata/95/idx',\n  PARTITION p2000 VALUES IN (1996, 2000, 2004)\n    DATA DIRECTORY = '/var/appdata/96/data'\n    INDEX DIRECTORY = '/var/appdata/96/idx',\n  PARTITION p2001 VALUES IN (1997, 2001, 2005)\n    DATA DIRECTORY = '/var/appdata/97/data'\n    INDEX DIRECTORY = '/var/appdata/97/idx',\n  PARTITION p2002 VALUES IN (1998, 2002, 2006)\n    DATA DIRECTORY = '/var/appdata/98/data'\n    INDEX DIRECTORY = '/var/appdata/98/idx'\n);\nDATA DIRECTORY and INDEX\n              DIRECTORY behave in the same way as in the\n              CREATE TABLE\n              statement's table_option\n              clause as used for MyISAM tables.\n            \n              One data directory and one index directory may be\n              specified per partition. If left unspecified, the data and\n              indexes are stored by default in the table's database\n              directory.\n            \n              The DATA DIRECTORY and INDEX\n              DIRECTORY options are ignored for creating\n              partitioned tables if\n              NO_DIR_IN_CREATE is in\n              effect.\n            \nMAX_ROWS and\n              MIN_ROWS\n\n              May be used to specify, respectively, the maximum and\n              minimum number of rows to be stored in the partition. The\n              values for max_number_of_rows\n              and min_number_of_rows must be\n              positive integers. As with the table-level options with\n              the same names, these act only as\n              \u201csuggestions\u201d to the server and are not hard\n              limits.\n            \nTABLESPACE\n\n              May be used to designate an InnoDB\n              file-per-table tablespace for the partition by specifying\n              TABLESPACE `innodb_file_per_table`. All\n              partitions must belong to the same storage engine.\n            \n              Placing InnoDB table partitions in\n              shared InnoDB tablespaces is not\n              supported. Shared tablespaces include the\n              InnoDB system tablespace and general\n              tablespaces.\n\n\n\nsubpartition_definition\n\n          The partition definition may optionally contain one or more\n          subpartition_definition clauses.\n          Each of these consists at a minimum of the\n          SUBPARTITION\n          name, where\n          name is an identifier for the\n          subpartition. Except for the replacement of the\n          PARTITION keyword with\n          SUBPARTITION, the syntax for a subpartition\n          definition is identical to that for a partition definition.\n        \n          Subpartitioning must be done by HASH or\n          KEY, and can be done only on\n          RANGE or LIST\n          partitions. See Section\u00a026.2.6, \u201cSubpartitioning\u201d.\n\n",
                "\nPartitioning by Generated Columns\n",
                "\n      Partitioning by generated columns is permitted. For example:\n    ",
                "Press CTRL+C to copy CREATE TABLE t1 (\n  s1 INT,\n  s2 INT AS (EXP(s1)) STORED\n)\nPARTITION BY LIST (s2) (\n  PARTITION p1 VALUES IN (1)\n);",
                "\n      Partitioning sees a generated column as a regular column, which\n      enables workarounds for limitations on functions that are not\n      permitted for partitioning (see\n      Section\u00a026.6.3, \u201cPartitioning Limitations Relating to Functions\u201d). The\n      preceding example demonstrates this technique:\n      EXP() cannot be used directly in\n      the PARTITION BY clause, but a generated column\n      defined using EXP() is permitted.\n"
            ]
        }
    ],
    "Examples": [
        "CREATE TABLE new_tbl LIKE orig_tbl;",
        "CREATE TABLE new_tbl AS SELECT * FROM orig_tbl;",
        "CREATE TABLE t (c CHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin);",
        "CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));",
        "CREATE TABLE t1 (c1 INT ENGINE_ATTRIBUTE='{\"key\":\"value\"}');",
        "mysql> CREATE TABLE t1 (\n    ->     c1 INT STORAGE DISK,\n    ->     c2 INT STORAGE MEMORY\n    -> ) ENGINE NDB;\nERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)\n\nmysql> CREATE TABLE t1 (\n    ->     c1 INT STORAGE DISK,\n    ->     c2 INT STORAGE MEMORY\n    -> ) TABLESPACE ts_1 ENGINE NDB;\nQuery OK, 0 rows affected (1.06 sec)",
        "CREATE TABLE lookup\n  (id INT, INDEX USING BTREE (id)\n) ENGINE = MEMORY;",
        "CREATE TABLE t1 (\n    c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    c2 VARCHAR(100),\n    c3 VARCHAR(100) )\nENGINE=NDB\nCOMMENT=\"NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE\";",
        "CREATE TABLE t1 (c1 INT) ENGINE_ATTRIBUTE='{\"key\":\"value\"}';",
        "CREATE TABLE t1 (col1 INT, col2 CHAR(5))\n    PARTITION BY HASH(col1);\n\nCREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)\n    PARTITION BY HASH ( YEAR(col3) );",
        "CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)\n    PARTITION BY KEY(col3)\n    PARTITIONS 4;",
        "CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)\n    PARTITION BY LINEAR KEY(col3)\n    PARTITIONS 5;",
        "CREATE TABLE t1 (\n    year_col  INT,\n    some_data INT\n)\nPARTITION BY RANGE (year_col) (\n    PARTITION p0 VALUES LESS THAN (1991),\n    PARTITION p1 VALUES LESS THAN (1995),\n    PARTITION p2 VALUES LESS THAN (1999),\n    PARTITION p3 VALUES LESS THAN (2002),\n    PARTITION p4 VALUES LESS THAN (2006),\n    PARTITION p5 VALUES LESS THAN MAXVALUE\n);",
        "CREATE TABLE rc (\n    a INT NOT NULL,\n    b INT NOT NULL\n)\nPARTITION BY RANGE COLUMNS(a,b) (\n    PARTITION p0 VALUES LESS THAN (10,5),\n    PARTITION p1 VALUES LESS THAN (20,10),\n    PARTITION p2 VALUES LESS THAN (50,MAXVALUE),\n    PARTITION p3 VALUES LESS THAN (65,MAXVALUE),\n    PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)\n);",
        "CREATE TABLE client_firms (\n    id   INT,\n    name VARCHAR(35)\n)\nPARTITION BY LIST (id) (\n    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),\n    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),\n    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),\n    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)\n);",
        "CREATE TABLE lc (\n    a INT NULL,\n    b INT NULL\n)\nPARTITION BY LIST COLUMNS(a,b) (\n    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),\n    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),\n    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),\n    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )\n);",
        "CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)\nPARTITION BY LIST(YEAR(adate))\n(\n  PARTITION p1999 VALUES IN (1995, 1999, 2003)\n    DATA DIRECTORY = '/var/appdata/95/data'\n    INDEX DIRECTORY = '/var/appdata/95/idx',\n  PARTITION p2000 VALUES IN (1996, 2000, 2004)\n    DATA DIRECTORY = '/var/appdata/96/data'\n    INDEX DIRECTORY = '/var/appdata/96/idx',\n  PARTITION p2001 VALUES IN (1997, 2001, 2005)\n    DATA DIRECTORY = '/var/appdata/97/data'\n    INDEX DIRECTORY = '/var/appdata/97/idx',\n  PARTITION p2002 VALUES IN (1998, 2002, 2006)\n    DATA DIRECTORY = '/var/appdata/98/data'\n    INDEX DIRECTORY = '/var/appdata/98/idx'\n);",
        "CREATE TABLE t1 (\n  s1 INT,\n  s2 INT AS (EXP(s1)) STORED\n)\nPARTITION BY LIST (s2) (\n  PARTITION p1 VALUES IN (1)\n);"
    ],
    "Category": [
        "Data Definition Statements"
    ]
}