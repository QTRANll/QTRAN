{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/insert.html"
    ],
    "Title": [
        "15.2.7 INSERT Statement"
    ],
    "Feature": [
        "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    [(col_name [, col_name] ...)]\n    { {VALUES | VALUE} (value_list) [, (value_list)] ... }\n    [AS row_alias[(col_alias [, col_alias] ...)]]\n    [ON DUPLICATE KEY UPDATE assignment_list]\n\nINSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    SET assignment_list\n    [AS row_alias[(col_alias [, col_alias] ...)]]\n    [ON DUPLICATE KEY UPDATE assignment_list]\n\nINSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]\n    [INTO] tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    [(col_name [, col_name] ...)]\n    { SELECT ... \n      | TABLE table_name \n      | VALUES row_constructor_list\n    }\n    [ON DUPLICATE KEY UPDATE assignment_list]\n\nvalue:\n    {expr | DEFAULT}\n\nvalue_list:\n    value [, value] ...\n\nrow_constructor_list:\n    ROW(value_list)[, ROW(value_list)][, ...]\n\nassignment:\n    col_name = \n          value\n        | [row_alias.]col_name\n        | [tbl_name.]col_name\n        | [row_alias.]col_alias\n\nassignment_list:\n    assignment [, assignment] ..."
    ],
    "Description": [
        "\nINSERT inserts new rows into an\n      existing table. The INSERT\n      ... VALUES,\n      INSERT ... VALUES\n      ROW(), and\n      INSERT ... SET\n      forms of the statement insert rows based on explicitly specified\n      values. The INSERT\n      ... SELECT form inserts rows selected from another table\n      or tables. You can also use\n      INSERT ... TABLE\n      to insert rows from a single table.\n      INSERT with an ON\n      DUPLICATE KEY UPDATE clause enables existing rows to be\n      updated if a row to be inserted would cause a duplicate value in a\n      UNIQUE index or PRIMARY KEY.\n      A row alias with one or more optional column aliases can be used\n      with ON DUPLICATE KEY UPDATE to refer to the\n      row to be inserted.\n    ",
        "\n      For additional information about\n      INSERT ...\n      SELECT and\n      INSERT ... ON\n      DUPLICATE KEY UPDATE, see\n      Section\u00a015.2.7.1, \u201cINSERT ... SELECT Statement\u201d, and\n      Section\u00a015.2.7.2, \u201cINSERT ... ON DUPLICATE KEY UPDATE Statement\u201d.\n    ",
        "\n      In MySQL 8.4, the DELAYED keyword\n      is accepted but ignored by the server. For the reasons for this,\n      see Section\u00a015.2.7.3, \u201cINSERT DELAYED Statement\u201d,\n    ",
        "\n      Inserting into a table requires the\n      INSERT privilege for the table. If\n      the ON DUPLICATE KEY UPDATE clause is used and\n      a duplicate key causes an UPDATE to\n      be performed instead, the statement requires the\n      UPDATE privilege for the columns to\n      be updated. For columns that are read but not modified you need\n      only the SELECT privilege (such as\n      for a column referenced only on the right hand side of an\n      col_name=expr\n      assignment in an ON DUPLICATE KEY UPDATE\n      clause).\n    ",
        "\n      When inserting into a partitioned table, you can control which\n      partitions and subpartitions accept new rows. The\n      PARTITION clause takes a list of the\n      comma-separated names of one or more partitions or subpartitions\n      (or both) of the table. If any of the rows to be inserted by a\n      given INSERT statement do not match\n      one of the partitions listed, the\n      INSERT statement fails with the\n      error Found a row not matching the given partition\n      set. For more information and examples, see\n      Section\u00a026.5, \u201cPartition Selection\u201d.\n    ",
        "\ntbl_name is the table into which rows\n      should be inserted. Specify the columns for which the statement\n      provides values as follows:\n",
        "\n\n          Provide a parenthesized list of comma-separated column names\n          following the table name. In this case, a value for each named\n          column must be provided by the VALUES list,\n          VALUES ROW()\n          list, or SELECT statement. For\n          the INSERT TABLE form, the number of\n          columns in the source table must match the number of columns\n          to be inserted.\n        \n          If you do not specify a list of column names for\n          INSERT ...\n          VALUES or\n          INSERT ...\n          SELECT, values for every column in the table must be\n          provided by the VALUES list,\n          SELECT statement, or\n          TABLE statement. If you do not\n          know the order of the columns in the table, use\n          DESCRIBE\n          tbl_name to find out.\n        \n          A SET clause indicates columns explicitly\n          by name, together with the value to assign each one.\n\n",
        "\n      Column values can be given in several ways:\n",
        "\n\n          If strict SQL mode is not enabled, any column not explicitly\n          given a value is set to its default (explicit or implicit)\n          value. For example, if you specify a column list that does not\n          name all the columns in the table, unnamed columns are set to\n          their default values. Default value assignment is described in\n          Section\u00a013.6, \u201cData Type Default Values\u201d.\n        \n          If strict SQL mode is enabled, an\n          INSERT statement generates an\n          error if it does not specify an explicit value for every\n          column that has no default value. See\n          Section\u00a07.1.11, \u201cServer SQL Modes\u201d.\n        \n          If both the column list and the VALUES list\n          are empty, INSERT creates a row\n          with each column set to its default value:\n        Press CTRL+C to copy INSERT INTO tbl_name () VALUES();\n          If strict mode is not enabled, MySQL uses the implicit default\n          value for any column that has no explicitly defined default.\n          If strict mode is enabled, an error occurs if any column has\n          no default value.\n        \n          Use the keyword DEFAULT to set a column\n          explicitly to its default value. This makes it easier to write\n          INSERT statements that assign\n          values to all but a few columns, because it enables you to\n          avoid writing an incomplete VALUES list\n          that does not include a value for each column in the table.\n          Otherwise, you must provide the list of column names\n          corresponding to each value in the VALUES\n          list.\n        \n          If a generated column is inserted into explicitly, the only\n          permitted value is DEFAULT. For information\n          about generated columns, see\n          Section\u00a015.1.20.8, \u201cCREATE TABLE and Generated Columns\u201d.\n        \n          In expressions, you can use\n          DEFAULT(col_name)\n          to produce the default value for column\n          col_name.\n        \n          Type conversion of an expression\n          expr that provides a column value\n          might occur if the expression data type does not match the\n          column data type. Conversion of a given value can result in\n          different inserted values depending on the column type. For\n          example, inserting the string '1999.0e-2'\n          into an INT,\n          FLOAT,\n          DECIMAL(10,6), or\n          YEAR column inserts the value\n          1999, 19.9921,\n          19.992100, or 1999,\n          respectively. The value stored in the\n          INT and\n          YEAR columns is\n          1999 because the string-to-number\n          conversion looks only at as much of the initial part of the\n          string as may be considered a valid integer or year. For the\n          FLOAT and\n          DECIMAL columns, the\n          string-to-number conversion considers the entire string a\n          valid numeric value.\n        \n          An expression expr can refer to any\n          column that was set earlier in a value list. For example, you\n          can do this because the value for col2\n          refers to col1, which has previously been\n          assigned:\n        Press CTRL+C to copy INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);\n          But the following is not legal, because the value for\n          col1 refers to col2,\n          which is assigned after col1:\n        Press CTRL+C to copy INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);\n          An exception occurs for columns that contain\n          AUTO_INCREMENT values. Because\n          AUTO_INCREMENT values are generated after\n          other value assignments, any reference to an\n          AUTO_INCREMENT column in the assignment\n          returns a 0.\n\n",
        "\nINSERT statements that use\n      VALUES syntax can insert multiple rows. To do\n      this, include multiple lists of comma-separated column values,\n      with lists enclosed within parentheses and separated by commas.\n      Example:\n    ",
        "Press CTRL+C to copy INSERT INTO tbl_name (a,b,c)\n    VALUES(1,2,3), (4,5,6), (7,8,9);",
        "\n      Each values list must contain exactly as many values as are to be\n      inserted per row. The following statement is invalid because it\n      contains one list of nine values, rather than three lists of three\n      values each:\n    ",
        "Press CTRL+C to copy INSERT INTO tbl_name (a,b,c) VALUES(1,2,3,4,5,6,7,8,9);",
        "\nVALUE is a synonym for\n      VALUES in this context. Neither implies\n      anything about the number of values lists, nor about the number of\n      values per list. Either may be used whether there is a single\n      values list or multiple lists, and regardless of the number of\n      values per list.\n    ",
        "\nINSERT statements using\n      VALUES ROW()\n      syntax can also insert multiple rows. In this case, each value\n      list must be contained within a ROW() (row\n      constructor), like this:\n    ",
        "Press CTRL+C to copy INSERT INTO tbl_name (a,b,c)\n    VALUES ROW(1,2,3), ROW(4,5,6), ROW(7,8,9);",
        "\n      The affected-rows value for an\n      INSERT can be obtained using the\n      ROW_COUNT() SQL function or the\n      mysql_affected_rows() C API\n      function. See Section\u00a014.15, \u201cInformation Functions\u201d, and\n      mysql_affected_rows().\n    ",
        "\n      If you use INSERT ...\n      VALUES or INSERT ... VALUES ROW()\n      with multiple value lists, or\n      INSERT ...\n      SELECT or INSERT ... TABLE, the\n      statement returns an information string in this format:\n    ",
        "\n      If you are using the C API, the information string can be obtained\n      by invoking the mysql_info()\n      function. See mysql_info().\n    ",
        "\nRecords indicates the number of rows processed\n      by the statement. (This is not necessarily the number of rows\n      actually inserted because Duplicates can be\n      nonzero.) Duplicates indicates the number of\n      rows that could not be inserted because they would duplicate some\n      existing unique index value. Warnings indicates\n      the number of attempts to insert column values that were\n      problematic in some way. Warnings can occur under any of the\n      following conditions:\n",
        "\n\n          Inserting NULL into a column that has been\n          declared NOT NULL. For multiple-row\n          INSERT statements or\n          INSERT INTO ...\n          SELECT statements, the column is set to the implicit\n          default value for the column data type. This is\n          0 for numeric types, the empty string\n          ('') for string types, and the\n          \u201czero\u201d value for date and time types.\n          INSERT INTO ...\n          SELECT statements are handled the same way as\n          multiple-row inserts because the server does not examine the\n          result set from the SELECT to\n          see whether it returns a single row. (For a single-row\n          INSERT, no warning occurs when\n          NULL is inserted into a NOT\n          NULL column. Instead, the statement fails with an\n          error.)\n        \n          Setting a numeric column to a value that lies outside the\n          column range. The value is clipped to the closest endpoint of\n          the range.\n        \n          Assigning a value such as '10.34 a' to a\n          numeric column. The trailing nonnumeric text is stripped off\n          and the remaining numeric part is inserted. If the string\n          value has no leading numeric part, the column is set to\n          0.\n        \n          Inserting a string into a string column\n          (CHAR,\n          VARCHAR,\n          TEXT, or\n          BLOB) that exceeds the column\n          maximum length. The value is truncated to the column maximum\n          length.\n        \n          Inserting a value into a date or time column that is illegal\n          for the data type. The column is set to the appropriate zero\n          value for the type.\n        \n          For INSERT examples involving\n          AUTO_INCREMENT column values, see\n          Section\u00a05.6.9, \u201cUsing AUTO_INCREMENT\u201d.\n        \n          If INSERT inserts a row into a\n          table that has an AUTO_INCREMENT column,\n          you can find the value used for that column by using the\n          LAST_INSERT_ID() SQL function\n          or the mysql_insert_id() C API\n          function.\n\n\n\nNote\n\n\n            These two functions do not always behave identically. The\n            behavior of INSERT statements\n            with respect to AUTO_INCREMENT columns is\n            discussed further in\n            Section\u00a014.15, \u201cInformation Functions\u201d, and\n            mysql_insert_id().\n\n\n\n",
        "\n      The INSERT statement supports the\n      following modifiers:\n",
        "\n\n          If you use the LOW_PRIORITY modifier,\n          execution of the INSERT is\n          delayed until no other clients are reading from the table.\n          This includes other clients that began reading while existing\n          clients are reading, and while the INSERT\n          LOW_PRIORITY statement is waiting. It is possible,\n          therefore, for a client that issues an INSERT\n          LOW_PRIORITY statement to wait for a very long time.\n        \nLOW_PRIORITY affects only storage engines\n          that use only table-level locking (such as\n          MyISAM, MEMORY, and\n          MERGE).\n\n\n\nNote\n\n\nLOW_PRIORITY should normally not be used\n            with MyISAM tables because doing so\n            disables concurrent inserts. See\n            Section\u00a010.11.3, \u201cConcurrent Inserts\u201d.\n\n\n\n          If you specify HIGH_PRIORITY, it overrides\n          the effect of the\n          --low-priority-updates option\n          if the server was started with that option. It also causes\n          concurrent inserts not to be used. See\n          Section\u00a010.11.3, \u201cConcurrent Inserts\u201d.\n        \nHIGH_PRIORITY affects only storage engines\n          that use only table-level locking (such as\n          MyISAM, MEMORY, and\n          MERGE).\n        \n          If you use the IGNORE modifier, ignorable\n          errors that occur while executing the\n          INSERT statement are ignored.\n          For example, without IGNORE, a row that\n          duplicates an existing UNIQUE index or\n          PRIMARY KEY value in the table causes a\n          duplicate-key error and the statement is aborted. With\n          IGNORE, the row is discarded and no error\n          occurs. Ignored errors generate warnings instead.\n        \n\nIGNORE has a similar effect on inserts into\n          partitioned tables where no partition matching a given value\n          is found. Without IGNORE, such\n          INSERT statements are aborted\n          with an error. When\n          INSERT\n          IGNORE is used, the insert operation fails silently\n          for rows containing the unmatched value, but inserts rows that\n          are matched. For an example, see\n          Section\u00a026.2.2, \u201cLIST Partitioning\u201d.\n        \n          Data conversions that would trigger errors abort the statement\n          if IGNORE is not specified. With\n          IGNORE, invalid values are adjusted to the\n          closest values and inserted; warnings are produced but the\n          statement does not abort. You can determine with the\n          mysql_info() C API function\n          how many rows were actually inserted into the table.\n        \n          For more information, see\n          The Effect of IGNORE on Statement Execution.\n        \n          You can use REPLACE instead of\n          INSERT to overwrite old rows.\n          REPLACE is the counterpart to\n          INSERT\n          IGNORE in the treatment of new rows that contain\n          unique key values that duplicate old rows: The new rows\n          replace the old rows rather than being discarded. See\n          Section\u00a015.2.12, \u201cREPLACE Statement\u201d.\n        \n          If you specify ON DUPLICATE KEY UPDATE, and\n          a row is inserted that would cause a duplicate value in a\n          UNIQUE index or PRIMARY\n          KEY, an UPDATE of the\n          old row occurs. The affected-rows value per row is 1 if the\n          row is inserted as a new row, 2 if an existing row is updated,\n          and 0 if an existing row is set to its current values. If you\n          specify the CLIENT_FOUND_ROWS flag to the\n          mysql_real_connect() C API\n          function when connecting to mysqld, the\n          affected-rows value is 1 (not 0) if an existing row is set to\n          its current values. See Section\u00a015.2.7.2, \u201cINSERT ... ON DUPLICATE KEY UPDATE Statement\u201d.\n        \nINSERT DELAYED was deprecated\n          in MySQL 5.6, and is scheduled for eventual removal. In MySQL\n          8.4, the DELAYED modifier is\n          accepted but ignored. Use INSERT (without\n          DELAYED) instead. See\n          Section\u00a015.2.7.3, \u201cINSERT DELAYED Statement\u201d.\n\n"
    ],
    "Examples": [
        "INSERT INTO tbl_name () VALUES();",
        "INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);",
        "INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);",
        "INSERT INTO tbl_name (a,b,c)\n    VALUES(1,2,3), (4,5,6), (7,8,9);",
        "INSERT INTO tbl_name (a,b,c) VALUES(1,2,3,4,5,6,7,8,9);",
        "INSERT INTO tbl_name (a,b,c)\n    VALUES ROW(1,2,3), ROW(4,5,6), ROW(7,8,9);"
    ],
    "Category": [
        "Data Manipulation Statements"
    ]
}