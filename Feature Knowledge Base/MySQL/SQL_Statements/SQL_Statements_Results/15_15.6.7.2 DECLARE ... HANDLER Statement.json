{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/declare-handler.html"
    ],
    "Title": [
        "15.6.7.2 DECLARE ... HANDLER Statement"
    ],
    "Feature": [
        "DECLARE handler_action HANDLER\n    FOR condition_value [, condition_value] ...\n    statement\n\nhandler_action: {\n    CONTINUE\n  | EXIT\n  | UNDO\n}\n\ncondition_value: {\n    mysql_error_code\n  | SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n  | SQLWARNING\n  | NOT FOUND\n  | SQLEXCEPTION\n}"
    ],
    "Description": [
        "\n        The DECLARE ...\n        HANDLER statement specifies a handler that deals with\n        one or more conditions. If one of these conditions occurs, the\n        specified statement executes.\n        statement can be a simple statement\n        such as SET var_name =\n        value, or a compound\n        statement written using BEGIN and\n        END (see Section\u00a015.6.1, \u201cBEGIN ... END Compound Statement\u201d).\n      ",
        "\n        Handler declarations must appear after variable or condition\n        declarations.\n      ",
        "\n        The handler_action value indicates\n        what action the handler takes after execution of the handler\n        statement:\n",
        "\n\nCONTINUE: Execution of the current\n            program continues.\n          \nEXIT: Execution terminates for the\n            BEGIN ...\n            END compound statement in which the handler is\n            declared. This is true even if the condition occurs in an\n            inner block.\n          \nUNDO: Not supported.\n\n",
        "\n        The condition_value for\n        DECLARE ...\n        HANDLER indicates the specific condition or class of\n        conditions that activates the handler. It can take the following\n        forms:\n",
        "\n\nmysql_error_code: An integer\n            literal indicating a MySQL error code, such as 1051 to\n            specify \u201cunknown table\u201d:\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR 1051\n  BEGIN\n    -- body of handler\n  END;\n            Do not use MySQL error code 0 because that indicates success\n            rather than an error condition. For a list of MySQL error\n            codes, see Server Error Message Reference.\n          \n            SQLSTATE [VALUE] sqlstate_value:\n            A 5-character string literal indicating an SQLSTATE value,\n            such as '42S01' to specify \u201cunknown\n            table\u201d:\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'\n  BEGIN\n    -- body of handler\n  END;\n            Do not use SQLSTATE values that begin with\n            '00' because those indicate success\n            rather than an error condition. For a list of SQLSTATE\n            values, see Server Error Message Reference.\n          \ncondition_name: A condition name\n            previously specified with\n            DECLARE\n            ... CONDITION. A condition name can be associated\n            with a MySQL error code or SQLSTATE value. See\n            Section\u00a015.6.7.1, \u201cDECLARE ... CONDITION Statement\u201d.\n          \nSQLWARNING: Shorthand for the class of\n            SQLSTATE values that begin with '01'.\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    -- body of handler\n  END;\nNOT FOUND: Shorthand for the class of\n            SQLSTATE values that begin with '02'.\n            This is relevant within the context of cursors and is used\n            to control what happens when a cursor reaches the end of a\n            data set. If no more rows are available, a No Data condition\n            occurs with SQLSTATE value '02000'. To\n            detect this condition, you can set up a handler for it or\n            for a NOT FOUND condition.\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR NOT FOUND\n  BEGIN\n    -- body of handler\n  END;\n            For another example, see Section\u00a015.6.6, \u201cCursors\u201d. The\n            NOT FOUND condition also occurs for\n            SELECT ... INTO\n            var_list statements\n            that retrieve no rows.\n          \nSQLEXCEPTION: Shorthand for the class of\n            SQLSTATE values that do not begin with\n            '00', '01', or\n            '02'.\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- body of handler\n  END;\n",
        "\n        For information about how the server chooses handlers when a\n        condition occurs, see Section\u00a015.6.7.6, \u201cScope Rules for Handlers\u201d.\n      ",
        "\n        If a condition occurs for which no handler has been declared,\n        the action taken depends on the condition class:\n",
        "\n\n            For SQLEXCEPTION conditions, the stored\n            program terminates at the statement that raised the\n            condition, as if there were an EXIT\n            handler. If the program was called by another stored\n            program, the calling program handles the condition using the\n            handler selection rules applied to its own handlers.\n          \n            For SQLWARNING conditions, the program\n            continues executing, as if there were a\n            CONTINUE handler.\n          \n            For NOT FOUND conditions, if the\n            condition was raised normally, the action is\n            CONTINUE. If it was raised by\n            SIGNAL or\n            RESIGNAL, the action is\n            EXIT.\n\n",
        "\n        The following example uses a handler for SQLSTATE\n        '23000', which occurs for a duplicate-key error:\n      ",
        "Press CTRL+C to copy mysql> CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter //\n\nmysql> CREATE PROCEDURE handlerdemo ()\n       BEGIN\n         DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;\n         SET @x = 1;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 2;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 3;\n       END;\n       //\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL handlerdemo()//\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @x//\n    +------+\n    | @x   |\n    +------+\n    | 3    |\n    +------+\n    1 row in set (0.00 sec)",
        "\n        Notice that @x is 3 after\n        the procedure executes, which shows that execution continued to\n        the end of the procedure after the error occurred. If the\n        DECLARE ...\n        HANDLER statement had not been present, MySQL would\n        have taken the default action (EXIT) after\n        the second INSERT failed due to\n        the PRIMARY KEY constraint, and\n        SELECT @x would have returned\n        2.\n      ",
        "\n        To ignore a condition, declare a CONTINUE\n        handler for it and associate it with an empty block. For\n        example:\n      ",
        "Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;",
        "\n        The scope of a block label does not include the code for\n        handlers declared within the block. Therefore, the statement\n        associated with a handler cannot use\n        ITERATE or\n        LEAVE to refer to labels for\n        blocks that enclose the handler declaration. Consider the\n        following example, where the\n        REPEAT block has a label of\n        retry:\n      ",
        "Press CTRL+C to copy CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            ITERATE retry;    # illegal\n          END;\n        IF i < 0 THEN\n          LEAVE retry;        # legal\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;",
        "\n        The retry label is in scope for the\n        IF statement within the block. It\n        is not in scope for the CONTINUE handler, so\n        the reference there is invalid and results in an error:\n      ",
        "\n        To avoid references to outer labels in handlers, use one of\n        these strategies:\n",
        "\n\n            To leave the block, use an EXIT handler.\n            If no block cleanup is required, the\n            BEGIN ...\n            END handler body can be empty:\n          Press CTRL+C to copy DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;\n            Otherwise, put the cleanup statements in the handler body:\n          Press CTRL+C to copy DECLARE EXIT HANDLER FOR SQLWARNING\n  BEGIN\n    block cleanup statements\n  END;\n            To continue execution, set a status variable in a\n            CONTINUE handler that can be checked in\n            the enclosing block to determine whether the handler was\n            invoked. The following example uses the variable\n            done for this purpose:\n          Press CTRL+C to copy CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  DECLARE done INT DEFAULT FALSE;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            SET done = TRUE;\n          END;\n        IF done OR i < 0 THEN\n          LEAVE retry;\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;\n"
    ],
    "Examples": [
        "DECLARE CONTINUE HANDLER FOR 1051\n  BEGIN\n    -- body of handler\n  END;",
        "DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'\n  BEGIN\n    -- body of handler\n  END;",
        "DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    -- body of handler\n  END;",
        "DECLARE CONTINUE HANDLER FOR NOT FOUND\n  BEGIN\n    -- body of handler\n  END;",
        "DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- body of handler\n  END;",
        "mysql> CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter //\n\nmysql> CREATE PROCEDURE handlerdemo ()\n       BEGIN\n         DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;\n         SET @x = 1;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 2;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 3;\n       END;\n       //\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL handlerdemo()//\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @x//\n    +------+\n    | @x   |\n    +------+\n    | 3    |\n    +------+\n    1 row in set (0.00 sec)",
        "DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;",
        "CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            ITERATE retry;    # illegal\n          END;\n        IF i < 0 THEN\n          LEAVE retry;        # legal\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;",
        "DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;",
        "DECLARE EXIT HANDLER FOR SQLWARNING\n  BEGIN\n    block cleanup statements\n  END;",
        "CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  DECLARE done INT DEFAULT FALSE;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            SET done = TRUE;\n          END;\n        IF done OR i < 0 THEN\n          LEAVE retry;\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;"
    ],
    "Category": [
        "Compound Statement Syntax"
    ]
}