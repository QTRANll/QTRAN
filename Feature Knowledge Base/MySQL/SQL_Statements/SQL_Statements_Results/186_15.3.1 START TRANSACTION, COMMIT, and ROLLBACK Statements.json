{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/commit.html"
    ],
    "Title": [
        "15.3.1 START TRANSACTION, COMMIT, and ROLLBACK Statements"
    ],
    "Feature": [
        "START TRANSACTION\n    [transaction_characteristic [, transaction_characteristic] ...]\n\ntransaction_characteristic: {\n    WITH CONSISTENT SNAPSHOT\n  | READ WRITE\n  | READ ONLY\n}\n\nBEGIN [WORK]\nCOMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]\nROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]\nSET autocommit = {0 | 1}"
    ],
    "Description": [
        "\n      These statements provide control over use of\n      transactions:\n",
        "\n\nSTART TRANSACTION or\n          BEGIN start a new transaction.\n        \nCOMMIT commits the current transaction,\n          making its changes permanent.\n        \nROLLBACK rolls back the current\n          transaction, canceling its changes.\n        \nSET autocommit disables or enables the\n          default autocommit mode for the current session.\n\n",
        "\n      By default, MySQL runs with\n      autocommit mode enabled.\n      This means that, when not otherwise inside a transaction, each\n      statement is atomic, as if it were surrounded by START\n      TRANSACTION and COMMIT. You cannot\n      use ROLLBACK to undo the effect; however, if an\n      error occurs during statement execution, the statement is rolled\n      back.\n    ",
        "\n      To disable autocommit mode implicitly for a single series of\n      statements, use the START TRANSACTION\n      statement:\n    ",
        "Press CTRL+C to copy START TRANSACTION;\nSELECT @A:=SUM(salary) FROM table1 WHERE type=1;\nUPDATE table2 SET summary=@A WHERE type=1;\nCOMMIT;",
        "\n      With START TRANSACTION, autocommit remains\n      disabled until you end the transaction with\n      COMMIT or ROLLBACK. The\n      autocommit mode then reverts to its previous state.\n    ",
        "\nSTART TRANSACTION permits several modifiers\n      that control transaction characteristics. To specify multiple\n      modifiers, separate them by commas.\n",
        "\n\n          The WITH CONSISTENT SNAPSHOT modifier\n          starts a consistent\n          read for storage engines that are capable of it. This\n          applies only to InnoDB. The effect is the\n          same as issuing a START TRANSACTION\n          followed by a SELECT from any\n          InnoDB table. See\n          Section\u00a017.7.2.3, \u201cConsistent Nonlocking Reads\u201d. The WITH\n          CONSISTENT SNAPSHOT modifier does not change the\n          current transaction\n          isolation level,\n          so it provides a consistent snapshot only if the current\n          isolation level is one that permits a consistent read. The\n          only isolation level that permits a consistent read is\n          REPEATABLE READ. For all\n          other isolation levels, the WITH CONSISTENT\n          SNAPSHOT clause is ignored. A warning is generated\n          when the WITH CONSISTENT SNAPSHOT clause is\n          ignored.\n        \n          The READ WRITE and READ\n          ONLY modifiers set the transaction access mode. They\n          permit or prohibit changes to tables used in the transaction.\n          The READ ONLY restriction prevents the\n          transaction from modifying or locking both transactional and\n          nontransactional tables that are visible to other\n          transactions; the transaction can still modify or lock\n          temporary tables.\n        \n          MySQL enables extra optimizations for queries on\n          InnoDB tables when the transaction is known\n          to be read-only. Specifying READ ONLY\n          ensures these optimizations are applied in cases where the\n          read-only status cannot be determined automatically. See\n          Section\u00a010.5.3, \u201cOptimizing InnoDB Read-Only Transactions\u201d for more\n          information.\n        \n          If no access mode is specified, the default mode applies.\n          Unless the default has been changed, it is read/write. It is\n          not permitted to specify both READ WRITE\n          and READ ONLY in the same statement.\n        \n          In read-only mode, it remains possible to change tables\n          created with the TEMPORARY keyword using\n          DML statements. Changes made with DDL statements are not\n          permitted, just as with permanent tables.\n        \n          For additional information about transaction access mode,\n          including ways to change the default mode, see\n          Section\u00a015.3.7, \u201cSET TRANSACTION Statement\u201d.\n        \n          If the read_only system\n          variable is enabled, explicitly starting a transaction with\n          START TRANSACTION READ WRITE requires the\n          CONNECTION_ADMIN privilege (or\n          the deprecated SUPER\n          privilege).\n\n",
        "\n\nImportant\n\n\n        Many APIs used for writing MySQL client applications (such as\n        JDBC) provide their own methods for starting transactions that\n        can (and sometimes should) be used instead of sending a\n        START TRANSACTION statement from the client.\n        See Chapter\u00a031, Connectors and APIs, or the documentation for\n        your API, for more information.\n\n",
        "\n      To disable autocommit mode explicitly, use the following\n      statement:\n    ",
        "Press CTRL+C to copy SET autocommit=0;",
        "\n      After disabling autocommit mode by setting the\n      autocommit variable to zero,\n      changes to transaction-safe tables (such as those for\n      InnoDB or\n      NDB) are not made permanent\n      immediately. You must use COMMIT to\n      store your changes to disk or ROLLBACK to\n      ignore the changes.\n    ",
        "\nautocommit is a session variable\n      and must be set for each session. To disable autocommit mode for\n      each new connection, see the description of the\n      autocommit system variable at\n      Section\u00a07.1.8, \u201cServer System Variables\u201d.\n    ",
        "\nBEGIN and BEGIN WORK are\n      supported as aliases of START TRANSACTION for\n      initiating a transaction. START TRANSACTION is\n      standard SQL syntax, is the recommended way to start an ad-hoc\n      transaction, and permits modifiers that BEGIN\n      does not.\n    ",
        "\n      The BEGIN statement differs from the use of the\n      BEGIN keyword that starts a\n      BEGIN ... END\n      compound statement. The latter does not begin a transaction. See\n      Section\u00a015.6.1, \u201cBEGIN ... END Compound Statement\u201d.\n",
        "\n\nNote\n\n\n        Within all stored programs (stored procedures and functions,\n        triggers, and events), the parser treats BEGIN\n        [WORK] as the beginning of a\n        BEGIN ...\n        END block. Begin a transaction in this context with\n        START\n        TRANSACTION instead.\n\n",
        "\n      The optional WORK keyword is supported for\n      COMMIT and ROLLBACK, as are\n      the CHAIN and RELEASE\n      clauses. CHAIN and RELEASE\n      can be used for additional control over transaction completion.\n      The value of the completion_type\n      system variable determines the default completion behavior. See\n      Section\u00a07.1.8, \u201cServer System Variables\u201d.\n    ",
        "\n      The AND CHAIN clause causes a new transaction\n      to begin as soon as the current one ends, and the new transaction\n      has the same isolation level as the just-terminated transaction.\n      The new transaction also uses the same access mode (READ\n      WRITE or READ ONLY) as the\n      just-terminated transaction. The RELEASE clause\n      causes the server to disconnect the current client session after\n      terminating the current transaction. Including the\n      NO keyword suppresses CHAIN\n      or RELEASE completion, which can be useful if\n      the completion_type system\n      variable is set to cause chaining or release completion by\n      default.\n    ",
        "\n      Beginning a transaction causes any pending transaction to be\n      committed. See Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d, for more\n      information.\n    ",
        "\n      Beginning a transaction also causes table locks acquired with\n      LOCK TABLES to be released, as\n      though you had executed\n      UNLOCK\n      TABLES. Beginning a transaction does not release a\n      global read lock acquired with FLUSH TABLES\n      WITH READ LOCK.\n    ",
        "\n      For best results, transactions should be performed using only\n      tables managed by a single transaction-safe storage engine.\n      Otherwise, the following problems can occur:\n",
        "\n\n          If you use tables from more than one transaction-safe storage\n          engine (such as InnoDB), and the\n          transaction isolation level is not\n          SERIALIZABLE, it is\n          possible that when one transaction commits, another ongoing\n          transaction that uses the same tables sees only some of the\n          changes made by the first transaction. That is, the atomicity\n          of transactions is not guaranteed with mixed engines and\n          inconsistencies can result. (If mixed-engine transactions are\n          infrequent, you can use\n          SET\n          TRANSACTION ISOLATION LEVEL to set the isolation\n          level to SERIALIZABLE on a\n          per-transaction basis as necessary.)\n        \n          If you use tables that are not transaction-safe within a\n          transaction, changes to those tables are stored at once,\n          regardless of the status of autocommit mode.\n        \n          If you issue a\n          ROLLBACK\n          statement after updating a nontransactional table within a\n          transaction, an\n          ER_WARNING_NOT_COMPLETE_ROLLBACK\n          warning occurs. Changes to transaction-safe tables are rolled\n          back, but not changes to nontransaction-safe tables.\n\n",
        "\n      Each transaction is stored in the binary log in one chunk, upon\n      COMMIT. Transactions that are\n      rolled back are not logged.\n      (Exception: Modifications to\n      nontransactional tables cannot be rolled back. If a transaction\n      that is rolled back includes modifications to nontransactional\n      tables, the entire transaction is logged with a\n      ROLLBACK\n      statement at the end to ensure that modifications to the\n      nontransactional tables are replicated.) See\n      Section\u00a07.4.4, \u201cThe Binary Log\u201d.\n    ",
        "\n      You can change the isolation level or access mode for transactions\n      with the SET TRANSACTION statement.\n      See Section\u00a015.3.7, \u201cSET TRANSACTION Statement\u201d.\n    ",
        "\n      Rolling back can be a slow operation that may occur implicitly\n      without the user having explicitly asked for it (for example, when\n      an error occurs). Because of this, SHOW\n      PROCESSLIST displays Rolling back in\n      the State column for the session, not only for\n      explicit rollbacks performed with the\n      ROLLBACK\n      statement but also for implicit rollbacks.\n",
        "\n\nNote\n\n\n        In MySQL 8.4, BEGIN,\n        COMMIT, and ROLLBACK are\n        not affected by --replicate-do-db\n        or --replicate-ignore-db rules.\n\n",
        "\n      When InnoDB performs a complete rollback of a\n      transaction, all locks set by the transaction are released. If a\n      single SQL statement within a transaction rolls back as a result\n      of an error, such as a duplicate key error, locks set by the\n      statement are preserved while the transaction remains active. This\n      happens because InnoDB stores row locks in a\n      format such that it cannot know afterward which lock was set by\n      which statement.\n    ",
        "\n      If a SELECT statement within a\n      transaction calls a stored function, and a statement within the\n      stored function fails, that statement rolls back. If\n      ROLLBACK is\n      executed for the transaction subsequently, the entire transaction\n      rolls back.\n"
    ],
    "Examples": [
        "START TRANSACTION;\nSELECT @A:=SUM(salary) FROM table1 WHERE type=1;\nUPDATE table2 SET summary=@A WHERE type=1;\nCOMMIT;",
        "SET autocommit=0;"
    ],
    "Category": [
        "Transactional and Locking Statements"
    ]
}