{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/signal.html"
    ],
    "Title": [
        "15.6.7.5 SIGNAL Statement"
    ],
    "Feature": [
        "SIGNAL condition_value\n    [SET signal_information_item\n    [, signal_information_item] ...]\n\ncondition_value: {\n    SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n}\n\nsignal_information_item:\n    condition_information_item_name = simple_value_specification\n\ncondition_information_item_name: {\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n}\n\ncondition_name, simple_value_specification:\n    (see following discussion)"
    ],
    "Description": [
        "\nSIGNAL is the way to\n        \u201creturn\u201d an error.\n        SIGNAL provides error information\n        to a handler, to an outer portion of the application, or to the\n        client. Also, it provides control over the error's\n        characteristics (error number, SQLSTATE\n        value, message). Without SIGNAL,\n        it is necessary to resort to workarounds such as deliberately\n        referring to a nonexistent table to cause a routine to return an\n        error.\n      ",
        "\n        No privileges are required to execute the\n        SIGNAL statement.\n      ",
        "\n        To retrieve information from the diagnostics area, use the\n        GET DIAGNOSTICS statement (see\n        Section\u00a015.6.7.3, \u201cGET DIAGNOSTICS Statement\u201d). For information about the\n        diagnostics area, see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n",
        "\nSIGNAL OverviewSignal Condition Information ItemsEffect of Signals on Handlers, Cursors, and Statements\n",
        "\n\n\n\nSIGNAL Overview\n\n\n\n\n          The condition_value in a\n          SIGNAL statement indicates the\n          error value to be returned. It can be an\n          SQLSTATE value (a 5-character string\n          literal) or a condition_name that\n          refers to a named condition previously defined with\n          DECLARE ...\n          CONDITION (see Section\u00a015.6.7.1, \u201cDECLARE ... CONDITION Statement\u201d).\n        \n          An SQLSTATE value can indicate errors,\n          warnings, or \u201cnot found.\u201d The first two\n          characters of the value indicate its error class, as discussed\n          in Signal Condition Information Items. Some\n          signal values cause statement termination; see\n          Effect of Signals on Handlers, Cursors, and Statements.\n        \n          The SQLSTATE value for a\n          SIGNAL statement should not\n          start with '00' because such values\n          indicate success and are not valid for signaling an error.\n          This is true whether the SQLSTATE value is\n          specified directly in the\n          SIGNAL statement or in a named\n          condition referred to in the statement. If the value is\n          invalid, a Bad SQLSTATE error occurs.\n        \n          To signal a generic SQLSTATE value, use\n          '45000', which means \u201cunhandled\n          user-defined exception.\u201d\n\n          The SIGNAL statement optionally\n          includes a SET clause that contains\n          multiple signal items, in a list of\n          condition_information_item_name =\n          simple_value_specification\n          assignments, separated by commas.\n        \n          Each\n          condition_information_item_name may\n          be specified only once in the SET clause.\n          Otherwise, a Duplicate condition information\n          item error occurs.\n        \n          Valid simple_value_specification\n          designators can be specified using stored procedure or\n          function parameters, stored program local variables declared\n          with DECLARE, user-defined\n          variables, system variables, or literals. A character literal\n          may include a _charset introducer.\n        \n          For information about permissible\n          condition_information_item_name\n          values, see\n          Signal Condition Information Items.\n        \n          The following procedure signals an error or warning depending\n          on the value of pval, its input parameter:\n        Press CTRL+C to copy CREATE PROCEDURE p (pval INT)\nBEGIN\n  DECLARE specialty CONDITION FOR SQLSTATE '45000';\n  IF pval = 0 THEN\n    SIGNAL SQLSTATE '01000';\n  ELSEIF pval = 1 THEN\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSEIF pval = 2 THEN\n    SIGNAL specialty\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSE\n    SIGNAL SQLSTATE '01000'\n      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;\n  END IF;\nEND;\n          If pval is 0, p()\n          signals a warning because SQLSTATE values\n          that begin with '01' are signals in the\n          warning class. The warning does not terminate the procedure,\n          and can be seen with SHOW\n          WARNINGS after the procedure returns.\n        \n          If pval is 1, p()\n          signals an error and sets the MESSAGE_TEXT\n          condition information item. The error terminates the\n          procedure, and the text is returned with the error\n          information.\n        \n          If pval is 2, the same error is signaled,\n          although the SQLSTATE value is specified\n          using a named condition in this case.\n        \n          If pval is anything else,\n          p() first signals a warning and sets the\n          message text and error number condition information items.\n          This warning does not terminate the procedure, so execution\n          continues and p() then signals an error.\n          The error does terminate the procedure. The message text and\n          error number set by the warning are replaced by the values set\n          by the error, which are returned with the error information.\n        \nSIGNAL is typically used within\n          stored programs, but it is a MySQL extension that it is\n          permitted outside handler context. For example, if you invoke\n          the mysql client program, you can enter any\n          of these statements at the prompt:\n        Press CTRL+C to copy SIGNAL SQLSTATE '77777';\n\nCREATE TRIGGER t_bi BEFORE INSERT ON t\n  FOR EACH ROW SIGNAL SQLSTATE '77777';\n\nCREATE EVENT e ON SCHEDULE EVERY 1 SECOND\n  DO SIGNAL SQLSTATE '77777';\nSIGNAL executes according to\n          the following rules:\n        \n          If the SIGNAL statement\n          indicates a particular SQLSTATE value, that\n          value is used to signal the condition specified. Example:\n        Press CTRL+C to copy CREATE PROCEDURE p (divisor INT)\nBEGIN\n  IF divisor = 0 THEN\n    SIGNAL SQLSTATE '22012';\n  END IF;\nEND;\n          If the SIGNAL statement uses a\n          named condition, the condition must be declared in some scope\n          that applies to the SIGNAL\n          statement, and must be defined using an\n          SQLSTATE value, not a MySQL error number.\n          Example:\n        Press CTRL+C to copy CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';\n  IF divisor = 0 THEN\n    SIGNAL divide_by_zero;\n  END IF;\nEND;\n          If the named condition does not exist in the scope of the\n          SIGNAL statement, an\n          Undefined CONDITION error occurs.\n        \n          If SIGNAL refers to a named\n          condition that is defined with a MySQL error number rather\n          than an SQLSTATE value, a\n          SIGNAL/RESIGNAL can only use a CONDITION defined with\n          SQLSTATE error occurs. The following statements\n          cause that error because the named condition is associated\n          with a MySQL error number:\n        Press CTRL+C to copy DECLARE no_such_table CONDITION FOR 1051;\nSIGNAL no_such_table;\n          If a condition with a given name is declared multiple times in\n          different scopes, the declaration with the most local scope\n          applies. Consider the following procedure:\n        Press CTRL+C to copy CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE my_error CONDITION FOR SQLSTATE '45000';\n  IF divisor = 0 THEN\n    BEGIN\n      DECLARE my_error CONDITION FOR SQLSTATE '22012';\n      SIGNAL my_error;\n    END;\n  END IF;\n  SIGNAL my_error;\nEND;\n          If divisor is 0, the first\n          SIGNAL statement executes. The\n          innermost my_error condition declaration\n          applies, raising SQLSTATE\n'22012'.\n        \n          If divisor is not 0, the second\n          SIGNAL statement executes. The\n          outermost my_error condition declaration\n          applies, raising SQLSTATE\n'45000'.\n        \n          For information about how the server chooses handlers when a\n          condition occurs, see Section\u00a015.6.7.6, \u201cScope Rules for Handlers\u201d.\n        \n          Signals can be raised within exception handlers:\n        Press CTRL+C to copy CREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SIGNAL SQLSTATE VALUE '99999'\n      SET MESSAGE_TEXT = 'An error occurred';\n  END;\n  DROP TABLE no_such_table;\nEND;\nCALL p() reaches the\n          DROP TABLE statement. There is\n          no table named no_such_table, so the error\n          handler is activated. The error handler destroys the original\n          error (\u201cno such table\u201d) and makes a new error\n          with SQLSTATE '99999'\n          and message An error occurred.\n\n",
        "\n\n\n\nSignal Condition Information Items\n\n\n\n\n          The following table lists the names of diagnostics area\n          condition information items that can be set in a\n          SIGNAL (or\n          RESIGNAL) statement. All items\n          are standard SQL except MYSQL_ERRNO, which\n          is a MySQL extension. For more information about these items\n          see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n        Press CTRL+C to copy Item Name             Definition\n---------             ----------\nCLASS_ORIGIN          VARCHAR(64)\nSUBCLASS_ORIGIN       VARCHAR(64)\nCONSTRAINT_CATALOG    VARCHAR(64)\nCONSTRAINT_SCHEMA     VARCHAR(64)\nCONSTRAINT_NAME       VARCHAR(64)\nCATALOG_NAME          VARCHAR(64)\nSCHEMA_NAME           VARCHAR(64)\nTABLE_NAME            VARCHAR(64)\nCOLUMN_NAME           VARCHAR(64)\nCURSOR_NAME           VARCHAR(64)\nMESSAGE_TEXT          VARCHAR(128)\nMYSQL_ERRNO           SMALLINT UNSIGNED\n          The character set for character items is UTF-8.\n        \n          It is illegal to assign NULL to a condition\n          information item in a SIGNAL\n          statement.\n        \n          A SIGNAL statement always\n          specifies an SQLSTATE value, either\n          directly, or indirectly by referring to a named condition\n          defined with an SQLSTATE value. The first\n          two characters of an SQLSTATE value are its\n          class, and the class determines the default value for the\n          condition information items:\n\n\n\n              Class = '00' (success)\n            \n              Illegal. SQLSTATE values that begin\n              with '00' indicate success and are not\n              valid for SIGNAL.\n            \n              Class = '01' (warning)\n            Press CTRL+C to copy MESSAGE_TEXT = 'Unhandled user-defined warning condition';\nMYSQL_ERRNO = ER_SIGNAL_WARN\n              Class = '02' (not found)\n            Press CTRL+C to copy MESSAGE_TEXT = 'Unhandled user-defined not found condition';\nMYSQL_ERRNO = ER_SIGNAL_NOT_FOUND\n              Class > '02' (exception)\n            Press CTRL+C to copy MESSAGE_TEXT = 'Unhandled user-defined exception condition';\nMYSQL_ERRNO = ER_SIGNAL_EXCEPTION\n\n\n          For legal classes, the other condition information items are\n          set as follows:\n        Press CTRL+C to copy CLASS_ORIGIN = SUBCLASS_ORIGIN = '';\nCONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';\nCATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';\nCURSOR_NAME = '';\n          The error values that are accessible after\n          SIGNAL executes are the\n          SQLSTATE value raised by the\n          SIGNAL statement and the\n          MESSAGE_TEXT and\n          MYSQL_ERRNO items. These values are\n          available from the C API:\n\n\n\nmysql_sqlstate() returns\n              the SQLSTATE value.\n            \nmysql_errno() returns the\n              MYSQL_ERRNO value.\n            \nmysql_error() returns the\n              MESSAGE_TEXT value.\n\n\n\n          At the SQL level, the output from SHOW\n          WARNINGS and SHOW\n          ERRORS indicates the MYSQL_ERRNO\n          and MESSAGE_TEXT values in the\n          Code and Message\n          columns.\n        \n          To retrieve information from the diagnostics area, use the\n          GET DIAGNOSTICS statement (see\n          Section\u00a015.6.7.3, \u201cGET DIAGNOSTICS Statement\u201d). For information about the\n          diagnostics area, see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n\n",
        "\n\n\n\nEffect of Signals on Handlers, Cursors, and Statements\n\n\n\n\n          Signals have different effects on statement execution\n          depending on the signal class. The class determines how severe\n          an error is. MySQL ignores the value of the\n          sql_mode system variable; in\n          particular, strict SQL mode does not matter. MySQL also\n          ignores IGNORE: The intent of\n          SIGNAL is to raise a\n          user-generated error explicitly, so a signal is never ignored.\n        \n          In the following descriptions, \u201cunhandled\u201d means\n          that no handler for the signaled SQLSTATE\n          value has been defined with\n          DECLARE ...\n          HANDLER.\n\n\n\n              Class = '00' (success)\n            \n              Illegal. SQLSTATE values that begin\n              with '00' indicate success and are not\n              valid for SIGNAL.\n            \n              Class = '01' (warning)\n            \n              The value of the\n              warning_count system\n              variable goes up. SHOW\n              WARNINGS shows the signal.\n              SQLWARNING handlers catch the signal.\n            \n              Warnings cannot be returned from stored functions because\n              the RETURN statement that\n              causes the function to return clears the diagnostic area.\n              The statement thus clears any warnings that may have been\n              present there (and resets\n              warning_count to 0).\n            \n              Class = '02' (not found)\n            \nNOT FOUND handlers catch the signal.\n              There is no effect on cursors. If the signal is unhandled\n              in a stored function, statements end.\n            \n              Class > '02' (exception)\n            \nSQLEXCEPTION handlers catch the signal.\n              If the signal is unhandled in a stored function,\n              statements end.\n            \n              Class = '40'\n\n              Treated as an ordinary exception.\n\n\n"
    ],
    "Examples": [
        "CREATE PROCEDURE p (pval INT)\nBEGIN\n  DECLARE specialty CONDITION FOR SQLSTATE '45000';\n  IF pval = 0 THEN\n    SIGNAL SQLSTATE '01000';\n  ELSEIF pval = 1 THEN\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSEIF pval = 2 THEN\n    SIGNAL specialty\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSE\n    SIGNAL SQLSTATE '01000'\n      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;\n  END IF;\nEND;",
        "SIGNAL SQLSTATE '77777';\n\nCREATE TRIGGER t_bi BEFORE INSERT ON t\n  FOR EACH ROW SIGNAL SQLSTATE '77777';\n\nCREATE EVENT e ON SCHEDULE EVERY 1 SECOND\n  DO SIGNAL SQLSTATE '77777';",
        "CREATE PROCEDURE p (divisor INT)\nBEGIN\n  IF divisor = 0 THEN\n    SIGNAL SQLSTATE '22012';\n  END IF;\nEND;",
        "CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';\n  IF divisor = 0 THEN\n    SIGNAL divide_by_zero;\n  END IF;\nEND;",
        "DECLARE no_such_table CONDITION FOR 1051;\nSIGNAL no_such_table;",
        "CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE my_error CONDITION FOR SQLSTATE '45000';\n  IF divisor = 0 THEN\n    BEGIN\n      DECLARE my_error CONDITION FOR SQLSTATE '22012';\n      SIGNAL my_error;\n    END;\n  END IF;\n  SIGNAL my_error;\nEND;",
        "CREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SIGNAL SQLSTATE VALUE '99999'\n      SET MESSAGE_TEXT = 'An error occurred';\n  END;\n  DROP TABLE no_such_table;\nEND;",
        "MESSAGE_TEXT = 'Unhandled user-defined warning condition';\nMYSQL_ERRNO = ER_SIGNAL_WARN",
        "MESSAGE_TEXT = 'Unhandled user-defined not found condition';\nMYSQL_ERRNO = ER_SIGNAL_NOT_FOUND",
        "MESSAGE_TEXT = 'Unhandled user-defined exception condition';\nMYSQL_ERRNO = ER_SIGNAL_EXCEPTION",
        "CLASS_ORIGIN = SUBCLASS_ORIGIN = '';\nCONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';\nCATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';\nCURSOR_NAME = '';"
    ],
    "Category": [
        "Compound Statement Syntax"
    ]
}