{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/optimize-table.html"
    ],
    "Title": [
        "15.7.3.4 OPTIMIZE TABLE Statement"
    ],
    "Feature": [
        "OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL]\n    TABLE tbl_name [, tbl_name] ..."
    ],
    "Description": [
        "\nOPTIMIZE TABLE reorganizes the\n        physical storage of table data and associated index data, to\n        reduce storage space and improve I/O efficiency when accessing\n        the table. The exact changes made to each table depend on the\n        storage engine used\n        by that table.\n      ",
        "\n        Use OPTIMIZE TABLE in these\n        cases, depending on the type of table:\n",
        "\n\n            After doing substantial insert, update, or delete operations\n            on an InnoDB table that has its own\n            .ibd file because it\n            was created with the\n            innodb_file_per_table\n            option enabled. The table and indexes are reorganized, and\n            disk space can be reclaimed for use by the operating system.\n          \n            After doing substantial insert, update, or delete operations\n            on columns that are part of a FULLTEXT\n            index in an InnoDB table. Set the\n            configuration option\n            innodb_optimize_fulltext_only=1\n            first. To keep the index maintenance period to a reasonable\n            time, set the\n            innodb_ft_num_word_optimize\n            option to specify how many words to update in the search\n            index, and run a sequence of OPTIMIZE\n            TABLE statements until the search index is fully\n            updated.\n          \n            After deleting a large part of a MyISAM\n            or ARCHIVE table, or making many changes\n            to a MyISAM or ARCHIVE\n            table with variable-length rows (tables that have\n            VARCHAR,\n            VARBINARY,\n            BLOB, or\n            TEXT columns). Deleted rows\n            are maintained in a linked list and subsequent\n            INSERT operations reuse old\n            row positions. You can use OPTIMIZE\n            TABLE to reclaim the unused space and to\n            defragment the data file. After extensive changes to a\n            table, this statement may also improve performance of\n            statements that use the table, sometimes significantly.\n\n",
        "\n        This statement requires SELECT\n        and INSERT privileges for the\n        table.\n      ",
        "\nOPTIMIZE TABLE works for\n        InnoDB,\n        MyISAM, and\n        ARCHIVE tables.\n        OPTIMIZE TABLE is also supported\n        for dynamic columns of in-memory\n        NDB tables. It does not work for\n        fixed-width columns of in-memory tables, nor does it work for\n        Disk Data tables. The performance of OPTIMIZE\n        on NDB Cluster tables can be tuned using\n        --ndb-optimization-delay, which\n        controls the length of time to wait between processing batches\n        of rows by OPTIMIZE TABLE. For\n        more information, see\n        Section\u00a025.2.7.11, \u201cPrevious NDB Cluster Issues Resolved in NDB Cluster 8.4\u201d.\n      ",
        "\n        For NDB Cluster tables, OPTIMIZE\n        TABLE can be interrupted by (for example) killing the\n        SQL thread performing the OPTIMIZE operation.\n      ",
        "\n        By default, OPTIMIZE TABLE does\n        not work for tables created using any other\n        storage engine and returns a result indicating this lack of\n        support. You can make OPTIMIZE\n        TABLE work for other storage engines by starting\n        mysqld with the\n        --skip-new option. In this case,\n        OPTIMIZE TABLE is just mapped to\n        ALTER TABLE.\n      ",
        "\n        This statement does not work with views.\n      ",
        "\nOPTIMIZE TABLE is supported for\n        partitioned tables. For information about using this statement\n        with partitioned tables and table partitions, see\n        Section\u00a026.3.4, \u201cMaintenance of Partitions\u201d.\n      ",
        "\n        By default, the server writes OPTIMIZE\n        TABLE statements to the binary log so that they\n        replicate to replicas. To suppress logging, specify the optional\n        NO_WRITE_TO_BINLOG keyword or its alias\n        LOCAL. You must have the\n        OPTIMIZE_LOCAL_TABLE privilege to\n        use this option.\n",
        "\nOPTIMIZE TABLE OutputInnoDB DetailsMyISAM DetailsOther Considerations\n",
        "\n\n\n\nOPTIMIZE TABLE Output\n\n\n\n\nOPTIMIZE TABLE returns a result\n          set with the columns shown in the following table.\n\n\n\nColumn\nValue\n\nTable\nThe table name\n\nOp\nAlways optimize\n\nMsg_type\nstatus, error,\n                info, note, or\n                warning\n\nMsg_text\nAn informational message\n\n\n\nOPTIMIZE TABLE table catches\n          and throws any errors that occur while copying table\n          statistics from the old file to the newly created file. For\n          example. if the user ID of the owner of the\n          .MYD or .MYI file is\n          different from the user ID of the mysqld\n          process, OPTIMIZE TABLE\n          generates a \"cannot change ownership of the file\" error unless\n          mysqld is started by the\n          root user.\n\n",
        "\n\n\n\nInnoDB Details\n\n\n\n\n          For InnoDB tables,\n          OPTIMIZE TABLE is mapped to\n          ALTER TABLE ...\n          FORCE, which rebuilds the table to update index\n          statistics and free unused space in the clustered index. This\n          is displayed in the output of OPTIMIZE\n          TABLE when you run it on an\n          InnoDB table, as shown here:\n        Press CTRL+C to copy mysql> OPTIMIZE TABLE foo;\n+----------+----------+----------+-------------------------------------------------------------------+\n| Table    | Op       | Msg_type | Msg_text                                                          |\n+----------+----------+----------+-------------------------------------------------------------------+\n| test.foo | optimize | note     | Table does not support optimize, doing recreate + analyze instead |\n| test.foo | optimize | status   | OK                                                                |\n+----------+----------+----------+-------------------------------------------------------------------+\nOPTIMIZE TABLE uses\n          online DDL for\n          regular and partitioned InnoDB tables,\n          which reduces downtime for concurrent DML operations. The\n          table rebuild triggered by OPTIMIZE\n          TABLE is completed in place. An exclusive table lock\n          is only taken briefly during the prepare phase and the commit\n          phase of the operation. During the prepare phase, metadata is\n          updated and an intermediate table is created. During the\n          commit phase, table metadata changes are committed.\n        \nOPTIMIZE TABLE rebuilds the\n          table using the table copy method under the following\n          conditions:\n\n\n\n              When the old_alter_table\n              system variable is enabled.\n            \n              When the server is started with the\n              --skip-new option.\n\n\n\nOPTIMIZE TABLE using\n          online DDL is not\n          supported for InnoDB tables that contain\n          FULLTEXT indexes. The table copy method is\n          used instead.\n        \nInnoDB stores data using a page-allocation\n          method and does not suffer from fragmentation in the same way\n          that legacy storage engines (such as\n          MyISAM) do. When considering whether or not\n          to run optimize, consider the workload of transactions that\n          your server is expected to process:\n\n\n\n\n                Some level of fragmentation is expected.\n                InnoDB only fills\n                pages 93% full, to\n                leave room for updates without having to split pages.\n              \n                Delete operations might leave gaps that leave pages less\n                filled than desired, which could make it worthwhile to\n                optimize the table.\n              \n                Updates to rows usually rewrite the data within the same\n                page, depending on the data type and row format, when\n                sufficient space is available. See\n                Section\u00a017.9.1.5, \u201cHow Compression Works for InnoDB Tables\u201d and\n                Section\u00a017.10, \u201cInnoDB Row Formats\u201d.\n              \n                High-concurrency workloads might leave gaps in indexes\n                over time, as InnoDB retains multiple\n                versions of the same data due through its\n                MVCC mechanism. See\n                Section\u00a017.3, \u201cInnoDB Multi-Versioning\u201d.\n\n\n\n\n",
        "\n\n\n\nMyISAM Details\n\n\n\n\n          For MyISAM tables,\n          OPTIMIZE TABLE works as\n          follows:\n\n\n\n              If the table has deleted or split rows, repair the table.\n            \n              If the index pages are not sorted, sort them.\n            \n              If the table's statistics are not up to date (and the\n              repair could not be accomplished by sorting the index),\n              update them.\n\n\n",
        "\n\n\n\nOther Considerations\n\n\n\n\nOPTIMIZE TABLE is performed\n          online for regular and partitioned InnoDB\n          tables. Otherwise, MySQL locks\n          the table during the time OPTIMIZE\n          TABLE is running.\n        \nOPTIMIZE TABLE does not sort\n          R-tree indexes, such as spatial indexes on\n          POINT columns. (Bug #23578)\n\n"
    ],
    "Examples": [
        "mysql> OPTIMIZE TABLE foo;\n+----------+----------+----------+-------------------------------------------------------------------+\n| Table    | Op       | Msg_type | Msg_text                                                          |\n+----------+----------+----------+-------------------------------------------------------------------+\n| test.foo | optimize | note     | Table does not support optimize, doing recreate + analyze instead |\n| test.foo | optimize | status   | OK                                                                |\n+----------+----------+----------+-------------------------------------------------------------------+"
    ],
    "Category": [
        "Database Administration Statements"
    ]
}