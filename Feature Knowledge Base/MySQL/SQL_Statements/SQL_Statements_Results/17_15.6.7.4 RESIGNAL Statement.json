{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/resignal.html"
    ],
    "Title": [
        "15.6.7.4 RESIGNAL Statement"
    ],
    "Feature": [
        "RESIGNAL [condition_value]\n    [SET signal_information_item\n    [, signal_information_item] ...]\n\ncondition_value: {\n    SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n}\n\nsignal_information_item:\n    condition_information_item_name = simple_value_specification\n\ncondition_information_item_name: {\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n}\n\ncondition_name, simple_value_specification:\n    (see following discussion)"
    ],
    "Description": [
        "\nRESIGNAL passes on the error\n        condition information that is available during execution of a\n        condition handler within a compound statement inside a stored\n        procedure or function, trigger, or event.\n        RESIGNAL may change some or all\n        information before passing it on.\n        RESIGNAL is related to\n        SIGNAL, but instead of\n        originating a condition as SIGNAL\n        does, RESIGNAL relays existing\n        condition information, possibly after modifying it.\n      ",
        "\nRESIGNAL makes it possible to\n        both handle an error and return the error information.\n        Otherwise, by executing an SQL statement within the handler,\n        information that caused the handler's activation is destroyed.\n        RESIGNAL also can make some\n        procedures shorter if a given handler can handle part of a\n        situation, then pass the condition \u201cup the line\u201d to\n        another handler.\n      ",
        "\n        No privileges are required to execute the\n        RESIGNAL statement.\n      ",
        "\n        All forms of RESIGNAL require\n        that the current context be a condition handler. Otherwise,\n        RESIGNAL is illegal and a\n        RESIGNAL when handler not active error\n        occurs.\n      ",
        "\n        To retrieve information from the diagnostics area, use the\n        GET DIAGNOSTICS statement (see\n        Section\u00a015.6.7.3, \u201cGET DIAGNOSTICS Statement\u201d). For information about the\n        diagnostics area, see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n",
        "\nRESIGNAL OverviewRESIGNAL AloneRESIGNAL with New Signal InformationRESIGNAL with a Condition Value and Optional New Signal InformationRESIGNAL Requires Condition Handler Context\n",
        "\n\n\n\nRESIGNAL Overview\n\n\n\n\n          For condition_value and\n          signal_information_item, the\n          definitions and rules are the same for\n          RESIGNAL as for\n          SIGNAL. For example, the\n          condition_value can be an\n          SQLSTATE value, and the value can indicate\n          errors, warnings, or \u201cnot found.\u201d For additional\n          information, see Section\u00a015.6.7.5, \u201cSIGNAL Statement\u201d.\n        \n          The RESIGNAL statement takes\n          condition_value and\n          SET clauses, both of which are optional.\n          This leads to several possible uses:\n\n\n\nRESIGNAL alone:\n            Press CTRL+C to copy RESIGNAL;\nRESIGNAL with new signal\n              information:\n            Press CTRL+C to copy RESIGNAL SET signal_information_item [, signal_information_item] ...;\nRESIGNAL with a condition\n              value and possibly new signal information:\n            Press CTRL+C to copy RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];\n\n\n          These use cases all cause changes to the diagnostics and\n          condition areas:\n\n\n\n              A diagnostics area contains one or more condition areas.\n            \n              A condition area contains condition information items,\n              such as the SQLSTATE value,\n              MYSQL_ERRNO, or\n              MESSAGE_TEXT.\n\n\n\n          There is a stack of diagnostics areas. When a handler takes\n          control, it pushes a diagnostics area to the top of the stack,\n          so there are two diagnostics areas during handler execution:\n\n\n\n              The first (current) diagnostics area, which starts as a\n              copy of the last diagnostics area, but is overwritten by\n              the first statement in the handler that changes the\n              current diagnostics area.\n            \n              The last (stacked) diagnostics area, which has the\n              condition areas that were set up before the handler took\n              control.\n\n\n\n          The maximum number of condition areas in a diagnostics area is\n          determined by the value of the\n          max_error_count system\n          variable. See\n          Diagnostics Area-Related System Variables.\n\n",
        "\n\n\n\nRESIGNAL Alone\n\n\n\n\n          A simple RESIGNAL alone means\n          \u201cpass on the error with no change.\u201d It restores\n          the last diagnostics area and makes it the current diagnostics\n          area. That is, it \u201cpops\u201d the diagnostics area\n          stack.\n        \n          Within a condition handler that catches a condition, one use\n          for RESIGNAL alone is to\n          perform some other actions, and then pass on without change\n          the original condition information (the information that\n          existed before entry into the handler).\n        \n          Example:\n        Press CTRL+C to copy DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();\n          Suppose that the DROP TABLE xx statement\n          fails. The diagnostics area stack looks like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\n          Then execution enters the EXIT handler. It\n          starts by pushing a diagnostics area to the top of the stack,\n          which now looks like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\nDA 2. ERROR 1051 (42S02): Unknown table 'xx'\n          At this point, the contents of the first (current) and second\n          (stacked) diagnostics areas are the same. The first\n          diagnostics area may be modified by statements executing\n          subsequently within the handler.\n        \n          Usually a procedure statement clears the first diagnostics\n          area. BEGIN is an exception, it does not\n          clear, it does nothing. SET is not an\n          exception, it clears, performs the operation, and produces a\n          result of \u201csuccess.\u201d The diagnostics area stack\n          now looks like this:\n        Press CTRL+C to copy DA 1. ERROR 0000 (00000): Successful operation\nDA 2. ERROR 1051 (42S02): Unknown table 'xx'\n          At this point, if @a = 0,\n          RESIGNAL pops the diagnostics\n          area stack, which now looks like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\n          And that is what the caller sees.\n        \n          If @a is not 0, the handler simply ends,\n          which means that there is no more use for the current\n          diagnostics area (it has been \u201chandled\u201d), so it\n          can be thrown away, causing the stacked diagnostics area to\n          become the current diagnostics area again. The diagnostics\n          area stack looks like this:\n        Press CTRL+C to copy DA 1. ERROR 0000 (00000): Successful operation\n          The details make it look complex, but the end result is quite\n          useful: Handlers can execute without destroying information\n          about the condition that caused activation of the handler.\n\n",
        "\n\n\n\nRESIGNAL with New Signal Information\n\n\n\n\nRESIGNAL with a\n          SET clause provides new signal information,\n          so the statement means \u201cpass on the error with\n          changes\u201d:\n        Press CTRL+C to copy RESIGNAL SET signal_information_item [, signal_information_item] ...;\n          As with RESIGNAL alone, the\n          idea is to pop the diagnostics area stack so that the original\n          information goes out. Unlike\n          RESIGNAL alone, anything\n          specified in the SET clause changes.\n        \n          Example:\n        Press CTRL+C to copy DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();\n          Remember from the previous discussion that\n          RESIGNAL alone results in a\n          diagnostics area stack like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\n          The RESIGNAL SET MYSQL_ERRNO = 5 statement\n          results in this stack instead, which is what the caller sees:\n        Press CTRL+C to copy DA 1. ERROR 5 (42S02): Unknown table 'xx'\n          In other words, it changes the error number, and nothing else.\n        \n          The RESIGNAL statement can\n          change any or all of the signal information items, making the\n          first condition area of the diagnostics area look quite\n          different.\n\n",
        "\n\n\n\nRESIGNAL with a Condition Value and Optional New Signal Information\n\n\n\n\nRESIGNAL with a condition value\n          means \u201cpush a condition into the current diagnostics\n          area.\u201d If the SET clause is present,\n          it also changes the error information.\n        Press CTRL+C to copy RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];\n          This form of RESIGNAL restores\n          the last diagnostics area and makes it the current diagnostics\n          area. That is, it \u201cpops\u201d the diagnostics area\n          stack, which is the same as what a simple\n          RESIGNAL alone would do.\n          However, it also changes the diagnostics area depending on the\n          condition value or signal information.\n        \n          Example:\n        Press CTRL+C to copy DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nSET @@max_error_count = 2;\nCALL p();\nSHOW ERRORS;\n          This is similar to the previous example, and the effects are\n          the same, except that if\n          RESIGNAL happens, the current\n          condition area looks different at the end. (The reason the\n          condition adds to rather than replaces the existing condition\n          is the use of a condition value.)\n        \n          The RESIGNAL statement includes\n          a condition value (SQLSTATE '45000'), so it\n          adds a new condition area, resulting in a diagnostics area\n          stack that looks like this:\n        Press CTRL+C to copy DA 1. (condition 2) ERROR 1051 (42S02): Unknown table 'xx'\n      (condition 1) ERROR 5 (45000) Unknown table 'xx'\n          The result of CALL\n          p() and SHOW ERRORS\n          for this example is:\n        Press CTRL+C to copy mysql> CALL p();\nERROR 5 (45000): Unknown table 'xx'\nmysql> SHOW ERRORS;\n+-------+------+----------------------------------+\n| Level | Code | Message                          |\n+-------+------+----------------------------------+\n| Error | 1051 | Unknown table 'xx'               |\n| Error |    5 | Unknown table 'xx'               |\n+-------+------+----------------------------------+\n",
        "\n\n\n\nRESIGNAL Requires Condition Handler Context\n\n\n\n\n          All forms of RESIGNAL require\n          that the current context be a condition handler. Otherwise,\n          RESIGNAL is illegal and a\n          RESIGNAL when handler not active error\n          occurs. For example:\n        Press CTRL+C to copy mysql> CREATE PROCEDURE p () RESIGNAL;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL p();\nERROR 1645 (0K000): RESIGNAL when handler not active\n          Here is a more difficult example:\n        Press CTRL+C to copy delimiter //\nCREATE FUNCTION f () RETURNS INT\nBEGIN\n  RESIGNAL;\n  RETURN 5;\nEND//\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();\n  SIGNAL SQLSTATE '55555';\nEND//\ndelimiter ;\nCALL p();\nRESIGNAL occurs within the\n          stored function f(). Although\n          f() itself is invoked within the context of\n          the EXIT handler, execution within\n          f() has its own context, which is not\n          handler context. Thus, RESIGNAL within\n          f() results in a \u201chandler not\n          active\u201d error.\n\n"
    ],
    "Examples": [
        "RESIGNAL;",
        "RESIGNAL SET signal_information_item [, signal_information_item] ...;",
        "RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];",
        "DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();",
        "RESIGNAL SET signal_information_item [, signal_information_item] ...;",
        "DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();",
        "RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];",
        "DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nSET @@max_error_count = 2;\nCALL p();\nSHOW ERRORS;",
        "mysql> CALL p();\nERROR 5 (45000): Unknown table 'xx'\nmysql> SHOW ERRORS;\n+-------+------+----------------------------------+\n| Level | Code | Message                          |\n+-------+------+----------------------------------+\n| Error | 1051 | Unknown table 'xx'               |\n| Error |    5 | Unknown table 'xx'               |\n+-------+------+----------------------------------+",
        "mysql> CREATE PROCEDURE p () RESIGNAL;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL p();\nERROR 1645 (0K000): RESIGNAL when handler not active",
        "delimiter //\nCREATE FUNCTION f () RETURNS INT\nBEGIN\n  RESIGNAL;\n  RETURN 5;\nEND//\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();\n  SIGNAL SQLSTATE '55555';\nEND//\ndelimiter ;\nCALL p();"
    ],
    "Category": [
        "Compound Statement Syntax"
    ]
}