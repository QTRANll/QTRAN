{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/show-table-status.html"
    ],
    "Title": [
        "15.7.7.37 SHOW TABLE STATUS Statement"
    ],
    "Feature": [
        "SHOW TABLE STATUS\n    [{FROM | IN} db_name]\n    [LIKE 'pattern' | WHERE expr]"
    ],
    "Description": [
        "\nSHOW TABLE STATUS works like\n        SHOW TABLES, but provides a lot\n        of information about each non-TEMPORARY\n        table. You can also get this list using the mysqlshow\n        --status db_name command.\n        The LIKE clause, if present,\n        indicates which table names to match. The\n        WHERE clause can be given to select rows\n        using more general conditions, as discussed in\n        Section\u00a028.8, \u201cExtensions to SHOW Statements\u201d.\n      ",
        "\n        This statement also displays information about views.\n      ",
        "\nSHOW TABLE STATUS output has\n        these columns:\n",
        "\n\nName\n\n            The name of the table.\n          \nEngine\n\n            The storage engine for the table. See\n            Chapter\u00a017, The InnoDB Storage Engine, and\n            Chapter\u00a018, Alternative Storage Engines.\n          \n            For partitioned tables, Engine shows the\n            name of the storage engine used by all partitions.\n          \nVersion\n\n            This column is unused. With the removal of\n            .frm files in MySQL 8.0, this column\n            now reports a hardcoded value of 10,\n            which was the last .frm file version\n            used in MySQL 5.7.\n          \nRow_format\n\n            The row-storage format (Fixed,\n            Dynamic, Compressed,\n            Redundant, Compact).\n            For MyISAM tables,\n            Dynamic corresponds to what\n            myisamchk -dvv reports as\n            Packed.\n          \nRows\n\n            The number of rows. Some storage engines, such as\n            MyISAM, store the exact count. For other\n            storage engines, such as InnoDB, this\n            value is an approximation, and may vary from the actual\n            value by as much as 40% to 50%. In such cases, use\n            SELECT COUNT(*) to obtain an accurate\n            count.\n          \n            The Rows value is NULL\n            for INFORMATION_SCHEMA tables.\n          \n            For InnoDB tables, the row\n            count is only a rough estimate used in SQL optimization.\n            (This is also true if the\n            InnoDB table is partitioned.)\n          \nAvg_row_length\n\n            The average row length.\n          \nData_length\n\n            For MyISAM,\n            Data_length is the length of the data\n            file, in bytes.\n          \n            For InnoDB,\n            Data_length is the approximate amount of\n            space allocated for the clustered index, in bytes.\n            Specifically, it is the clustered index size, in pages,\n            multiplied by the InnoDB page size.\n          \n            Refer to the notes at the end of this section for\n            information regarding other storage engines.\n          \nMax_data_length\n\n            For MyISAM,\n            Max_data_length is maximum length of the\n            data file. This is the total number of bytes of data that\n            can be stored in the table, given the data pointer size\n            used.\n          \n            Unused for InnoDB.\n          \n            Refer to the notes at the end of this section for\n            information regarding other storage engines.\n          \nIndex_length\n\n            For MyISAM,\n            Index_length is the length of the index\n            file, in bytes.\n          \n            For InnoDB,\n            Index_length is the approximate amount of\n            space allocated for non-clustered indexes, in bytes.\n            Specifically, it is the sum of non-clustered index sizes, in\n            pages, multiplied by the InnoDB page\n            size.\n          \n            Refer to the notes at the end of this section for\n            information regarding other storage engines.\n          \nData_free\n\n            The number of allocated but unused bytes.\n          \nInnoDB tables report the free space of\n            the tablespace to which the table belongs. For a table\n            located in the shared tablespace, this is the free space of\n            the shared tablespace. If you are using multiple tablespaces\n            and the table has its own tablespace, the free space is for\n            only that table. Free space means the number of bytes in\n            completely free extents minus a safety margin. Even if free\n            space displays as 0, it may be possible to insert rows as\n            long as new extents need not be allocated.\n          \n            For NDB Cluster, Data_free shows the\n            space allocated on disk for, but not used by, a Disk Data\n            table or fragment on disk. (In-memory data resource usage is\n            reported by the Data_length column.)\n          \n            For partitioned tables, this value is only an estimate and\n            may not be absolutely correct. A more accurate method of\n            obtaining this information in such cases is to query the\n            INFORMATION_SCHEMA\nPARTITIONS table, as shown in\n            this example:\n          Press CTRL+C to copy SELECT SUM(DATA_FREE)\n    FROM  INFORMATION_SCHEMA.PARTITIONS\n    WHERE TABLE_SCHEMA = 'mydb'\n    AND   TABLE_NAME   = 'mytable';\n            For more information, see\n            Section\u00a028.3.21, \u201cThe INFORMATION_SCHEMA PARTITIONS Table\u201d.\n          \nAuto_increment\n\n            The next AUTO_INCREMENT value.\n          \nCreate_time\n\n            When the table was created.\n          \nUpdate_time\n\n            When the data file was last updated. For some storage\n            engines, this value is NULL. For example,\n            InnoDB stores multiple tables in its\n            system\n            tablespace and the data file timestamp does not\n            apply. Even with\n            file-per-table\n            mode with each InnoDB table in a separate\n            .ibd file,\n            change\n            buffering can delay the write to the data file, so\n            the file modification time is different from the time of the\n            last insert, update, or delete. For\n            MyISAM, the data file timestamp is used;\n            however, on Windows the timestamp is not updated by updates,\n            so the value is inaccurate.\n          \nUpdate_time displays a timestamp value\n            for the last UPDATE,\n            INSERT, or\n            DELETE performed on\n            InnoDB tables that are not partitioned.\n            For MVCC, the timestamp value reflects the\n            COMMIT time, which is\n            considered the last update time. Timestamps are not\n            persisted when the server is restarted or when the table is\n            evicted from the InnoDB data dictionary\n            cache.\n          \nCheck_time\n\n            When the table was last checked. Not all storage engines\n            update this time, in which case, the value is always\n            NULL.\n          \n            For partitioned InnoDB tables,\n            Check_time is always\n            NULL.\n          \nCollation\n\n            The table default collation. The output does not explicitly\n            list the table default character set, but the collation name\n            begins with the character set name.\n          \nChecksum\n\n            The live checksum value, if any.\n          \nCreate_options\n\n            Extra options used with CREATE\n            TABLE.\n          \nCreate_options shows\n            partitioned for a partitioned table.\n          \nCreate_options shows the\n            ENCRYPTION clause for file-per-table\n            tablespaces if the table is encrypted or if the specified\n            encryption differs from the schema encryption. The\n            encryption clause is not shown for tables created in general\n            tablespaces. To identify encrypted file-per-table and\n            general tablespaces, query the\n            INNODB_TABLESPACES\nENCRYPTION column.\n          \n            When creating a table with\n            strict mode\n            disabled, the storage engine's default row format is\n            used if the specified row format is not supported. The\n            actual row format of the table is reported in the\n            Row_format column.\n            Create_options shows the row format that\n            was specified in the CREATE\n            TABLE statement.\n          \n            When altering the storage engine of a table, table options\n            that are not applicable to the new storage engine are\n            retained in the table definition to enable reverting the\n            table with its previously defined options to the original\n            storage engine, if necessary.\n            Create_options may show retained options.\n          \nComment\n\n            The comment used when creating the table (or information as\n            to why MySQL could not access the table information).\n\n",
        "Notes",
        "\n\n            For InnoDB tables,\n            SHOW TABLE STATUS does not\n            give accurate statistics except for the physical size\n            reserved by the table. The row count is only a rough\n            estimate used in SQL optimization.\n          \n            For NDB tables, the output of\n            this statement shows appropriate values for the\n            Avg_row_length and\n            Data_length columns, with the exception\n            that BLOB columns are not\n            taken into account.\n          \n            For NDB tables,\n            Data_length includes data stored in main\n            memory only; the Max_data_length and\n            Data_free columns apply to Disk Data.\n          \n            For NDB Cluster Disk Data tables,\n            Max_data_length shows the space allocated\n            for the disk part of a Disk Data table or fragment.\n            (In-memory data resource usage is reported by the\n            Data_length column.)\n          \n            For MEMORY tables, the\n            Data_length,\n            Max_data_length, and\n            Index_length values approximate the\n            actual amount of allocated memory. The allocation algorithm\n            reserves memory in large amounts to reduce the number of\n            allocation operations.\n          \n            For views, most columns displayed by\n            SHOW TABLE STATUS are 0 or\n            NULL except that Name\n            indicates the view name, Create_time\n            indicates the creation time, and Comment\n            says VIEW.\n\n",
        "\n        Table information is also available from the\n        INFORMATION_SCHEMA\nTABLES table. See\n        Section\u00a028.3.38, \u201cThe INFORMATION_SCHEMA TABLES Table\u201d.\n"
    ],
    "Examples": [
        "SELECT SUM(DATA_FREE)\n    FROM  INFORMATION_SCHEMA.PARTITIONS\n    WHERE TABLE_SCHEMA = 'mydb'\n    AND   TABLE_NAME   = 'mytable';"
    ],
    "Category": [
        "Database Administration Statements"
    ]
}