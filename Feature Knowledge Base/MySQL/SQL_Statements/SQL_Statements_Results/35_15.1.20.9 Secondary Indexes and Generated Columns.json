{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/create-table-secondary-indexes.html"
    ],
    "Title": [
        "15.1.20.9 Secondary Indexes and Generated Columns"
    ],
    "Feature": [
        "mysql> EXPLAIN SELECT c->>\"$.name\" AS name\n    ->           FROM jempn WHERE g > 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: jempn\n   partitions: p0,p1,p2,p3\n         type: range\npossible_keys: i\n          key: i\n      key_len: 5\n          ref: NULL\n         rows: 3\n     filtered: 100.00\n        Extra: Using pushed condition (`test`.`jempn`.`g` > 2)\n1 row in set, 1 warning (0.01 sec)\n\nmysql> SHOW WARNINGS\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select\njson_unquote(json_extract(`test`.`jempn`.`c`,'$.name')) AS `name` from\n`test`.`jempn` where (`test`.`jempn`.`g` > 2)   \n1 row in set (0.00 sec)"
    ],
    "Description": [
        "\nInnoDB supports secondary indexes on virtual\n        generated columns. Other index types are not supported. A\n        secondary index defined on a virtual column is sometimes\n        referred to as a \u201cvirtual index\u201d.\n      ",
        "\n        A secondary index may be created on one or more virtual columns\n        or on a combination of virtual columns and regular columns or\n        stored generated columns. Secondary indexes that include virtual\n        columns may be defined as UNIQUE.\n      ",
        "\n        When a secondary index is created on a virtual generated column,\n        generated column values are materialized in the records of the\n        index. If the index is a\n        covering index (one\n        that includes all the columns retrieved by a query), generated\n        column values are retrieved from materialized values in the\n        index structure instead of computed \u201con the fly\u201d.\n      ",
        "\n        There are additional write costs to consider when using a\n        secondary index on a virtual column due to computation performed\n        when materializing virtual column values in secondary index\n        records during INSERT and\n        UPDATE operations. Even with\n        additional write costs, secondary indexes on virtual columns may\n        be preferable to generated stored columns,\n        which are materialized in the clustered index, resulting in\n        larger tables that require more disk space and memory. If a\n        secondary index is not defined on a virtual column, there are\n        additional costs for reads, as virtual column values must be\n        computed each time the column's row is examined.\n      ",
        "\n        Values of an indexed virtual column are MVCC-logged to avoid\n        unnecessary recomputation of generated column values during\n        rollback or during a purge operation. The data length of logged\n        values is limited by the index key limit of 767 bytes for\n        COMPACT and REDUNDANT row\n        formats, and 3072 bytes for DYNAMIC and\n        COMPRESSED row formats.\n      ",
        "\n        Adding or dropping a secondary index on a virtual column is an\n        in-place operation.\n",
        "\n\n\n\nIndexing a Generated Column to Provide a JSON Column Index\n\n\n\n\n          As noted elsewhere, JSON\n          columns cannot be indexed directly. To create an index that\n          references such a column indirectly, you can define a\n          generated column that extracts the information that should be\n          indexed, then create an index on the generated column, as\n          shown in this example:\n        Press CTRL+C to copy mysql> CREATE TABLE jemp (\n    ->     c JSON,\n    ->     g INT GENERATED ALWAYS AS (c->\"$.id\"),\n    ->     INDEX i (g)\n    -> );\nQuery OK, 0 rows affected (0.28 sec)\n\nmysql> INSERT INTO jemp (c) VALUES\n     >   ('{\"id\": \"1\", \"name\": \"Fred\"}'), ('{\"id\": \"2\", \"name\": \"Wilma\"}'),\n     >   ('{\"id\": \"3\", \"name\": \"Barney\"}'), ('{\"id\": \"4\", \"name\": \"Betty\"}');\nQuery OK, 4 rows affected (0.04 sec)\nRecords: 4  Duplicates: 0  Warnings: 0\n\nmysql> SELECT c->>\"$.name\" AS name\n     >     FROM jemp WHERE g > 2;\n+--------+\n| name   |\n+--------+\n| Barney |\n| Betty  |\n+--------+\n2 rows in set (0.00 sec)\n\nmysql> EXPLAIN SELECT c->>\"$.name\" AS name\n     >    FROM jemp WHERE g > 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: jemp\n   partitions: NULL\n         type: range\npossible_keys: i\n          key: i\n      key_len: 5\n          ref: NULL\n         rows: 2\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n\nmysql> SHOW WARNINGS\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name'))\nAS `name` from `test`.`jemp` where (`test`.`jemp`.`g` > 2)\n1 row in set (0.00 sec)\n          (We have wrapped the output from the last statement in this\n          example to fit the viewing area.)\n        \n          When you use EXPLAIN on a\n          SELECT or other SQL statement\n          containing one or more expressions that use the\n          -> or ->>\n          operator, these expressions are translated into their\n          equivalents using JSON_EXTRACT() and (if\n          needed) JSON_UNQUOTE() instead, as shown\n          here in the output from SHOW\n          WARNINGS immediately following this\n          EXPLAIN statement:\n        Press CTRL+C to copy mysql> EXPLAIN SELECT c->>\"$.name\"\n     > FROM jemp WHERE g > 2 ORDER BY c->\"$.name\"\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: jemp\n   partitions: NULL\n         type: range\npossible_keys: i\n          key: i\n      key_len: 5\n          ref: NULL\n         rows: 2\n     filtered: 100.00\n        Extra: Using where; Using filesort\n1 row in set, 1 warning (0.00 sec)\n\nmysql> SHOW WARNINGS\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name')) AS\n`c->>\"$.name\"` from `test`.`jemp` where (`test`.`jemp`.`g` > 2) order by\njson_extract(`test`.`jemp`.`c`,'$.name')\n1 row in set (0.00 sec)\n          See the descriptions of the\n          ->\n          and\n          ->>\n          operators, as well as those of the\n          JSON_EXTRACT() and\n          JSON_UNQUOTE() functions, for\n          additional information and examples.\n        \n          This technique also can be used to provide indexes that\n          indirectly reference columns of other types that cannot be\n          indexed directly, such as GEOMETRY columns.\n        \n          It is also possible to create an index on a\n          JSON column using the\n          JSON_VALUE() function with an\n          expression that can be used to optimize queries employing the\n          expression. See the description of that function for more\n          information and examples.\n        JSON columns and indirect indexing in NDB Cluster\n\n\n\n\n\n          It is also possible to use indirect indexing of JSON columns\n          in MySQL NDB Cluster, subject to the following conditions:\n\n\n\nNDB handles a\n              JSON column value\n              internally as a BLOB. This\n              means that any NDB table having one or\n              more JSON columns must have a primary key, else it cannot\n              be recorded in the binary log.\n            \n              The NDB storage engine does\n              not support indexing of virtual columns. Since the default\n              for generated columns is VIRTUAL, you\n              must specify explicitly the generated column to which to\n              apply the indirect index as STORED.\n\n\n\n          The CREATE TABLE statement\n          used to create the table jempn shown here\n          is a version of the jemp table shown\n          previously, with modifications making it compatible with\n          NDB:\n        Press CTRL+C to copy CREATE TABLE jempn (\n  a BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n  c JSON DEFAULT NULL,\n  g INT GENERATED ALWAYS AS (c->\"$.id\") STORED,\n  INDEX i (g)\n) ENGINE=NDB;\n          We can populate this table using the following\n          INSERT statement:\n        Press CTRL+C to copy INSERT INTO jempn (c) VALUES\n  ('{\"id\": \"1\", \"name\": \"Fred\"}'),\n  ('{\"id\": \"2\", \"name\": \"Wilma\"}'),\n  ('{\"id\": \"3\", \"name\": \"Barney\"}'),\n  ('{\"id\": \"4\", \"name\": \"Betty\"}');\n          Now NDB can use index i,\n          as shown here:\n        Press CTRL+C to copy mysql> EXPLAIN SELECT c->>\"$.name\" AS name\n    ->           FROM jempn WHERE g > 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: jempn\n   partitions: p0,p1,p2,p3\n         type: range\npossible_keys: i\n          key: i\n      key_len: 5\n          ref: NULL\n         rows: 3\n     filtered: 100.00\n        Extra: Using pushed condition (`test`.`jempn`.`g` > 2)\n1 row in set, 1 warning (0.01 sec)\n\nmysql> SHOW WARNINGS\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select\njson_unquote(json_extract(`test`.`jempn`.`c`,'$.name')) AS `name` from\n`test`.`jempn` where (`test`.`jempn`.`g` > 2)   \n1 row in set (0.00 sec)\n          You should keep in mind that a stored generated column, as\n          well as any index on such a column, uses\n          DataMemory.\n\n"
    ],
    "Examples": [
        "mysql> CREATE TABLE jemp (\n    ->     c JSON,\n    ->     g INT GENERATED ALWAYS AS (c->\"$.id\"),\n    ->     INDEX i (g)\n    -> );\nQuery OK, 0 rows affected (0.28 sec)\n\nmysql> INSERT INTO jemp (c) VALUES\n     >   ('{\"id\": \"1\", \"name\": \"Fred\"}'), ('{\"id\": \"2\", \"name\": \"Wilma\"}'),\n     >   ('{\"id\": \"3\", \"name\": \"Barney\"}'), ('{\"id\": \"4\", \"name\": \"Betty\"}');\nQuery OK, 4 rows affected (0.04 sec)\nRecords: 4  Duplicates: 0  Warnings: 0\n\nmysql> SELECT c->>\"$.name\" AS name\n     >     FROM jemp WHERE g > 2;\n+--------+\n| name   |\n+--------+\n| Barney |\n| Betty  |\n+--------+\n2 rows in set (0.00 sec)\n\nmysql> EXPLAIN SELECT c->>\"$.name\" AS name\n     >    FROM jemp WHERE g > 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: jemp\n   partitions: NULL\n         type: range\npossible_keys: i\n          key: i\n      key_len: 5\n          ref: NULL\n         rows: 2\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n\nmysql> SHOW WARNINGS\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name'))\nAS `name` from `test`.`jemp` where (`test`.`jemp`.`g` > 2)\n1 row in set (0.00 sec)",
        "mysql> EXPLAIN SELECT c->>\"$.name\"\n     > FROM jemp WHERE g > 2 ORDER BY c->\"$.name\"\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: jemp\n   partitions: NULL\n         type: range\npossible_keys: i\n          key: i\n      key_len: 5\n          ref: NULL\n         rows: 2\n     filtered: 100.00\n        Extra: Using where; Using filesort\n1 row in set, 1 warning (0.00 sec)\n\nmysql> SHOW WARNINGS\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name')) AS\n`c->>\"$.name\"` from `test`.`jemp` where (`test`.`jemp`.`g` > 2) order by\njson_extract(`test`.`jemp`.`c`,'$.name')\n1 row in set (0.00 sec)",
        "CREATE TABLE jempn (\n  a BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n  c JSON DEFAULT NULL,\n  g INT GENERATED ALWAYS AS (c->\"$.id\") STORED,\n  INDEX i (g)\n) ENGINE=NDB;",
        "INSERT INTO jempn (c) VALUES\n  ('{\"id\": \"1\", \"name\": \"Fred\"}'),\n  ('{\"id\": \"2\", \"name\": \"Wilma\"}'),\n  ('{\"id\": \"3\", \"name\": \"Barney\"}'),\n  ('{\"id\": \"4\", \"name\": \"Betty\"}');"
    ],
    "Category": [
        "Data Definition Statements"
    ]
}