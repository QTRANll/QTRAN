{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/create-trigger.html"
    ],
    "Title": [
        "15.1.22 CREATE TRIGGER Statement"
    ],
    "Feature": [
        "CREATE\n    [DEFINER = user]\n    TRIGGER [IF NOT EXISTS] trigger_name\n    trigger_time trigger_event\n    ON tbl_name FOR EACH ROW\n    [trigger_order]\n    trigger_body\n\ntrigger_time: { BEFORE | AFTER }\n\ntrigger_event: { INSERT | UPDATE | DELETE }\n\ntrigger_order: { FOLLOWS | PRECEDES } other_trigger_name"
    ],
    "Description": [
        "\n      This statement creates a new trigger. A trigger is a named\n      database object that is associated with a table, and that\n      activates when a particular event occurs for the table. The\n      trigger becomes associated with the table named\n      tbl_name, which must refer to a\n      permanent table. You cannot associate a trigger with a\n      TEMPORARY table or a view.\n    ",
        "\n      Trigger names exist in the schema namespace, meaning that all\n      triggers must have unique names within a schema. Triggers in\n      different schemas can have the same name.\n    ",
        "\nIF NOT EXISTS prevents an error from occurring\n      if a trigger having the same name, on the same table, exists in\n      the same schema.\n    ",
        "\n      This section describes CREATE\n      TRIGGER syntax. For additional discussion, see\n      Section\u00a027.3.1, \u201cTrigger Syntax and Examples\u201d.\n    ",
        "\nCREATE TRIGGER requires the\n      TRIGGER privilege for the table\n      associated with the trigger. If the DEFINER\n      clause is present, the privileges required depend on the\n      user value, as discussed in\n      Section\u00a027.6, \u201cStored Object Access Control\u201d. If binary logging is\n      enabled, CREATE TRIGGER might\n      require the SUPER privilege, as\n      discussed in Section\u00a027.7, \u201cStored Program Binary Logging\u201d.\n    ",
        "\n      The DEFINER clause determines the security\n      context to be used when checking access privileges at trigger\n      activation time, as described later in this section.\n    ",
        "\ntrigger_time is the trigger action\n      time. It can be BEFORE or\n      AFTER to indicate that the trigger activates\n      before or after each row to be modified.\n    ",
        "\n      Basic column value checks occur prior to trigger activation, so\n      you cannot use BEFORE triggers to convert\n      values inappropriate for the column type to valid values.\n    ",
        "\ntrigger_event indicates the kind of\n      operation that activates the trigger. These\n      trigger_event values are permitted:\n",
        "\n\nINSERT: The trigger activates\n          whenever a new row is inserted into the table (for example,\n          through INSERT,\n          LOAD DATA, and\n          REPLACE statements).\n        \nUPDATE: The trigger activates\n          whenever a row is modified (for example, through\n          UPDATE statements).\n        \nDELETE: The trigger activates\n          whenever a row is deleted from the table (for example, through\n          DELETE and\n          REPLACE statements).\n          DROP TABLE and\n          TRUNCATE TABLE statements on\n          the table do not activate this trigger,\n          because they do not use DELETE.\n          Dropping a partition does not activate\n          DELETE triggers, either.\n\n",
        "\n      The trigger_event does not represent a\n      literal type of SQL statement that activates the trigger so much\n      as it represents a type of table operation. For example, an\n      INSERT trigger activates not only\n      for INSERT statements but also\n      LOAD DATA statements because both\n      statements insert rows into a table.\n    ",
        "\n      A potentially confusing example of this is the INSERT\n      INTO ... ON DUPLICATE KEY UPDATE ... syntax: a\n      BEFORE INSERT trigger activates for every row,\n      followed by either an AFTER INSERT trigger or\n      both the BEFORE UPDATE and AFTER\n      UPDATE triggers, depending on whether there was a\n      duplicate key for the row.\n",
        "\n\nNote\n\n\n        Cascaded foreign key actions do not activate triggers.\n\n",
        "\n      It is possible to define multiple triggers for a given table that\n      have the same trigger event and action time. For example, you can\n      have two BEFORE UPDATE triggers for a table. By\n      default, triggers that have the same trigger event and action time\n      activate in the order they were created. To affect trigger order,\n      specify a trigger_order clause that\n      indicates FOLLOWS or\n      PRECEDES and the name of an existing trigger\n      that also has the same trigger event and action time. With\n      FOLLOWS, the new trigger activates after the\n      existing trigger. With PRECEDES, the new\n      trigger activates before the existing trigger.\n    ",
        "\ntrigger_body is the statement to\n      execute when the trigger activates. To execute multiple\n      statements, use the\n      BEGIN ... END\n      compound statement construct. This also enables you to use the\n      same statements that are permitted within stored routines. See\n      Section\u00a015.6.1, \u201cBEGIN ... END Compound Statement\u201d. Some statements are not permitted in\n      triggers; see Section\u00a027.8, \u201cRestrictions on Stored Programs\u201d.\n    ",
        "\n      Within the trigger body, you can refer to columns in the subject\n      table (the table associated with the trigger) by using the aliases\n      OLD and NEW.\n      OLD.col_name refers\n      to a column of an existing row before it is updated or deleted.\n      NEW.col_name refers\n      to the column of a new row to be inserted or an existing row after\n      it is updated.\n    ",
        "\n      Triggers cannot use\n      NEW.col_name or use\n      OLD.col_name to\n      refer to generated columns. For information about generated\n      columns, see Section\u00a015.1.20.8, \u201cCREATE TABLE and Generated Columns\u201d.\n    ",
        "\n      MySQL stores the sql_mode system\n      variable setting in effect when a trigger is created, and always\n      executes the trigger body with this setting in force,\n      regardless of the current server SQL mode when the\n      trigger begins executing.\n    ",
        "\n      The DEFINER clause specifies the MySQL account\n      to be used when checking access privileges at trigger activation\n      time. If the DEFINER clause is present, the\n      user value should be a MySQL account\n      specified as\n      'user_name'@'host_name',\n      CURRENT_USER, or\n      CURRENT_USER(). The permitted\n      user values depend on the privileges\n      you hold, as discussed in\n      Section\u00a027.6, \u201cStored Object Access Control\u201d. Also see that section\n      for additional information about trigger security.\n    ",
        "\n      If the DEFINER clause is omitted, the default\n      definer is the user who executes the CREATE\n      TRIGGER statement. This is the same as specifying\n      DEFINER = CURRENT_USER explicitly.\n    ",
        "\n      MySQL takes the DEFINER user into account when\n      checking trigger privileges as follows:\n",
        "\n\n          At CREATE TRIGGER time, the\n          user who issues the statement must have the\n          TRIGGER privilege.\n        \n          At trigger activation time, privileges are checked against the\n          DEFINER user. This user must have these\n          privileges:\n\n\n\n              The TRIGGER privilege for\n              the subject table.\n            \n              The SELECT privilege for\n              the subject table if references to table columns occur\n              using\n              OLD.col_name\n              or\n              NEW.col_name\n              in the trigger body.\n            \n              The UPDATE privilege for\n              the subject table if table columns are targets of\n              SET NEW.col_name =\n              value assignments in\n              the trigger body.\n            \n              Whatever other privileges normally are required for the\n              statements executed by the trigger.\n\n\n\n",
        "\n      Within a trigger body, the\n      CURRENT_USER function returns the\n      account used to check privileges at trigger activation time. This\n      is the DEFINER user, not the user whose actions\n      caused the trigger to be activated. For information about user\n      auditing within triggers, see\n      Section\u00a08.2.23, \u201cSQL-Based Account Activity Auditing\u201d.\n    ",
        "\n      If you use LOCK TABLES to lock a\n      table that has triggers, the tables used within the trigger are\n      also locked, as described in\n      LOCK TABLES and Triggers.\n    ",
        "\n      For additional discussion of trigger use, see\n      Section\u00a027.3.1, \u201cTrigger Syntax and Examples\u201d.\n"
    ],
    "Examples": [],
    "Category": [
        "Data Definition Statements"
    ]
}