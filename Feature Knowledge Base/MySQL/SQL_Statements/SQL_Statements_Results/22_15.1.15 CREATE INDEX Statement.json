{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/create-index.html"
    ],
    "Title": [
        "15.1.15 CREATE INDEX Statement"
    ],
    "Feature": [
        "CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name\n    [index_type]\n    ON tbl_name (key_part,...)\n    [index_option]\n    [algorithm_option | lock_option] ...\n\nkey_part: {col_name [(length)] | (expr)} [ASC | DESC]\n\nindex_option: {\n    KEY_BLOCK_SIZE [=] value\n  | index_type\n  | WITH PARSER parser_name\n  | COMMENT 'string'\n  | {VISIBLE | INVISIBLE}\n  | ENGINE_ATTRIBUTE [=] 'string'\n  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'\n}\n\nindex_type:\n    USING {BTREE | HASH}\n\nalgorithm_option:\n    ALGORITHM [=] {DEFAULT | INPLACE | COPY}\n\nlock_option:\n    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}",
        "INDEX ((col1 + col2), (col3 - col4))",
        "INDEX (col1 + col2, col3 - col4)",
        "INDEX ((col1), (col2))",
        "INDEX (col1, col2)",
        "+------------------------------------+\n| data                               |\n+------------------------------------+\n| {\"name\": \"James\", \"salary\": 10000} |\n+------------------------------------+",
        "+------------------------------------+\n| data                               |\n+------------------------------------+\n| {\"name\": \"james\", \"salary\": 9000}  |\n| {\"name\": \"James\", \"salary\": 10000} |\n+------------------------------------+",
        "CAST(data->'$.arr[*][*]' AS UNSIGNED ARRAY)"
    ],
    "Description": [
        "\n      Normally, you create all indexes on a table at the time the table\n      itself is created with CREATE\n      TABLE. See Section\u00a015.1.20, \u201cCREATE TABLE Statement\u201d. This\n      guideline is especially important for\n      InnoDB tables, where the primary key\n      determines the physical layout of rows in the data file.\n      CREATE INDEX enables you to add\n      indexes to existing tables.\n    ",
        "\nCREATE INDEX is mapped to an\n      ALTER TABLE statement to create\n      indexes. See Section\u00a015.1.9, \u201cALTER TABLE Statement\u201d.\n      CREATE INDEX cannot be used to\n      create a PRIMARY KEY; use\n      ALTER TABLE instead. For more\n      information about indexes, see Section\u00a010.3.1, \u201cHow MySQL Uses Indexes\u201d.\n    ",
        "\nInnoDB supports secondary indexes on\n      virtual columns. For more information, see\n      Section\u00a015.1.20.9, \u201cSecondary Indexes and Generated Columns\u201d.\n    ",
        "\n      When the innodb_stats_persistent\n      setting is enabled, run the ANALYZE\n      TABLE statement for an\n      InnoDB table after creating an index\n      on that table.\n    ",
        "\n      The expr for a\n      key_part specification can also take\n      the form (CAST json_expression\n      AS type ARRAY) to create a\n      multi-valued index on a JSON\n      column. See Multi-Valued Indexes.\n    ",
        "\n      An index specification of the form\n      (key_part1,\n      key_part2, ...) creates an\n      index with multiple key parts. Index key values are formed by\n      concatenating the values of the given key parts. For example\n      (col1, col2, col3) specifies a multiple-column\n      index with index keys consisting of values from\n      col1, col2, and\n      col3.\n    ",
        "\n      A key_part specification can end with\n      ASC or DESC to specify\n      whether index values are stored in ascending or descending order.\n      The default is ascending if no order specifier is given.\n    ",
        "\nASC and DESC are not\n      supported for HASH indexes, multi-valued\n      indexes or SPATIAL indexes.\n    ",
        "\n      The following sections describe different aspects of the\n      CREATE INDEX statement:\n",
        "\nColumn Prefix Key PartsFunctional Key PartsUnique IndexesFull-Text IndexesMulti-Valued IndexesSpatial IndexesIndex OptionsTable Copying and Locking Options\n",
        "\n\n\n\nColumn Prefix Key Parts\n\n\n\n\n        For string columns, indexes can be created that use only the\n        leading part of column values, using\n        col_name(length)\n        syntax to specify an index prefix length:\n\n\n\n            Prefixes can be specified for\n            CHAR,\n            VARCHAR,\n            BINARY, and\n            VARBINARY key parts.\n          \n            Prefixes must be specified for\n            BLOB and\n            TEXT key parts. Additionally,\n            BLOB and\n            TEXT columns can be indexed\n            only for InnoDB,\n            MyISAM, and BLACKHOLE\n            tables.\n          \n            Prefix limits are measured in bytes.\n            However, prefix lengths for index\n            specifications in CREATE\n            TABLE, ALTER TABLE,\n            and CREATE INDEX statements\n            are interpreted as number of characters for nonbinary string\n            types (CHAR,\n            VARCHAR,\n            TEXT) and number of bytes for\n            binary string types (BINARY,\n            VARBINARY,\n            BLOB). Take this into account\n            when specifying a prefix length for a nonbinary string\n            column that uses a multibyte character set.\n          \n            Prefix support and lengths of prefixes (where supported) are\n            storage engine dependent. For example, a prefix can be up to\n            767 bytes long for InnoDB\n            tables that use the\n            REDUNDANT\n            or\n            COMPACT\n            row format. The prefix length limit is 3072 bytes for\n            InnoDB tables that use the\n            DYNAMIC\n            or\n            COMPRESSED\n            row format. For MyISAM tables,\n            the prefix length limit is 1000 bytes. The\n            NDB storage engine does not\n            support prefixes (see\n            Section\u00a025.2.7.6, \u201cUnsupported or Missing Features in NDB Cluster\u201d).\n\n\n\n        If a specified index prefix exceeds the maximum column data type\n        size, CREATE INDEX handles the\n        index as follows:\n\n\n\n            For a nonunique index, either an error occurs (if strict SQL\n            mode is enabled), or the index length is reduced to lie\n            within the maximum column data type size and a warning is\n            produced (if strict SQL mode is not enabled).\n          \n            For a unique index, an error occurs regardless of SQL mode\n            because reducing the index length might enable insertion of\n            nonunique entries that do not meet the specified uniqueness\n            requirement.\n\n\n\n        The statement shown here creates an index using the first 10\n        characters of the name column (assuming that\n        name has a nonbinary string type):\n      Press CTRL+C to copy CREATE INDEX part_of_name ON customer (name(10));\n        If names in the column usually differ in the first 10\n        characters, lookups performed using this index should not be\n        much slower than using an index created from the entire\n        name column. Also, using column prefixes for\n        indexes can make the index file much smaller, which could save a\n        lot of disk space and might also speed up\n        INSERT operations.\n\n",
        "\n\n\n\nFunctional Key Parts\n\n\n\n\n        A \u201cnormal\u201d index indexes column values or prefixes\n        of column values. For example, in the following table, the index\n        entry for a given t1 row includes the full\n        col1 value and a prefix of the\n        col2 value consisting of its first 10\n        characters:\n      Press CTRL+C to copy CREATE TABLE t1 (\n  col1 VARCHAR(10),\n  col2 VARCHAR(20),\n  INDEX (col1, col2(10))\n);\n        Functional key parts that index expression values canalso be\n        used in place of column or column prefix values. Use of\n        functional key parts enables indexing of values not stored\n        directly in the table. Examples:\n      Press CTRL+C to copy CREATE TABLE t1 (col1 INT, col2 INT, INDEX func_index ((ABS(col1))));\nCREATE INDEX idx1 ON t1 ((col1 + col2));\nCREATE INDEX idx2 ON t1 ((col1 + col2), (col1 - col2), col1);\nALTER TABLE t1 ADD INDEX ((col1 * 40) DESC);\n        An index with multiple key parts can mix nonfunctional and\n        functional key parts.\n      \nASC and DESC are supported\n        for functional key parts.\n      \n        Functional key parts must adhere to the following rules. An\n        error occurs if a key part definition contains disallowed\n        constructs.\n\n\n\n            In index definitions, enclose expressions within parentheses\n            to distinguish them from columns or column prefixes. For\n            example, this is permitted; the expressions are enclosed\n            within parentheses:\n          Press CTRL+C to copy INDEX ((col1 + col2), (col3 - col4))\n            This produces an error; the expressions are not enclosed\n            within parentheses:\n          Press CTRL+C to copy INDEX (col1 + col2, col3 - col4)\n            A functional key part cannot consist solely of a column\n            name. For example, this is not permitted:\n          Press CTRL+C to copy INDEX ((col1), (col2))\n            Instead, write the key parts as nonfunctional key parts,\n            without parentheses:\n          Press CTRL+C to copy INDEX (col1, col2)\n            A functional key part expression cannot refer to column\n            prefixes. For a workaround, see the discussion of\n            SUBSTRING() and\n            CAST() later in this section.\n          \n            Functional key parts are not permitted in foreign key\n            specifications.\n\n\n\n        For CREATE\n        TABLE ... LIKE, the destination table preserves\n        functional key parts from the original table.\n      \n        Functional indexes are implemented as hidden virtual generated\n        columns, which has these implications:\n\n\n\n            Each functional key part counts against the limit on total\n            number of table columns; see\n            Section\u00a010.4.7, \u201cLimits on Table Column Count and Row Size\u201d.\n          \n            Functional key parts inherit all restrictions that apply to\n            generated columns. Examples:\n\n\n\n                Only functions permitted for generated columns are\n                permitted for functional key parts.\n              \n                Subqueries, parameters, variables, stored functions, and\n                loadable functions are not permitted.\n\n\n\n            For more information about applicable restrictions, see\n            Section\u00a015.1.20.8, \u201cCREATE TABLE and Generated Columns\u201d, and\n            Section\u00a015.1.9.2, \u201cALTER TABLE and Generated Columns\u201d.\n          \n            The virtual generated column itself requires no storage. The\n            index itself takes up storage space as any other index.\n\n\n\nUNIQUE is supported for indexes that include\n        functional key parts. However, primary keys cannot include\n        functional key parts. A primary key requires the generated\n        column to be stored, but functional key parts are implemented as\n        virtual generated columns, not stored generated columns.\n      \nSPATIAL and FULLTEXT\n        indexes cannot have functional key parts.\n      \n        If a table contains no primary key, InnoDB\n        automatically promotes the first UNIQUE NOT\n        NULL index to the primary key. This is not supported\n        for UNIQUE NOT NULL indexes that have\n        functional key parts.\n      \n        Nonfunctional indexes raise a warning if there are duplicate\n        indexes. Indexes that contain functional key parts do not have\n        this feature.\n      \n        To remove a column that is referenced by a functional key part,\n        the index must be removed first. Otherwise, an error occurs.\n      \n        Although nonfunctional key parts support a prefix length\n        specification, this is not possible for functional key parts.\n        The solution is to use\n        SUBSTRING() (or\n        CAST(), as described later in\n        this section). For a functional key part containing the\n        SUBSTRING() function to be used\n        in a query, the WHERE clause must contain\n        SUBSTRING() with the same\n        arguments. In the following example, only the second\n        SELECT is able to use the index\n        because that is the only query in which the arguments to\n        SUBSTRING() match the index\n        specification:\n      Press CTRL+C to copy CREATE TABLE tbl (\n  col1 LONGTEXT,\n  INDEX idx1 ((SUBSTRING(col1, 1, 10)))\n);\nSELECT * FROM tbl WHERE SUBSTRING(col1, 1, 9) = '123456789';\nSELECT * FROM tbl WHERE SUBSTRING(col1, 1, 10) = '1234567890';\n        Functional key parts enable indexing of values that cannot be\n        indexed otherwise, such as JSON\n        values. However, this must be done correctly to achieve the\n        desired effect. For example, this syntax does not work:\n      Press CTRL+C to copy CREATE TABLE employees (\n  data JSON,\n  INDEX ((data->>'$.name'))\n);\n        The syntax fails because:\n\n\n\n            The\n            ->>\n            operator translates into\n            JSON_UNQUOTE(JSON_EXTRACT(...)).\n          \nJSON_UNQUOTE() returns a\n            value with a data type of\n            LONGTEXT, and the hidden\n            generated column thus is assigned the same data type.\n          \n            MySQL cannot index LONGTEXT\n            columns specified without a prefix length on the key part,\n            and prefix lengths are not permitted in functional key\n            parts.\n\n\n\n        To index the JSON column, you could try using\n        the CAST() function as follows:\n      Press CTRL+C to copy CREATE TABLE employees (\n  data JSON,\n  INDEX ((CAST(data->>'$.name' AS CHAR(30))))\n);\n        The hidden generated column is assigned the\n        VARCHAR(30) data type, which can\n        be indexed. But this approach produces a new issue when trying\n        to use the index:\n\n\n\nCAST() returns a string with\n            the collation utf8mb4_0900_ai_ci (the\n            server default collation).\n          \nJSON_UNQUOTE() returns a\n            string with the collation utf8mb4_bin\n            (hard coded).\n\n\n\n        As a result, there is a collation mismatch between the indexed\n        expression in the preceding table definition and the\n        WHERE clause expression in the following\n        query:\n      Press CTRL+C to copy SELECT * FROM employees WHERE data->>'$.name' = 'James';\n        The index is not used because the expressions in the query and\n        the index differ. To support this kind of scenario for\n        functional key parts, the optimizer automatically strips\n        CAST() when looking for an index\n        to use, but only if the collation of the\n        indexed expression matches that of the query expression. For an\n        index with a functional key part to be used, either of the\n        following two solutions work (although they differ somewhat in\n        effect):\n\n\n\n            Solution 1. Assign the indexed expression the same collation\n            as JSON_UNQUOTE():\n          Press CTRL+C to copy CREATE TABLE employees (\n  data JSON,\n  INDEX idx ((CAST(data->>\"$.name\" AS CHAR(30)) COLLATE utf8mb4_bin))\n);\nINSERT INTO employees VALUES\n  ('{ \"name\": \"james\", \"salary\": 9000 }'),\n  ('{ \"name\": \"James\", \"salary\": 10000 }'),\n  ('{ \"name\": \"Mary\", \"salary\": 12000 }'),\n  ('{ \"name\": \"Peter\", \"salary\": 8000 }');\nSELECT * FROM employees WHERE data->>'$.name' = 'James';\n            The ->> operator is the same as\n            JSON_UNQUOTE(JSON_EXTRACT(...)), and\n            JSON_UNQUOTE() returns a string with\n            collation utf8mb4_bin. The comparison is\n            thus case-sensitive, and only one row matches:\n          Press CTRL+C to copy +------------------------------------+\n| data                               |\n+------------------------------------+\n| {\"name\": \"James\", \"salary\": 10000} |\n+------------------------------------+\n            Solution 2. Specify the full expression in the query:\n          Press CTRL+C to copy CREATE TABLE employees (\n  data JSON,\n  INDEX idx ((CAST(data->>\"$.name\" AS CHAR(30))))\n);\nINSERT INTO employees VALUES\n  ('{ \"name\": \"james\", \"salary\": 9000 }'),\n  ('{ \"name\": \"James\", \"salary\": 10000 }'),\n  ('{ \"name\": \"Mary\", \"salary\": 12000 }'),\n  ('{ \"name\": \"Peter\", \"salary\": 8000 }');\nSELECT * FROM employees WHERE CAST(data->>'$.name' AS CHAR(30)) = 'James';\nCAST() returns a string with collation\n            utf8mb4_0900_ai_ci, so the comparison\n            case-insensitive and two rows match:\n          Press CTRL+C to copy +------------------------------------+\n| data                               |\n+------------------------------------+\n| {\"name\": \"james\", \"salary\": 9000}  |\n| {\"name\": \"James\", \"salary\": 10000} |\n+------------------------------------+\n\n\n        Be aware that although the optimizer supports automatically\n        stripping CAST() with indexed\n        generated columns, the following approach does not work because\n        it produces a different result with and without an index\n        (Bug#27337092):\n      Press CTRL+C to copy mysql> CREATE TABLE employees (\n         data JSON,\n         generated_col VARCHAR(30) AS (CAST(data->>'$.name' AS CHAR(30)))\n       );\nQuery OK, 0 rows affected, 1 warning (0.03 sec)\n\nmysql> INSERT INTO employees (data)\n       VALUES ('{\"name\": \"james\"}'), ('{\"name\": \"James\"}');\nQuery OK, 2 rows affected, 1 warning (0.01 sec)\nRecords: 2  Duplicates: 0  Warnings: 1\n\nmysql> SELECT * FROM employees WHERE data->>'$.name' = 'James';\n+-------------------+---------------+\n| data              | generated_col |\n+-------------------+---------------+\n| {\"name\": \"James\"} | James         |\n+-------------------+---------------+\n1 row in set (0.00 sec)\n\nmysql> ALTER TABLE employees ADD INDEX idx (generated_col);\nQuery OK, 0 rows affected, 1 warning (0.03 sec)\nRecords: 0  Duplicates: 0  Warnings: 1\n\nmysql> SELECT * FROM employees WHERE data->>'$.name' = 'James';\n+-------------------+---------------+\n| data              | generated_col |\n+-------------------+---------------+\n| {\"name\": \"james\"} | james         |\n| {\"name\": \"James\"} | James         |\n+-------------------+---------------+\n2 rows in set (0.01 sec)\n",
        "\n\n\n\nUnique Indexes\n\n\n\n\n        A UNIQUE index creates a constraint such that\n        all values in the index must be distinct. An error occurs if you\n        try to add a new row with a key value that matches an existing\n        row. If you specify a prefix value for a column in a\n        UNIQUE index, the column values must be\n        unique within the prefix length. A UNIQUE\n        index permits multiple NULL values for\n        columns that can contain NULL.\n      \n        If a table has a PRIMARY KEY or\n        UNIQUE NOT NULL index that consists of a\n        single column that has an integer type, you can use\n        _rowid to refer to the indexed column in\n        SELECT statements, as follows:\n\n\n\n_rowid refers to the PRIMARY\n            KEY column if there is a PRIMARY\n            KEY consisting of a single integer column. If\n            there is a PRIMARY KEY but it does not\n            consist of a single integer column,\n            _rowid cannot be used.\n          \n            Otherwise, _rowid refers to the column in\n            the first UNIQUE NOT NULL index if that\n            index consists of a single integer column. If the first\n            UNIQUE NOT NULL index does not consist of\n            a single integer column, _rowid cannot be\n            used.\n\n\n",
        "\n\n\n\nFull-Text Indexes\n\n\n\n\nFULLTEXT indexes are supported only for\n        InnoDB and\n        MyISAM tables and can include only\n        CHAR,\n        VARCHAR, and\n        TEXT columns. Indexing always\n        happens over the entire column; column prefix indexing is not\n        supported and any prefix length is ignored if specified. See\n        Section\u00a014.9, \u201cFull-Text Search Functions\u201d, for details of operation.\n\n",
        "\n\n\n\nMulti-Valued Indexes\n\n\n\n\nInnoDB supports multi-valued indexes. A\n        multi-valued index is a secondary index defined on a column that\n        stores an array of values. A \u201cnormal\u201d index has one\n        index record for each data record (1:1). A multi-valued index\n        can have multiple index records for a single data record (N:1).\n        Multi-valued indexes are intended for indexing\n        JSON arrays. For example, a multi-valued\n        index defined on the array of zip codes in the following JSON\n        document creates an index record for each zip code, with each\n        index record referencing the same data record.\n      Press CTRL+C to copy {\n    \"user\":\"Bob\",\n    \"user_id\":31,\n    \"zipcode\":[94477,94536]\n}\nCreating multi-valued Indexes\n\n        You can create a multi-valued index in a\n        CREATE TABLE,\n        ALTER TABLE, or\n        CREATE INDEX statement. This\n        requires using CAST(... AS ...\n        ARRAY) in the index definition, which casts same-typed\n        scalar values in a JSON array to an SQL data\n        type array. A virtual column is then generated transparently\n        with the values in the SQL data type array; finally, a\n        functional index (also referred to as a virtual index) is\n        created on the virtual column. It is the functional index\n        defined on the virtual column of values from the SQL data type\n        array that forms the multi-valued index.\n      \n        The examples in the following list show the three different ways\n        in which a multi-valued index zips can be\n        created on an array $.zipcode on a\n        JSON column custinfo in a\n        table named customers. In each case, the JSON\n        array is cast to an SQL data type array of\n        UNSIGNED integer values.\n\n\n\nCREATE TABLE only:\n          Press CTRL+C to copy CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON,\n    INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) )\n    );\nCREATE TABLE plus ALTER\n            TABLE:\n          \nPress CTRL+C to copy CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON\n    );\n\nALTER TABLE customers ADD INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );\n\nCREATE TABLE plus CREATE\n            INDEX:\n          \nPress CTRL+C to copy CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON\n    );\n\nCREATE INDEX zips ON customers ( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );\n\n\n\n        A multi-valued index can also be defined as part of a composite\n        index. This example shows a composite index that includes two\n        single-valued parts (for the id and\n        modified columns), and one multi-valued part\n        (for the custinfo column):\n      Press CTRL+C to copy CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON\n    );\n\nALTER TABLE customers ADD INDEX comp(id, modified,\n    (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );\n        Only one multi-valued key part can be used in a composite index.\n        The multi-valued key part may be used in any order relative to\n        the other parts of the key. In other words, the ALTER\n        TABLE statement just shown could have used\n        comp(id, (CAST(custinfo->'$.zipcode' AS UNSIGNED\n        ARRAY), modified)) (or any other ordering) and still\n        have been valid.\n\nUsing multi-valued Indexes\n\n        The optimizer uses a multi-valued index to fetch records when\n        the following functions are specified in a\n        WHERE clause:\n\n\n\nMEMBER OF()\n\nJSON_CONTAINS()\n\nJSON_OVERLAPS()\n\n\n\n        We can demonstrate this by creating and populating the\n        customers table using the following\n        CREATE TABLE and INSERT\n        statements:\n      Press CTRL+C to copy mysql> CREATE TABLE customers (\n    ->     id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    ->     modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    ->     custinfo JSON\n    ->     );\nQuery OK, 0 rows affected (0.51 sec)\n\nmysql> INSERT INTO customers VALUES\n    ->     (NULL, NOW(), '{\"user\":\"Jack\",\"user_id\":37,\"zipcode\":[94582,94536]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Jill\",\"user_id\":22,\"zipcode\":[94568,94507,94582]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Bob\",\"user_id\":31,\"zipcode\":[94477,94507]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Mary\",\"user_id\":72,\"zipcode\":[94536]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Ted\",\"user_id\":56,\"zipcode\":[94507,94582]}');\nQuery OK, 5 rows affected (0.07 sec)\nRecords: 5  Duplicates: 0  Warnings: 0\n        First we execute three queries on the\n        customers table, one each using\n        MEMBER OF(),\n        JSON_CONTAINS(), and\n        JSON_OVERLAPS(), with the result from each\n        query shown here:\n      Press CTRL+C to copy mysql> SELECT * FROM customers\n    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');\n+----+---------------------+-------------------------------------------------------------------+\n| id | modified            | custinfo                                                          |\n+----+---------------------+-------------------------------------------------------------------+\n|  2 | 2019-06-29 22:23:12 | {\"user\": \"Jill\", \"user_id\": 22, \"zipcode\": [94568, 94507, 94582]} |\n|  3 | 2019-06-29 22:23:12 | {\"user\": \"Bob\", \"user_id\": 31, \"zipcode\": [94477, 94507]}         |\n|  5 | 2019-06-29 22:23:12 | {\"user\": \"Ted\", \"user_id\": 56, \"zipcode\": [94507, 94582]}         |\n+----+---------------------+-------------------------------------------------------------------+\n3 rows in set (0.00 sec)\n\nmysql> SELECT * FROM customers\n    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+---------------------+-------------------------------------------------------------------+\n| id | modified            | custinfo                                                          |\n+----+---------------------+-------------------------------------------------------------------+\n|  2 | 2019-06-29 22:23:12 | {\"user\": \"Jill\", \"user_id\": 22, \"zipcode\": [94568, 94507, 94582]} |\n|  5 | 2019-06-29 22:23:12 | {\"user\": \"Ted\", \"user_id\": 56, \"zipcode\": [94507, 94582]}         |\n+----+---------------------+-------------------------------------------------------------------+\n2 rows in set (0.00 sec)\n\nmysql> SELECT * FROM customers\n    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+---------------------+-------------------------------------------------------------------+\n| id | modified            | custinfo                                                          |\n+----+---------------------+-------------------------------------------------------------------+\n|  1 | 2019-06-29 22:23:12 | {\"user\": \"Jack\", \"user_id\": 37, \"zipcode\": [94582, 94536]}        |\n|  2 | 2019-06-29 22:23:12 | {\"user\": \"Jill\", \"user_id\": 22, \"zipcode\": [94568, 94507, 94582]} |\n|  3 | 2019-06-29 22:23:12 | {\"user\": \"Bob\", \"user_id\": 31, \"zipcode\": [94477, 94507]}         |\n|  5 | 2019-06-29 22:23:12 | {\"user\": \"Ted\", \"user_id\": 56, \"zipcode\": [94507, 94582]}         |\n+----+---------------------+-------------------------------------------------------------------+\n4 rows in set (0.00 sec)\n        Next, we run EXPLAIN on each of\n        the previous three queries:\n      Press CTRL+C to copy mysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.01 sec)\n        None of the three queries just shown are able to use any keys.\n        To solve this problem, we can add a multi-valued index on the\n        zipcode array in the JSON\n        column (custinfo), like this:\n      Press CTRL+C to copy mysql> ALTER TABLE customers\n    ->     ADD INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );\nQuery OK, 0 rows affected (0.47 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n        When we run the previous EXPLAIN statements\n        again, we can now observe that the queries can (and do) use the\n        index zips that was just created:\n      Press CTRL+C to copy mysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');\n+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ref  | zips          | zips | 9       | const |    1 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | range | zips          | zips | 9       | NULL |    6 |   100.00 | Using where |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | range | zips          | zips | 9       | NULL |    6 |   100.00 | Using where |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.01 sec)\n        A multi-valued index can be defined as a unique key. If defined\n        as a unique key, attempting to insert a value already present in\n        the multi-valued index returns a duplicate key error. If\n        duplicate values are already present, attempting to add a unique\n        multi-valued index fails, as shown here:\n      Press CTRL+C to copy mysql> ALTER TABLE customers DROP INDEX zips;\nQuery OK, 0 rows affected (0.55 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> ALTER TABLE customers\n    ->     ADD UNIQUE INDEX zips((CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)));\nERROR 1062 (23000): Duplicate entry '[94507, ' for key 'customers.zips'\nmysql> ALTER TABLE customers\n    ->     ADD INDEX zips((CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)));\nQuery OK, 0 rows affected (0.36 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\nCharacteristics of Multi-Valued Indexes\n\n        Multi-valued indexes have the additional characteristics listed\n        here:\n\n\n\n            DML operations that affect multi-valued indexes are handled\n            in the same way as DML operations that affect a normal\n            index, with the only difference being that there may be more\n            than one insert or update for a single clustered index\n            record.\n          \n            Nullability and multi-valued indexes:\n\n\n\n                If a multi-valued key part has an empty array, no\n                entries are added to the index, and the data record is\n                not accessible by an index scan.\n              \n                If multi-valued key part generation returns a\n                NULL value, a single entry containing\n                NULL is added to the multi-valued\n                index. If the key part is defined as NOT\n                NULL, an error is reported.\n              \n                If the typed array column is set to\n                NULL, the storage engine stores a\n                single record containing NULL that\n                points to the data record.\n              \nJSON null values are not permitted in\n                indexed arrays. If any returned value is\n                NULL, it is treated as a JSON null\n                and an Invalid JSON value error\n                is reported.\n\n\n\n            Because multi-valued indexes are virtual indexes on virtual\n            columns, they must adhere to the same rules as secondary\n            indexes on virtual generated columns.\n          \n            Index records are not added for empty arrays.\n\n\nLimitations and Restrictions on Multi-valued Indexes\n\n        Multi-valued indexes are subject to the limitations and\n        restrictions listed here:\n\n\n\n            Only one multi-valued key part is permitted per multi-valued\n            index. However, the CAST(... AS ...\n            ARRAY) expression can refer to multiple arrays\n            within a JSON document, as shown here:\n          Press CTRL+C to copy CAST(data->'$.arr[*][*]' AS UNSIGNED ARRAY)\n            In this case, all values matching the JSON expression are\n            stored in the index as a single flat array.\n          \n            An index with a multi-valued key part does not support\n            ordering and therefore cannot be used as a primary key. For\n            the same reason, a multi-valued index cannot be defined\n            using the ASC or DESC\n            keyword.\n          \n            A multi-valued index cannot be a covering index.\n          \n            The maximum number of values per record for a multi-valued\n            index is determined by the amount of data than can be stored\n            on a single undo log page, which is 65221 bytes (64K minus\n            315 bytes for overhead), which means that the maximum total\n            length of key values is also 65221 bytes. The maximum number\n            of keys depends on various factors, which prevents defining\n            a specific limit. Tests have shown a multi-valued index to\n            permit as many as 1604 integer keys per record, for example.\n            When the limit is reached, an error similar to the following\n            is reported: ERROR 3905 (HY000): Exceeded max\n            number of values per record for multi-valued index 'idx' by\n            1 value(s).\n\n            The only type of expression that is permitted in a\n            multi-valued key part is a JSON\n            expression. The expression need not reference an existing\n            element in a JSON document inserted into the indexed column,\n            but must itself be syntactically valid.\n          \n            Because index records for the same clustered index record\n            are dispersed throughout a multi-valued index, a\n            multi-valued index does not support range scans or\n            index-only scans.\n          \n            Multi-valued indexes are not permitted in foreign key\n            specifications.\n          \n            Index prefixes cannot be defined for multi-valued indexes.\n          \n            Multi-valued indexes cannot be defined on data cast as\n            BINARY (see the description\n            of the CAST() function).\n          \n            Online creation of a multi-value index is not supported,\n            which means the operation uses\n            ALGORITHM=COPY. See\n            Performance and Space Requirements.\n          \n            Character sets and collations other than the following two\n            combinations of character set and collation are not\n            supported for multi-valued indexes:\n\n\n\n                The binary character set with the\n                default binary collation\n              \n                The utf8mb4 character set with the\n                default utf8mb4_0900_as_cs collation.\n\n\n\n            As with other indexes on columns of\n            InnoDB tables, a multi-valued index\n            cannot be created with USING HASH;\n            attempting to do so results in a warning: This\n            storage engine does not support the HASH index algorithm,\n            storage engine default was used instead.\n            (USING BTREE is supported as usual.)\n\n\n",
        "\n\n\n\nSpatial Indexes\n\n\n\n\n        The MyISAM,\n        InnoDB,\n        NDB, and\n        ARCHIVE storage engines support\n        spatial columns such as POINT and\n        GEOMETRY.\n        (Section\u00a013.4, \u201cSpatial Data Types\u201d, describes the spatial data\n        types.) However, support for spatial column indexing varies\n        among engines. Spatial and nonspatial indexes on spatial columns\n        are available according to the following rules.\n      \n        Spatial indexes on spatial columns have these characteristics:\n\n\n\n            Available only for InnoDB and\n            MyISAM tables. Specifying\n            SPATIAL INDEX for other storage engines\n            results in an error.\n          \n            An index on a spatial column must be a\n            SPATIAL index. The\n            SPATIAL keyword is thus optional but\n            implicit for creating an index on a spatial column.\n          \n            Available for single spatial columns only. A spatial index\n            cannot be created over multiple spatial columns.\n          \n            Indexed columns must be NOT NULL.\n          \n            Column prefix lengths are prohibited. The full width of each\n            column is indexed.\n          \n            Not permitted for a primary key or unique index.\n\n\n\n        Nonspatial indexes on spatial columns (created with\n        INDEX, UNIQUE, or\n        PRIMARY KEY) have these characteristics:\n\n\n\n            Permitted for any storage engine that supports spatial\n            columns except ARCHIVE.\n          \n            Columns can be NULL unless the index is a\n            primary key.\n          \n            The index type for a non-SPATIAL index\n            depends on the storage engine. Currently, B-tree is used.\n          \n            Permitted for a column that can have NULL\n            values only for InnoDB,\n            MyISAM, and\n            MEMORY tables.\n\n\n",
        "\n\n\n\nIndex Options\n\n\n\n\n        Following the key part list, index options can be given. An\n        index_option value can be any of the\n        following:\n\n\n\nKEY_BLOCK_SIZE [=]\n            value\n\n            For MyISAM tables,\n            KEY_BLOCK_SIZE optionally specifies the\n            size in bytes to use for index key blocks. The value is\n            treated as a hint; a different size could be used if\n            necessary. A KEY_BLOCK_SIZE value\n            specified for an individual index definition overrides a\n            table-level KEY_BLOCK_SIZE value.\n          \nKEY_BLOCK_SIZE is not supported at the\n            index level for InnoDB tables.\n            See Section\u00a015.1.20, \u201cCREATE TABLE Statement\u201d.\n          \nindex_type\n\n            Some storage engines permit you to specify an index type\n            when creating an index. For example:\n          Press CTRL+C to copy CREATE TABLE lookup (id INT) ENGINE = MEMORY;\nCREATE INDEX id_index ON lookup (id) USING BTREE;\nTable\u00a015.1, \u201cIndex Types Per Storage Engine\u201d\n            shows the permissible index type values supported by\n            different storage engines. Where multiple index types are\n            listed, the first one is the default when no index type\n            specifier is given. Storage engines not listed in the table\n            do not support an index_type\n            clause in index definitions.\n\n\nTable\u00a015.1\u00a0Index Types Per Storage Engine\n\n\nStorage Engine\nPermissible Index Types\n\nInnoDB\nBTREE\n\nMyISAM\nBTREE\n\nMEMORY/HEAP\nHASH, BTREE\n\nNDB\nHASH, BTREE (see note in text)\n\n\n\n\n            The index_type clause cannot be\n            used for FULLTEXT INDEX specifications.\n            Full-text index implementation is storage-engine dependent.\n            Spatial indexes are implemented as R-tree indexes.\n          \n            If you specify an index type that is not valid for a given\n            storage engine, but another index type is available that the\n            engine can use without affecting query results, the engine\n            uses the available type. The parser recognizes\n            RTREE as a type name. This is permitted\n            only for SPATIAL indexes.\n          \nBTREE indexes are implemented by the\n            NDB storage engine as T-tree\n            indexes.\n\n\n\nNote\n\n\n              For indexes on NDB table\n              columns, the USING option can be\n              specified only for a unique index or primary key.\n              USING HASH prevents the creation of an\n              ordered index; otherwise, creating a unique index or\n              primary key on an NDB table\n              automatically results in the creation of both an ordered\n              index and a hash index, each of which indexes the same set\n              of columns.\n            \n              For unique indexes that include one or more\n              NULL columns of an\n              NDB table, the hash index can\n              be used only to look up literal values, which means that\n              IS [NOT] NULL conditions require a full\n              scan of the table. One workaround is to make sure that a\n              unique index using one or more NULL\n              columns on such a table is always created in such a way\n              that it includes the ordered index; that is, avoid\n              employing USING HASH when creating the\n              index.\n\n\n\n            If you specify an index type that is not valid for a given\n            storage engine, but another index type is available that the\n            engine can use without affecting query results, the engine\n            uses the available type. The parser recognizes\n            RTREE as a type name, but currently this\n            cannot be specified for any storage engine.\n\n\n\nNote\n\n\n              Use of the index_type option\n              before the ON\n              tbl_name clause is\n              deprecated; expect support for use of the option in this\n              position to be removed in a future MySQL release. If an\n              index_type option is given in\n              both the earlier and later positions, the final option\n              applies.\n\n\n\nTYPE type_name\n            is recognized as a synonym for USING\n            type_name. However,\n            USING is the preferred form.\n          \n            The following tables show index characteristics for the\n            storage engines that support the\n            index_type option.\n\n\nTable\u00a015.2\u00a0InnoDB Storage Engine Index Characteristics\n\n\nIndex Class\nIndex Type\nStores NULL VALUES\nPermits Multiple NULL Values\nIS NULL Scan Type\nIS NOT NULL Scan Type\n\nPrimary key\nBTREE\nNo\nNo\nN/A\nN/A\n\nUnique\nBTREE\nYes\nYes\nIndex\nIndex\n\nKey\nBTREE\nYes\nYes\nIndex\nIndex\n\nFULLTEXT\nN/A\nYes\nYes\nTable\nTable\n\nSPATIAL\nN/A\nNo\nNo\nN/A\nN/A\n\n\n\n\n\nTable\u00a015.3\u00a0MyISAM Storage Engine Index Characteristics\n\n\nIndex Class\nIndex Type\nStores NULL VALUES\nPermits Multiple NULL Values\nIS NULL Scan Type\nIS NOT NULL Scan Type\n\nPrimary key\nBTREE\nNo\nNo\nN/A\nN/A\n\nUnique\nBTREE\nYes\nYes\nIndex\nIndex\n\nKey\nBTREE\nYes\nYes\nIndex\nIndex\n\nFULLTEXT\nN/A\nYes\nYes\nTable\nTable\n\nSPATIAL\nN/A\nNo\nNo\nN/A\nN/A\n\n\n\n\n\nTable\u00a015.4\u00a0MEMORY Storage Engine Index Characteristics\n\n\nIndex Class\nIndex Type\nStores NULL VALUES\nPermits Multiple NULL Values\nIS NULL Scan Type\nIS NOT NULL Scan Type\n\nPrimary key\nBTREE\nNo\nNo\nN/A\nN/A\n\nUnique\nBTREE\nYes\nYes\nIndex\nIndex\n\nKey\nBTREE\nYes\nYes\nIndex\nIndex\n\nPrimary key\nHASH\nNo\nNo\nN/A\nN/A\n\nUnique\nHASH\nYes\nYes\nIndex\nIndex\n\nKey\nHASH\nYes\nYes\nIndex\nIndex\n\n\n\n\n\nTable\u00a015.5\u00a0NDB Storage Engine Index Characteristics\n\n\nIndex Class\nIndex Type\nStores NULL VALUES\nPermits Multiple NULL Values\nIS NULL Scan Type\nIS NOT NULL Scan Type\n\nPrimary key\nBTREE\nNo\nNo\nIndex\nIndex\n\nUnique\nBTREE\nYes\nYes\nIndex\nIndex\n\nKey\nBTREE\nYes\nYes\nIndex\nIndex\n\nPrimary key\nHASH\nNo\nNo\nTable (see note 1)\nTable (see note 1)\n\nUnique\nHASH\nYes\nYes\nTable (see note 1)\nTable (see note 1)\n\nKey\nHASH\nYes\nYes\nTable (see note 1)\nTable (see note 1)\n\n\n\n\n            Table note:\n          \n            1. USING HASH prevents creation of an\n            implicit ordered index.\n          \nWITH PARSER\n            parser_name\n\n            This option can be used only with\n            FULLTEXT indexes. It associates a parser\n            plugin with the index if full-text indexing and searching\n            operations need special handling.\n            InnoDB and\n            MyISAM support full-text parser\n            plugins. If you have a MyISAM\n            table with an associated full-text parser plugin, you can\n            convert the table to InnoDB using\n            ALTER TABLE. See\n            Full-Text Parser Plugins and\n            Writing Full-Text Parser Plugins for more\n            information.\n          \nCOMMENT\n            'string'\n\n            Index definitions can include an optional comment of up to\n            1024 characters.\n          \n            The\n            MERGE_THRESHOLD\n            for index pages can be configured for individual indexes\n            using the index_option\nCOMMENT clause of the\n            CREATE INDEX statement. For\n            example:\n          Press CTRL+C to copy CREATE TABLE t1 (id INT);\nCREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';\n            If the page-full percentage for an index page falls below\n            the MERGE_THRESHOLD value when a row is\n            deleted or when a row is shortened by an update operation,\n            InnoDB attempts to merge the\n            index page with a neighboring index page. The default\n            MERGE_THRESHOLD value is 50, which is the\n            previously hardcoded value.\n          \nMERGE_THRESHOLD can also be defined at\n            the index level and table level using\n            CREATE TABLE and\n            ALTER TABLE statements. For\n            more information, see\n            Section\u00a017.8.11, \u201cConfiguring the Merge Threshold for Index Pages\u201d.\n          \nVISIBLE, INVISIBLE\n\n            Specify index visibility. Indexes are visible by default. An\n            invisible index is not used by the optimizer. Specification\n            of index visibility applies to indexes other than primary\n            keys (either explicit or implicit). For more information,\n            see Section\u00a010.3.12, \u201cInvisible Indexes\u201d.\n          \n            The ENGINE_ATTRIBUTE and\n            SECONDARY_ENGINE_ATTRIBUTE are used to\n            specify index attributes for primary and secondary storage\n            engines. The options are reserved for future use.\n          \n            The value assigned to this option is a string literal\n            containing a valid JSON document or an empty string ('').\n            Invalid JSON is rejected.\n          Press CTRL+C to copy CREATE INDEX i1 ON t1 (c1) ENGINE_ATTRIBUTE='{\"key\":\"value\"}';\nENGINE_ATTRIBUTE and\n            SECONDARY_ENGINE_ATTRIBUTE values can be\n            repeated without error. In this case, the last specified\n            value is used.\n          \nENGINE_ATTRIBUTE and\n            SECONDARY_ENGINE_ATTRIBUTE values are not\n            checked by the server, nor are they cleared when the\n            table's storage engine is changed.\n\n\n",
        "\n\n\n\nTable Copying and Locking Options\n\n\n\n\nALGORITHM and LOCK clauses\n        may be given to influence the table copying method and level of\n        concurrency for reading and writing the table while its indexes\n        are being modified. They have the same meaning as for the\n        ALTER TABLE statement. For more\n        information, see Section\u00a015.1.9, \u201cALTER TABLE Statement\u201d\n\n        NDB Cluster supports online operations using the same\n        ALGORITHM=INPLACE syntax used with the\n        standard MySQL Server. See\n        Section\u00a025.6.12, \u201cOnline Operations with ALTER TABLE in NDB Cluster\u201d, for more\n        information.\n\n"
    ],
    "Examples": [
        "CREATE INDEX part_of_name ON customer (name(10));",
        "CREATE TABLE t1 (\n  col1 VARCHAR(10),\n  col2 VARCHAR(20),\n  INDEX (col1, col2(10))\n);",
        "CREATE TABLE t1 (col1 INT, col2 INT, INDEX func_index ((ABS(col1))));\nCREATE INDEX idx1 ON t1 ((col1 + col2));\nCREATE INDEX idx2 ON t1 ((col1 + col2), (col1 - col2), col1);\nALTER TABLE t1 ADD INDEX ((col1 * 40) DESC);",
        "CREATE TABLE tbl (\n  col1 LONGTEXT,\n  INDEX idx1 ((SUBSTRING(col1, 1, 10)))\n);\nSELECT * FROM tbl WHERE SUBSTRING(col1, 1, 9) = '123456789';\nSELECT * FROM tbl WHERE SUBSTRING(col1, 1, 10) = '1234567890';",
        "CREATE TABLE employees (\n  data JSON,\n  INDEX ((data->>'$.name'))\n);",
        "CREATE TABLE employees (\n  data JSON,\n  INDEX ((CAST(data->>'$.name' AS CHAR(30))))\n);",
        "SELECT * FROM employees WHERE data->>'$.name' = 'James';",
        "CREATE TABLE employees (\n  data JSON,\n  INDEX idx ((CAST(data->>\"$.name\" AS CHAR(30)) COLLATE utf8mb4_bin))\n);\nINSERT INTO employees VALUES\n  ('{ \"name\": \"james\", \"salary\": 9000 }'),\n  ('{ \"name\": \"James\", \"salary\": 10000 }'),\n  ('{ \"name\": \"Mary\", \"salary\": 12000 }'),\n  ('{ \"name\": \"Peter\", \"salary\": 8000 }');\nSELECT * FROM employees WHERE data->>'$.name' = 'James';",
        "CREATE TABLE employees (\n  data JSON,\n  INDEX idx ((CAST(data->>\"$.name\" AS CHAR(30))))\n);\nINSERT INTO employees VALUES\n  ('{ \"name\": \"james\", \"salary\": 9000 }'),\n  ('{ \"name\": \"James\", \"salary\": 10000 }'),\n  ('{ \"name\": \"Mary\", \"salary\": 12000 }'),\n  ('{ \"name\": \"Peter\", \"salary\": 8000 }');\nSELECT * FROM employees WHERE CAST(data->>'$.name' AS CHAR(30)) = 'James';",
        "mysql> CREATE TABLE employees (\n         data JSON,\n         generated_col VARCHAR(30) AS (CAST(data->>'$.name' AS CHAR(30)))\n       );\nQuery OK, 0 rows affected, 1 warning (0.03 sec)\n\nmysql> INSERT INTO employees (data)\n       VALUES ('{\"name\": \"james\"}'), ('{\"name\": \"James\"}');\nQuery OK, 2 rows affected, 1 warning (0.01 sec)\nRecords: 2  Duplicates: 0  Warnings: 1\n\nmysql> SELECT * FROM employees WHERE data->>'$.name' = 'James';\n+-------------------+---------------+\n| data              | generated_col |\n+-------------------+---------------+\n| {\"name\": \"James\"} | James         |\n+-------------------+---------------+\n1 row in set (0.00 sec)\n\nmysql> ALTER TABLE employees ADD INDEX idx (generated_col);\nQuery OK, 0 rows affected, 1 warning (0.03 sec)\nRecords: 0  Duplicates: 0  Warnings: 1\n\nmysql> SELECT * FROM employees WHERE data->>'$.name' = 'James';\n+-------------------+---------------+\n| data              | generated_col |\n+-------------------+---------------+\n| {\"name\": \"james\"} | james         |\n| {\"name\": \"James\"} | James         |\n+-------------------+---------------+\n2 rows in set (0.01 sec)",
        "CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON,\n    INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) )\n    );",
        "CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON\n    );\n\nALTER TABLE customers ADD INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );",
        "CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON\n    );\n\nCREATE INDEX zips ON customers ( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );",
        "CREATE TABLE customers (\n    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    custinfo JSON\n    );\n\nALTER TABLE customers ADD INDEX comp(id, modified,\n    (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );",
        "mysql> CREATE TABLE customers (\n    ->     id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    ->     modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    ->     custinfo JSON\n    ->     );\nQuery OK, 0 rows affected (0.51 sec)\n\nmysql> INSERT INTO customers VALUES\n    ->     (NULL, NOW(), '{\"user\":\"Jack\",\"user_id\":37,\"zipcode\":[94582,94536]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Jill\",\"user_id\":22,\"zipcode\":[94568,94507,94582]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Bob\",\"user_id\":31,\"zipcode\":[94477,94507]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Mary\",\"user_id\":72,\"zipcode\":[94536]}'),\n    ->     (NULL, NOW(), '{\"user\":\"Ted\",\"user_id\":56,\"zipcode\":[94507,94582]}');\nQuery OK, 5 rows affected (0.07 sec)\nRecords: 5  Duplicates: 0  Warnings: 0",
        "mysql> SELECT * FROM customers\n    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');\n+----+---------------------+-------------------------------------------------------------------+\n| id | modified            | custinfo                                                          |\n+----+---------------------+-------------------------------------------------------------------+\n|  2 | 2019-06-29 22:23:12 | {\"user\": \"Jill\", \"user_id\": 22, \"zipcode\": [94568, 94507, 94582]} |\n|  3 | 2019-06-29 22:23:12 | {\"user\": \"Bob\", \"user_id\": 31, \"zipcode\": [94477, 94507]}         |\n|  5 | 2019-06-29 22:23:12 | {\"user\": \"Ted\", \"user_id\": 56, \"zipcode\": [94507, 94582]}         |\n+----+---------------------+-------------------------------------------------------------------+\n3 rows in set (0.00 sec)\n\nmysql> SELECT * FROM customers\n    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+---------------------+-------------------------------------------------------------------+\n| id | modified            | custinfo                                                          |\n+----+---------------------+-------------------------------------------------------------------+\n|  2 | 2019-06-29 22:23:12 | {\"user\": \"Jill\", \"user_id\": 22, \"zipcode\": [94568, 94507, 94582]} |\n|  5 | 2019-06-29 22:23:12 | {\"user\": \"Ted\", \"user_id\": 56, \"zipcode\": [94507, 94582]}         |\n+----+---------------------+-------------------------------------------------------------------+\n2 rows in set (0.00 sec)\n\nmysql> SELECT * FROM customers\n    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+---------------------+-------------------------------------------------------------------+\n| id | modified            | custinfo                                                          |\n+----+---------------------+-------------------------------------------------------------------+\n|  1 | 2019-06-29 22:23:12 | {\"user\": \"Jack\", \"user_id\": 37, \"zipcode\": [94582, 94536]}        |\n|  2 | 2019-06-29 22:23:12 | {\"user\": \"Jill\", \"user_id\": 22, \"zipcode\": [94568, 94507, 94582]} |\n|  3 | 2019-06-29 22:23:12 | {\"user\": \"Bob\", \"user_id\": 31, \"zipcode\": [94477, 94507]}         |\n|  5 | 2019-06-29 22:23:12 | {\"user\": \"Ted\", \"user_id\": 56, \"zipcode\": [94507, 94582]}         |\n+----+---------------------+-------------------------------------------------------------------+\n4 rows in set (0.00 sec)",
        "mysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.01 sec)",
        "mysql> ALTER TABLE customers\n    ->     ADD INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );\nQuery OK, 0 rows affected (0.47 sec)\nRecords: 0  Duplicates: 0  Warnings: 0",
        "mysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');\n+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+\n| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | ref  | zips          | zips | 9       | const |    1 |   100.00 | Using where |\n+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | range | zips          | zips | 9       | NULL |    6 |   100.00 | Using where |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> EXPLAIN SELECT * FROM customers\n    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | customers | NULL       | range | zips          | zips | 9       | NULL |    6 |   100.00 | Using where |\n+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.01 sec)",
        "mysql> ALTER TABLE customers DROP INDEX zips;\nQuery OK, 0 rows affected (0.55 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> ALTER TABLE customers\n    ->     ADD UNIQUE INDEX zips((CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)));\nERROR 1062 (23000): Duplicate entry '[94507, ' for key 'customers.zips'\nmysql> ALTER TABLE customers\n    ->     ADD INDEX zips((CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)));\nQuery OK, 0 rows affected (0.36 sec)\nRecords: 0  Duplicates: 0  Warnings: 0",
        "CREATE TABLE lookup (id INT) ENGINE = MEMORY;\nCREATE INDEX id_index ON lookup (id) USING BTREE;",
        "CREATE TABLE t1 (id INT);\nCREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';",
        "CREATE INDEX i1 ON t1 (c1) ENGINE_ATTRIBUTE='{\"key\":\"value\"}';"
    ],
    "Category": [
        "Data Definition Statements"
    ]
}