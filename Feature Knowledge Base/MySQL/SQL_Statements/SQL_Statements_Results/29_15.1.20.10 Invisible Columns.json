{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/invisible-columns.html"
    ],
    "Title": [
        "15.1.20.10 Invisible Columns"
    ],
    "Feature": [
        "mysql> SHOW CREATE TABLE t1\\G\n*************************** 1. row ***************************\n       Table: t1\nCreate Table: CREATE TABLE `t1` (\n  `i` int DEFAULT NULL,\n  `j` int DEFAULT NULL,\n  `k` int DEFAULT NULL /*!80023 INVISIBLE */\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci"
    ],
    "Description": [
        "\n        MySQL 8.4 supports invisible columns. An invisible\n        column is normally hidden to queries, but can be accessed if\n        explicitly referenced.\n      ",
        "\n        As an illustration of when invisible columns may be useful,\n        suppose that an application uses SELECT *\n        queries to access a table, and must continue to work without\n        modification even if the table is altered to add a new column\n        that the application does not expect to be there. In a\n        SELECT * query, the *\n        evaluates to all table columns, except those that are invisible,\n        so the solution is to add the new column as an invisible column.\n        The column remains \u201chidden\u201d from SELECT\n        * queries, and the application continues to work as\n        previously. A newer version of the application can refer to the\n        invisible column if necessary by explicitly referencing it.\n      ",
        "\n        The following sections detail how MySQL treats invisible\n        columns.\n",
        "\nDDL Statements and Invisible ColumnsDML Statements and Invisible ColumnsInvisible Column MetadataThe Binary Log and Invisible Columns\n",
        "\n\n\n\nDDL Statements and Invisible Columns\n\n\n\n\n          Columns are visible by default. To explicitly specify\n          visibility for a new column, use a VISIBLE\n          or INVISIBLE keyword as part of the column\n          definition for CREATE TABLE or\n          ALTER TABLE:\n        Press CTRL+C to copy CREATE TABLE t1 (\n  i INT,\n  j DATE INVISIBLE\n) ENGINE = InnoDB;\nALTER TABLE t1 ADD COLUMN k INT INVISIBLE;\n          To alter the visibility of an existing column, use a\n          VISIBLE or INVISIBLE\n          keyword with one of the ALTER TABLE\n          column-modification clauses:\n        Press CTRL+C to copy ALTER TABLE t1 CHANGE COLUMN j j DATE VISIBLE;\nALTER TABLE t1 MODIFY COLUMN j DATE INVISIBLE;\nALTER TABLE t1 ALTER COLUMN j SET VISIBLE;\n          A table must have at least one visible column. Attempting to\n          make all columns invisible produces an error.\n        \n          Invisible columns support the usual column attributes:\n          NULL, NOT NULL,\n          AUTO_INCREMENT, and so forth.\n        \n          Generated columns can be invisible.\n        \n          Index definitions can name invisible columns, including\n          definitions for PRIMARY KEY and\n          UNIQUE indexes. Although a table must have\n          at least one visible column, an index definition need not have\n          any visible columns.\n        \n          An invisible column dropped from a table is dropped in the\n          usual way from any index definition that names the column.\n        \n          Foreign key constraints can be defined on invisible columns,\n          and foreign key constraints can reference invisible columns.\n        \nCHECK constraints can be defined on\n          invisible columns. For new or modified rows, violation of a\n          CHECK constraint on an invisible column\n          produces an error.\n        \nCREATE\n          TABLE ... LIKE includes invisible columns, and they\n          are invisible in the new table.\n        \nCREATE\n          TABLE ... SELECT does not include invisible columns,\n          unless they are explicitly referenced in the\n          SELECT part. However, even if\n          explicitly referenced, a column that is invisible in the\n          existing table is visible in the new table:\n        Press CTRL+C to copy mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nmysql> CREATE TABLE t2 AS SELECT col1, col2 FROM t1;\nmysql> SHOW CREATE TABLE t2\\G\n*************************** 1. row ***************************\n       Table: t2\nCreate Table: CREATE TABLE `t2` (\n  `col1` int DEFAULT NULL,\n  `col2` int DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n          If invisibility should be preserved, provide a definition for\n          the invisible column in the CREATE\n          TABLE part of the\n          CREATE\n          TABLE ... SELECT statement:\n        Press CTRL+C to copy mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nmysql> CREATE TABLE t2 (col2 INT INVISIBLE) AS SELECT col1, col2 FROM t1;\nmysql> SHOW CREATE TABLE t2\\G\n*************************** 1. row ***************************\n       Table: t2\nCreate Table: CREATE TABLE `t2` (\n  `col1` int DEFAULT NULL,\n  `col2` int DEFAULT NULL /*!80023 INVISIBLE */\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n          Views can refer to invisible columns by explicitly referencing\n          them in the SELECT statement that defines\n          the view. Changing a column's visibility subsequent to\n          defining a view that references the column does not change\n          view behavior.\n\n",
        "\n\n\n\nDML Statements and Invisible Columns\n\n\n\n\n          For SELECT statements, an\n          invisible column is not part of the result set unless\n          explicitly referenced in the select list. In a select list,\n          the * and\n          tbl_name.*\n          shorthands do not include invisible columns. Natural joins do\n          not include invisible columns.\n        \n          Consider the following statement sequence:\n        Press CTRL+C to copy mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nmysql> INSERT INTO t1 (col1, col2) VALUES(1, 2), (3, 4);\n\nmysql> SELECT * FROM t1;\n+------+\n| col1 |\n+------+\n|    1 |\n|    3 |\n+------+\n\nmysql> SELECT col1, col2 FROM t1;\n+------+------+\n| col1 | col2 |\n+------+------+\n|    1 |    2 |\n|    3 |    4 |\n+------+------+\n          The first SELECT does not reference the\n          invisible column col2 in the select list\n          (because * does not include invisible\n          columns), so col2 does not appear in the\n          statement result. The second SELECT\n          explicitly references col2, so the column\n          appears in the result.\n        \n          The statement TABLE\n          t1 produces the same output as the first\n          SELECT statement. Since there is no way to\n          specify columns in a TABLE statement,\n          TABLE never displays invisible columns.\n        \n          For statements that create new rows, an invisible column is\n          assigned its implicit default value unless explicitly\n          referenced and assigned a value. For information about\n          implicit defaults, see\n          Implicit Default Handling.\n        \n          For INSERT (and\n          REPLACE, for non-replaced\n          rows), implicit default assignment occurs with a missing\n          column list, an empty column list, or a nonempty column list\n          that does not include the invisible column:\n        Press CTRL+C to copy CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nINSERT INTO t1 VALUES(...);\nINSERT INTO t1 () VALUES(...);\nINSERT INTO t1 (col1) VALUES(...);\n          For the first two INSERT\n          statements, the VALUES() list must provide\n          a value for each visible column and no invisible column. For\n          the third INSERT statement, the\n          VALUES() list must provide the same number\n          of values as the number of named columns; the same is true\n          when you use VALUES\n          ROW() rather than VALUES().\n        \n          For LOAD DATA and\n          LOAD XML, implicit default\n          assignment occurs with a missing column list or a nonempty\n          column list that does not include the invisible column. Input\n          rows should not include a value for the invisible column.\n        \n          To assign a value other than the implicit default for the\n          preceding statements, explicitly name the invisible column in\n          the column list and provide a value for it.\n        \nINSERT INTO ...\n          SELECT * and\n          REPLACE INTO ...\n          SELECT * do not include invisible columns because\n          * does not include invisible columns.\n          Implicit default assignment occurs as described previously.\n        \n          For statements that insert or ignore new rows, or that replace\n          or modify existing rows, based on values in a PRIMARY\n          KEY or UNIQUE index, MySQL treats\n          invisible columns the same as visible columns: Invisible\n          columns participate in key value comparisons. Specifically, if\n          a new row has the same value as an existing row for a unique\n          key value, these behaviors occur whether the index columns are\n          visible or invisible:\n\n\n\n              With the IGNORE modifier,\n              INSERT,\n              LOAD DATA, and\n              LOAD XML ignore the new\n              row.\n            \nREPLACE replaces the\n              existing row with the new row. With the\n              REPLACE modifier,\n              LOAD DATA and\n              LOAD XML do the same.\n            \nINSERT\n              ... ON DUPLICATE KEY UPDATE updates the existing\n              row.\n\n\n\n          To update invisible columns for\n          UPDATE statements, name them\n          and assign a value, just as for visible columns.\n\n",
        "\n\n\n\nInvisible Column Metadata\n\n\n\n\n          Information about whether a column is visible or invisible is\n          available from the EXTRA column of the\n          Information Schema COLUMNS table\n          or SHOW COLUMNS output. For\n          example:\n        Press CTRL+C to copy mysql> SELECT TABLE_NAME, COLUMN_NAME, EXTRA\n       FROM INFORMATION_SCHEMA.COLUMNS\n       WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';\n+------------+-------------+-----------+\n| TABLE_NAME | COLUMN_NAME | EXTRA     |\n+------------+-------------+-----------+\n| t1         | i           |           |\n| t1         | j           |           |\n| t1         | k           | INVISIBLE |\n+------------+-------------+-----------+\n          Columns are visible by default, so in that case,\n          EXTRA displays no visibility information.\n          For invisible columns, EXTRA displays\n          INVISIBLE.\n        \nSHOW CREATE TABLE displays invisible\n          columns in the table definition, with the\n          INVISIBLE keyword in a version-specific\n          comment:\n        Press CTRL+C to copy mysql> SHOW CREATE TABLE t1\\G\n*************************** 1. row ***************************\n       Table: t1\nCreate Table: CREATE TABLE `t1` (\n  `i` int DEFAULT NULL,\n  `j` int DEFAULT NULL,\n  `k` int DEFAULT NULL /*!80023 INVISIBLE */\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\nmysqldump uses SHOW CREATE\n          TABLE, so they include invisible columns in dumped\n          table definitions. They also include invisible column values\n          in dumped data.\n        \n          Reloading a dump file into an older version of MySQL that does\n          not support invisible columns causes the version-specific\n          comment to be ignored, which creates any invisible columns as\n          visible.\n\n",
        "\n\n\n\nThe Binary Log and Invisible Columns\n\n\n\n\n          MySQL treats invisible columns as follows with respect to\n          events in the binary log:\n\n\n\n              Table-creation events include the\n              INVISIBLE attribute for invisible\n              columns.\n            \n              Invisible columns are treated like visible columns in row\n              events. They are included if needed according to the\n              binlog_row_image system\n              variable setting.\n            \n              When row events are applied, invisible columns are treated\n              like visible columns in row events.\n            \n              Invisible columns are treated like visible columns when\n              computing writesets. In particular, writesets include\n              indexes defined on invisible columns.\n            \n              The mysqlbinlog command includes\n              visibility in column metadata.\n\n\n"
    ],
    "Examples": [
        "CREATE TABLE t1 (\n  i INT,\n  j DATE INVISIBLE\n) ENGINE = InnoDB;\nALTER TABLE t1 ADD COLUMN k INT INVISIBLE;",
        "ALTER TABLE t1 CHANGE COLUMN j j DATE VISIBLE;\nALTER TABLE t1 MODIFY COLUMN j DATE INVISIBLE;\nALTER TABLE t1 ALTER COLUMN j SET VISIBLE;",
        "mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nmysql> CREATE TABLE t2 AS SELECT col1, col2 FROM t1;\nmysql> SHOW CREATE TABLE t2\\G\n*************************** 1. row ***************************\n       Table: t2\nCreate Table: CREATE TABLE `t2` (\n  `col1` int DEFAULT NULL,\n  `col2` int DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci",
        "mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nmysql> CREATE TABLE t2 (col2 INT INVISIBLE) AS SELECT col1, col2 FROM t1;\nmysql> SHOW CREATE TABLE t2\\G\n*************************** 1. row ***************************\n       Table: t2\nCreate Table: CREATE TABLE `t2` (\n  `col1` int DEFAULT NULL,\n  `col2` int DEFAULT NULL /*!80023 INVISIBLE */\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci",
        "mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nmysql> INSERT INTO t1 (col1, col2) VALUES(1, 2), (3, 4);\n\nmysql> SELECT * FROM t1;\n+------+\n| col1 |\n+------+\n|    1 |\n|    3 |\n+------+\n\nmysql> SELECT col1, col2 FROM t1;\n+------+------+\n| col1 | col2 |\n+------+------+\n|    1 |    2 |\n|    3 |    4 |\n+------+------+",
        "CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);\nINSERT INTO t1 VALUES(...);\nINSERT INTO t1 () VALUES(...);\nINSERT INTO t1 (col1) VALUES(...);",
        "mysql> SELECT TABLE_NAME, COLUMN_NAME, EXTRA\n       FROM INFORMATION_SCHEMA.COLUMNS\n       WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';\n+------------+-------------+-----------+\n| TABLE_NAME | COLUMN_NAME | EXTRA     |\n+------------+-------------+-----------+\n| t1         | i           |           |\n| t1         | j           |           |\n| t1         | k           | INVISIBLE |\n+------------+-------------+-----------+"
    ],
    "Category": [
        "Data Definition Statements"
    ]
}