{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/create-procedure.html"
    ],
    "Title": [
        "15.1.17 CREATE PROCEDURE and CREATE FUNCTION Statements"
    ],
    "Feature": [
        "CREATE\n    [DEFINER = user]\n    PROCEDURE [IF NOT EXISTS] sp_name ([proc_parameter[,...]])\n    [characteristic ...] routine_body\n\nCREATE\n    [DEFINER = user]\n    FUNCTION [IF NOT EXISTS] sp_name ([func_parameter[,...]])\n    RETURNS type\n    [characteristic ...] routine_body\n\nproc_parameter:\n    [ IN | OUT | INOUT ] param_name type\n\nfunc_parameter:\n    param_name type\n\ntype:\n    Any valid MySQL data type\n\ncharacteristic: {\n    COMMENT 'string'\n  | LANGUAGE SQL\n  | [NOT] DETERMINISTIC\n  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }\n  | SQL SECURITY { DEFINER | INVOKER }\n}\n\nroutine_body:\n    SQL routine"
    ],
    "Description": [
        "\n      These statements are used to create a stored routine (a stored\n      procedure or function). That is, the specified routine becomes\n      known to the server. By default, a stored routine is associated\n      with the default database. To associate the routine explicitly\n      with a given database, specify the name as\n      db_name.sp_name when you create it.\n    ",
        "\n      The CREATE FUNCTION statement is also used in\n      MySQL to support loadable functions. See\n      Section\u00a015.7.4.1, \u201cCREATE FUNCTION Statement for Loadable Functions\u201d. A loadable function\n      can be regarded as an external stored function. Stored functions\n      share their namespace with loadable functions. See\n      Section\u00a011.2.5, \u201cFunction Name Parsing and Resolution\u201d, for the rules describing\n      how the server interprets references to different kinds of\n      functions.\n    ",
        "\n      To invoke a stored procedure, use the\n      CALL statement (see\n      Section\u00a015.2.1, \u201cCALL Statement\u201d). To invoke a stored function, refer to it\n      in an expression. The function returns a value during expression\n      evaluation.\n    ",
        "\nCREATE PROCEDURE and\n      CREATE FUNCTION require the\n      CREATE ROUTINE privilege. If the\n      DEFINER clause is present, the privileges\n      required depend on the user value, as\n      discussed in Section\u00a027.6, \u201cStored Object Access Control\u201d. If binary\n      logging is enabled, CREATE FUNCTION\n      might require the SUPER privilege,\n      as discussed in Section\u00a027.7, \u201cStored Program Binary Logging\u201d.\n    ",
        "\n      By default, MySQL automatically grants the\n      ALTER ROUTINE and\n      EXECUTE privileges to the routine\n      creator. This behavior can be changed by disabling the\n      automatic_sp_privileges system\n      variable. See Section\u00a027.2.2, \u201cStored Routines and MySQL Privileges\u201d.\n    ",
        "\n      The DEFINER and SQL SECURITY\n      clauses specify the security context to be used when checking\n      access privileges at routine execution time, as described later in\n      this section.\n    ",
        "\n      If the routine name is the same as the name of a built-in SQL\n      function, a syntax error occurs unless you use a space between the\n      name and the following parenthesis when defining the routine or\n      invoking it later. For this reason, avoid using the names of\n      existing SQL functions for your own stored routines.\n    ",
        "\n      The IGNORE_SPACE SQL mode\n      applies to built-in functions, not to stored routines. It is\n      always permissible to have spaces after a stored routine name,\n      regardless of whether\n      IGNORE_SPACE is enabled.\n    ",
        "\nIF NOT EXISTS prevents an error from occurring\n      if there already exists a routine with the same name. This option\n      is supported with both CREATE FUNCTION and\n      CREATE PROCEDURE.\n    ",
        "\n      If a built-in function with the same name already exists,\n      attempting to create a stored function with CREATE\n      FUNCTION ... IF NOT EXISTS succeeds with a warning\n      indicating that it has the same name as a native function; this is\n      no different than when performing the same CREATE\n      FUNCTION statement without specifying IF NOT\n      EXISTS.\n    ",
        "\n      If a loadable function with the same name already exists,\n      attempting to create a stored function using IF NOT\n      EXISTS succeeds with a warning. This is the same as\n      without specifying IF NOT EXISTS.\n    ",
        "\n      See Function Name Resolution, for more\n      information.\n    ",
        "\n      The parameter list enclosed within parentheses must always be\n      present. If there are no parameters, an empty parameter list of\n      () should be used. Parameter names are not\n      case-sensitive.\n    ",
        "\n      Each parameter is an IN parameter by default.\n      To specify otherwise for a parameter, use the keyword\n      OUT or INOUT before the\n      parameter name.\n",
        "\n\nNote\n\n\n        Specifying a parameter as IN,\n        OUT, or INOUT is valid\n        only for a PROCEDURE. For a\n        FUNCTION, parameters are always regarded as\n        IN parameters.\n\n",
        "\n      An IN parameter passes a value into a\n      procedure. The procedure might modify the value, but the\n      modification is not visible to the caller when the procedure\n      returns. An OUT parameter passes a value from\n      the procedure back to the caller. Its initial value is\n      NULL within the procedure, and its value is\n      visible to the caller when the procedure returns. An\n      INOUT parameter is initialized by the caller,\n      can be modified by the procedure, and any change made by the\n      procedure is visible to the caller when the procedure returns.\n    ",
        "\n      For each OUT or INOUT\n      parameter, pass a user-defined variable in the\n      CALL statement that invokes the\n      procedure so that you can obtain its value when the procedure\n      returns. If you are calling the procedure from within another\n      stored procedure or function, you can also pass a routine\n      parameter or local routine variable as an OUT\n      or INOUT parameter. If you are calling the\n      procedure from within a trigger, you can also pass\n      NEW.col_name as an\n      OUT or INOUT parameter.\n    ",
        "\n      For information about the effect of unhandled conditions on\n      procedure parameters, see\n      Section\u00a015.6.7.8, \u201cCondition Handling and OUT or INOUT Parameters\u201d.\n    ",
        "\n      Routine parameters cannot be referenced in statements prepared\n      within the routine; see\n      Section\u00a027.8, \u201cRestrictions on Stored Programs\u201d.\n    ",
        "\n      The following example shows a simple stored procedure that, given\n      a country code, counts the number of cities for that country that\n      appear in the city table of the\n      world database. The country code is passed\n      using an IN parameter, and the city count is\n      returned using an OUT parameter:\n    ",
        "Press CTRL+C to copy mysql> delimiter //\n\nmysql> CREATE PROCEDURE citycount (IN country CHAR(3), OUT cities INT)\n       BEGIN\n         SELECT COUNT(*) INTO cities FROM world.city\n         WHERE CountryCode = country;\n       END//\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter ;\n\nmysql> CALL citycount('JPN', @cities); -- cities in Japan\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @cities;\n+---------+\n| @cities |\n+---------+\n|     248 |\n+---------+\n1 row in set (0.00 sec)\n\nmysql> CALL citycount('FRA', @cities); -- cities in France\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @cities;\n+---------+\n| @cities |\n+---------+\n|      40 |\n+---------+\n1 row in set (0.00 sec)",
        "\n      The example uses the mysql client\n      delimiter command to change the statement\n      delimiter from ; to // while\n      the procedure is being defined. This enables the\n      ; delimiter used in the procedure body to be\n      passed through to the server rather than being interpreted by\n      mysql itself. See\n      Section\u00a027.1, \u201cDefining Stored Programs\u201d.\n    ",
        "\n      The RETURNS clause may be specified only for a\n      FUNCTION, for which it is mandatory. It\n      indicates the return type of the function, and the function body\n      must contain a RETURN\n      value statement. If the\n      RETURN statement returns a value of\n      a different type, the value is coerced to the proper type. For\n      example, if a function specifies an\n      ENUM or\n      SET value in the\n      RETURNS clause, but the\n      RETURN statement returns an\n      integer, the value returned from the function is the string for\n      the corresponding ENUM member of\n      set of SET members.\n    ",
        "\n      The following example function takes a parameter, performs an\n      operation using an SQL function, and returns the result. In this\n      case, it is unnecessary to use delimiter\n      because the function definition contains no internal\n      ; statement delimiters:\n    ",
        "Press CTRL+C to copy mysql> CREATE FUNCTION hello (s CHAR(20))\nmysql> RETURNS CHAR(50) DETERMINISTIC\n       RETURN CONCAT('Hello, ',s,'!');\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT hello('world');\n+----------------+\n| hello('world') |\n+----------------+\n| Hello, world!  |\n+----------------+\n1 row in set (0.00 sec)",
        "\n      Parameter types and function return types can be declared to use\n      any valid data type. The COLLATE attribute can\n      be used if preceded by a CHARACTER SET\n      specification.\n    ",
        "\n      The routine_body consists of a valid\n      SQL routine statement. This can be a simple statement such as\n      SELECT or\n      INSERT, or a compound statement\n      written using BEGIN and END.\n      Compound statements can contain declarations, loops, and other\n      control structure statements. The syntax for these statements is\n      described in Section\u00a015.6, \u201cCompound Statement Syntax\u201d. In\n      practice, stored functions tend to use compound statements, unless\n      the body consists of a single\n      RETURN statement.\n    ",
        "\n      MySQL permits routines to contain DDL statements, such as\n      CREATE and DROP. MySQL also\n      permits stored procedures (but not stored functions) to contain\n      SQL transaction statements such as\n      COMMIT. Stored functions may not\n      contain statements that perform explicit or implicit commit or\n      rollback. Support for these statements is not required by the SQL\n      standard, which states that each DBMS vendor may decide whether to\n      permit them.\n    ",
        "\n      Statements that return a result set can be used within a stored\n      procedure but not within a stored function. This prohibition\n      includes SELECT statements that do\n      not have an INTO\n      var_list clause and other\n      statements such as SHOW,\n      EXPLAIN, and\n      CHECK TABLE. For statements that\n      can be determined at function definition time to return a result\n      set, a Not allowed to return a result set from a\n      function error occurs\n      (ER_SP_NO_RETSET). For statements\n      that can be determined only at runtime to return a result set, a\n      PROCEDURE %s can't return a result set in the given\n      context error occurs\n      (ER_SP_BADSELECT).\n    ",
        "\nUSE statements within stored\n      routines are not permitted. When a routine is invoked, an implicit\n      USE db_name is\n      performed (and undone when the routine terminates). The causes the\n      routine to have the given default database while it executes.\n      References to objects in databases other than the routine default\n      database should be qualified with the appropriate database name.\n    ",
        "\n      For additional information about statements that are not permitted\n      in stored routines, see\n      Section\u00a027.8, \u201cRestrictions on Stored Programs\u201d.\n    ",
        "\n      For information about invoking stored procedures from within\n      programs written in a language that has a MySQL interface, see\n      Section\u00a015.2.1, \u201cCALL Statement\u201d.\n    ",
        "\n      MySQL stores the sql_mode system\n      variable setting in effect when a routine is created or altered,\n      and always executes the routine with this setting in force,\n      regardless of the current server SQL mode when the\n      routine begins executing.\n    ",
        "\n      The switch from the SQL mode of the invoker to that of the routine\n      occurs after evaluation of arguments and assignment of the\n      resulting values to routine parameters. If you define a routine in\n      strict SQL mode but invoke it in nonstrict mode, assignment of\n      arguments to routine parameters does not take place in strict\n      mode. If you require that expressions passed to a routine be\n      assigned in strict SQL mode, you should invoke the routine with\n      strict mode in effect.\n    ",
        "\n      The COMMENT characteristic is a MySQL\n      extension, and may be used to describe the stored routine. This\n      information is displayed by the SHOW CREATE\n      PROCEDURE and SHOW CREATE\n      FUNCTION statements.\n    ",
        "\n      The LANGUAGE characteristic indicates the\n      language in which the routine is written. The server ignores this\n      characteristic; only SQL routines are supported.\n    ",
        "\n      A routine is considered \u201cdeterministic\u201d if it always\n      produces the same result for the same input parameters, and\n      \u201cnot deterministic\u201d otherwise. If neither\n      DETERMINISTIC nor NOT\n      DETERMINISTIC is given in the routine definition, the\n      default is NOT DETERMINISTIC. To declare that a\n      function is deterministic, you must specify\n      DETERMINISTIC explicitly.\n    ",
        "\n      Assessment of the nature of a routine is based on the\n      \u201chonesty\u201d of the creator: MySQL does not check that a\n      routine declared DETERMINISTIC is free of\n      statements that produce nondeterministic results. However,\n      misdeclaring a routine might affect results or affect performance.\n      Declaring a nondeterministic routine as\n      DETERMINISTIC might lead to unexpected results\n      by causing the optimizer to make incorrect execution plan choices.\n      Declaring a deterministic routine as\n      NONDETERMINISTIC might diminish performance by\n      causing available optimizations not to be used.\n    ",
        "\n      If binary logging is enabled, the DETERMINISTIC\n      characteristic affects which routine definitions MySQL accepts.\n      See Section\u00a027.7, \u201cStored Program Binary Logging\u201d.\n    ",
        "\n      A routine that contains the NOW()\n      function (or its synonyms) or\n      RAND() is nondeterministic, but it\n      might still be replication-safe. For\n      NOW(), the binary log includes the\n      timestamp and replicates correctly.\n      RAND() also replicates correctly as\n      long as it is called only a single time during the execution of a\n      routine. (You can consider the routine execution timestamp and\n      random number seed as implicit inputs that are identical on the\n      source and replica.)\n    ",
        "\n      Several characteristics provide information about the nature of\n      data use by the routine. In MySQL, these characteristics are\n      advisory only. The server does not use them to constrain what\n      kinds of statements a routine is permitted to execute.\n",
        "\n\nCONTAINS SQL indicates that the routine\n          does not contain statements that read or write data. This is\n          the default if none of these characteristics is given\n          explicitly. Examples of such statements are SET @x =\n          1 or DO RELEASE_LOCK('abc'),\n          which execute but neither read nor write data.\n        \nNO SQL indicates that the routine contains\n          no SQL statements.\n        \nREADS SQL DATA indicates that the routine\n          contains statements that read data (for example,\n          SELECT), but not statements\n          that write data.\n        \nMODIFIES SQL DATA indicates that the\n          routine contains statements that may write data (for example,\n          INSERT or\n          DELETE).\n\n",
        "\n      The SQL SECURITY characteristic can be\n      DEFINER or INVOKER to\n      specify the security context; that is, whether the routine\n      executes using the privileges of the account named in the routine\n      DEFINER clause or the user who invokes it. This\n      account must have permission to access the database with which the\n      routine is associated. The default value is\n      DEFINER. The user who invokes the routine must\n      have the EXECUTE privilege for it,\n      as must the DEFINER account if the routine\n      executes in definer security context.\n    ",
        "\n      The DEFINER clause specifies the MySQL account\n      to be used when checking access privileges at routine execution\n      time for routines that have the SQL SECURITY\n      DEFINER characteristic.\n    ",
        "\n      If the DEFINER clause is present, the\n      user value should be a MySQL account\n      specified as\n      'user_name'@'host_name',\n      CURRENT_USER, or\n      CURRENT_USER(). The permitted\n      user values depend on the privileges\n      you hold, as discussed in\n      Section\u00a027.6, \u201cStored Object Access Control\u201d. Also see that section\n      for additional information about stored routine security.\n    ",
        "\n      If the DEFINER clause is omitted, the default\n      definer is the user who executes the CREATE\n      PROCEDURE or CREATE\n      FUNCTION statement. This is the same as specifying\n      DEFINER = CURRENT_USER explicitly.\n    ",
        "\n      Within the body of a stored routine that is defined with the\n      SQL SECURITY DEFINER characteristic, the\n      CURRENT_USER function returns the\n      routine's DEFINER value. For information about\n      user auditing within stored routines, see\n      Section\u00a08.2.23, \u201cSQL-Based Account Activity Auditing\u201d.\n    ",
        "\n      Consider the following procedure, which displays a count of the\n      number of MySQL accounts listed in the\n      mysql.user system table:\n    ",
        "Press CTRL+C to copy CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()\nBEGIN\n  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;\nEND;",
        "\n      The procedure is assigned a DEFINER account of\n      'admin'@'localhost' no matter which user\n      defines it. It executes with the privileges of that account no\n      matter which user invokes it (because the default security\n      characteristic is DEFINER). The procedure\n      succeeds or fails depending on whether invoker has the\n      EXECUTE privilege for it and\n      'admin'@'localhost' has the\n      SELECT privilege for the\n      mysql.user table.\n    ",
        "\n      Now suppose that the procedure is defined with the SQL\n      SECURITY INVOKER characteristic:\n    ",
        "Press CTRL+C to copy CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()\nSQL SECURITY INVOKER\nBEGIN\n  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;\nEND;",
        "\n      The procedure still has a DEFINER of\n      'admin'@'localhost', but in this case, it\n      executes with the privileges of the invoking user. Thus, the\n      procedure succeeds or fails depending on whether the invoker has\n      the EXECUTE privilege for it and\n      the SELECT privilege for the\n      mysql.user table.\n    ",
        "\n      By default, when a routine with the SQL SECURITY\n      DEFINER characteristic is executed, MySQL Server does\n      not set any active roles for the MySQL account named in the\n      DEFINER clause, only the default roles. The\n      exception is if the\n      activate_all_roles_on_login\n      system variable is enabled, in which case MySQL Server sets all\n      roles granted to the DEFINER user, including\n      mandatory roles. Any privileges granted through roles are\n      therefore not checked by default when the\n      CREATE PROCEDURE or\n      CREATE FUNCTION statement is\n      issued. For stored programs, if execution should occur with roles\n      different from the default, the program body can execute\n      SET ROLE to activate the required\n      roles. This must be done with caution since the privileges\n      assigned to roles can be changed.\n    ",
        "\n      The server handles the data type of a routine parameter, local\n      routine variable created with\n      DECLARE, or function return value\n      as follows:\n",
        "\n\n          Assignments are checked for data type mismatches and overflow.\n          Conversion and overflow problems result in warnings, or errors\n          in strict SQL mode.\n        \n          Only scalar values can be assigned. For example, a statement\n          such as SET x = (SELECT 1, 2) is invalid.\n        \n          For character data types, if CHARACTER SET\n          is included in the declaration, the specified character set\n          and its default collation is used. If the\n          COLLATE attribute is also present, that\n          collation is used rather than the default collation.\n        \n          If CHARACTER SET and\n          COLLATE are not present, the database\n          character set and collation in effect at routine creation time\n          are used. To avoid having the server use the database\n          character set and collation, provide an explicit\n          CHARACTER SET and a\n          COLLATE attribute for character data\n          parameters.\n        \n          If you alter the database default character set or collation,\n          stored routines that are to use the new database defaults must\n          be dropped and recreated.\n        \n          The database character set and collation are given by the\n          value of the\n          character_set_database and\n          collation_database system\n          variables. For more information, see\n          Section\u00a012.3.3, \u201cDatabase Character Set and Collation\u201d.\n\n"
    ],
    "Examples": [
        "mysql> delimiter //\n\nmysql> CREATE PROCEDURE citycount (IN country CHAR(3), OUT cities INT)\n       BEGIN\n         SELECT COUNT(*) INTO cities FROM world.city\n         WHERE CountryCode = country;\n       END//\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter ;\n\nmysql> CALL citycount('JPN', @cities); -- cities in Japan\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @cities;\n+---------+\n| @cities |\n+---------+\n|     248 |\n+---------+\n1 row in set (0.00 sec)\n\nmysql> CALL citycount('FRA', @cities); -- cities in France\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @cities;\n+---------+\n| @cities |\n+---------+\n|      40 |\n+---------+\n1 row in set (0.00 sec)",
        "mysql> CREATE FUNCTION hello (s CHAR(20))\nmysql> RETURNS CHAR(50) DETERMINISTIC\n       RETURN CONCAT('Hello, ',s,'!');\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT hello('world');\n+----------------+\n| hello('world') |\n+----------------+\n| Hello, world!  |\n+----------------+\n1 row in set (0.00 sec)",
        "CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()\nBEGIN\n  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;\nEND;",
        "CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()\nSQL SECURITY INVOKER\nBEGIN\n  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;\nEND;"
    ],
    "Category": [
        "Data Definition Statements"
    ]
}