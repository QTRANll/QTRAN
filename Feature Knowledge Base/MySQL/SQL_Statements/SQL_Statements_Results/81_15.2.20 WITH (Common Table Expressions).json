{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/with.html"
    ],
    "Title": [
        "15.2.20 WITH (Common Table Expressions)"
    ],
    "Feature": [
        "with_clause:\n    WITH [RECURSIVE]\n        cte_name [(col_name [, col_name] ...)] AS (subquery)\n        [, cte_name [(col_name [, col_name] ...)] AS (subquery)] ...",
        "WITH ... SELECT ...\nWITH ... UPDATE ...\nWITH ... DELETE ...",
        "SELECT ... WHERE id IN (WITH ... SELECT ...) ...\nSELECT * FROM (WITH ... SELECT ...) AS dt ...",
        "INSERT ... WITH ... SELECT ...\nREPLACE ... WITH ... SELECT ...\nCREATE TABLE ... WITH ... SELECT ...\nCREATE VIEW ... WITH ... SELECT ...\nDECLARE CURSOR ... WITH ... SELECT ...\nEXPLAIN ... WITH ... SELECT ...",
        "WITH cte1 AS (...) WITH cte2 AS (...) SELECT ...",
        "WITH cte1 AS (...), cte2 AS (...) SELECT ...",
        "WITH cte1 AS (...), cte1 AS (...) SELECT ...",
        "WITH cte1 AS (...), cte2 AS (...) SELECT ...",
        "SELECT ...      -- return initial row set\nUNION ALL\nSELECT ...      -- return additional row sets",
        "SELECT 1",
        "SELECT n + 1 FROM cte WHERE n < 5"
    ],
    "Description": [
        "\n      A common table expression (CTE) is a named temporary result set\n      that exists within the scope of a single statement and that can be\n      referred to later within that statement, possibly multiple times.\n      The following discussion describes how to write statements that\n      use CTEs.\n",
        "\nCommon Table ExpressionsRecursive Common Table ExpressionsLimiting Common Table Expression RecursionRecursive Common Table Expression ExamplesCommon Table Expressions Compared to Similar Constructs\n",
        "\n      For information about CTE optimization, see\n      Section\u00a010.2.2.4, \u201cOptimizing Derived Tables, View References, and Common Table Expressions\n          with Merging or Materialization\u201d.\n",
        "\n\n\n\nCommon Table Expressions\n\n\n\n\n        To specify common table expressions, use a\n        WITH clause that has one or more\n        comma-separated subclauses. Each subclause provides a subquery\n        that produces a result set, and associates a name with the\n        subquery. The following example defines CTEs named\n        cte1 and cte2 in the\n        WITH clause, and refers to them\n        in the top-level SELECT that\n        follows the WITH clause:\n      Press CTRL+C to copy WITH\n  cte1 AS (SELECT a, b FROM table1),\n  cte2 AS (SELECT c, d FROM table2)\nSELECT b, d FROM cte1 JOIN cte2\nWHERE cte1.a = cte2.c;\n        In the statement containing the\n        WITH clause, each CTE name can be\n        referenced to access the corresponding CTE result set.\n      \n        A CTE name can be referenced in other CTEs, enabling CTEs to be\n        defined based on other CTEs.\n      \n        A CTE can refer to itself to define a recursive CTE. Common\n        applications of recursive CTEs include series generation and\n        traversal of hierarchical or tree-structured data.\n      \n        Common table expressions are an optional part of the syntax for\n        DML statements. They are defined using a\n        WITH clause:\n      Press CTRL+C to copy with_clause:\n    WITH [RECURSIVE]\n        cte_name [(col_name [, col_name] ...)] AS (subquery)\n        [, cte_name [(col_name [, col_name] ...)] AS (subquery)] ...\ncte_name names a single common table\n        expression and can be used as a table reference in the statement\n        containing the WITH clause.\n      \n        The subquery part of AS\n        (subquery) is called the\n        \u201csubquery of the CTE\u201d and is what produces the CTE\n        result set. The parentheses following AS are\n        required.\n      \n        A common table expression is recursive if its subquery refers to\n        its own name. The RECURSIVE keyword must be\n        included if any CTE in the WITH\n        clause is recursive. For more information, see\n        Recursive Common Table Expressions.\n      \n        Determination of column names for a given CTE occurs as follows:\n\n\n\n            If a parenthesized list of names follows the CTE name, those\n            names are the column names:\n          Press CTRL+C to copy WITH cte (col1, col2) AS\n(\n  SELECT 1, 2\n  UNION ALL\n  SELECT 3, 4\n)\nSELECT col1, col2 FROM cte;\n            The number of names in the list must be the same as the\n            number of columns in the result set.\n          \n            Otherwise, the column names come from the select list of the\n            first SELECT within the\n            AS (subquery)\n            part:\n          Press CTRL+C to copy WITH cte AS\n(\n  SELECT 1 AS col1, 2 AS col2\n  UNION ALL\n  SELECT 3, 4\n)\nSELECT col1, col2 FROM cte;\n\n\n        A WITH clause is permitted in\n        these contexts:\n\n\n\n            At the beginning of SELECT,\n            UPDATE, and\n            DELETE statements.\n          Press CTRL+C to copy WITH ... SELECT ...\nWITH ... UPDATE ...\nWITH ... DELETE ...\n            At the beginning of subqueries (including derived table\n            subqueries):\n          Press CTRL+C to copy SELECT ... WHERE id IN (WITH ... SELECT ...) ...\nSELECT * FROM (WITH ... SELECT ...) AS dt ...\n            Immediately preceding SELECT\n            for statements that include a\n            SELECT statement:\n          Press CTRL+C to copy INSERT ... WITH ... SELECT ...\nREPLACE ... WITH ... SELECT ...\nCREATE TABLE ... WITH ... SELECT ...\nCREATE VIEW ... WITH ... SELECT ...\nDECLARE CURSOR ... WITH ... SELECT ...\nEXPLAIN ... WITH ... SELECT ...\n\n\n        Only one WITH clause is permitted\n        at the same level. WITH followed\n        by WITH at the same level is not\n        permitted, so this is illegal:\n      Press CTRL+C to copy WITH cte1 AS (...) WITH cte2 AS (...) SELECT ...\n        To make the statement legal, use a single\n        WITH clause that separates the\n        subclauses by a comma:\n      Press CTRL+C to copy WITH cte1 AS (...), cte2 AS (...) SELECT ...\n        However, a statement can contain multiple\n        WITH clauses if they occur at\n        different levels:\n      Press CTRL+C to copy WITH cte1 AS (SELECT 1)\nSELECT * FROM (WITH cte2 AS (SELECT 2) SELECT * FROM cte2 JOIN cte1) AS dt;\n        A WITH clause can define one or\n        more common table expressions, but each CTE name must be unique\n        to the clause. This is illegal:\n      Press CTRL+C to copy WITH cte1 AS (...), cte1 AS (...) SELECT ...\n        To make the statement legal, define the CTEs with unique names:\n      Press CTRL+C to copy WITH cte1 AS (...), cte2 AS (...) SELECT ...\n        A CTE can refer to itself or to other CTEs:\n\n\n\n            A self-referencing CTE is recursive.\n          \n            A CTE can refer to CTEs defined earlier in the same\n            WITH clause, but not those\n            defined later.\n          \n            This constraint rules out mutually-recursive CTEs, where\n            cte1 references cte2\n            and cte2 references\n            cte1. One of those references must be to\n            a CTE defined later, which is not permitted.\n          \n            A CTE in a given query block can refer to CTEs defined in\n            query blocks at a more outer level, but not CTEs defined in\n            query blocks at a more inner level.\n\n\n\n        For resolving references to objects with the same names, derived\n        tables hide CTEs; and CTEs hide base tables,\n        TEMPORARY tables, and views. Name resolution\n        occurs by searching for objects in the same query block, then\n        proceeding to outer blocks in turn while no object with the name\n        is found.\n      \n        For additional syntax considerations specific to recursive CTEs,\n        see Recursive Common Table Expressions.\n\n",
        "\n\n\n\nRecursive Common Table Expressions\n\n\n\n\n        A recursive common table expression is one having a subquery\n        that refers to its own name. For example:\n      Press CTRL+C to copy WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte WHERE n < 5\n)\nSELECT * FROM cte;\n        When executed, the statement produces this result, a single\n        column containing a simple linear sequence:\n      Press CTRL+C to copy +------+\n| n    |\n+------+\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n|    5 |\n+------+\n        A recursive CTE has this structure:\n\n\n\n            The WITH clause must begin with\n            WITH RECURSIVE if any CTE in the\n            WITH clause refers to itself. (If no CTE\n            refers to itself, RECURSIVE is permitted\n            but not required.)\n          \n            If you forget RECURSIVE for a recursive\n            CTE, this error is a likely result:\n          Press CTRL+C to copy ERROR 1146 (42S02): Table 'cte_name' doesn't exist\n            The recursive CTE subquery has two parts, separated by\n            UNION ALL\n            or UNION\n            [DISTINCT]:\n          Press CTRL+C to copy SELECT ...      -- return initial row set\nUNION ALL\nSELECT ...      -- return additional row sets\n            The first SELECT produces the\n            initial row or rows for the CTE and does not refer to the\n            CTE name. The second SELECT\n            produces additional rows and recurses by referring to the\n            CTE name in its FROM clause. Recursion\n            ends when this part produces no new rows. Thus, a recursive\n            CTE consists of a nonrecursive\n            SELECT part followed by a\n            recursive SELECT part.\n          \n            Each SELECT part can itself\n            be a union of multiple SELECT\n            statements.\n          \n            The types of the CTE result columns are inferred from the\n            column types of the nonrecursive\n            SELECT part only, and the\n            columns are all nullable. For type determination, the\n            recursive SELECT part is\n            ignored.\n          \n            If the nonrecursive and recursive parts are separated by\n            UNION\n            DISTINCT, duplicate rows are eliminated. This is\n            useful for queries that perform transitive closures, to\n            avoid infinite loops.\n          \n            Each iteration of the recursive part operates only on the\n            rows produced by the previous iteration. If the recursive\n            part has multiple query blocks, iterations of each query\n            block are scheduled in unspecified order, and each query\n            block operates on rows that have been produced either by its\n            previous iteration or by other query blocks since that\n            previous iteration's end.\n\n\n\n        The recursive CTE subquery shown earlier has this nonrecursive\n        part that retrieves a single row to produce the initial row set:\n      Press CTRL+C to copy SELECT 1\n        The CTE subquery also has this recursive part:\n      Press CTRL+C to copy SELECT n + 1 FROM cte WHERE n < 5\n        At each iteration, that SELECT\n        produces a row with a new value one greater than the value of\n        n from the previous row set. The first\n        iteration operates on the initial row set (1)\n        and produces 1+1=2; the second iteration\n        operates on the first iteration's row set (2)\n        and produces 2+1=3; and so forth. This\n        continues until recursion ends, which occurs when\n        n is no longer less than 5.\n      \n        If the recursive part of a CTE produces wider values for a\n        column than the nonrecursive part, it may be necessary to widen\n        the column in the nonrecursive part to avoid data truncation.\n        Consider this statement:\n      Press CTRL+C to copy WITH RECURSIVE cte AS\n(\n  SELECT 1 AS n, 'abc' AS str\n  UNION ALL\n  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n < 3\n)\nSELECT * FROM cte;\n        In nonstrict SQL mode, the statement produces this output:\n      Press CTRL+C to copy +------+------+\n| n    | str  |\n+------+------+\n|    1 | abc  |\n|    2 | abc  |\n|    3 | abc  |\n+------+------+\n        The str column values are all\n        'abc' because the nonrecursive\n        SELECT determines the column\n        widths. Consequently, the wider str values\n        produced by the recursive SELECT\n        are truncated.\n      \n        In strict SQL mode, the statement produces an error:\n      Press CTRL+C to copy ERROR 1406 (22001): Data too long for column 'str' at row 1\n        To address this issue, so that the statement does not produce\n        truncation or errors, use CAST()\n        in the nonrecursive SELECT to\n        make the str column wider:\n      Press CTRL+C to copy WITH RECURSIVE cte AS\n(\n  SELECT 1 AS n, CAST('abc' AS CHAR(20)) AS str\n  UNION ALL\n  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n < 3\n)\nSELECT * FROM cte;\n        Now the statement produces this result, without truncation:\n      Press CTRL+C to copy +------+--------------+\n| n    | str          |\n+------+--------------+\n|    1 | abc          |\n|    2 | abcabc       |\n|    3 | abcabcabcabc |\n+------+--------------+\n        Columns are accessed by name, not position, which means that\n        columns in the recursive part can access columns in the\n        nonrecursive part that have a different position, as this CTE\n        illustrates:\n      Press CTRL+C to copy WITH RECURSIVE cte AS\n(\n  SELECT 1 AS n, 1 AS p, -1 AS q\n  UNION ALL\n  SELECT n + 1, q * 2, p * 2 FROM cte WHERE n < 5\n)\nSELECT * FROM cte;\n        Because p in one row is derived from\n        q in the previous row, and vice versa, the\n        positive and negative values swap positions in each successive\n        row of the output:\n      Press CTRL+C to copy +------+------+------+\n| n    | p    | q    |\n+------+------+------+\n|    1 |    1 |   -1 |\n|    2 |   -2 |    2 |\n|    3 |    4 |   -4 |\n|    4 |   -8 |    8 |\n|    5 |   16 |  -16 |\n+------+------+------+\n        Some syntax constraints apply within recursive CTE subqueries:\n\n\n\n            The recursive SELECT part\n            must not contain these constructs:\n\n\n\n                Aggregate functions such as SUM()\n\n                Window functions\n              \nGROUP BY\n\nORDER BY\n\nDISTINCT\n\n\n\n            The recursive SELECT part of\n            a recursive CTE can also use a LIMIT\n            clause, along with an optional OFFSET\n            clause. The effect on the result set is the same as when\n            using LIMIT in the outermost\n            SELECT, but is also more efficient, since\n            using it with the recursive SELECT stops\n            the generation of rows as soon as the requested number of\n            them has been produced.\n          \n            The prohibition on DISTINCT applies only\n            to UNION members;\n            UNION DISTINCT is permitted.\n          \n            The recursive SELECT part\n            must reference the CTE only once and only in its\n            FROM clause, not in any subquery. It can\n            reference tables other than the CTE and join them with the\n            CTE. If used in a join like this, the CTE must not be on the\n            right side of a LEFT JOIN.\n\n\n\n        These constraints come from the SQL standard, other than the\n        MySQL-specific exclusions mentioned previously.\n      \n        For recursive CTEs, EXPLAIN\n        output rows for recursive SELECT\n        parts display Recursive in the\n        Extra column.\n      \n        Cost estimates displayed by\n        EXPLAIN represent cost per\n        iteration, which might differ considerably from total cost. The\n        optimizer cannot predict the number of iterations because it\n        cannot predict at what point the WHERE clause\n        becomes false.\n      \n        CTE actual cost may also be affected by result set size. A CTE\n        that produces many rows may require an internal temporary table\n        large enough to be converted from in-memory to on-disk format\n        and may suffer a performance penalty. If so, increasing the\n        permitted in-memory temporary table size may improve\n        performance; see Section\u00a010.4.4, \u201cInternal Temporary Table Use in MySQL\u201d.\n\n",
        "\n\n\n\nLimiting Common Table Expression Recursion\n\n\n\n\n        It is important for recursive CTEs that the recursive\n        SELECT part include a condition\n        to terminate recursion. As a development technique to guard\n        against a runaway recursive CTE, you can force termination by\n        placing a limit on execution time:\n\n\n\n            The cte_max_recursion_depth\n            system variable enforces a limit on the number of recursion\n            levels for CTEs. The server terminates execution of any CTE\n            that recurses more levels than the value of this variable.\n          \n            The max_execution_time\n            system variable enforces an execution timeout for\n            SELECT statements executed\n            within the current session.\n          \n            The MAX_EXECUTION_TIME\n            optimizer hint enforces a per-query execution timeout for\n            the SELECT statement in which\n            it appears.\n\n\n\n        Suppose that a recursive CTE is mistakenly written with no\n        recursion execution termination condition:\n      Press CTRL+C to copy WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte\n)\nSELECT * FROM cte;\n        By default,\n        cte_max_recursion_depth has a\n        value of 1000, causing the CTE to terminate when it recurses\n        past 1000 levels. Applications can change the session value to\n        adjust for their requirements:\n      Press CTRL+C to copy SET SESSION cte_max_recursion_depth = 10;      -- permit only shallow recursion\nSET SESSION cte_max_recursion_depth = 1000000; -- permit deeper recursion\n        You can also set the global\n        cte_max_recursion_depth value\n        to affect all sessions that begin subsequently.\n      \n        For queries that execute and thus recurse slowly or in contexts\n        for which there is reason to set the\n        cte_max_recursion_depth value\n        very high, another way to guard against deep recursion is to set\n        a per-session timeout. To do so, execute a statement like this\n        prior to executing the CTE statement:\n      Press CTRL+C to copy SET max_execution_time = 1000; -- impose one second timeout\n        Alternatively, include an optimizer hint within the CTE\n        statement itself:\n      Press CTRL+C to copy WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte\n)\nSELECT /*+ SET_VAR(cte_max_recursion_depth = 1M) */ * FROM cte;\n\nWITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte\n)\nSELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;\n        You can also use LIMIT within the recursive\n        query to impose a maximum number of rows to be returned to the\n        outermost SELECT, for example:\n      Press CTRL+C to copy WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte LIMIT 10000\n)\nSELECT * FROM cte;\n        You can do this in addition to or instead of setting a time\n        limit. Thus, the following CTE terminates after returning ten\n        thousand rows or running for one second (1000 milliseconds),\n        whichever occurs first:\n      Press CTRL+C to copy WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte LIMIT 10000\n)\nSELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;\n        If a recursive query without an execution time limit enters an\n        infinite loop, you can terminate it from another session using\n        KILL QUERY.\n        Within the session itself, the client program used to run the\n        query might provide a way to kill the query. For example, in\n        mysql, typing Control+C\n        interrupts the current statement.\n\n",
        "\n\n\n\nRecursive Common Table Expression Examples\n\n\n\n\n        As mentioned previously, recursive common table expressions\n        (CTEs) are frequently used for series generation and traversing\n        hierarchical or tree-structured data. This section shows some\n        simple examples of these techniques.\n\n\nFibonacci Series GenerationDate Series GenerationHierarchical Data Traversal\n\nFibonacci Series Generation\n\n        A Fibonacci series begins with the two numbers 0 and 1 (or 1 and\n        1) and each number after that is the sum of the previous two\n        numbers. A recursive common table expression can generate a\n        Fibonacci series if each row produced by the recursive\n        SELECT has access to the two\n        previous numbers from the series. The following CTE generates a\n        10-number series using 0 and 1 as the first two numbers:\n      Press CTRL+C to copy WITH RECURSIVE fibonacci (n, fib_n, next_fib_n) AS\n(\n  SELECT 1, 0, 1\n  UNION ALL\n  SELECT n + 1, next_fib_n, fib_n + next_fib_n\n    FROM fibonacci WHERE n < 10\n)\nSELECT * FROM fibonacci;\n        The CTE produces this result:\n      Press CTRL+C to copy +------+-------+------------+\n| n    | fib_n | next_fib_n |\n+------+-------+------------+\n|    1 |     0 |          1 |\n|    2 |     1 |          1 |\n|    3 |     1 |          2 |\n|    4 |     2 |          3 |\n|    5 |     3 |          5 |\n|    6 |     5 |          8 |\n|    7 |     8 |         13 |\n|    8 |    13 |         21 |\n|    9 |    21 |         34 |\n|   10 |    34 |         55 |\n+------+-------+------------+\n        How the CTE works:\n\n\n\nn is a display column to indicate that\n            the row contains the n-th Fibonacci\n            number. For example, the 8th Fibonacci number is 13.\n          \n            The fib_n column displays Fibonacci\n            number n.\n          \n            The next_fib_n column displays the next\n            Fibonacci number after number n. This\n            column provides the next series value to the next row, so\n            that row can produce the sum of the two previous series\n            values in its fib_n column.\n          \n            Recursion ends when n reaches 10. This is\n            an arbitrary choice, to limit the output to a small set of\n            rows.\n\n\n\n        The preceding output shows the entire CTE result. To select just\n        part of it, add an appropriate WHERE clause\n        to the top-level SELECT. For\n        example, to select the 8th Fibonacci number, do this:\n      Press CTRL+C to copy mysql> WITH RECURSIVE fibonacci ...\n       ...\n       SELECT fib_n FROM fibonacci WHERE n = 8;\n+-------+\n| fib_n |\n+-------+\n|    13 |\n+-------+\nDate Series Generation\n\n        A common table expression can generate a series of successive\n        dates, which is useful for generating summaries that include a\n        row for all dates in the series, including dates not represented\n        in the summarized data.\n      \n        Suppose that a table of sales numbers contains these rows:\n      Press CTRL+C to copy mysql> SELECT * FROM sales ORDER BY date, price;\n+------------+--------+\n| date       | price  |\n+------------+--------+\n| 2017-01-03 | 100.00 |\n| 2017-01-03 | 200.00 |\n| 2017-01-06 |  50.00 |\n| 2017-01-08 |  10.00 |\n| 2017-01-08 |  20.00 |\n| 2017-01-08 | 150.00 |\n| 2017-01-10 |   5.00 |\n+------------+--------+\n        This query summarizes the sales per day:\n      Press CTRL+C to copy mysql> SELECT date, SUM(price) AS sum_price\n       FROM sales\n       GROUP BY date\n       ORDER BY date;\n+------------+-----------+\n| date       | sum_price |\n+------------+-----------+\n| 2017-01-03 |    300.00 |\n| 2017-01-06 |     50.00 |\n| 2017-01-08 |    180.00 |\n| 2017-01-10 |      5.00 |\n+------------+-----------+\n        However, that result contains \u201choles\u201d for dates not\n        represented in the range of dates spanned by the table. A result\n        that represents all dates in the range can be produced using a\n        recursive CTE to generate that set of dates, joined with a\n        LEFT JOIN to the sales data.\n      \n        Here is the CTE to generate the date range series:\n      Press CTRL+C to copy WITH RECURSIVE dates (date) AS\n(\n  SELECT MIN(date) FROM sales\n  UNION ALL\n  SELECT date + INTERVAL 1 DAY FROM dates\n  WHERE date + INTERVAL 1 DAY <= (SELECT MAX(date) FROM sales)\n)\nSELECT * FROM dates;\n        The CTE produces this result:\n      Press CTRL+C to copy +------------+\n| date       |\n+------------+\n| 2017-01-03 |\n| 2017-01-04 |\n| 2017-01-05 |\n| 2017-01-06 |\n| 2017-01-07 |\n| 2017-01-08 |\n| 2017-01-09 |\n| 2017-01-10 |\n+------------+\n        How the CTE works:\n\n\n\n            The nonrecursive SELECT\n            produces the lowest date in the date range spanned by the\n            sales table.\n          \n            Each row produced by the recursive\n            SELECT adds one day to the\n            date produced by the previous row.\n          \n            Recursion ends after the dates reach the highest date in the\n            date range spanned by the sales table.\n\n\n\n        Joining the CTE with a LEFT JOIN against the\n        sales table produces the sales summary with a\n        row for each date in the range:\n      Press CTRL+C to copy WITH RECURSIVE dates (date) AS\n(\n  SELECT MIN(date) FROM sales\n  UNION ALL\n  SELECT date + INTERVAL 1 DAY FROM dates\n  WHERE date + INTERVAL 1 DAY <= (SELECT MAX(date) FROM sales)\n)\nSELECT dates.date, COALESCE(SUM(price), 0) AS sum_price\nFROM dates LEFT JOIN sales ON dates.date = sales.date\nGROUP BY dates.date\nORDER BY dates.date;\n        The output looks like this:\n      Press CTRL+C to copy +------------+-----------+\n| date       | sum_price |\n+------------+-----------+\n| 2017-01-03 |    300.00 |\n| 2017-01-04 |      0.00 |\n| 2017-01-05 |      0.00 |\n| 2017-01-06 |     50.00 |\n| 2017-01-07 |      0.00 |\n| 2017-01-08 |    180.00 |\n| 2017-01-09 |      0.00 |\n| 2017-01-10 |      5.00 |\n+------------+-----------+\n        Some points to note:\n\n\n\n            Are the queries inefficient, particularly the one with the\n            MAX() subquery executed for\n            each row in the recursive\n            SELECT?\n            EXPLAIN shows that the\n            subquery containing MAX() is\n            evaluated only once and the result is cached.\n          \n            The use of COALESCE() avoids\n            displaying NULL in the\n            sum_price column on days for which no\n            sales data occur in the sales table.\n\n\nHierarchical Data Traversal\n\n        Recursive common table expressions are useful for traversing\n        data that forms a hierarchy. Consider these statements that\n        create a small data set that shows, for each employee in a\n        company, the employee name and ID number, and the ID of the\n        employee's manager. The top-level employee (the CEO), has a\n        manager ID of NULL (no manager).\n      Press CTRL+C to copy CREATE TABLE employees (\n  id         INT PRIMARY KEY NOT NULL,\n  name       VARCHAR(100) NOT NULL,\n  manager_id INT NULL,\n  INDEX (manager_id),\nFOREIGN KEY (manager_id) REFERENCES employees (id)\n);\nINSERT INTO employees VALUES\n(333, \"Yasmina\", NULL),  # Yasmina is the CEO (manager_id is NULL)\n(198, \"John\", 333),      # John has ID 198 and reports to 333 (Yasmina)\n(692, \"Tarek\", 333),\n(29, \"Pedro\", 198),\n(4610, \"Sarah\", 29),\n(72, \"Pierre\", 29),\n(123, \"Adil\", 692);\n        The resulting data set looks like this:\n      Press CTRL+C to copy mysql> SELECT * FROM employees ORDER BY id;\n+------+---------+------------+\n| id   | name    | manager_id |\n+------+---------+------------+\n|   29 | Pedro   |        198 |\n|   72 | Pierre  |         29 |\n|  123 | Adil    |        692 |\n|  198 | John    |        333 |\n|  333 | Yasmina |       NULL |\n|  692 | Tarek   |        333 |\n| 4610 | Sarah   |         29 |\n+------+---------+------------+\n        To produce the organizational chart with the management chain\n        for each employee (that is, the path from CEO to employee), use\n        a recursive CTE:\n      Press CTRL+C to copy WITH RECURSIVE employee_paths (id, name, path) AS\n(\n  SELECT id, name, CAST(id AS CHAR(200))\n    FROM employees\n    WHERE manager_id IS NULL\n  UNION ALL\n  SELECT e.id, e.name, CONCAT(ep.path, ',', e.id)\n    FROM employee_paths AS ep JOIN employees AS e\n      ON ep.id = e.manager_id\n)\nSELECT * FROM employee_paths ORDER BY path;\n        The CTE produces this output:\n      Press CTRL+C to copy +------+---------+-----------------+\n| id   | name    | path            |\n+------+---------+-----------------+\n|  333 | Yasmina | 333             |\n|  198 | John    | 333,198         |\n|   29 | Pedro   | 333,198,29      |\n| 4610 | Sarah   | 333,198,29,4610 |\n|   72 | Pierre  | 333,198,29,72   |\n|  692 | Tarek   | 333,692         |\n|  123 | Adil    | 333,692,123     |\n+------+---------+-----------------+\n        How the CTE works:\n\n\n\n            The nonrecursive SELECT\n            produces the row for the CEO (the row with a\n            NULL manager ID).\n          \n            The path column is widened to\n            CHAR(200) to ensure that there is room\n            for the longer path values produced by\n            the recursive SELECT.\n          \n            Each row produced by the recursive\n            SELECT finds all employees\n            who report directly to an employee produced by a previous\n            row. For each such employee, the row includes the employee\n            ID and name, and the employee management chain. The chain is\n            the manager's chain, with the employee ID added to the end.\n          \n            Recursion ends when employees have no others who report to\n            them.\n\n\n\n        To find the path for a specific employee or employees, add a\n        WHERE clause to the top-level\n        SELECT. For example, to display\n        the results for Tarek and Sarah, modify that\n        SELECT like this:\n      Press CTRL+C to copy mysql> WITH RECURSIVE ...\n       ...\n       SELECT * FROM employees_extended\n       WHERE id IN (692, 4610)\n       ORDER BY path;\n+------+-------+-----------------+\n| id   | name  | path            |\n+------+-------+-----------------+\n| 4610 | Sarah | 333,198,29,4610 |\n|  692 | Tarek | 333,692         |\n+------+-------+-----------------+\n",
        "\n\n\n\nCommon Table Expressions Compared to Similar Constructs\n\n\n\n\n        Common table expressions (CTEs) are similar to derived tables in\n        some ways:\n\n\n\n            Both constructs are named.\n          \n            Both constructs exist for the scope of a single statement.\n\n\n\n        Because of these similarities, CTEs and derived tables often can\n        be used interchangeably. As a trivial example, these statements\n        are equivalent:\n      Press CTRL+C to copy WITH cte AS (SELECT 1) SELECT * FROM cte;\nSELECT * FROM (SELECT 1) AS dt;\n        However, CTEs have some advantages over derived tables:\n\n\n\n            A derived table can be referenced only a single time within\n            a query. A CTE can be referenced multiple times. To use\n            multiple instances of a derived table result, you must\n            derive the result multiple times.\n          \n            A CTE can be self-referencing (recursive).\n          \n            One CTE can refer to another.\n          \n            A CTE may be easier to read when its definition appears at\n            the beginning of the statement rather than embedded within\n            it.\n\n\n\n        CTEs are similar to tables created with\n        CREATE [TEMPORARY]\n        TABLE but need not be defined or dropped explicitly.\n        For a CTE, you need no privileges to create tables.\n\n"
    ],
    "Examples": [
        "WITH\n  cte1 AS (SELECT a, b FROM table1),\n  cte2 AS (SELECT c, d FROM table2)\nSELECT b, d FROM cte1 JOIN cte2\nWHERE cte1.a = cte2.c;",
        "WITH cte (col1, col2) AS\n(\n  SELECT 1, 2\n  UNION ALL\n  SELECT 3, 4\n)\nSELECT col1, col2 FROM cte;",
        "WITH cte AS\n(\n  SELECT 1 AS col1, 2 AS col2\n  UNION ALL\n  SELECT 3, 4\n)\nSELECT col1, col2 FROM cte;",
        "WITH cte1 AS (SELECT 1)\nSELECT * FROM (WITH cte2 AS (SELECT 2) SELECT * FROM cte2 JOIN cte1) AS dt;",
        "WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte WHERE n < 5\n)\nSELECT * FROM cte;",
        "WITH RECURSIVE cte AS\n(\n  SELECT 1 AS n, 'abc' AS str\n  UNION ALL\n  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n < 3\n)\nSELECT * FROM cte;",
        "WITH RECURSIVE cte AS\n(\n  SELECT 1 AS n, CAST('abc' AS CHAR(20)) AS str\n  UNION ALL\n  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n < 3\n)\nSELECT * FROM cte;",
        "WITH RECURSIVE cte AS\n(\n  SELECT 1 AS n, 1 AS p, -1 AS q\n  UNION ALL\n  SELECT n + 1, q * 2, p * 2 FROM cte WHERE n < 5\n)\nSELECT * FROM cte;",
        "WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte\n)\nSELECT * FROM cte;",
        "SET SESSION cte_max_recursion_depth = 10;      -- permit only shallow recursion\nSET SESSION cte_max_recursion_depth = 1000000; -- permit deeper recursion",
        "SET max_execution_time = 1000; -- impose one second timeout",
        "WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte\n)\nSELECT /*+ SET_VAR(cte_max_recursion_depth = 1M) */ * FROM cte;\n\nWITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte\n)\nSELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;",
        "WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte LIMIT 10000\n)\nSELECT * FROM cte;",
        "WITH RECURSIVE cte (n) AS\n(\n  SELECT 1\n  UNION ALL\n  SELECT n + 1 FROM cte LIMIT 10000\n)\nSELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;",
        "WITH RECURSIVE fibonacci (n, fib_n, next_fib_n) AS\n(\n  SELECT 1, 0, 1\n  UNION ALL\n  SELECT n + 1, next_fib_n, fib_n + next_fib_n\n    FROM fibonacci WHERE n < 10\n)\nSELECT * FROM fibonacci;",
        "mysql> WITH RECURSIVE fibonacci ...\n       ...\n       SELECT fib_n FROM fibonacci WHERE n = 8;\n+-------+\n| fib_n |\n+-------+\n|    13 |\n+-------+",
        "mysql> SELECT * FROM sales ORDER BY date, price;\n+------------+--------+\n| date       | price  |\n+------------+--------+\n| 2017-01-03 | 100.00 |\n| 2017-01-03 | 200.00 |\n| 2017-01-06 |  50.00 |\n| 2017-01-08 |  10.00 |\n| 2017-01-08 |  20.00 |\n| 2017-01-08 | 150.00 |\n| 2017-01-10 |   5.00 |\n+------------+--------+",
        "mysql> SELECT date, SUM(price) AS sum_price\n       FROM sales\n       GROUP BY date\n       ORDER BY date;\n+------------+-----------+\n| date       | sum_price |\n+------------+-----------+\n| 2017-01-03 |    300.00 |\n| 2017-01-06 |     50.00 |\n| 2017-01-08 |    180.00 |\n| 2017-01-10 |      5.00 |\n+------------+-----------+",
        "WITH RECURSIVE dates (date) AS\n(\n  SELECT MIN(date) FROM sales\n  UNION ALL\n  SELECT date + INTERVAL 1 DAY FROM dates\n  WHERE date + INTERVAL 1 DAY <= (SELECT MAX(date) FROM sales)\n)\nSELECT * FROM dates;",
        "WITH RECURSIVE dates (date) AS\n(\n  SELECT MIN(date) FROM sales\n  UNION ALL\n  SELECT date + INTERVAL 1 DAY FROM dates\n  WHERE date + INTERVAL 1 DAY <= (SELECT MAX(date) FROM sales)\n)\nSELECT dates.date, COALESCE(SUM(price), 0) AS sum_price\nFROM dates LEFT JOIN sales ON dates.date = sales.date\nGROUP BY dates.date\nORDER BY dates.date;",
        "CREATE TABLE employees (\n  id         INT PRIMARY KEY NOT NULL,\n  name       VARCHAR(100) NOT NULL,\n  manager_id INT NULL,\n  INDEX (manager_id),\nFOREIGN KEY (manager_id) REFERENCES employees (id)\n);\nINSERT INTO employees VALUES\n(333, \"Yasmina\", NULL),  # Yasmina is the CEO (manager_id is NULL)\n(198, \"John\", 333),      # John has ID 198 and reports to 333 (Yasmina)\n(692, \"Tarek\", 333),\n(29, \"Pedro\", 198),\n(4610, \"Sarah\", 29),\n(72, \"Pierre\", 29),\n(123, \"Adil\", 692);",
        "mysql> SELECT * FROM employees ORDER BY id;\n+------+---------+------------+\n| id   | name    | manager_id |\n+------+---------+------------+\n|   29 | Pedro   |        198 |\n|   72 | Pierre  |         29 |\n|  123 | Adil    |        692 |\n|  198 | John    |        333 |\n|  333 | Yasmina |       NULL |\n|  692 | Tarek   |        333 |\n| 4610 | Sarah   |         29 |\n+------+---------+------------+",
        "WITH RECURSIVE employee_paths (id, name, path) AS\n(\n  SELECT id, name, CAST(id AS CHAR(200))\n    FROM employees\n    WHERE manager_id IS NULL\n  UNION ALL\n  SELECT e.id, e.name, CONCAT(ep.path, ',', e.id)\n    FROM employee_paths AS ep JOIN employees AS e\n      ON ep.id = e.manager_id\n)\nSELECT * FROM employee_paths ORDER BY path;",
        "mysql> WITH RECURSIVE ...\n       ...\n       SELECT * FROM employees_extended\n       WHERE id IN (692, 4610)\n       ORDER BY path;\n+------+-------+-----------------+\n| id   | name  | path            |\n+------+-------+-----------------+\n| 4610 | Sarah | 333,198,29,4610 |\n|  692 | Tarek | 333,692         |\n+------+-------+-----------------+",
        "WITH cte AS (SELECT 1) SELECT * FROM cte;\nSELECT * FROM (SELECT 1) AS dt;"
    ],
    "Category": [
        "Data Manipulation Statements"
    ]
}