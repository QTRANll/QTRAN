{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/flush.html"
    ],
    "Title": [
        "15.7.8.3 FLUSH Statement"
    ],
    "Feature": [
        "FLUSH [NO_WRITE_TO_BINLOG | LOCAL] {\n    flush_option [, flush_option] ...\n  | tables_option\n}\n\nflush_option: {\n    BINARY LOGS\n  | ENGINE LOGS\n  | ERROR LOGS\n  | GENERAL LOGS\n  | LOGS\n  | PRIVILEGES\n  | OPTIMIZER_COSTS\n  | RELAY LOGS [FOR CHANNEL channel]\n  | SLOW LOGS\n  | STATUS\n  | USER_RESOURCES\n}\n\ntables_option: {\n    table_synonym\n  | table_synonym tbl_name [, tbl_name] ...\n  | table_synonym WITH READ LOCK\n  | table_synonym tbl_name [, tbl_name] ... WITH READ LOCK\n  | table_synonym tbl_name [, tbl_name] ... FOR EXPORT\n}\n\ntable_synonym: {\n    TABLE\n  | TABLES\n}",
        "FLUSH BINARY LOGS\nFLUSH ENGINE LOGS\nFLUSH ERROR LOGS\nFLUSH GENERAL LOGS\nFLUSH RELAY LOGS\nFLUSH SLOW LOGS",
        "FLUSH TABLES ... WITH READ LOCK\nFLUSH TABLES ... FOR EXPORT\nLOCK TABLES ... READ\nLOCK TABLES ... WRITE",
        "FLUSH TABLES WITH READ LOCK\nFLUSH TABLES ... WITH READ LOCK\nFLUSH TABLES ... FOR EXPORT"
    ],
    "Description": [
        "\n        The FLUSH statement has several\n        variant forms that clear or reload various internal caches,\n        flush tables, or acquire locks. Each\n        FLUSH operation requires the\n        privileges indicated in its description.\n",
        "\n\nNote\n\n\n          It is not possible to issue\n          FLUSH statements within stored\n          functions or triggers. However, you may use\n          FLUSH in stored procedures, so\n          long as these are not called from stored functions or\n          triggers. See Section\u00a027.8, \u201cRestrictions on Stored Programs\u201d.\n\n",
        "\n        By default, the server writes\n        FLUSH statements to the binary\n        log so that they replicate to replicas. To suppress logging,\n        specify the optional NO_WRITE_TO_BINLOG\n        keyword or its alias LOCAL.\n",
        "\n\nNote\n\n\nFLUSH LOGS,\n          FLUSH BINARY LOGS,\n          FLUSH TABLES WITH READ LOCK\n          (with or without a table list), and\n          FLUSH\n          TABLES tbl_name ... FOR\n          EXPORT are not written to the binary log in any case\n          because they would cause problems if replicated to a replica.\n\n",
        "\n        The FLUSH statement causes an\n        implicit commit. See Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n      ",
        "\n        The mysqladmin utility provides a\n        command-line interface to some flush operations, using commands\n        such as flush-logs,\n        flush-privileges,\n        flush-status, and\n        flush-tables. See\n        Section\u00a06.5.2, \u201cmysqladmin \u2014 A MySQL Server Administration Program\u201d.\n      ",
        "\n        Sending a SIGHUP or\n        SIGUSR1 signal to the server causes several\n        flush operations to occur that are similar to various forms of\n        the FLUSH statement. Signals can\n        be sent by the root system account or the\n        system account that owns the server process. This enables the\n        flush operations to be performed without having to connect to\n        the server, which requires a MySQL account that has privileges\n        sufficient for those operations. See\n        Section\u00a06.10, \u201cUnix Signal Handling in MySQL\u201d.\n      ",
        "\n        The RESET statement is similar to\n        FLUSH. See\n        Section\u00a015.7.8.6, \u201cRESET Statement\u201d, for information about using\n        RESET with replication.\n      ",
        "\n        The following list describes the permitted\n        FLUSH statement\n        flush_option values. For descriptions\n        of the permitted tables_option\n        values, see FLUSH TABLES Syntax.\n",
        "\n\nFLUSH BINARY LOGS\n\n            Closes and reopens any binary log file to which the server\n            is writing. If binary logging is enabled, the sequence\n            number of the binary log file is incremented by one relative\n            to the previous file.\n          \n            This operation requires the\n            RELOAD privilege.\n          \nFLUSH ENGINE LOGS\n\n            Closes and reopens any flushable logs for installed storage\n            engines. This causes InnoDB to flush its\n            logs to disk.\n          \n            This operation requires the\n            RELOAD privilege.\n          \nFLUSH ERROR LOGS\n\n            Closes and reopens any error log file to which the server is\n            writing.\n          \n            This operation requires the\n            RELOAD privilege.\n          \nFLUSH GENERAL LOGS\n\n            Closes and reopens any general query log file to which the\n            server is writing.\n          \n            This operation requires the\n            RELOAD privilege.\n          \n            This operation has no effect on tables used for the general\n            query log (see Section\u00a07.4.1, \u201cSelecting General Query Log and Slow Query Log Output Destinations\u201d).\n          \nFLUSH LOGS\n\n            Closes and reopens any log file to which the server is\n            writing.\n          \n            This operation requires the\n            RELOAD privilege.\n          \n            The effect of this operation is equivalent to the combined\n            effects of these operations:\n          Press CTRL+C to copy FLUSH BINARY LOGS\nFLUSH ENGINE LOGS\nFLUSH ERROR LOGS\nFLUSH GENERAL LOGS\nFLUSH RELAY LOGS\nFLUSH SLOW LOGS\nFLUSH OPTIMIZER_COSTS\n\n            Re-reads the cost model tables so that the optimizer starts\n            using the current cost estimates stored in them.\n          \n            This operation requires the\n            FLUSH_OPTIMIZER_COSTS or\n            RELOAD privilege.\n          \n            The server writes a warning to the error log for any\n            unrecognized cost model table entries. For information about\n            these tables, see Section\u00a010.9.5, \u201cThe Optimizer Cost Model\u201d. This\n            operation affects only sessions that begin subsequent to the\n            flush. Existing sessions continue to use the cost estimates\n            that were current when they began.\n          \nFLUSH PRIVILEGES\n\n            Re-reads the privileges from the grant tables in the\n            mysql system schema. As part of this\n            operation, the server reads the\n            global_grants table containing dynamic\n            privilege assignments and registers any unregistered\n            privileges found there.\n          \n            Reloading the grant tables is necessary to enable updates to\n            MySQL privileges and users only if you make such changes\n            directly to the grant tables; it is not needed for account\n            management statements such as\n            GRANT or\n            REVOKE, which take effect\n            immediately. See Section\u00a08.2.13, \u201cWhen Privilege Changes Take Effect\u201d, for\n            more information.\n          \n            This operation requires the\n            RELOAD or\n            FLUSH_PRIVILEGES privilege.\n          \n            If the --skip-grant-tables\n            option was specified at server startup to disable the MySQL\n            privilege system, FLUSH\n            PRIVILEGES provides a way to enable the privilege\n            system at runtime.\n          \n            Resets failed-login tracking (or enables it if the server\n            was started with\n            --skip-grant-tables) and\n            unlocks any temporarily locked accounts. See\n            Section\u00a08.2.15, \u201cPassword Management\u201d.\n          \n            Frees memory cached by the server as a result of\n            GRANT,\n            CREATE USER,\n            CREATE SERVER, and\n            INSTALL PLUGIN statements.\n            This memory is not released by the corresponding\n            REVOKE,\n            DROP USER,\n            DROP SERVER, and\n            UNINSTALL PLUGIN statements,\n            so for a server that executes many instances of the\n            statements that cause caching, there is an increase in\n            cached memory use unless it is freed with\n            FLUSH PRIVILEGES.\n          \n            Clears the in-memory cache used by the\n            caching_sha2_password authentication\n            plugin. See\n            Cache Operation for SHA-2 Pluggable Authentication.\n          \nFLUSH\n            RELAY LOGS [FOR CHANNEL\n            channel]\n\n            Closes and reopens any relay log file to which the server is\n            writing. If relay logging is enabled, the sequence number of\n            the relay log file is incremented by one relative to the\n            previous file.\n          \n            This operation requires the\n            RELOAD privilege.\n          \n            The FOR CHANNEL\n            channel clause enables\n            you to name which replication channel the operation applies\n            to. Execute\n            FLUSH\n            RELAY LOGS FOR CHANNEL\n            channel to flush the\n            relay log for a specific replication channel. If no channel\n            is named and no extra replication channels exist, the\n            operation applies to the default channel. If no channel is\n            named and multiple replication channels exist, the operation\n            applies to all replication channels. For more information,\n            see Section\u00a019.2.2, \u201cReplication Channels\u201d.\n          \nFLUSH SLOW LOGS\n\n            Closes and reopens any slow query log file to which the\n            server is writing.\n          \n            This operation requires the\n            RELOAD privilege.\n          \n            This operation has no effect on tables used for the slow\n            query log (see Section\u00a07.4.1, \u201cSelecting General Query Log and Slow Query Log Output Destinations\u201d).\n          \nFLUSH STATUS\n\n            Flushes status indicators.\n          \n            This operation adds the current thread's session status\n            variable values to the global values and resets the session\n            values to zero. Some global variables may be reset to zero\n            as well. It also resets the counters for key caches (default\n            and named) to zero and sets\n            Max_used_connections to\n            the current number of open connections. This information may\n            be of use when debugging a query. See\n            Section\u00a01.6, \u201cHow to Report Bugs or Problems\u201d.\n          \nFLUSH STATUS is unaffected by\n            read_only or\n            super_read_only, and is\n            always written to the binary log.\n          \n            This operation requires the\n            FLUSH_STATUS or\n            RELOAD privilege.\n          \nFLUSH USER_RESOURCES\n\n            Resets all per-hour user resource indicators to zero.\n          \n            This operation requires the\n            FLUSH_USER_RESOURCES or\n            RELOAD privilege.\n          \n            Resetting resource indicators enables clients that have\n            reached their hourly connection, query, or update limits to\n            resume activity immediately. FLUSH\n            USER_RESOURCES does not apply to the limit on\n            maximum simultaneous connections that is controlled by the\n            max_user_connections system\n            variable. See Section\u00a08.2.21, \u201cSetting Account Resource Limits\u201d.\n\n",
        "FLUSH TABLES Syntax",
        "\nFLUSH TABLES flushes tables, and,\n        depending on the variant used, acquires locks. Any\n        TABLES variant used in a\n        FLUSH statement must be the only\n        option used. FLUSH\n        TABLE is a synonym for FLUSH\n        TABLES.\n",
        "\n\nNote\n\n\n          The descriptions here that indicate tables are flushed by\n          closing them apply differently for InnoDB,\n          which flushes table contents to disk but leaves them open.\n          This still permits table files to be copied while the tables\n          are open, as long as other activity does not modify them.\n\n",
        "\n\nFLUSH TABLES\n\n            Closes all open tables, forces all tables in use to be\n            closed, and flushes the prepared statement cache.\n          \n            This operation requires the\n            FLUSH_TABLES or\n            RELOAD privilege.\n          \n            For information about prepared statement caching, see\n            Section\u00a010.10.3, \u201cCaching of Prepared Statements and Stored Programs\u201d.\n          \nFLUSH TABLES is not permitted\n            when there is an active\n            LOCK TABLES ...\n            READ. To flush and lock tables, use\n            FLUSH\n            TABLES tbl_name ... WITH READ\n            LOCK instead.\n          \nFLUSH\n            TABLES tbl_name [,\n            tbl_name] ...\n\n            With a list of one or more comma-separated table names, this\n            operation is like FLUSH\n            TABLES with no names except that the server\n            flushes only the named tables. If a named table does not\n            exist, no error occurs.\n          \n            This operation requires the\n            FLUSH_TABLES or\n            RELOAD privilege.\n          \nFLUSH\n            TABLES WITH READ LOCK\n\n            Closes all open tables and locks all tables for all\n            databases with a global read lock.\n          \n            This operation requires the\n            FLUSH_TABLES or\n            RELOAD privilege.\n          \n            This operation is a very convenient way to get backups if\n            you have a file system such as Veritas or ZFS that can take\n            snapshots in time. Use\n            UNLOCK\n            TABLES to release the lock.\n          \nFLUSH TABLES WITH READ LOCK\n            acquires a global read lock rather than table locks, so it\n            is not subject to the same behavior as\n            LOCK TABLES and\n            UNLOCK\n            TABLES with respect to table locking and implicit\n            commits:\n\n\n\nUNLOCK\n                TABLES implicitly commits any active\n                transaction only if any tables currently have been\n                locked with LOCK TABLES.\n                The commit does not occur for\n                UNLOCK\n                TABLES following FLUSH\n                TABLES WITH READ LOCK because the latter\n                statement does not acquire table locks.\n              \n                Beginning a transaction causes table locks acquired with\n                LOCK TABLES to be\n                released, as though you had executed\n                UNLOCK\n                TABLES. Beginning a transaction does not\n                release a global read lock acquired with\n                FLUSH TABLES WITH READ\n                LOCK.\n\n\n\nFLUSH TABLES WITH READ LOCK\n            does not prevent the server from inserting rows into the log\n            tables (see Section\u00a07.4.1, \u201cSelecting General Query Log and Slow Query Log Output Destinations\u201d).\n          \nFLUSH\n            TABLES tbl_name [,\n            tbl_name] ... WITH READ\n            LOCK\n\n            Flushes and acquires read locks for the named tables.\n          \n            This operation requires the\n            FLUSH_TABLES or\n            RELOAD privilege. Because it\n            acquires table locks, it also requires the\n            LOCK TABLES privilege for\n            each table.\n          \n            The operation first acquires exclusive metadata locks for\n            the tables, so it waits for transactions that have those\n            tables open to complete. Then the operation flushes the\n            tables from the table cache, reopens the tables, acquires\n            table locks (like\n            LOCK TABLES ...\n            READ), and downgrades the metadata locks from\n            exclusive to shared. After the operation acquires locks and\n            downgrades the metadata locks, other sessions can read but\n            not modify the tables.\n          \n            This operation applies only to existing base\n            (non-TEMPORARY) tables. If a name refers\n            to a base table, that table is used. If it refers to a\n            TEMPORARY table, it is ignored. If a name\n            applies to a view, an\n            ER_WRONG_OBJECT error\n            occurs. Otherwise, an\n            ER_NO_SUCH_TABLE error\n            occurs.\n          \n            Use UNLOCK\n            TABLES to release the locks,\n            LOCK TABLES to release the\n            locks and acquire other locks, or\n            START\n            TRANSACTION to release the locks and begin a new\n            transaction.\n          \n            This FLUSH TABLES variant\n            enables tables to be flushed and locked in a single\n            operation. It provides a workaround for the restriction that\n            FLUSH TABLES is not permitted\n            when there is an active\n            LOCK TABLES ...\n            READ.\n          \n            This operation does not perform an implicit\n            UNLOCK\n            TABLES, so an error results if you perform the\n            operation while there is any active\n            LOCK TABLES or use it a\n            second time without first releasing the locks acquired.\n          \n            If a flushed table was opened with\n            HANDLER, the handler is\n            implicitly flushed and loses its position.\n          \nFLUSH\n            TABLES tbl_name [,\n            tbl_name] ... FOR\n            EXPORT\n\n            This FLUSH TABLES variant\n            applies to InnoDB tables. It ensures that\n            changes to the named tables have been flushed to disk so\n            that binary table copies can be made while the server is\n            running.\n          \n            This operation requires the\n            FLUSH_TABLES or\n            RELOAD privilege. Because it\n            acquires locks on tables in preparation for exporting them,\n            it also requires the LOCK\n            TABLES and SELECT\n            privileges for each table.\n          \n            The operation works like this:\n\n\n\n                It acquires shared metadata locks for the named tables.\n                The operation blocks as long as other sessions have\n                active transactions that have modified those tables or\n                hold table locks for them. When the locks have been\n                acquired, the operation blocks transactions that attempt\n                to update the tables, while permitting read-only\n                operations to continue.\n              \n                It checks whether all storage engines for the tables\n                support FOR EXPORT. If any do not, an\n                ER_ILLEGAL_HA error\n                occurs and the operation fails.\n              \n                The operation notifies the storage engine for each table\n                to make the table ready for export. The storage engine\n                must ensure that any pending changes are written to\n                disk.\n              \n                The operation puts the session in lock-tables mode so\n                that the metadata locks acquired earlier are not\n                released when the FOR EXPORT\n                operation completes.\n\n\n\n            This operation applies only to existing base\n            (non-TEMPORARY) tables. If a name refers\n            to a base table, that table is used. If it refers to a\n            TEMPORARY table, it is ignored. If a name\n            applies to a view, an\n            ER_WRONG_OBJECT error\n            occurs. Otherwise, an\n            ER_NO_SUCH_TABLE error\n            occurs.\n          \nInnoDB supports FOR\n            EXPORT for tables that have their own\n            .ibd\n            file file (that is, tables created with the\n            innodb_file_per_table\n            setting enabled). InnoDB ensures when\n            notified by the FOR EXPORT operation that\n            any changes have been flushed to disk. This permits a binary\n            copy of table contents to be made while the FOR\n            EXPORT operation is in effect because the\n            .ibd file is transaction consistent and\n            can be copied while the server is running. FOR\n            EXPORT does not apply to InnoDB\n            system tablespace files, or to InnoDB\n            tables that have FULLTEXT indexes.\n          \nFLUSH\n            TABLES ...FOR EXPORT is supported for partitioned\n            InnoDB tables.\n          \n            When notified by FOR EXPORT,\n            InnoDB writes to disk certain kinds of\n            data that is normally held in memory or in separate disk\n            buffers outside the tablespace files. For each table,\n            InnoDB also produces a file named\n            table_name.cfg\n            in the same database directory as the table. The\n            .cfg file contains metadata needed to\n            reimport the tablespace files later, into the same or\n            different server.\n          \n            When the FOR EXPORT operation completes,\n            InnoDB has flushed all\n            dirty pages to the\n            table data files. Any\n            change buffer\n            entries are merged prior to flushing. At this point, the\n            tables are locked and quiescent: The tables are in a\n            transactionally consistent state on disk and you can copy\n            the .ibd tablespace files along with\n            the corresponding .cfg files to get a\n            consistent snapshot of those tables.\n          \n            For the procedure to reimport the copied table data into a\n            MySQL instance, see Section\u00a017.6.1.3, \u201cImporting InnoDB Tables\u201d.\n          \n            After you are done with the tables, use\n            UNLOCK\n            TABLES to release the locks,\n            LOCK TABLES to release the\n            locks and acquire other locks, or\n            START\n            TRANSACTION to release the locks and begin a new\n            transaction.\n          \n            While any of these statements is in effect within the\n            session, attempts to use\n            FLUSH\n            TABLES ... FOR EXPORT produce an error:\n          Press CTRL+C to copy FLUSH TABLES ... WITH READ LOCK\nFLUSH TABLES ... FOR EXPORT\nLOCK TABLES ... READ\nLOCK TABLES ... WRITE\n            While\n            FLUSH\n            TABLES ... FOR EXPORT is in effect within the\n            session, attempts to use any of these statements produce an\n            error:\n          Press CTRL+C to copy FLUSH TABLES WITH READ LOCK\nFLUSH TABLES ... WITH READ LOCK\nFLUSH TABLES ... FOR EXPORT\n"
    ],
    "Examples": [],
    "Category": [
        "Database Administration Statements"
    ]
}