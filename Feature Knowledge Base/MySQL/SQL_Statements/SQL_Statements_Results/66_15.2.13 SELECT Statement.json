{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/select.html"
    ],
    "Title": [
        "15.2.13 SELECT Statement"
    ],
    "Feature": [
        "SELECT\n    [ALL | DISTINCT | DISTINCTROW ]\n    [HIGH_PRIORITY]\n    [STRAIGHT_JOIN]\n    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]\n    [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]\n    select_expr [, select_expr] ...\n    [into_option]\n    [FROM table_references\n      [PARTITION partition_list]]\n    [WHERE where_condition]\n    [GROUP BY {col_name | expr | position}, ... [WITH ROLLUP]]\n    [HAVING where_condition]\n    [WINDOW window_name AS (window_spec)\n        [, window_name AS (window_spec)] ...]\n    [ORDER BY {col_name | expr | position}\n      [ASC | DESC], ... [WITH ROLLUP]]\n    [LIMIT {[offset,] row_count | row_count OFFSET offset}]\n    [into_option]\n    [FOR {UPDATE | SHARE}\n        [OF tbl_name [, tbl_name] ...]\n        [NOWAIT | SKIP LOCKED]\n      | LOCK IN SHARE MODE]\n    [into_option]\n\ninto_option: {\n    INTO OUTFILE 'file_name'\n        [CHARACTER SET charset_name]\n        export_options\n  | INTO DUMPFILE 'file_name'\n  | INTO var_name [, var_name] ...\n}",
        "SELECT * FROM t1 INNER JOIN t2 ...",
        "SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ...",
        "SELECT id, * FROM t1",
        "SELECT id, t1.* FROM t1",
        "SELECT AVG(score), t1.* FROM t1 ...",
        "tbl_name [[AS] alias] [index_hint]"
    ],
    "Description": [
        "\nSELECT is used to retrieve rows\n      selected from one or more tables, and can include\n      UNION operations and subqueries.\n      INTERSECT and\n      EXCEPT operations are also\n      supported. The UNION,\n      INTERSECT, and EXCEPT\n      operators are described in more detail later in this section. See\n      also Section\u00a015.2.15, \u201cSubqueries\u201d.\n    ",
        "\n      A SELECT statement can start with a\n      WITH clause to define common table\n      expressions accessible within the\n      SELECT. See Section\u00a015.2.20, \u201cWITH (Common Table Expressions)\u201d.\n    ",
        "\n      The most commonly used clauses of\n      SELECT statements are these:\n",
        "\n\n          Each select_expr indicates a column\n          that you want to retrieve. There must be at least one\n          select_expr.\n        \ntable_references indicates the\n          table or tables from which to retrieve rows. Its syntax is\n          described in Section\u00a015.2.13.2, \u201cJOIN Clause\u201d.\n        \nSELECT supports explicit partition\n          selection using the PARTITION clause with a\n          list of partitions or subpartitions (or both) following the\n          name of the table in a\n          table_reference (see\n          Section\u00a015.2.13.2, \u201cJOIN Clause\u201d). In this case, rows are selected only\n          from the partitions listed, and any other partitions of the\n          table are ignored. For more information and examples, see\n          Section\u00a026.5, \u201cPartition Selection\u201d.\n        \n          The WHERE clause, if given, indicates the\n          condition or conditions that rows must satisfy to be selected.\n          where_condition is an expression\n          that evaluates to true for each row to be selected. The\n          statement selects all rows if there is no\n          WHERE clause.\n        \n          In the WHERE expression, you can use any of\n          the functions and operators that MySQL supports, except for\n          aggregate (group) functions. See\n          Section\u00a011.5, \u201cExpressions\u201d, and\n          Chapter\u00a014, Functions and Operators.\n\n",
        "\nSELECT can also be used to retrieve\n      rows computed without reference to any table.\n    ",
        "\n      For example:\n    ",
        "Press CTRL+C to copy mysql> SELECT 1 + 1;\n        -> 2",
        "\n\n\n      You are permitted to specify DUAL as a dummy\n      table name in situations where no tables are referenced:\n    ",
        "Press CTRL+C to copy mysql> SELECT 1 + 1 FROM DUAL;\n        -> 2",
        "\nDUAL is purely for the convenience of people\n      who require that all SELECT\n      statements should have FROM and possibly other\n      clauses. MySQL may ignore the clauses. MySQL does not require\n      FROM DUAL if no tables are referenced.\n    ",
        "\n      In general, clauses used must be given in exactly the order shown\n      in the syntax description. For example, a\n      HAVING clause must come after any\n      GROUP BY clause and before any ORDER\n      BY clause. The INTO clause, if\n      present, can appear in any position indicated by the syntax\n      description, but within a given statement can appear only once,\n      not in multiple positions. For more information about\n      INTO, see Section\u00a015.2.13.1, \u201cSELECT ... INTO Statement\u201d.\n    ",
        "\n      The list of select_expr terms comprises\n      the select list that indicates which columns to retrieve. Terms\n      specify a column or expression or can use\n      *-shorthand:\n",
        "\n\n          A select list consisting only of a single unqualified\n          * can be used as shorthand to select all\n          columns from all tables:\n        Press CTRL+C to copy SELECT * FROM t1 INNER JOIN t2 ...\ntbl_name.* can\n          be used as a qualified shorthand to select all columns from\n          the named table:\n        Press CTRL+C to copy SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ...\n          If a table has invisible columns, * and\n          tbl_name.* do\n          not include them. To be included, invisible columns must be\n          referenced explicitly.\n        \n          Use of an unqualified * with other items in\n          the select list may produce a parse error. For example:\n        Press CTRL+C to copy SELECT id, * FROM t1\n          To avoid this problem, use a qualified\n          tbl_name.*\n          reference:\n        Press CTRL+C to copy SELECT id, t1.* FROM t1\n          Use qualified\n          tbl_name.*\n          references for each table in the select list:\n        Press CTRL+C to copy SELECT AVG(score), t1.* FROM t1 ...\n",
        "\n      The following list provides additional information about other\n      SELECT clauses:\n",
        "\n\n\n\n\n          A select_expr can be given an alias\n          using AS\n          alias_name. The alias is\n          used as the expression's column name and can be used in\n          GROUP BY, ORDER BY, or\n          HAVING clauses. For example:\n        Press CTRL+C to copy SELECT CONCAT(last_name,', ',first_name) AS full_name\n  FROM mytable ORDER BY full_name;\n          The AS keyword is optional when aliasing a\n          select_expr with an identifier. The\n          preceding example could have been written like this:\n        Press CTRL+C to copy SELECT CONCAT(last_name,', ',first_name) full_name\n  FROM mytable ORDER BY full_name;\n          However, because the AS is optional, a\n          subtle problem can occur if you forget the comma between two\n          select_expr expressions: MySQL\n          interprets the second as an alias name. For example, in the\n          following statement, columnb is treated as\n          an alias name:\n        Press CTRL+C to copy SELECT columna columnb FROM mytable;\n          For this reason, it is good practice to be in the habit of\n          using AS explicitly when specifying column\n          aliases.\n        \n          It is not permissible to refer to a column alias in a\n          WHERE clause, because the column value\n          might not yet be determined when the WHERE\n          clause is executed. See Section\u00a0B.3.4.4, \u201cProblems with Column Aliases\u201d.\n        \n\n\n\n          The FROM\n          table_references clause\n          indicates the table or tables from which to retrieve rows. If\n          you name more than one table, you are performing a join. For\n          information on join syntax, see Section\u00a015.2.13.2, \u201cJOIN Clause\u201d. For\n          each table specified, you can optionally specify an alias.\n        Press CTRL+C to copy tbl_name [[AS] alias] [index_hint]\n          The use of index hints provides the optimizer with information\n          about how to choose indexes during query processing. For a\n          description of the syntax for specifying these hints, see\n          Section\u00a010.9.4, \u201cIndex Hints\u201d.\n        \n          You can use SET\n          max_seeks_for_key=value\n          as an alternative way to force MySQL to prefer key scans\n          instead of table scans. See\n          Section\u00a07.1.8, \u201cServer System Variables\u201d.\n        \n          You can refer to a table within the default database as\n          tbl_name, or as\n          db_name.tbl_name\n          to specify a database explicitly. You can refer to a column as\n          col_name,\n          tbl_name.col_name,\n          or\n          db_name.tbl_name.col_name.\n          You need not specify a tbl_name or\n          db_name.tbl_name\n          prefix for a column reference unless the reference would be\n          ambiguous. See Section\u00a011.2.2, \u201cIdentifier Qualifiers\u201d, for\n          examples of ambiguity that require the more explicit column\n          reference forms.\n        \n\n\n\n          A table reference can be aliased using\n          tbl_name AS\n          alias_name or\n          tbl_name alias_name. These\n          statements are equivalent:\n        Press CTRL+C to copy SELECT t1.name, t2.salary FROM employee AS t1, info AS t2\n  WHERE t1.name = t2.name;\n\nSELECT t1.name, t2.salary FROM employee t1, info t2\n  WHERE t1.name = t2.name;\n\n\n          Columns selected for output can be referred to in\n          ORDER BY and GROUP BY\n          clauses using column names, column aliases, or column\n          positions. Column positions are integers and begin with 1:\n        Press CTRL+C to copy SELECT college, region, seed FROM tournament\n  ORDER BY region, seed;\n\nSELECT college, region AS r, seed AS s FROM tournament\n  ORDER BY r, s;\n\nSELECT college, region, seed FROM tournament\n  ORDER BY 2, 3;\n          To sort in reverse order, add the DESC\n          (descending) keyword to the name of the column in the\n          ORDER BY clause that you are sorting by.\n          The default is ascending order; this can be specified\n          explicitly using the ASC keyword.\n        \n          If ORDER BY occurs within a parenthesized\n          query expression and also is applied in the outer query, the\n          results are undefined and may change in a future version of\n          MySQL.\n        \n          Use of column positions is deprecated because the syntax has\n          been removed from the SQL standard.\n        \n\n\n\n          When you use ORDER BY or GROUP\n          BY to sort a column in a\n          SELECT, the server sorts values\n          using only the initial number of bytes indicated by the\n          max_sort_length system\n          variable.\n        \n          MySQL extends the use of GROUP BY to permit\n          selecting fields that are not mentioned in the GROUP\n          BY clause. If you are not getting the results that\n          you expect from your query, please read the description of\n          GROUP BY found in\n          Section\u00a014.19, \u201cAggregate Functions\u201d.\n        \n          The HAVING clause, like the\n          WHERE clause, specifies selection\n          conditions. The WHERE clause specifies\n          conditions on columns in the select list, but cannot refer to\n          aggregate functions. The HAVING clause\n          specifies conditions on groups, typically formed by the\n          GROUP BY clause. The query result includes\n          only groups satisfying the HAVING\n          conditions. (If no GROUP BY is present, all\n          rows implicitly form a single aggregate group.)\n        \n          The HAVING clause is applied nearly last,\n          just before items are sent to the client, with no\n          optimization. (LIMIT is applied after\n          HAVING.)\n        \n          The SQL standard requires that HAVING must\n          reference only columns in the GROUP BY\n          clause or columns used in aggregate functions. However, MySQL\n          supports an extension to this behavior, and permits\n          HAVING to refer to columns in the\n          SELECT list and columns in\n          outer subqueries as well.\n        \n          If the HAVING clause refers to a column\n          that is ambiguous, a warning occurs. In the following\n          statement, col2 is ambiguous because it is\n          used as both an alias and a column name:\n        Press CTRL+C to copy SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;\n          Preference is given to standard SQL behavior, so if a\n          HAVING column name is used both in\n          GROUP BY and as an aliased column in the\n          select column list, preference is given to the column in the\n          GROUP BY column.\n        \n          Do not use HAVING for items that should be\n          in the WHERE clause. For example, do not\n          write the following:\n        Press CTRL+C to copy SELECT col_name FROM tbl_name HAVING col_name > 0;\n          Write this instead:\n        Press CTRL+C to copy SELECT col_name FROM tbl_name WHERE col_name > 0;\n          The HAVING clause can refer to aggregate\n          functions, which the WHERE clause cannot:\n        Press CTRL+C to copy SELECT user, MAX(salary) FROM users\n  GROUP BY user HAVING MAX(salary) > 10;\n          (This did not work in some older versions of MySQL.)\n        \n          MySQL permits duplicate column names. That is, there can be\n          more than one select_expr with the\n          same name. This is an extension to standard SQL. Because MySQL\n          also permits GROUP BY and\n          HAVING to refer to\n          select_expr values, this can result\n          in an ambiguity:\n        Press CTRL+C to copy SELECT 12 AS a, a FROM t GROUP BY a;\n          In that statement, both columns have the name\n          a. To ensure that the correct column is\n          used for grouping, use different names for each\n          select_expr.\n        \n          The WINDOW clause, if present, defines\n          named windows that can be referred to by window functions. For\n          details, see Section\u00a014.20.4, \u201cNamed Windows\u201d.\n        \n          MySQL resolves unqualified column or alias references in\n          ORDER BY clauses by searching in the\n          select_expr values, then in the\n          columns of the tables in the FROM clause.\n          For GROUP BY or HAVING\n          clauses, it searches the FROM clause before\n          searching in the select_expr\n          values. (For GROUP BY and\n          HAVING, this differs from the pre-MySQL 5.0\n          behavior that used the same rules as for ORDER\n          BY.)\n        \n\n\n          The LIMIT clause can be used to constrain\n          the number of rows returned by the\n          SELECT statement.\n          LIMIT takes one or two numeric arguments,\n          which must both be nonnegative integer constants, with these\n          exceptions:\n\n\n\n              Within prepared statements, LIMIT\n              parameters can be specified using ?\n              placeholder markers.\n            \n              Within stored programs, LIMIT\n              parameters can be specified using integer-valued routine\n              parameters or local variables.\n\n\n\n          With two arguments, the first argument specifies the offset of\n          the first row to return, and the second specifies the maximum\n          number of rows to return. The offset of the initial row is 0\n          (not 1):\n        Press CTRL+C to copy SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15\n          To retrieve all rows from a certain offset up to the end of\n          the result set, you can use some large number for the second\n          parameter. This statement retrieves all rows from the 96th row\n          to the last:\n        Press CTRL+C to copy SELECT * FROM tbl LIMIT 95,18446744073709551615;\n          With one argument, the value specifies the number of rows to\n          return from the beginning of the result set:\n        Press CTRL+C to copy SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows\n          In other words, LIMIT\n          row_count is equivalent\n          to LIMIT 0,\n          row_count.\n        \n          For prepared statements, you can use placeholders. The\n          following statements return one row from the\n          tbl table:\n        Press CTRL+C to copy SET @a=1;\nPREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?';\nEXECUTE STMT USING @a;\n          The following statements return the second to sixth rows from\n          the tbl table:\n        Press CTRL+C to copy SET @skip=1; SET @numrows=5;\nPREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?';\nEXECUTE STMT USING @skip, @numrows;\n          For compatibility with PostgreSQL, MySQL also supports the\n          LIMIT row_count OFFSET\n          offset syntax.\n        \n          If LIMIT occurs within a parenthesized\n          query expression and also is applied in the outer query, the\n          results are undefined and may change in a future version of\n          MySQL.\n        \n          The SELECT ...\n          INTO form of SELECT\n          enables the query result to be written to a file or stored in\n          variables. For more information, see\n          Section\u00a015.2.13.1, \u201cSELECT ... INTO Statement\u201d.\n        \n\n\n\n\n\n\n          If you use FOR UPDATE with a storage engine\n          that uses page or row locks, rows examined by the query are\n          write-locked until the end of the current transaction.\n        \n          You cannot use FOR UPDATE as part of the\n          SELECT in a statement such as\n          CREATE\n          TABLE new_table SELECT ... FROM\n          old_table .... (If you\n          attempt to do so, the statement is rejected with the error\n          Can't update table\n          'old_table' while\n          'new_table' is being\n          created.)\n        \nFOR SHARE and LOCK IN SHARE\n          MODE set shared locks that permit other transactions\n          to read the examined rows but not to update or delete them.\n          FOR SHARE and LOCK IN SHARE\n          MODE are equivalent. However, FOR\n          SHARE, like FOR UPDATE, supports\n          NOWAIT, SKIP LOCKED, and\n          OF tbl_name\n          options. FOR SHARE is a replacement for\n          LOCK IN SHARE MODE, but LOCK IN\n          SHARE MODE remains available for backward\n          compatibility.\n        \nNOWAIT causes a FOR\n          UPDATE or FOR SHARE query to\n          execute immediately, returning an error if a row lock cannot\n          be obtained due to a lock held by another transaction.\n        \nSKIP LOCKED causes a FOR\n          UPDATE or FOR SHARE query to\n          execute immediately, excluding rows from the result set that\n          are locked by another transaction.\n        \nNOWAIT and SKIP LOCKED\n          options are unsafe for statement-based replication.\n\n\n\nNote\n\n\n            Queries that skip locked rows return an inconsistent view of\n            the data. SKIP LOCKED is therefore not\n            suitable for general transactional work. However, it may be\n            used to avoid lock contention when multiple sessions access\n            the same queue-like table.\n\n\n\nOF tbl_name\n          applies FOR UPDATE and FOR\n          SHARE queries to named tables. For example:\n        Press CTRL+C to copy SELECT * FROM t1, t2 FOR SHARE OF t1 FOR UPDATE OF t2;\n          All tables referenced by the query block are locked when\n          OF tbl_name is\n          omitted. Consequently, using a locking clause without\n          OF tbl_name in\n          combination with another locking clause returns an error.\n          Specifying the same table in multiple locking clauses returns\n          an error. If an alias is specified as the table name in the\n          SELECT statement, a locking clause may only\n          use the alias. If the SELECT statement does\n          not specify an alias explicitly, the locking clause may only\n          specify the actual table name.\n        \n          For more information about FOR UPDATE and\n          FOR SHARE, see\n          Section\u00a017.7.2.4, \u201cLocking Reads\u201d. For additional\n          information about NOWAIT and SKIP\n          LOCKED options, see\n          Locking Read Concurrency with NOWAIT and SKIP LOCKED.\n\n",
        "\n      Following the SELECT keyword, you\n      can use a number of modifiers that affect the operation of the\n      statement. HIGH_PRIORITY,\n      STRAIGHT_JOIN, and modifiers beginning with\n      SQL_ are MySQL extensions to standard SQL.\n",
        "\n\n          The ALL and DISTINCT\n          modifiers specify whether duplicate rows should be returned.\n          ALL (the default) specifies that all\n          matching rows should be returned, including duplicates.\n          DISTINCT specifies removal of duplicate\n          rows from the result set. It is an error to specify both\n          modifiers. DISTINCTROW is a synonym for\n          DISTINCT.\n        \nDISTINCT can be used with a query that also\n          uses WITH ROLLUP.\n        \nHIGH_PRIORITY gives the\n          SELECT higher priority than a\n          statement that updates a table. You should use this only for\n          queries that are very fast and must be done at once. A\n          SELECT HIGH_PRIORITY query that is issued\n          while the table is locked for reading runs even if there is an\n          update statement waiting for the table to be free. This\n          affects only storage engines that use only table-level locking\n          (such as MyISAM, MEMORY,\n          and MERGE).\n        \nHIGH_PRIORITY cannot be used with\n          SELECT statements that are part\n          of a UNION.\n        \nSTRAIGHT_JOIN forces the optimizer to join\n          the tables in the order in which they are listed in the\n          FROM clause. You can use this to speed up a\n          query if the optimizer joins the tables in nonoptimal order.\n          STRAIGHT_JOIN also can be used in the\n          table_references list. See\n          Section\u00a015.2.13.2, \u201cJOIN Clause\u201d.\n        \nSTRAIGHT_JOIN does not apply to any table\n          that the optimizer treats as a\n          const or\n          system table. Such a table\n          produces a single row, is read during the optimization phase\n          of query execution, and references to its columns are replaced\n          with the appropriate column values before query execution\n          proceeds. These tables appear first in the query plan\n          displayed by EXPLAIN. See\n          Section\u00a010.8.1, \u201cOptimizing Queries with EXPLAIN\u201d. This exception may not apply\n          to const or\n          system tables that are used\n          on the NULL-complemented side of an outer\n          join (that is, the right-side table of a LEFT\n          JOIN or the left-side table of a RIGHT\n          JOIN.\n        \nSQL_BIG_RESULT or\n          SQL_SMALL_RESULT can be used with\n          GROUP BY or DISTINCT to\n          tell the optimizer that the result set has many rows or is\n          small, respectively. For SQL_BIG_RESULT,\n          MySQL directly uses disk-based temporary tables if they are\n          created, and prefers sorting to using a temporary table with a\n          key on the GROUP BY elements. For\n          SQL_SMALL_RESULT, MySQL uses in-memory\n          temporary tables to store the resulting table instead of using\n          sorting. This should not normally be needed.\n        \nSQL_BUFFER_RESULT forces the result to be\n          put into a temporary table. This helps MySQL free the table\n          locks early and helps in cases where it takes a long time to\n          send the result set to the client. This modifier can be used\n          only for top-level SELECT\n          statements, not for subqueries or following\n          UNION.\n        \nSQL_CALC_FOUND_ROWS tells MySQL to\n          calculate how many rows there would be in the result set,\n          disregarding any LIMIT clause. The number\n          of rows can then be retrieved with SELECT\n          FOUND_ROWS(). See\n          Section\u00a014.15, \u201cInformation Functions\u201d.\n\n\n\nNote\n\n\n            The SQL_CALC_FOUND_ROWS query modifier\n            and accompanying FOUND_ROWS()\n            function are deprecated; expect them to be removed in a\n            future version of MySQL. See the description of\n            FOUND_ROWS() for information\n            about an alternative strategy.\n\n\n\n          The SQL_CACHE and\n          SQL_NO_CACHE modifiers were used with the\n          query cache prior to MySQL 8.4. The query cache\n          was removed in MySQL 8.4. The\n          SQL_CACHE modifier was removed as well.\n          SQL_NO_CACHE is deprecated, and has no\n          effect; expect it to be removed in a future MySQL release.\n\n"
    ],
    "Examples": [
        "mysql> SELECT 1 + 1;\n        -> 2",
        "mysql> SELECT 1 + 1 FROM DUAL;\n        -> 2",
        "SELECT CONCAT(last_name,', ',first_name) AS full_name\n  FROM mytable ORDER BY full_name;",
        "SELECT CONCAT(last_name,', ',first_name) full_name\n  FROM mytable ORDER BY full_name;",
        "SELECT columna columnb FROM mytable;",
        "SELECT t1.name, t2.salary FROM employee AS t1, info AS t2\n  WHERE t1.name = t2.name;\n\nSELECT t1.name, t2.salary FROM employee t1, info t2\n  WHERE t1.name = t2.name;",
        "SELECT college, region, seed FROM tournament\n  ORDER BY region, seed;\n\nSELECT college, region AS r, seed AS s FROM tournament\n  ORDER BY r, s;\n\nSELECT college, region, seed FROM tournament\n  ORDER BY 2, 3;",
        "SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;",
        "SELECT col_name FROM tbl_name HAVING col_name > 0;",
        "SELECT col_name FROM tbl_name WHERE col_name > 0;",
        "SELECT user, MAX(salary) FROM users\n  GROUP BY user HAVING MAX(salary) > 10;",
        "SELECT 12 AS a, a FROM t GROUP BY a;",
        "SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15",
        "SELECT * FROM tbl LIMIT 95,18446744073709551615;",
        "SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows",
        "SET @a=1;\nPREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?';\nEXECUTE STMT USING @a;",
        "SET @skip=1; SET @numrows=5;\nPREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?';\nEXECUTE STMT USING @skip, @numrows;",
        "SELECT * FROM t1, t2 FOR SHARE OF t1 FOR UPDATE OF t2;"
    ],
    "Category": [
        "Data Manipulation Statements"
    ]
}