{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/load-data.html"
    ],
    "Title": [
        "15.2.9 LOAD DATA Statement"
    ],
    "Feature": [
        "LOAD DATA\n    [LOW_PRIORITY | CONCURRENT] [LOCAL]\n    INFILE 'file_name'\n    [REPLACE | IGNORE]\n    INTO TABLE tbl_name\n    [PARTITION (partition_name [, partition_name] ...)]\n    [CHARACTER SET charset_name]\n    [{FIELDS | COLUMNS}\n        [TERMINATED BY 'string']\n        [[OPTIONALLY] ENCLOSED BY 'char']\n        [ESCAPED BY 'char']\n    ]\n    [LINES\n        [STARTING BY 'string']\n        [TERMINATED BY 'string']\n    ]\n    [IGNORE number {LINES | ROWS}]\n    [(col_name_or_user_var\n        [, col_name_or_user_var] ...)]\n    [SET col_name={expr | DEFAULT}\n        [, col_name={expr | DEFAULT}] ...]",
        "FIELDS TERMINATED BY '\\t' ENCLOSED BY '' ESCAPED BY '\\\\'\nLINES TERMINATED BY '\\n' STARTING BY ''",
        "FIELDS TERMINATED BY '\"' ENCLOSED BY '\"'",
        "SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-2), 2, 10) AS UNSIGNED)"
    ],
    "Description": [
        "\n      The LOAD DATA statement reads rows\n      from a text file into a table at a very high speed. The file can\n      be read from the server host or the client host, depending on\n      whether the LOCAL modifier is given.\n      LOCAL also affects data interpretation and\n      error handling.\n    ",
        "\nLOAD DATA is the complement of\n      SELECT ... INTO\n      OUTFILE. (See Section\u00a015.2.13.1, \u201cSELECT ... INTO Statement\u201d.) To write\n      data from a table to a file, use\n      SELECT ... INTO\n      OUTFILE. To read the file back into a table, use\n      LOAD DATA. The syntax of the\n      FIELDS and LINES clauses is\n      the same for both statements.\n    ",
        "\n      The mysqlimport utility provides another way to\n      load data files; it operates by sending a\n      LOAD DATA statement to the server.\n      See Section\u00a06.5.5, \u201cmysqlimport \u2014 A Data Import Program\u201d.\n    ",
        "\n      For information about the efficiency of\n      INSERT versus\n      LOAD DATA and speeding up\n      LOAD DATA, see\n      Section\u00a010.2.5.1, \u201cOptimizing INSERT Statements\u201d.\n",
        "\nNon-LOCAL Versus LOCAL OperationInput File Character SetInput File LocationSecurity RequirementsDuplicate-Key and Error HandlingIndex HandlingField and Line HandlingColumn List SpecificationInput PreprocessingColumn Value AssignmentPartitioned Table SupportConcurrency ConsiderationsStatement Result InformationReplication ConsiderationsMiscellaneous Topics\n",
        "\n\n\n\nNon-LOCAL Versus LOCAL Operation\n\n\n\n\n        The LOCAL modifier affects these aspects of\n        LOAD DATA, compared to\n        non-LOCAL operation:\n\n\n\n            It changes the expected location of the input file; see\n            Input File Location.\n          \n            It changes the statement security requirements; see\n            Security Requirements.\n          \n            It has the same effect as the IGNORE\n            modifier on the interpretation of input file contents and\n            error handling; see\n            Duplicate-Key and Error Handling, and\n            Column Value Assignment.\n\n\n\nLOCAL works only if the server and your\n        client both have been configured to permit it. For example, if\n        mysqld was started with the\n        local_infile system variable\n        disabled, LOCAL produces an error. See\n        Section\u00a08.1.6, \u201cSecurity Considerations for LOAD DATA LOCAL\u201d.\n\n",
        "\n\n\n\nInput File Character Set\n\n\n\n\n        The file name must be given as a literal string. On Windows,\n        specify backslashes in path names as forward slashes or doubled\n        backslashes. The server interprets the file name using the\n        character set indicated by the\n        character_set_filesystem system\n        variable.\n      \n        By default, the server interprets the file contents using the\n        character set indicated by the\n        character_set_database system\n        variable. If the file contents use a character set different\n        from this default, it is a good idea to specify that character\n        set by using the CHARACTER SET clause. A\n        character set of binary specifies \u201cno\n        conversion.\u201d\n\nSET NAMES and the setting of\n        character_set_client do not\n        affect interpretation of file contents.\n      \nLOAD DATA interprets all fields\n        in the file as having the same character set, regardless of the\n        data types of the columns into which field values are loaded.\n        For proper interpretation of the file, you must ensure that it\n        was written with the correct character set. For example, if you\n        write a data file with mysqldump -T or by\n        issuing a SELECT\n        ... INTO OUTFILE statement in\n        mysql, be sure to use a\n        --default-character-set option to\n        write output in the character set to be used when the file is\n        loaded with LOAD DATA.\n\n\n\nNote\n\n\n          It is not possible to load data files that use the\n          ucs2, utf16,\n          utf16le, or utf32\n          character set.\n\n\n",
        "\n\n\n\nInput File Location\n\n\n\n\n        These rules determine the LOAD\n        DATA input file location:\n\n\n\n            If LOCAL is not specified, the file must\n            be located on the server host. The server reads the file\n            directly, locating it as follows:\n\n\n\n                If the file name is an absolute path name, the server\n                uses it as given.\n              \n                If the file name is a relative path name with leading\n                components, the server looks for the file relative to\n                its data directory.\n              \n                If the file name has no leading components, the server\n                looks for the file in the database directory of the\n                default database.\n\n\n\n            If LOCAL is specified, the file must be\n            located on the client host. The client program reads the\n            file, locating it as follows:\n\n\n\n                If the file name is an absolute path name, the client\n                program uses it as given.\n              \n                If the file name is a relative path name, the client\n                program looks for the file relative to its invocation\n                directory.\n\n\n\n            When LOCAL is used, the client program\n            reads the file and sends its contents to the server. The\n            server creates a copy of the file in the directory where it\n            stores temporary files. See\n            Section\u00a0B.3.3.5, \u201cWhere MySQL Stores Temporary Files\u201d. Lack of sufficient space\n            for the copy in this directory can cause the\n            LOAD DATA\n            LOCAL statement to fail.\n\n\n\n        The non-LOCAL rules mean that the server\n        reads a file named as ./myfile.txt relative\n        to its data directory, whereas it reads a file named as\n        myfile.txt from the database directory of\n        the default database. For example, if the following\n        LOAD DATA statement is executed\n        while db1 is the default database, the server\n        reads the file data.txt from the database\n        directory for db1, even though the statement\n        explicitly loads the file into a table in the\n        db2 database:\n      Press CTRL+C to copy LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table;\n\n\nNote\n\n\n          The server also uses the non-LOCAL rules to\n          locate .sdi files for the\n          IMPORT TABLE statement.\n\n\n",
        "\n\n\n\nSecurity Requirements\n\n\n\n\n        For a non-LOCAL load operation, the server\n        reads a text file located on the server host, so these security\n        requirements must be satisfied:\n\n\n\n            You must have the FILE\n            privilege. See Section\u00a08.2.2, \u201cPrivileges Provided by MySQL\u201d.\n          \n            The operation is subject to the\n            secure_file_priv system\n            variable setting:\n\n\n\n                If the variable value is a nonempty directory name, the\n                file must be located in that directory.\n              \n                If the variable value is empty (which is insecure), the\n                file need only be readable by the server.\n\n\n\n\n\n        For a LOCAL load operation, the client\n        program reads a text file located on the client host. Because\n        the file contents are sent over the connection by the client to\n        the server, using LOCAL is a bit slower than\n        when the server accesses the file directly. On the other hand,\n        you do not need the FILE\n        privilege, and the file can be located in any directory the\n        client program can access.\n\n",
        "\n\n\n\nDuplicate-Key and Error Handling\n\n\n\n\n        The REPLACE and IGNORE\n        modifiers control handling of new (input) rows that duplicate\n        existing table rows on unique key values (PRIMARY\n        KEY or UNIQUE index values):\n\n\n\n            With REPLACE, new rows that have the same\n            value as a unique key value in an existing row replace the\n            existing row. See Section\u00a015.2.12, \u201cREPLACE Statement\u201d.\n          \n            With IGNORE, new rows that duplicate an\n            existing row on a unique key value are discarded. For more\n            information, see\n            The Effect of IGNORE on Statement Execution.\n\n\n\n        The LOCAL modifier has the same effect as\n        IGNORE. This occurs because the server has no\n        way to stop transmission of the file in the middle of the\n        operation.\n      \n        If none of REPLACE,\n        IGNORE, or LOCAL is\n        specified, an error occurs when a duplicate key value is found,\n        and the rest of the text file is ignored.\n      \n        In addition to affecting duplicate-key handling as just\n        described, IGNORE and\n        LOCAL also affect error handling:\n\n\n\n            With neither IGNORE nor\n            LOCAL, data-interpretation errors\n            terminate the operation.\n          \n            With IGNORE or LOCAL,\n            data-interpretation errors become warnings and the load\n            operation continues, even if the SQL mode is restrictive.\n            For examples, see\n            Column Value Assignment.\n\n\n",
        "\n\n\n\nIndex Handling\n\n\n\n\n        To ignore foreign key constraints during the load operation,\n        execute a SET foreign_key_checks = 0\n        statement before executing LOAD\n        DATA.\n      \n        If you use LOAD DATA on an empty\n        MyISAM table, all nonunique indexes are\n        created in a separate batch (as for REPAIR\n        TABLE). Normally, this makes LOAD\n        DATA much faster when you have many indexes. In some\n        extreme cases, you can create the indexes even faster by turning\n        them off with ALTER\n        TABLE ... DISABLE KEYS before loading the file into\n        the table and re-creating the indexes with\n        ALTER TABLE ...\n        ENABLE KEYS after loading the file. See\n        Section\u00a010.2.5.1, \u201cOptimizing INSERT Statements\u201d.\n\n",
        "\n\n\n\nField and Line Handling\n\n\n\n\n        For both the LOAD DATA and\n        SELECT ... INTO\n        OUTFILE statements, the syntax of the\n        FIELDS and LINES clauses\n        is the same. Both clauses are optional, but\n        FIELDS must precede LINES\n        if both are specified.\n      \n        If you specify a FIELDS clause, each of its\n        subclauses (TERMINATED BY,\n        [OPTIONALLY] ENCLOSED BY, and\n        ESCAPED BY) is also optional, except that you\n        must specify at least one of them. Arguments to these clauses\n        are permitted to contain only ASCII characters.\n      \n        If you specify no FIELDS or\n        LINES clause, the defaults are the same as if\n        you had written this:\n      Press CTRL+C to copy FIELDS TERMINATED BY '\\t' ENCLOSED BY '' ESCAPED BY '\\\\'\nLINES TERMINATED BY '\\n' STARTING BY ''\n        Backslash is the MySQL escape character within strings in SQL\n        statements. Thus, to specify a literal backslash, you must\n        specify two backslashes for the value to be interpreted as a\n        single backslash. The escape sequences '\\t'\n        and '\\n' specify tab and newline characters,\n        respectively.\n      \n        In other words, the defaults cause LOAD\n        DATA to act as follows when reading input:\n\n\n\n            Look for line boundaries at newlines.\n          \n            Do not skip any line prefix.\n          \n            Break lines into fields at tabs.\n          \n            Do not expect fields to be enclosed within any quoting\n            characters.\n          \n            Interpret characters preceded by the escape character\n            \\ as escape sequences. For example,\n            \\t, \\n, and\n            \\\\ signify tab, newline, and backslash,\n            respectively. See the discussion of FIELDS ESCAPED\n            BY later for the full list of escape sequences.\n\n\n\n        Conversely, the defaults cause\n        SELECT ... INTO\n        OUTFILE to act as follows when writing output:\n\n\n\n            Write tabs between fields.\n          \n            Do not enclose fields within any quoting characters.\n          \n            Use \\ to escape instances of tab,\n            newline, or \\ that occur within field\n            values.\n          \n            Write newlines at the ends of lines.\n\n\n\n\nNote\n\n\n          For a text file generated on a Windows system, proper file\n          reading might require LINES TERMINATED BY\n          '\\r\\n' because Windows programs typically use two\n          characters as a line terminator. Some programs, such as\n          WordPad, might use \\r as\n          a line terminator when writing files. To read such files, use\n          LINES TERMINATED BY '\\r'.\n\n\n\n        If all the input lines have a common prefix that you want to\n        ignore, you can use LINES STARTING BY\n        'prefix_string' to skip the\n        prefix and anything before it. If a line\n        does not include the prefix, the entire line is skipped. Suppose\n        that you issue the following statement:\n      Press CTRL+C to copy LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test\n  FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx';\n        If the data file looks like this:\n      Press CTRL+C to copy xxx\"abc\",1\nsomething xxx\"def\",2\n\"ghi\",3\n        The resulting rows are (\"abc\",1) and\n        (\"def\",2). The third row in the file is\n        skipped because it does not contain the prefix.\n      \n        The IGNORE number\n        LINES clause can be used to ignore lines at the start\n        of the file. For example, you can use IGNORE 1\n        LINES to skip an initial header line containing column\n        names:\n      Press CTRL+C to copy LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test IGNORE 1 LINES;\n        When you use SELECT\n        ... INTO OUTFILE in tandem with\n        LOAD DATA to write data from a\n        database into a file and then read the file back into the\n        database later, the field- and line-handling options for both\n        statements must match. Otherwise, LOAD\n        DATA does not interpret the contents of the file\n        properly. Suppose that you use\n        SELECT ... INTO\n        OUTFILE to write a file with fields delimited by\n        commas:\n      Press CTRL+C to copy SELECT * INTO OUTFILE 'data.txt'\n  FIELDS TERMINATED BY ','\n  FROM table2;\n        To read the comma-delimited file, the correct statement is:\n      Press CTRL+C to copy LOAD DATA INFILE 'data.txt' INTO TABLE table2\n  FIELDS TERMINATED BY ',';\n        If instead you tried to read the file with the statement shown\n        following, it would not work because it instructs\n        LOAD DATA to look for tabs\n        between fields:\n      Press CTRL+C to copy LOAD DATA INFILE 'data.txt' INTO TABLE table2\n  FIELDS TERMINATED BY '\\t';\n        The likely result is that each input line would be interpreted\n        as a single field.\n      \nLOAD DATA can be used to read\n        files obtained from external sources. For example, many programs\n        can export data in comma-separated values (CSV) format, such\n        that lines have fields separated by commas and enclosed within\n        double quotation marks, with an initial line of column names. If\n        the lines in such a file are terminated by carriage\n        return/newline pairs, the statement shown here illustrates the\n        field- and line-handling options you would use to load the file:\n      Press CTRL+C to copy LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name\n  FIELDS TERMINATED BY ',' ENCLOSED BY '\"'\n  LINES TERMINATED BY '\\r\\n'\n  IGNORE 1 LINES;\n        If the input values are not necessarily enclosed within\n        quotation marks, use OPTIONALLY before the\n        ENCLOSED BY option.\n      \n        Any of the field- or line-handling options can specify an empty\n        string (''). If not empty, the\n        FIELDS [OPTIONALLY] ENCLOSED BY and\n        FIELDS ESCAPED BY values must be a single\n        character. The FIELDS TERMINATED BY,\n        LINES STARTING BY, and LINES\n        TERMINATED BY values can be more than one character.\n        For example, to write lines that are terminated by carriage\n        return/linefeed pairs, or to read a file containing such lines,\n        specify a LINES TERMINATED BY '\\r\\n' clause.\n      \n        To read a file containing jokes that are separated by lines\n        consisting of %%, you can do this\n      Press CTRL+C to copy CREATE TABLE jokes\n  (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n  joke TEXT NOT NULL);\nLOAD DATA INFILE '/tmp/jokes.txt' INTO TABLE jokes\n  FIELDS TERMINATED BY ''\n  LINES TERMINATED BY '\\n%%\\n' (joke);\nFIELDS [OPTIONALLY] ENCLOSED BY controls\n        quoting of fields. For output\n        (SELECT ... INTO\n        OUTFILE), if you omit the word\n        OPTIONALLY, all fields are enclosed by the\n        ENCLOSED BY character. An example of such\n        output (using a comma as the field delimiter) is shown here:\n      Press CTRL+C to copy \"1\",\"a string\",\"100.20\"\n\"2\",\"a string containing a , comma\",\"102.20\"\n\"3\",\"a string containing a \\\" quote\",\"102.20\"\n\"4\",\"a string containing a \\\", quote and comma\",\"102.20\"\n        If you specify OPTIONALLY, the\n        ENCLOSED BY character is used only to enclose\n        values from columns that have a string data type (such as\n        CHAR,\n        BINARY,\n        TEXT, or\n        ENUM):\n      Press CTRL+C to copy 1,\"a string\",100.20\n2,\"a string containing a , comma\",102.20\n3,\"a string containing a \\\" quote\",102.20\n4,\"a string containing a \\\", quote and comma\",102.20\n        Occurrences of the ENCLOSED BY character\n        within a field value are escaped by prefixing them with the\n        ESCAPED BY character. Also, if you specify an\n        empty ESCAPED BY value, it is possible to\n        inadvertently generate output that cannot be read properly by\n        LOAD DATA. For example, the\n        preceding output just shown would appear as follows if the\n        escape character is empty. Observe that the second field in the\n        fourth line contains a comma following the quote, which\n        (erroneously) appears to terminate the field:\n      Press CTRL+C to copy 1,\"a string\",100.20\n2,\"a string containing a , comma\",102.20\n3,\"a string containing a \" quote\",102.20\n4,\"a string containing a \", quote and comma\",102.20\n        For input, the ENCLOSED BY character, if\n        present, is stripped from the ends of field values. (This is\n        true regardless of whether OPTIONALLY is\n        specified; OPTIONALLY has no effect on input\n        interpretation.) Occurrences of the ENCLOSED\n        BY character preceded by the ESCAPED\n        BY character are interpreted as part of the current\n        field value.\n      \n        If the field begins with the ENCLOSED BY\n        character, instances of that character are recognized as\n        terminating a field value only if followed by the field or line\n        TERMINATED BY sequence. To avoid ambiguity,\n        occurrences of the ENCLOSED BY character\n        within a field value can be doubled and are interpreted as a\n        single instance of the character. For example, if\n        ENCLOSED BY '\"' is specified, quotation marks\n        are handled as shown here:\n      Press CTRL+C to copy \"The \"\"BIG\"\" boss\"  -> The \"BIG\" boss\nThe \"BIG\" boss      -> The \"BIG\" boss\nThe \"\"BIG\"\" boss    -> The \"\"BIG\"\" boss\nFIELDS ESCAPED BY controls how to read or\n        write special characters:\n\n\n\n            For input, if the FIELDS ESCAPED BY\n            character is not empty, occurrences of that character are\n            stripped and the following character is taken literally as\n            part of a field value. Some two-character sequences that are\n            exceptions, where the first character is the escape\n            character. These sequences are shown in the following table\n            (using \\ for the escape character). The\n            rules for NULL handling are described\n            later in this section.\n\n\n\nCharacter\nEscape Sequence\n\n\\0\nAn ASCII NUL (X'00') character\n\n\\b\nA backspace character\n\n\\n\nA newline (linefeed) character\n\n\\r\nA carriage return character\n\n\\t\nA tab character.\n\n\\Z\nASCII 26 (Control+Z)\n\n\\N\nNULL\n\n\n\n            For more information about \\-escape\n            syntax, see Section\u00a011.1.1, \u201cString Literals\u201d.\n          \n            If the FIELDS ESCAPED BY character is\n            empty, escape-sequence interpretation does not occur.\n          \n            For output, if the FIELDS ESCAPED BY\n            character is not empty, it is used to prefix the following\n            characters on output:\n\n\n\n                The FIELDS ESCAPED BY character.\n              \n                The FIELDS [OPTIONALLY] ENCLOSED BY\n                character.\n              \n                The first character of the FIELDS TERMINATED\n                BY and LINES TERMINATED BY\n                values, if the ENCLOSED BY character\n                is empty or unspecified.\n              \n                ASCII 0 (what is actually written\n                following the escape character is ASCII\n                0, not a zero-valued byte).\n\n\n\n            If the FIELDS ESCAPED BY character is\n            empty, no characters are escaped and NULL\n            is output as NULL, not\n            \\N. It is probably not a good idea to\n            specify an empty escape character, particularly if field\n            values in your data contain any of the characters in the\n            list just given.\n\n\n\n        In certain cases, field- and line-handling options interact:\n\n\n\n            If LINES TERMINATED BY is an empty string\n            and FIELDS TERMINATED BY is nonempty,\n            lines are also terminated with FIELDS TERMINATED\n            BY.\n          \n            If the FIELDS TERMINATED BY and\n            FIELDS ENCLOSED BY values are both empty\n            (''), a fixed-row (nondelimited) format\n            is used. With fixed-row format, no delimiters are used\n            between fields (but you can still have a line terminator).\n            Instead, column values are read and written using a field\n            width wide enough to hold all values in the field. For\n            TINYINT,\n            SMALLINT,\n            MEDIUMINT,\n            INT, and\n            BIGINT, the field widths are\n            4, 6, 8, 11, and 20, respectively, no matter what the\n            declared display width is.\n          \nLINES TERMINATED BY is still used to\n            separate lines. If a line does not contain all fields, the\n            rest of the columns are set to their default values. If you\n            do not have a line terminator, you should set this to\n            ''. In this case, the text file must\n            contain all fields for each row.\n          \n            Fixed-row format also affects handling of\n            NULL values, as described later.\n\n\n\nNote\n\n\n              Fixed-size format does not work if you are using a\n              multibyte character set.\n\n\n\n\n\n        Handling of NULL values varies according to\n        the FIELDS and LINES\n        options in use:\n\n\n\n            For the default FIELDS and\n            LINES values, NULL is\n            written as a field value of \\N for\n            output, and a field value of \\N is read\n            as NULL for input (assuming that the\n            ESCAPED BY character is\n            \\).\n          \n            If FIELDS ENCLOSED BY is not empty, a\n            field containing the literal word NULL as\n            its value is read as a NULL value. This\n            differs from the word NULL enclosed\n            within FIELDS ENCLOSED BY characters,\n            which is read as the string 'NULL'.\n          \n            If FIELDS ESCAPED BY is empty,\n            NULL is written as the word\n            NULL.\n          \n            With fixed-row format (which is used when FIELDS\n            TERMINATED BY and FIELDS ENCLOSED\n            BY are both empty), NULL is\n            written as an empty string. This causes both\n            NULL values and empty strings in the\n            table to be indistinguishable when written to the file\n            because both are written as empty strings. If you need to be\n            able to tell the two apart when reading the file back in,\n            you should not use fixed-row format.\n\n\n\n        An attempt to load NULL into a NOT\n        NULL column produces either a warning or an error\n        according to the rules described in\n        Column Value Assignment.\n      \n        Some cases are not supported by LOAD\n        DATA:\n\n\n\n            Fixed-size rows (FIELDS TERMINATED BY and\n            FIELDS ENCLOSED BY both empty) and\n            BLOB or\n            TEXT columns.\n          \n            If you specify one separator that is the same as or a prefix\n            of another, LOAD DATA cannot\n            interpret the input properly. For example, the following\n            FIELDS clause would cause problems:\n          Press CTRL+C to copy FIELDS TERMINATED BY '\"' ENCLOSED BY '\"'\n            If FIELDS ESCAPED BY is empty, a field\n            value that contains an occurrence of FIELDS\n            ENCLOSED BY or LINES TERMINATED\n            BY followed by the FIELDS TERMINATED\n            BY value causes LOAD\n            DATA to stop reading a field or line too early.\n            This happens because LOAD\n            DATA cannot properly determine where the field or\n            line value ends.\n\n\n",
        "\n\n\n\nColumn List Specification\n\n\n\n\n        The following example loads all columns of the\n        persondata table:\n      Press CTRL+C to copy LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;\n        By default, when no column list is provided at the end of the\n        LOAD DATA statement, input lines\n        are expected to contain a field for each table column. If you\n        want to load only some of a table's columns, specify a column\n        list:\n      Press CTRL+C to copy LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata\n(col_name_or_user_var [, col_name_or_user_var] ...);\n        You must also specify a column list if the order of the fields\n        in the input file differs from the order of the columns in the\n        table. Otherwise, MySQL cannot tell how to match input fields\n        with table columns.\n\n",
        "\n\n\n\nInput Preprocessing\n\n\n\n\n        Each instance of col_name_or_user_var\n        in LOAD DATA syntax is either a\n        column name or a user variable. With user variables, the\n        SET clause enables you to perform\n        preprocessing transformations on their values before assigning\n        the result to columns.\n      \n        User variables in the SET clause can be used\n        in several ways. The following example uses the first input\n        column directly for the value of t1.column1,\n        and assigns the second input column to a user variable that is\n        subjected to a division operation before being used for the\n        value of t1.column2:\n      Press CTRL+C to copy LOAD DATA INFILE 'file.txt'\n  INTO TABLE t1\n  (column1, @var1)\n  SET column2 = @var1/100;\n        The SET clause can be used to supply values\n        not derived from the input file. The following statement sets\n        column3 to the current date and time:\n      Press CTRL+C to copy LOAD DATA INFILE 'file.txt'\n  INTO TABLE t1\n  (column1, column2)\n  SET column3 = CURRENT_TIMESTAMP;\n        You can also discard an input value by assigning it to a user\n        variable and not assigning the variable to any table column:\n      Press CTRL+C to copy LOAD DATA INFILE 'file.txt'\n  INTO TABLE t1\n  (column1, @dummy, column2, @dummy, column3);\n        Use of the column/variable list and SET\n        clause is subject to the following restrictions:\n\n\n\n            Assignments in the SET clause should have\n            only column names on the left hand side of assignment\n            operators.\n          \n            You can use subqueries in the right hand side of\n            SET assignments. A subquery that returns\n            a value to be assigned to a column may be a scalar subquery\n            only. Also, you cannot use a subquery to select from the\n            table that is being loaded.\n          \n            Lines ignored by an IGNORE\n            number LINES clause are\n            not processed for the column/variable list or\n            SET clause.\n          \n            User variables cannot be used when loading data with\n            fixed-row format because user variables do not have a\n            display width.\n\n\n",
        "\n\n\n\nColumn Value Assignment\n\n\n\n\n        To process an input line, LOAD\n        DATA splits it into fields and uses the values\n        according to the column/variable list and the\n        SET clause, if they are present. Then the\n        resulting row is inserted into the table. If there are\n        BEFORE INSERT or AFTER\n        INSERT triggers for the table, they are activated\n        before or after inserting the row, respectively.\n      \n        Interpretation of field values and assignment to table columns\n        depends on these factors:\n\n\n\n            The SQL mode (the value of the\n            sql_mode system variable).\n            The mode can be nonrestrictive, or restrictive in various\n            ways. For example, strict SQL mode can be enabled, or the\n            mode can include values such as\n            NO_ZERO_DATE or\n            NO_ZERO_IN_DATE.\n          \n            Presence or absence of the IGNORE and\n            LOCAL modifiers.\n\n\n\n        Those factors combine to produce restrictive or nonrestrictive\n        data interpretation by LOAD DATA:\n\n\n\n            Data interpretation is restrictive if the SQL mode is\n            restrictive and neither the IGNORE nor\n            the LOCAL modifier is specified. Errors\n            terminate the load operation.\n          \n            Data interpretation is nonrestrictive if the SQL mode is\n            nonrestrictive or the IGNORE or\n            LOCAL modifier is specified. (In\n            particular, either modifier if specified\n            overrides a restrictive SQL mode when\n            the REPLACE modifier is omitted.) Errors\n            become warnings and the load operation continues.\n\n\n\n        Restrictive data interpretation uses these rules:\n\n\n\n            Too many or too few fields results an error.\n          \n            Assigning NULL (that is,\n            \\N) to a non-NULL\n            column results in an error.\n          \n            A value that is out of range for the column data type\n            results in an error.\n          \n            Invalid values produce errors. For example, a value such as\n            'x' for a numeric column results in an\n            error, not conversion to 0.\n\n\n\n        By contrast, nonrestrictive data interpretation uses these\n        rules:\n\n\n\n            If an input line has too many fields, the extra fields are\n            ignored and the number of warnings is incremented.\n          \n            If an input line has too few fields, the columns for which\n            input fields are missing are assigned their default values.\n            Default value assignment is described in\n            Section\u00a013.6, \u201cData Type Default Values\u201d.\n          \n            Assigning NULL (that is,\n            \\N) to a non-NULL\n            column results in assignment of the implicit default value\n            for the column data type. Implicit default values are\n            described in Section\u00a013.6, \u201cData Type Default Values\u201d.\n          \n            Invalid values produce warnings rather than errors, and are\n            converted to the \u201cclosest\u201d valid value for the\n            column data type. Examples:\n\n\n\n                A value such as 'x' for a numeric\n                column results in conversion to 0.\n              \n                An out-of-range numeric or temporal value is clipped to\n                the closest endpoint of the range for the column data\n                type.\n              \n                An invalid value for a DATETIME,\n                DATE, or TIME\n                column is inserted as the implicit default value,\n                regardless of the SQL mode\n                NO_ZERO_DATE setting.\n                The implicit default is the appropriate\n                \u201czero\u201d value for the type\n                ('0000-00-00 00:00:00',\n                '0000-00-00', or\n                '00:00:00'). See\n                Section\u00a013.2, \u201cDate and Time Data Types\u201d.\n\n\n\nLOAD DATA interprets an empty\n            field value differently from a missing field:\n\n\n\n                For string types, the column is set to the empty string.\n              \n                For numeric types, the column is set to\n                0.\n              \n                For date and time types, the column is set to the\n                appropriate \u201czero\u201d value for the type. See\n                Section\u00a013.2, \u201cDate and Time Data Types\u201d.\n\n\n\n            These are the same values that result if you assign an empty\n            string explicitly to a string, numeric, or date or time type\n            explicitly in an INSERT or\n            UPDATE statement.\n\n\n\nTIMESTAMP columns are set to the\n        current date and time only if there is a NULL\n        value for the column (that is, \\N) and the\n        column is not declared to permit NULL values,\n        or if the TIMESTAMP column\n        default value is the current timestamp and it is omitted from\n        the field list when a field list is specified.\n      \nLOAD DATA regards all input as\n        strings, so you cannot use numeric values for\n        ENUM or\n        SET columns the way you can with\n        INSERT statements. All\n        ENUM and\n        SET values must be specified as\n        strings.\n      \nBIT values cannot be loaded\n        directly using binary notation (for example,\n        b'011010'). To work around this, use the\n        SET clause to strip off the leading\n        b' and trailing ' and\n        perform a base-2 to base-10 conversion so that MySQL loads the\n        values into the BIT column\n        properly:\n      Press CTRL+C to copy $> cat /tmp/bit_test.txt\nb'10'\nb'1111111'\n$> mysql test\nmysql> LOAD DATA INFILE '/tmp/bit_test.txt'\n       INTO TABLE bit_test (@var1)\n       SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-3), 2, 10) AS UNSIGNED);\nQuery OK, 2 rows affected (0.00 sec)\nRecords: 2  Deleted: 0  Skipped: 0  Warnings: 0\n\nmysql> SELECT BIN(b+0) FROM bit_test;\n+----------+\n| BIN(b+0) |\n+----------+\n| 10       |\n| 1111111  |\n+----------+\n2 rows in set (0.00 sec)\n        For BIT values in\n        0b binary notation (for example,\n        0b011010), use this SET\n        clause instead to strip off the leading 0b:\n      Press CTRL+C to copy SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-2), 2, 10) AS UNSIGNED)\n",
        "\n\n\n\nPartitioned Table Support\n\n\n\n\nLOAD DATA supports explicit\n        partition selection using the PARTITION\n        clause with a list of one or more comma-separated names of\n        partitions, subpartitions, or both. When this clause is used, if\n        any rows from the file cannot be inserted into any of the\n        partitions or subpartitions named in the list, the statement\n        fails with the error Found a row not matching the\n        given partition set. For more information and\n        examples, see Section\u00a026.5, \u201cPartition Selection\u201d.\n\n",
        "\n\n\n\nConcurrency Considerations\n\n\n\n\n        With the LOW_PRIORITY modifier, execution of\n        the LOAD DATA statement is\n        delayed until no other clients are reading from the table. This\n        affects only storage engines that use only table-level locking\n        (such as MyISAM, MEMORY,\n        and MERGE).\n      \n        With the CONCURRENT modifier and a\n        MyISAM table that satisfies the condition for\n        concurrent inserts (that is, it contains no free blocks in the\n        middle), other threads can retrieve data from the table while\n        LOAD DATA is executing. This\n        modifier affects the performance of LOAD\n        DATA a bit, even if no other thread is using the table\n        at the same time.\n\n",
        "\n\n\n\nStatement Result Information\n\n\n\n\n        When the LOAD DATA statement\n        finishes, it returns an information string in the following\n        format:\n      Press CTRL+C to copy Records: 1  Deleted: 0  Skipped: 0  Warnings: 0\n        Warnings occur under the same circumstances as when values are\n        inserted using the INSERT\n        statement (see Section\u00a015.2.7, \u201cINSERT Statement\u201d), except that\n        LOAD DATA also generates warnings\n        when there are too few or too many fields in the input row.\n      \n        You can use SHOW WARNINGS to get\n        a list of the first\n        max_error_count warnings as\n        information about what went wrong. See\n        Section\u00a015.7.7.41, \u201cSHOW WARNINGS Statement\u201d.\n      \n        If you are using the C API, you can get information about the\n        statement by calling the\n        mysql_info() function. See\n        mysql_info().\n\n",
        "\n\n\n\nReplication Considerations\n\n\n\n\nLOAD DATA is considered unsafe\n        for statement-based replication. If you use\n        LOAD DATA with\n        binlog_format=STATEMENT, each\n        replica on which the changes are to be applied creates a\n        temporary file containing the data. This temporary file is not\n        encrypted, even if binary log encryption is active on the\n        source, If encryption is required, use row-based or mixed binary\n        logging format instead, for which replicas do not create the\n        temporary file. For more information on the interaction between\n        LOAD DATA and replication, see\n        Section\u00a019.5.1.19, \u201cReplication and LOAD DATA\u201d.\n\n",
        "\n\n\n\nMiscellaneous Topics\n\n\n\n\n        On Unix, if you need LOAD DATA to\n        read from a pipe, you can use the following technique (the\n        example loads a listing of the / directory\n        into the table db1.t1):\n      Press CTRL+C to copy mkfifo /mysql/data/db1/ls.dat\nchmod 666 /mysql/data/db1/ls.dat\nfind / -ls > /mysql/data/db1/ls.dat &\nmysql -e \"LOAD DATA INFILE 'ls.dat' INTO TABLE t1\" db1\n        Here you must run the command that generates the data to be\n        loaded and the mysql commands either on\n        separate terminals, or run the data generation process in the\n        background (as shown in the preceding example). If you do not do\n        this, the pipe blocks until data is read by the\n        mysql process.\n\n"
    ],
    "Examples": [
        "LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table;",
        "LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test\n  FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx';",
        "LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test IGNORE 1 LINES;",
        "SELECT * INTO OUTFILE 'data.txt'\n  FIELDS TERMINATED BY ','\n  FROM table2;",
        "LOAD DATA INFILE 'data.txt' INTO TABLE table2\n  FIELDS TERMINATED BY ',';",
        "LOAD DATA INFILE 'data.txt' INTO TABLE table2\n  FIELDS TERMINATED BY '\\t';",
        "LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name\n  FIELDS TERMINATED BY ',' ENCLOSED BY '\"'\n  LINES TERMINATED BY '\\r\\n'\n  IGNORE 1 LINES;",
        "CREATE TABLE jokes\n  (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n  joke TEXT NOT NULL);\nLOAD DATA INFILE '/tmp/jokes.txt' INTO TABLE jokes\n  FIELDS TERMINATED BY ''\n  LINES TERMINATED BY '\\n%%\\n' (joke);",
        "LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;",
        "LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata\n(col_name_or_user_var [, col_name_or_user_var] ...);",
        "LOAD DATA INFILE 'file.txt'\n  INTO TABLE t1\n  (column1, @var1)\n  SET column2 = @var1/100;",
        "LOAD DATA INFILE 'file.txt'\n  INTO TABLE t1\n  (column1, column2)\n  SET column3 = CURRENT_TIMESTAMP;",
        "LOAD DATA INFILE 'file.txt'\n  INTO TABLE t1\n  (column1, @dummy, column2, @dummy, column3);"
    ],
    "Category": [
        "Data Manipulation Statements"
    ]
}