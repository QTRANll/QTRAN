{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/join.html"
    ],
    "Title": [
        "15.2.13.2 JOIN Clause"
    ],
    "Feature": [
        "table_references:\n    escaped_table_reference [, escaped_table_reference] ...\n\nescaped_table_reference: {\n    table_reference\n  | { OJ table_reference }\n}\n\ntable_reference: {\n    table_factor\n  | joined_table\n}\n\ntable_factor: {\n    tbl_name [PARTITION (partition_names)]\n        [[AS] alias] [index_hint_list]\n  | [LATERAL] table_subquery [AS] alias [(col_list)]\n  | ( table_references )\n}\n\njoined_table: {\n    table_reference {[INNER | CROSS] JOIN | STRAIGHT_JOIN} table_factor [join_specification]\n  | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_specification\n  | table_reference NATURAL [INNER | {LEFT|RIGHT} [OUTER]] JOIN table_factor\n}\n\njoin_specification: {\n    ON search_condition\n  | USING (join_column_list)\n}\n\njoin_column_list:\n    column_name [, column_name] ...\n\nindex_hint_list:\n    index_hint [, index_hint] ...\n\nindex_hint: {\n    USE {INDEX|KEY}\n      [FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])\n  | {IGNORE|FORCE} {INDEX|KEY}\n      [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)\n}\n\nindex_list:\n    index_name [, index_name] ...",
        "SELECT * FROM t1 LEFT JOIN (t2, t3, t4)\n                 ON (t2.a = t1.a AND t3.b = t1.b AND t4.c = t1.c)",
        "SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)\n                 ON (t2.a = t1.a AND t3.b = t1.b AND t4.c = t1.c)",
        "a LEFT JOIN b USING (c1, c2, c3)",
        "COALESCE(x, y) = (CASE WHEN x IS NOT NULL THEN x ELSE y END)",
        "a LEFT JOIN b USING (c1, c2, c3)\na LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3",
        "COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3)"
    ],
    "Description": [
        "\n        MySQL supports the following JOIN syntax for\n        the table_references part of\n        SELECT statements and\n        multiple-table DELETE and\n        UPDATE statements:\n      ",
        "\n        A table reference is also known as a join expression.\n      ",
        "\n        A table reference (when it refers to a partitioned table) may\n        contain a PARTITION clause, including a list\n        of comma-separated partitions, subpartitions, or both. This\n        option follows the name of the table and precedes any alias\n        declaration. The effect of this option is that rows are selected\n        only from the listed partitions or subpartitions. Any partitions\n        or subpartitions not named in the list are ignored. For more\n        information and examples, see\n        Section\u00a026.5, \u201cPartition Selection\u201d.\n      ",
        "\n        The syntax of table_factor is\n        extended in MySQL in comparison with standard SQL. The standard\n        accepts only table_reference, not a\n        list of them inside a pair of parentheses.\n      ",
        "\n        This is a conservative extension if each comma in a list of\n        table_reference items is considered\n        as equivalent to an inner join. For example:\n      ",
        "\n        is equivalent to:\n      ",
        "\n        In MySQL, JOIN, CROSS\n        JOIN, and INNER JOIN are syntactic\n        equivalents (they can replace each other). In standard SQL, they\n        are not equivalent. INNER JOIN is used with\n        an ON clause, CROSS JOIN\n        is used otherwise.\n      ",
        "\n        In general, parentheses can be ignored in join expressions\n        containing only inner join operations. MySQL also supports\n        nested joins. See Section\u00a010.2.1.8, \u201cNested Join Optimization\u201d.\n      ",
        "\n        Index hints can be specified to affect how the MySQL optimizer\n        makes use of indexes. For more information, see\n        Section\u00a010.9.4, \u201cIndex Hints\u201d. Optimizer hints and the\n        optimizer_switch system variable are other\n        ways to influence optimizer use of indexes. See\n        Section\u00a010.9.3, \u201cOptimizer Hints\u201d, and\n        Section\u00a010.9.2, \u201cSwitchable Optimizations\u201d.\n      ",
        "\n        The following list describes general factors to take into\n        account when writing joins:\n",
        "\n\n            A table reference can be aliased using\n            tbl_name AS\n            alias_name or\n            tbl_name alias_name:\n          Press CTRL+C to copy SELECT t1.name, t2.salary\n  FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name;\n\nSELECT t1.name, t2.salary\n  FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name;\n            A table_subquery is also known as\n            a derived table or subquery in the FROM\n            clause. See Section\u00a015.2.15.8, \u201cDerived Tables\u201d. Such\n            subqueries must include an alias to\n            give the subquery result a table name, and may optionally\n            include a list of table column names in parentheses. A\n            trivial example follows:\n          Press CTRL+C to copy SELECT * FROM (SELECT 1, 2, 3) AS t1;\n            The maximum number of tables that can be referenced in a\n            single join is 61. This includes a join handled by merging\n            derived tables and views in the FROM\n            clause into the outer query block (see\n            Section\u00a010.2.2.4, \u201cOptimizing Derived Tables, View References, and Common Table Expressions\n          with Merging or Materialization\u201d).\n          \nINNER JOIN and ,\n            (comma) are semantically equivalent in the absence of a join\n            condition: both produce a Cartesian product between the\n            specified tables (that is, each and every row in the first\n            table is joined to each and every row in the second table).\n          \n            However, the precedence of the comma operator is less than\n            that of INNER JOIN, CROSS\n            JOIN, LEFT JOIN, and so on. If\n            you mix comma joins with the other join types when there is\n            a join condition, an error of the form Unknown\n            column 'col_name' in 'on\n            clause' may occur. Information about dealing with\n            this problem is given later in this section.\n          \n            The search_condition used with\n            ON is any conditional expression of the\n            form that can be used in a WHERE clause.\n            Generally, the ON clause serves for\n            conditions that specify how to join tables, and the\n            WHERE clause restricts which rows to\n            include in the result set.\n          \n            If there is no matching row for the right table in the\n            ON or USING part in a\n            LEFT JOIN, a row with all columns set to\n            NULL is used for the right table. You can\n            use this fact to find rows in a table that have no\n            counterpart in another table:\n          Press CTRL+C to copy SELECT left_tbl.*\n  FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id\n  WHERE right_tbl.id IS NULL;\n            This example finds all rows in left_tbl\n            with an id value that is not present in\n            right_tbl (that is, all rows in\n            left_tbl with no corresponding row in\n            right_tbl). See\n            Section\u00a010.2.1.9, \u201cOuter Join Optimization\u201d.\n          \n            The\n            USING(join_column_list)\n            clause names a list of columns that must exist in both\n            tables. If tables a and\n            b both contain columns\n            c1, c2, and\n            c3, the following join compares\n            corresponding columns from the two tables:\n          Press CTRL+C to copy a LEFT JOIN b USING (c1, c2, c3)\n            The NATURAL [LEFT] JOIN of two tables is\n            defined to be semantically equivalent to an INNER\n            JOIN or a LEFT JOIN with a\n            USING clause that names all columns that\n            exist in both tables.\n          \nRIGHT JOIN works analogously to\n            LEFT JOIN. To keep code portable across\n            databases, it is recommended that you use LEFT\n            JOIN instead of RIGHT JOIN.\n          \n\n\n\n            The { OJ ... } syntax shown in the join\n            syntax description exists only for compatibility with ODBC.\n            The curly braces in the syntax should be written literally;\n            they are not metasyntax as used elsewhere in syntax\n            descriptions.\n          Press CTRL+C to copy SELECT left_tbl.*\n    FROM { OJ left_tbl LEFT OUTER JOIN right_tbl\n           ON left_tbl.id = right_tbl.id }\n    WHERE right_tbl.id IS NULL;\n            You can use other types of joins within { OJ ...\n            }, such as INNER JOIN or\n            RIGHT OUTER JOIN. This helps with\n            compatibility with some third-party applications, but is not\n            official ODBC syntax.\n          \nSTRAIGHT_JOIN is similar to\n            JOIN, except that the left table is\n            always read before the right table. This can be used for\n            those (few) cases for which the join optimizer processes the\n            tables in a suboptimal order.\n\n",
        "\n        Some join examples:\n      ",
        "Press CTRL+C to copy SELECT * FROM table1, table2;\n\nSELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;\n\nSELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;\n\nSELECT * FROM table1 LEFT JOIN table2 USING (id);\n\nSELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id\n  LEFT JOIN table3 ON table2.id = table3.id;",
        "\n        Natural joins and joins with USING, including\n        outer join variants, are processed according to the SQL:2003\n        standard:\n",
        "\n\n            Redundant columns of a NATURAL join do\n            not appear. Consider this set of statements:\n          Press CTRL+C to copy CREATE TABLE t1 (i INT, j INT);\nCREATE TABLE t2 (k INT, j INT);\nINSERT INTO t1 VALUES(1, 1);\nINSERT INTO t2 VALUES(1, 1);\nSELECT * FROM t1 NATURAL JOIN t2;\nSELECT * FROM t1 JOIN t2 USING (j);\n            In the first SELECT\n            statement, column j appears in both\n            tables and thus becomes a join column, so, according to\n            standard SQL, it should appear only once in the output, not\n            twice. Similarly, in the second SELECT statement, column\n            j is named in the\n            USING clause and should appear only once\n            in the output, not twice.\n          \n            Thus, the statements produce this output:\n          Press CTRL+C to copy +------+------+------+\n| j    | i    | k    |\n+------+------+------+\n|    1 |    1 |    1 |\n+------+------+------+\n+------+------+------+\n| j    | i    | k    |\n+------+------+------+\n|    1 |    1 |    1 |\n+------+------+------+\n            Redundant column elimination and column ordering occurs\n            according to standard SQL, producing this display order:\n\n\n\n                First, coalesced common columns of the two joined\n                tables, in the order in which they occur in the first\n                table\n              \n                Second, columns unique to the first table, in order in\n                which they occur in that table\n              \n                Third, columns unique to the second table, in order in\n                which they occur in that table\n\n\n\n            The single result column that replaces two common columns is\n            defined using the coalesce operation. That is, for two\n            t1.a and t2.a the\n            resulting single join column a is defined\n            as a = COALESCE(t1.a, t2.a), where:\n          Press CTRL+C to copy COALESCE(x, y) = (CASE WHEN x IS NOT NULL THEN x ELSE y END)\n            If the join operation is any other join, the result columns\n            of the join consist of the concatenation of all columns of\n            the joined tables.\n          \n            A consequence of the definition of coalesced columns is\n            that, for outer joins, the coalesced column contains the\n            value of the non-NULL column if one of\n            the two columns is always NULL. If\n            neither or both columns are NULL, both\n            common columns have the same value, so it doesn't matter\n            which one is chosen as the value of the coalesced column. A\n            simple way to interpret this is to consider that a coalesced\n            column of an outer join is represented by the common column\n            of the inner table of a JOIN. Suppose\n            that the tables t1(a, b) and\n            t2(a, c) have the following contents:\n          Press CTRL+C to copy t1    t2\n----  ----\n1 x   2 z\n2 y   3 w\n            Then, for this join, column a contains\n            the values of t1.a:\n          Press CTRL+C to copy mysql> SELECT * FROM t1 NATURAL LEFT JOIN t2;\n+------+------+------+\n| a    | b    | c    |\n+------+------+------+\n|    1 | x    | NULL |\n|    2 | y    | z    |\n+------+------+------+\n            By contrast, for this join, column a\n            contains the values of t2.a.\n          Press CTRL+C to copy mysql> SELECT * FROM t1 NATURAL RIGHT JOIN t2;\n+------+------+------+\n| a    | c    | b    |\n+------+------+------+\n|    2 | z    | y    |\n|    3 | w    | NULL |\n+------+------+------+\n            Compare those results to the otherwise equivalent queries\n            with JOIN ... ON:\n          Press CTRL+C to copy mysql> SELECT * FROM t1 LEFT JOIN t2 ON (t1.a = t2.a);\n+------+------+------+------+\n| a    | b    | a    | c    |\n+------+------+------+------+\n|    1 | x    | NULL | NULL |\n|    2 | y    |    2 | z    |\n+------+------+------+------+Press CTRL+C to copy mysql> SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a = t2.a);\n+------+------+------+------+\n| a    | b    | a    | c    |\n+------+------+------+------+\n|    2 | y    |    2 | z    |\n| NULL | NULL |    3 | w    |\n+------+------+------+------+\n            A USING clause can be rewritten as an\n            ON clause that compares corresponding\n            columns. However, although USING and\n            ON are similar, they are not quite the\n            same. Consider the following two queries:\n          Press CTRL+C to copy a LEFT JOIN b USING (c1, c2, c3)\na LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3\n            With respect to determining which rows satisfy the join\n            condition, both joins are semantically identical.\n          \n            With respect to determining which columns to display for\n            SELECT * expansion, the two joins are not\n            semantically identical. The USING join\n            selects the coalesced value of corresponding columns,\n            whereas the ON join selects all columns\n            from all tables. For the USING join,\n            SELECT * selects these values:\n          Press CTRL+C to copy COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3)\n            For the ON join, SELECT\n            * selects these values:\n          Press CTRL+C to copy a.c1, a.c2, a.c3, b.c1, b.c2, b.c3\n            With an inner join, COALESCE(a.c1,\n            b.c1) is the same as either\n            a.c1 or b.c1 because\n            both columns have the same value. With an outer join (such\n            as LEFT JOIN), one of the two columns can\n            be NULL. That column is omitted from the\n            result.\n          \n            An ON clause can refer only to its\n            operands.\n          \n            Example:\n          Press CTRL+C to copy CREATE TABLE t1 (i1 INT);\nCREATE TABLE t2 (i2 INT);\nCREATE TABLE t3 (i3 INT);\nSELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;\n            The statement fails with an Unknown column 'i3' in\n            'on clause' error because i3 is\n            a column in t3, which is not an operand\n            of the ON clause. To enable the join to\n            be processed, rewrite the statement as follows:\n          Press CTRL+C to copy SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);\nJOIN has higher precedence than the comma\n            operator (,), so the join expression\n            t1, t2 JOIN t3 is interpreted as\n            (t1, (t2 JOIN t3)), not as ((t1,\n            t2) JOIN t3). This affects statements that use an\n            ON clause because that clause can refer\n            only to columns in the operands of the join, and the\n            precedence affects interpretation of what those operands\n            are.\n          \n            Example:\n          Press CTRL+C to copy CREATE TABLE t1 (i1 INT, j1 INT);\nCREATE TABLE t2 (i2 INT, j2 INT);\nCREATE TABLE t3 (i3 INT, j3 INT);\nINSERT INTO t1 VALUES(1, 1);\nINSERT INTO t2 VALUES(1, 1);\nINSERT INTO t3 VALUES(1, 1);\nSELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);\n            The JOIN takes precedence over the comma\n            operator, so the operands for the ON\n            clause are t2 and t3.\n            Because t1.i1 is not a column in either\n            of the operands, the result is an Unknown column\n            't1.i1' in 'on clause' error.\n          \n            To enable the join to be processed, use either of these\n            strategies:\n\n\n\n                Group the first two tables explicitly with parentheses\n                so that the operands for the ON\n                clause are (t1, t2) and\n                t3:\n              Press CTRL+C to copy SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);\n                Avoid the use of the comma operator and use\n                JOIN instead:\n              Press CTRL+C to copy SELECT * FROM t1 JOIN t2 JOIN t3 ON (t1.i1 = t3.i3);\n\n\n            The same precedence interpretation also applies to\n            statements that mix the comma operator with INNER\n            JOIN, CROSS JOIN, LEFT\n            JOIN, and RIGHT JOIN, all of\n            which have higher precedence than the comma operator.\n          \n            A MySQL extension compared to the SQL:2003 standard is that\n            MySQL permits you to qualify the common (coalesced) columns\n            of NATURAL or USING\n            joins, whereas the standard disallows that.\n\n"
    ],
    "Examples": [
        "SELECT t1.name, t2.salary\n  FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name;\n\nSELECT t1.name, t2.salary\n  FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name;",
        "SELECT * FROM (SELECT 1, 2, 3) AS t1;",
        "SELECT left_tbl.*\n  FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id\n  WHERE right_tbl.id IS NULL;",
        "SELECT left_tbl.*\n    FROM { OJ left_tbl LEFT OUTER JOIN right_tbl\n           ON left_tbl.id = right_tbl.id }\n    WHERE right_tbl.id IS NULL;",
        "SELECT * FROM table1, table2;\n\nSELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;\n\nSELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;\n\nSELECT * FROM table1 LEFT JOIN table2 USING (id);\n\nSELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id\n  LEFT JOIN table3 ON table2.id = table3.id;",
        "CREATE TABLE t1 (i INT, j INT);\nCREATE TABLE t2 (k INT, j INT);\nINSERT INTO t1 VALUES(1, 1);\nINSERT INTO t2 VALUES(1, 1);\nSELECT * FROM t1 NATURAL JOIN t2;\nSELECT * FROM t1 JOIN t2 USING (j);",
        "mysql> SELECT * FROM t1 NATURAL LEFT JOIN t2;\n+------+------+------+\n| a    | b    | c    |\n+------+------+------+\n|    1 | x    | NULL |\n|    2 | y    | z    |\n+------+------+------+",
        "mysql> SELECT * FROM t1 NATURAL RIGHT JOIN t2;\n+------+------+------+\n| a    | c    | b    |\n+------+------+------+\n|    2 | z    | y    |\n|    3 | w    | NULL |\n+------+------+------+",
        "mysql> SELECT * FROM t1 LEFT JOIN t2 ON (t1.a = t2.a);\n+------+------+------+------+\n| a    | b    | a    | c    |\n+------+------+------+------+\n|    1 | x    | NULL | NULL |\n|    2 | y    |    2 | z    |\n+------+------+------+------+",
        "mysql> SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a = t2.a);\n+------+------+------+------+\n| a    | b    | a    | c    |\n+------+------+------+------+\n|    2 | y    |    2 | z    |\n| NULL | NULL |    3 | w    |\n+------+------+------+------+",
        "CREATE TABLE t1 (i1 INT);\nCREATE TABLE t2 (i2 INT);\nCREATE TABLE t3 (i3 INT);\nSELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;",
        "SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);",
        "CREATE TABLE t1 (i1 INT, j1 INT);\nCREATE TABLE t2 (i2 INT, j2 INT);\nCREATE TABLE t3 (i3 INT, j3 INT);\nINSERT INTO t1 VALUES(1, 1);\nINSERT INTO t2 VALUES(1, 1);\nINSERT INTO t3 VALUES(1, 1);\nSELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);",
        "SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);",
        "SELECT * FROM t1 JOIN t2 JOIN t3 ON (t1.i1 = t3.i3);"
    ],
    "Category": [
        "Data Manipulation Statements"
    ]
}