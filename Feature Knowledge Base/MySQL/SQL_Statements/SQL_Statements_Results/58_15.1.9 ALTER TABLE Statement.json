{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/alter-table.html"
    ],
    "Title": [
        "15.1.9 ALTER TABLE Statement"
    ],
    "Feature": [
        "ALTER TABLE tbl_name\n    [alter_option [, alter_option] ...]\n    [partition_options]\n\nalter_option: {\n    table_options\n  | ADD [COLUMN] col_name column_definition\n        [FIRST | AFTER col_name]\n  | ADD [COLUMN] (col_name column_definition,...)\n  | ADD {INDEX | KEY} [index_name]\n        [index_type] (key_part,...) [index_option] ...\n  | ADD {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name]\n        (key_part,...) [index_option] ...\n  | ADD [CONSTRAINT [symbol]] PRIMARY KEY\n        [index_type] (key_part,...)\n        [index_option] ...\n  | ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]\n        [index_name] [index_type] (key_part,...)\n        [index_option] ...\n  | ADD [CONSTRAINT [symbol]] FOREIGN KEY\n        [index_name] (col_name,...)\n        reference_definition\n  | ADD [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]\n  | DROP {CHECK | CONSTRAINT} symbol\n  | ALTER {CHECK | CONSTRAINT} symbol [NOT] ENFORCED\n  | ALGORITHM [=] {DEFAULT | INSTANT | INPLACE | COPY}\n  | ALTER [COLUMN] col_name {\n        SET DEFAULT {literal | (expr)}\n      | SET {VISIBLE | INVISIBLE}\n      | DROP DEFAULT\n    }\n  | ALTER INDEX index_name {VISIBLE | INVISIBLE}\n  | CHANGE [COLUMN] old_col_name new_col_name column_definition\n        [FIRST | AFTER col_name]\n  | [DEFAULT] CHARACTER SET [=] charset_name [COLLATE [=] collation_name]\n  | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]\n  | {DISABLE | ENABLE} KEYS\n  | {DISCARD | IMPORT} TABLESPACE\n  | DROP [COLUMN] col_name\n  | DROP {INDEX | KEY} index_name\n  | DROP PRIMARY KEY\n  | DROP FOREIGN KEY fk_symbol\n  | FORCE\n  | LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}\n  | MODIFY [COLUMN] col_name column_definition\n        [FIRST | AFTER col_name]\n  | ORDER BY col_name [, col_name] ...\n  | RENAME COLUMN old_col_name TO new_col_name\n  | RENAME {INDEX | KEY} old_index_name TO new_index_name\n  | RENAME [TO | AS] new_tbl_name\n  | {WITHOUT | WITH} VALIDATION\n}\n\npartition_options:\n    partition_option [partition_option] ...\n\npartition_option: {\n    ADD PARTITION (partition_definition)\n  | DROP PARTITION partition_names\n  | DISCARD PARTITION {partition_names | ALL} TABLESPACE\n  | IMPORT PARTITION {partition_names | ALL} TABLESPACE\n  | TRUNCATE PARTITION {partition_names | ALL}\n  | COALESCE PARTITION number\n  | REORGANIZE PARTITION partition_names INTO (partition_definitions)\n  | EXCHANGE PARTITION partition_name WITH TABLE tbl_name [{WITH | WITHOUT} VALIDATION]\n  | ANALYZE PARTITION {partition_names | ALL}\n  | CHECK PARTITION {partition_names | ALL}\n  | OPTIMIZE PARTITION {partition_names | ALL}\n  | REBUILD PARTITION {partition_names | ALL}\n  | REPAIR PARTITION {partition_names | ALL}\n  | REMOVE PARTITIONING\n}\n\nkey_part: {col_name [(length)] | (expr)} [ASC | DESC]\n\nindex_type:\n    USING {BTREE | HASH}\n\nindex_option: {\n    KEY_BLOCK_SIZE [=] value\n  | index_type\n  | WITH PARSER parser_name\n  | COMMENT 'string'\n  | {VISIBLE | INVISIBLE}\n}\n\ntable_options:\n    table_option [[,] table_option] ...\n\ntable_option: {\n    AUTOEXTEND_SIZE [=] value\n  | AUTO_INCREMENT [=] value\n  | AVG_ROW_LENGTH [=] value\n  | [DEFAULT] CHARACTER SET [=] charset_name\n  | CHECKSUM [=] {0 | 1}\n  | [DEFAULT] COLLATE [=] collation_name\n  | COMMENT [=] 'string'\n  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}\n  | CONNECTION [=] 'connect_string'\n  | {DATA | INDEX} DIRECTORY [=] 'absolute path to directory'\n  | DELAY_KEY_WRITE [=] {0 | 1}\n  | ENCRYPTION [=] {'Y' | 'N'}\n  | ENGINE [=] engine_name\n  | ENGINE_ATTRIBUTE [=] 'string'\n  | INSERT_METHOD [=] { NO | FIRST | LAST }\n  | KEY_BLOCK_SIZE [=] value\n  | MAX_ROWS [=] value\n  | MIN_ROWS [=] value\n  | PACK_KEYS [=] {0 | 1 | DEFAULT}\n  | PASSWORD [=] 'string'\n  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}\n  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'\n  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}\n  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}\n  | STATS_SAMPLE_PAGES [=] value\n  | TABLESPACE tablespace_name [STORAGE {DISK | MEMORY}]\n  | UNION [=] (tbl_name[,tbl_name]...)\n}\n\npartition_options:\n    (see CREATE TABLE options)",
        "ADD CONSTRAINT name FOREIGN KEY (....) ..."
    ],
    "Description": [
        "\nALTER TABLE changes the structure\n      of a table. For example, you can add or delete columns, create or\n      destroy indexes, change the type of existing columns, or rename\n      columns or the table itself. You can also change characteristics\n      such as the storage engine used for the table or the table\n      comment.\n",
        "\n\n          To use ALTER TABLE, you need\n          ALTER,\n          CREATE, and\n          INSERT privileges for the\n          table. Renaming a table requires\n          ALTER and\n          DROP on the old table,\n          ALTER,\n          CREATE, and\n          INSERT on the new table.\n        \n          Following the table name, specify the alterations to be made.\n          If none are given, ALTER TABLE\n          does nothing.\n        \n          The syntax for many of the permissible alterations is similar\n          to clauses of the CREATE TABLE\n          statement. column_definition\n          clauses use the same syntax for ADD and\n          CHANGE as for CREATE\n          TABLE. For more information, see\n          Section\u00a015.1.20, \u201cCREATE TABLE Statement\u201d.\n        \n          The word COLUMN is optional and can be\n          omitted, except for RENAME COLUMN (to\n          distinguish a column-renaming operation from the\n          RENAME table-renaming operation).\n        \n          Multiple ADD, ALTER,\n          DROP, and CHANGE clauses\n          are permitted in a single ALTER\n          TABLE statement, separated by commas. This is a\n          MySQL extension to standard SQL, which permits only one of\n          each clause per ALTER TABLE\n          statement. For example, to drop multiple columns in a single\n          statement, do this:\n        Press CTRL+C to copy ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;\n          If a storage engine does not support an attempted\n          ALTER TABLE operation, a\n          warning may result. Such warnings can be displayed with\n          SHOW WARNINGS. See\n          Section\u00a015.7.7.41, \u201cSHOW WARNINGS Statement\u201d. For information on\n          troubleshooting ALTER TABLE,\n          see Section\u00a0B.3.6.1, \u201cProblems with ALTER TABLE\u201d.\n        \n          For information about generated columns, see\n          Section\u00a015.1.9.2, \u201cALTER TABLE and Generated Columns\u201d.\n        \n          For usage examples, see\n          Section\u00a015.1.9.3, \u201cALTER TABLE Examples\u201d.\n        \nInnoDB supports addition of\n          multi-valued indexes on JSON columns using a\n          key_part specification can take the\n          form (CAST json_path AS\n          type ARRAY). See\n          Multi-Valued Indexes, for detailed\n          information regarding multi-valued index creation and usage\n          of, as well as restrictions and limitations on multi-valued\n          indexes.\n        \n          With the mysql_info() C API\n          function, you can find out how many rows were copied by\n          ALTER TABLE. See\n          mysql_info().\n\n",
        "\n      There are several additional aspects to the ALTER\n      TABLE statement, described under the following topics in\n      this section:\n",
        "\nTable OptionsPerformance and Space RequirementsConcurrency ControlAdding and Dropping ColumnsRenaming, Redefining, and Reordering ColumnsPrimary Keys and IndexesForeign Keys and Other ConstraintsChanging the Character SetImporting InnoDB TablesRow Order for MyISAM TablesPartitioning Options\n",
        {
            "Sub-title": "Table Options",
            "Illustration": [
                "\ntable_options signifies table options\n      of the kind that can be used in the CREATE\n      TABLE statement, such as ENGINE,\n      AUTO_INCREMENT,\n      AVG_ROW_LENGTH, MAX_ROWS,\n      ROW_FORMAT, or TABLESPACE.\n    ",
                "\n      For descriptions of all table options, see\n      Section\u00a015.1.20, \u201cCREATE TABLE Statement\u201d. However,\n      ALTER TABLE ignores DATA\n      DIRECTORY and INDEX DIRECTORY when\n      given as table options. ALTER TABLE\n      permits them only as partitioning options, and requires that you\n      have the FILE privilege.\n    ",
                "\n      Use of table options with ALTER\n      TABLE provides a convenient way of altering single table\n      characteristics. For example:\n",
                "\n\n          If t1 is currently not an\n          InnoDB table, this statement changes its\n          storage engine to InnoDB:\n        Press CTRL+C to copy ALTER TABLE t1 ENGINE = InnoDB;\n\n\n              See Section\u00a017.6.1.5, \u201cConverting Tables from MyISAM to InnoDB\u201d for\n              considerations when switching tables to the\n              InnoDB storage engine.\n            \n              When you specify an ENGINE clause,\n              ALTER TABLE rebuilds the\n              table. This is true even if the table already has the\n              specified storage engine.\n            \n              Running ALTER\n              TABLE tbl_name\n              ENGINE=INNODB on an existing\n              InnoDB table performs a\n              \u201cnull\u201d ALTER\n              TABLE operation, which can be used to defragment\n              an InnoDB table, as described in\n              Section\u00a017.11.4, \u201cDefragmenting a Table\u201d. Running\n              ALTER TABLE\n              tbl_name FORCE on an\n              InnoDB table performs the same\n              function.\n            \nALTER TABLE\n              tbl_name\n              ENGINE=INNODB and\n              ALTER TABLE\n              tbl_name FORCE use\n              online DDL. For\n              more information, see Section\u00a017.12, \u201cInnoDB and Online DDL\u201d.\n            \n              The outcome of attempting to change the storage engine of\n              a table is affected by whether the desired storage engine\n              is available and the setting of the\n              NO_ENGINE_SUBSTITUTION\n              SQL mode, as described in Section\u00a07.1.11, \u201cServer SQL Modes\u201d.\n            \n              To prevent inadvertent loss of data,\n              ALTER TABLE cannot be used\n              to change the storage engine of a table to\n              MERGE or BLACKHOLE.\n\n\n\n          To change the InnoDB table to use\n          compressed row-storage format:\n        Press CTRL+C to copy ALTER TABLE t1 ROW_FORMAT = COMPRESSED;\n          The ENCRYPTION clause enables or disables\n          page-level data encryption for an InnoDB\n          table. A keyring plugin must be installed and configured to\n          enable encryption.\n        \n          If the\n          table_encryption_privilege_check\n          variable is enabled, the\n          TABLE_ENCRYPTION_ADMIN\n          privilege is required to use an ENCRYPTION\n          clause with a setting that differs from the default schema\n          encryption setting.\n        \nENCRYPTION is also supported for tables\n          residing in general tablespaces.\n        \n          For tables that reside in general tablespaces, table and\n          tablespace encryption must match.\n        \n          Altering table encryption by moving a table to a different\n          tablespace or changing the storage engine is not permitted\n          without explicitly specifying an ENCRYPTION\n          clause.\n        \n          Specifying an ENCRYPTION clause with a\n          value other than 'N' or\n          '' is not permitted if the table uses a\n          storage engine that does not support encryption. Attempting to\n          create a table without an ENCRYPTION clause\n          in an encryption-enabled schema using a storage engine that\n          does not support encryption is also not permitted.\n        \n          For more information, see\n          Section\u00a017.13, \u201cInnoDB Data-at-Rest Encryption\u201d.\n        \n          To reset the current auto-increment value:\n        Press CTRL+C to copy ALTER TABLE t1 AUTO_INCREMENT = 13;\n          You cannot reset the counter to a value less than or equal to\n          the value that is currently in use. For both\n          InnoDB and MyISAM, if\n          the value is less than or equal to the maximum value currently\n          in the AUTO_INCREMENT column, the value is\n          reset to the current maximum AUTO_INCREMENT\n          column value plus one.\n        \n          To change the default table character set:\n        Press CTRL+C to copy ALTER TABLE t1 CHARACTER SET = utf8mb4;\n          See also Changing the Character Set.\n        \n          To add (or change) a table comment:\n        Press CTRL+C to copy ALTER TABLE t1 COMMENT = 'New table comment';\n          Use ALTER TABLE with the\n          TABLESPACE option to move\n          InnoDB tables between existing\n          general\n          tablespaces,\n          file-per-table\n          tablespaces, and the\n          system\n          tablespace. See\n          Moving Tables Between Tablespaces Using ALTER TABLE.\n\n\n\nALTER TABLE ... TABLESPACE operations\n              always cause a full table rebuild, even if the\n              TABLESPACE attribute has not changed\n              from its previous value.\n            \nALTER TABLE ... TABLESPACE syntax does\n              not support moving a table from a temporary tablespace to\n              a persistent tablespace.\n            \n              The DATA DIRECTORY clause, which is\n              supported with\n              CREATE TABLE\n              ... TABLESPACE, is not supported with\n              ALTER TABLE ... TABLESPACE, and is\n              ignored if specified.\n            \n              For more information about the capabilities and\n              limitations of the TABLESPACE option,\n              see CREATE TABLE.\n\n\n\n          MySQL NDB Cluster 8.4 supports setting\n          NDB_TABLE options for controlling a\n          table's partition balance (fragment count type),\n          read-from-any-replica capability, full replication, or any\n          combination of these, as part of the table comment for an\n          ALTER TABLE statement in the same manner as\n          for CREATE TABLE, as shown in\n          this example:\n        Press CTRL+C to copy ALTER TABLE t1 COMMENT = \"NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RA_BY_NODE\";\n          It is also possible to set NDB_COMMENT\n          options for columns of NDB tables\n          as part of an ALTER TABLE statement, like\n          this one:\n        Press CTRL+C to copy ALTER TABLE t1 \n  CHANGE COLUMN c1 c1 BLOB \n    COMMENT = 'NDB_COLUMN=BLOB_INLINE_SIZE=4096,MAX_BLOB_PART_SIZE';\n          Bear in mind that ALTER TABLE ... COMMENT\n          ... discards any existing comment for the table. See\n          Setting NDB_TABLE options, for\n          additional information and examples.\n        \nENGINE_ATTRIBUTE and\n          SECONDARY_ENGINE_ATTRIBUTE options are used\n          to specify table, column, and index attributes for primary and\n          secondary storage engines. These options are reserved for\n          future use. Index attributes cannot be altered. An index must\n          be dropped and added back with the desired change, which can\n          be performed in a single ALTER\n          TABLE statement.\n\n",
                "\n      To verify that the table options were changed as intended, use\n      SHOW CREATE TABLE, or query the\n      Information Schema TABLES table.\n"
            ]
        },
        {
            "Sub-title": "Performance and Space Requirements",
            "Illustration": [
                "\nALTER TABLE operations are\n      processed using one of the following algorithms:\n",
                "\n\nCOPY: Operations are performed on a copy of\n          the original table, and table data is copied from the original\n          table to the new table row by row. Concurrent DML is not\n          permitted.\n        \nINPLACE: Operations avoid copying table\n          data but may rebuild the table in place. An exclusive metadata\n          lock on the table may be taken briefly during preparation and\n          execution phases of the operation. Typically, concurrent DML\n          is supported.\n        \nINSTANT: Operations only modify metadata in\n          the data dictionary. An exclusive metadata lock on the table\n          may be taken briefly during the execution phase of the\n          operation. Table data is unaffected, making operations\n          instantaneous. Concurrent DML is permitted.\n\n",
                "\n      For tables using the NDB storage\n      engine, these algorithms work as follows:\n",
                "\n\nCOPY: NDB creates a copy\n          of the table and alters it; the NDB Cluster handler then\n          copies the data between the old and new versions of the table.\n          Subsequently, NDB deletes the old table and\n          renames the new one.\n        \n          This is sometimes also referred to as a \u201ccopying\u201d\n          or \u201coffline\u201d ALTER TABLE.\n        \nINPLACE: The data nodes make the required\n          changes; the NDB Cluster handler does not copy data or\n          otherwise take part.\n        \n          This is sometimes also referred to as a\n          \u201cnon-copying\u201d or \u201conline\u201d\nALTER TABLE.\n        \nINSTANT: Not supported by\n          NDB.\n\n",
                "\n      See Section\u00a025.6.12, \u201cOnline Operations with ALTER TABLE in NDB Cluster\u201d, for more\n      information.\n    ",
                "\n      The ALGORITHM clause is optional. If the\n      ALGORITHM clause is omitted, MySQL uses\n      ALGORITHM=INSTANT for storage engines and\n      ALTER TABLE clauses that support\n      it. Otherwise, ALGORITHM=INPLACE is used. If\n      ALGORITHM=INPLACE is not supported,\n      ALGORITHM=COPY is used.\n",
                "\n\nNote\n\n\n        After adding a column to a partitioned table using\n        ALGORITHM=INSTANT, it is no longer possible\n        to perform\n        ALTER\n        TABLE ... EXCHANGE PARTITION on the table.\n\n",
                "\n      Specifying an ALGORITHM clause requires the\n      operation to use the specified algorithm for clauses and storage\n      engines that support it, or fail with an error otherwise.\n      Specifying ALGORITHM=DEFAULT is the same as\n      omitting the ALGORITHM clause.\n    ",
                "\nALTER TABLE operations that use the\n      COPY algorithm wait for other operations that\n      are modifying the table to complete. After alterations are applied\n      to the table copy, data is copied over, the original table is\n      deleted, and the table copy is renamed to the name of the original\n      table. While the ALTER TABLE\n      operation executes, the original table is readable by other\n      sessions (with the exception noted shortly). Updates and writes to\n      the table started after the ALTER\n      TABLE operation begins are stalled until the new table\n      is ready, then are automatically redirected to the new table. The\n      temporary copy of the table is created in the database directory\n      of the original table unless it is a RENAME TO\n      operation that moves the table to a database that resides in a\n      different directory.\n    ",
                "\n      The exception referred to earlier is that\n      ALTER TABLE blocks reads (not just\n      writes) at the point where it is ready to clear outdated table\n      structures from the table and table definition caches. At this\n      point, it must acquire an exclusive lock. To do so, it waits for\n      current readers to finish, and blocks new reads and writes.\n    ",
                "\n      An ALTER TABLE operation that uses\n      the COPY algorithm prevents concurrent DML\n      operations. Concurrent queries are still allowed. That is, a\n      table-copying operation always includes at least the concurrency\n      restrictions of LOCK=SHARED (allow queries but\n      not DML). You can further restrict concurrency for operations that\n      support the LOCK clause by specifying\n      LOCK=EXCLUSIVE, which prevents DML and queries.\n      For more information, see\n      Concurrency Control.\n    ",
                "\n      To force use of the COPY algorithm for an\n      ALTER TABLE operation that would\n      otherwise not use it, specify ALGORITHM=COPY or\n      enable the old_alter_table system\n      variable. If there is a conflict between the\n      old_alter_table setting and an\n      ALGORITHM clause with a value other than\n      DEFAULT, the ALGORITHM\n      clause takes precedence.\n    ",
                "\n      For InnoDB tables, an\n      ALTER TABLE operation that uses the\n      COPY algorithm on a table that resides in a\n      shared tablespace\n      can increase the amount of space used by the tablespace. Such\n      operations require as much additional space as the data in the\n      table plus indexes. For a table residing in a shared tablespace,\n      the additional space used during the operation is not released\n      back to the operating system as it is for a table that resides in\n      a file-per-table\n      tablespace.\n    ",
                "\n      For information about space requirements for online DDL\n      operations, see\n      Section\u00a017.12.3, \u201cOnline DDL Space Requirements\u201d.\n    ",
                "\nALTER TABLE operations that support\n      the INPLACE algorithm include:\n",
                "\n\nALTER TABLE operations supported by the\n          InnoDB\nonline DDL feature. See\n          Section\u00a017.12.1, \u201cOnline DDL Operations\u201d.\n        \n          Renaming a table. MySQL renames files that correspond to the\n          table tbl_name without making a\n          copy. (You can also use the RENAME\n          TABLE statement to rename tables. See\n          Section\u00a015.1.36, \u201cRENAME TABLE Statement\u201d.) Privileges granted\n          specifically for the renamed table are not migrated to the new\n          name. They must be changed manually.\n        \n          Operations that modify table metadata only. These operations\n          are immediate because the server does not touch table\n          contents. Metadata-only operations include:\n\n\n\n              Renaming a column. In NDB Cluster, this operation can also\n              be performed online.\n            \n              Changing the default value of a column (except for\n              NDB tables).\n            \n              Modifying the definition of an\n              ENUM or\n              SET column by adding new\n              enumeration or set members to the end\n              of the list of valid member values, as long as the storage\n              size of the data type does not change. For example, adding\n              a member to a SET column\n              that has 8 members changes the required storage per value\n              from 1 byte to 2 bytes; this requires a table copy. Adding\n              members in the middle of the list causes renumbering of\n              existing members, which requires a table copy.\n            \n              Changing the definition of a spatial column to remove the\n              SRID attribute. (Adding or changing an\n              SRID attribute requires a rebuild, and\n              cannot be done in place, because the server must verify\n              that all values have the specified SRID\n              value.)\n            \n              Changing a column character set, when these conditions\n              apply:\n\n\n\n                  The column data type is\n                  CHAR,\n                  VARCHAR, a\n                  TEXT type, or\n                  ENUM.\n                \n                  The character set change is from\n                  utf8mb3 to\n                  utf8mb4, or any character set to\n                  binary.\n                \n                  There is no index on the column.\n\n\n\n              Changing a generated column, when these conditions apply:\n\n\n\n                  For InnoDB tables, statements that\n                  modify generated stored columns but do not change\n                  their type, expression, or nullability.\n                \n                  For non-InnoDB tables, statements\n                  that modify generated stored or virtual columns but do\n                  not change their type, expression, or nullability.\n\n\n\n              An example of such a change is a change to the column\n              comment.\n\n\n\n          Renaming an index.\n        \n          Adding or dropping a secondary index, for\n          InnoDB and\n          NDB tables. See\n          Section\u00a017.12.1, \u201cOnline DDL Operations\u201d.\n        \n          For NDB tables, operations that\n          add and drop indexes on variable-width columns. These\n          operations occur online, without table copying and without\n          blocking concurrent DML actions for most of their duration.\n          See Section\u00a025.6.12, \u201cOnline Operations with ALTER TABLE in NDB Cluster\u201d.\n        \n          Modifying index visibility with an ALTER\n          INDEX operation.\n        \n          Column modifications of tables containing generated columns\n          that depend on columns with a DEFAULT value\n          if the modified columns are not involved in the generated\n          column expressions. For example, changing the\n          NULL property of a separate column can be\n          done in place without a table rebuild.\n\n",
                "\nALTER TABLE operations that support the\n      INSTANT algorithm include:\n",
                "\n\n          Adding a column. This feature is referred to as \u201cInstant\n          ADD COLUMN\u201d. Limitations apply. See\n          Section\u00a017.12.1, \u201cOnline DDL Operations\u201d.\n        \n          Dropping a column. This feature is referred to as\n          \u201cInstant DROP COLUMN\u201d.\n          Limitations apply. See\n          Section\u00a017.12.1, \u201cOnline DDL Operations\u201d.\n        \n          Adding or dropping a virtual column.\n        \n          Adding or dropping a column default value.\n        \n          Modifying the definition of an\n          ENUM or\n          SET column. The same\n          restrictions apply as described above for\n          ALGORITHM=INSTANT.\n        \n          Changing the index type.\n        \n          Renaming a table. The same restrictions apply as described\n          above for ALGORITHM=INSTANT.\n\n",
                "\n      For more information about operations that support\n      ALGORITHM=INSTANT, see\n      Section\u00a017.12.1, \u201cOnline DDL Operations\u201d.\n    ",
                "\nALTER TABLE upgrades MySQL 5.5\n      temporal columns to 5.6 format for ADD COLUMN,\n      CHANGE COLUMN, MODIFY\n      COLUMN, ADD INDEX, and\n      FORCE operations. This conversion cannot be\n      done using the INPLACE algorithm because the\n      table must be rebuilt, so specifying\n      ALGORITHM=INPLACE in these cases results in an\n      error. Specify ALGORITHM=COPY if necessary.\n    ",
                "\n      If an ALTER TABLE operation on a multicolumn\n      index used to partition a table by KEY changes\n      the order of the columns, it can only be performed using\n      ALGORITHM=COPY.\n    ",
                "\n      The WITHOUT VALIDATION and WITH\n      VALIDATION clauses affect whether\n      ALTER TABLE performs an in-place\n      operation for\n      virtual generated\n      column modifications. See\n      Section\u00a015.1.9.2, \u201cALTER TABLE and Generated Columns\u201d.\n    ",
                "\n      NDB Cluster 8.4 supports online operations using the\n      same ALGORITHM=INPLACE syntax used with the\n      standard MySQL Server. NDB does not allow\n      changing a tablespace online. See\n      Section\u00a025.6.12, \u201cOnline Operations with ALTER TABLE in NDB Cluster\u201d, for more\n      information.\n    ",
                "\n      When performing a copying ALTER TABLE,\n      NDB checks to ensure that no concurrent writes\n      have been made to the affected table. If it finds that any have\n      been made, NDB rejects the\n      ALTER TABLE statement and raises\n      ER_TABLE_DEF_CHANGED.\n    ",
                "\nALTER TABLE with DISCARD ... PARTITION\n      ... TABLESPACE or IMPORT ... PARTITION ...\n      TABLESPACE does not create any temporary tables or\n      temporary partition files.\n    ",
                "\nALTER TABLE with ADD\n      PARTITION, DROP PARTITION,\n      COALESCE PARTITION, REBUILD\n      PARTITION, or REORGANIZE PARTITION\n      does not create temporary tables (except when used with\n      NDB tables); however, these\n      operations can and do create temporary partition files.\n    ",
                "\nADD or DROP operations for\n      RANGE or LIST partitions are\n      immediate operations or nearly so. ADD or\n      COALESCE operations for HASH\n      or KEY partitions copy data between all\n      partitions, unless LINEAR HASH or\n      LINEAR KEY was used; this is effectively the\n      same as creating a new table, although the ADD\n      or COALESCE operation is performed partition by\n      partition. REORGANIZE operations copy only\n      changed partitions and do not touch unchanged ones.\n    ",
                "\n      For MyISAM tables, you can speed up index\n      re-creation (the slowest part of the alteration process) by\n      setting the\n      myisam_sort_buffer_size system\n      variable to a high value.\n"
            ]
        },
        {
            "Sub-title": "Concurrency Control",
            "Illustration": [
                "\n      For ALTER TABLE operations that\n      support it, you can use the LOCK clause to\n      control the level of concurrent reads and writes on a table while\n      it is being altered. Specifying a non-default value for this\n      clause enables you to require a certain amount of concurrent\n      access or exclusivity during the alter operation, and halts the\n      operation if the requested degree of locking is not available.\n    ",
                "\n      Only LOCK = DEFAULT is permitted for operations\n      that use ALGORITHM=INSTANT. The other\n      LOCK clause parameters are not applicable.\n    ",
                "\n      The parameters for the LOCK clause are:\n",
                "\n\nLOCK = DEFAULT\n\n          Maximum level of concurrency for the given\n          ALGORITHM clause (if any) and\n          ALTER TABLE operation: Permit concurrent\n          reads and writes if supported. If not, permit concurrent reads\n          if supported. If not, enforce exclusive access.\n        \nLOCK = NONE\n\n          If supported, permit concurrent reads and writes. Otherwise,\n          an error occurs.\n        \nLOCK = SHARED\n\n          If supported, permit concurrent reads but block writes. Writes\n          are blocked even if concurrent writes are supported by the\n          storage engine for the given ALGORITHM\n          clause (if any) and ALTER TABLE operation.\n          If concurrent reads are not supported, an error occurs.\n        \nLOCK = EXCLUSIVE\n\n          Enforce exclusive access. This is done even if concurrent\n          reads/writes are supported by the storage engine for the given\n          ALGORITHM clause (if any) and\n          ALTER TABLE operation.\n\n"
            ]
        },
        {
            "Sub-title": "Adding and Dropping Columns",
            "Illustration": [
                "\n      Use ADD to add new columns to a table, and\n      DROP to remove existing columns. DROP\n      col_name is a MySQL extension\n      to standard SQL.\n    ",
                "\n      To add a column at a specific position within a table row, use\n      FIRST or AFTER\n      col_name. The default is to\n      add the column last.\n    ",
                "\n      If a table contains only one column, the column cannot be dropped.\n      If what you intend is to remove the table, use the\n      DROP TABLE statement instead.\n    ",
                "\n      If columns are dropped from a table, the columns are also removed\n      from any index of which they are a part. If all columns that make\n      up an index are dropped, the index is dropped as well. If you use\n      CHANGE or MODIFY to shorten\n      a column for which an index exists on the column, and the\n      resulting column length is less than the index length, MySQL\n      shortens the index automatically.\n    ",
                "\n      For ALTER TABLE ... ADD, if the column has an\n      expression default value that uses a nondeterministic function,\n      the statement may produce a warning or error. For further\n      information, see Section\u00a013.6, \u201cData Type Default Values\u201d, and\n      Section\u00a019.1.3.7, \u201cRestrictions on Replication with GTIDs\u201d.\n"
            ]
        },
        {
            "Sub-title": "Renaming, Redefining, and Reordering Columns",
            "Illustration": [
                "\n      The CHANGE, MODIFY,\n      RENAME COLUMN, and ALTER\n      clauses enable the names and definitions of existing columns to be\n      altered. They have these comparative characteristics:\n",
                "\n\nCHANGE:\n\n\n\n              Can rename a column and change its definition, or both.\n            \n              Has more capability than MODIFY or\n              RENAME COLUMN, but at the expense of\n              convenience for some operations. CHANGE\n              requires naming the column twice if not renaming it, and\n              requires respecifying the column definition if only\n              renaming it.\n            \n              With FIRST or AFTER,\n              can reorder columns.\n\n\n\nMODIFY:\n\n\n\n              Can change a column definition but not its name.\n            \n              More convenient than CHANGE to change a\n              column definition without renaming it.\n            \n              With FIRST or AFTER,\n              can reorder columns.\n\n\n\nRENAME COLUMN:\n\n\n\n              Can change a column name but not its definition.\n            \n              More convenient than CHANGE to rename a\n              column without changing its definition.\n\n\n\nALTER: Used only to change a column default\n          value.\n\n",
                "\nCHANGE is a MySQL extension to standard SQL.\n      MODIFY and RENAME COLUMN are\n      MySQL extensions for Oracle compatibility.\n    ",
                "\n      To alter a column to change both its name and definition, use\n      CHANGE, specifying the old and new names and\n      the new definition. For example, to rename an INT NOT\n      NULL column from a to\n      b and change its definition to use the\n      BIGINT data type while retaining the\n      NOT NULL attribute, do this:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 CHANGE a b BIGINT NOT NULL;",
                "\n      To change a column definition but not its name, use\n      CHANGE or MODIFY. With\n      CHANGE, the syntax requires two column names,\n      so you must specify the same name twice to leave the name\n      unchanged. For example, to change the definition of column\n      b, do this:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 CHANGE b b INT NOT NULL;",
                "\nMODIFY is more convenient to change the\n      definition without changing the name because it requires the\n      column name only once:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 MODIFY b INT NOT NULL;",
                "\n      To change a column name but not its definition, use\n      CHANGE or RENAME COLUMN.\n      With CHANGE, the syntax requires a column\n      definition, so to leave the definition unchanged, you must\n      respecify the definition the column currently has. For example, to\n      rename an INT NOT NULL column from\n      b to a, do this:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 CHANGE b a INT NOT NULL;",
                "\nRENAME COLUMN is more convenient to change the\n      name without changing the definition because it requires only the\n      old and new names:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 RENAME COLUMN b TO a;",
                "\n      In general, you cannot rename a column to a name that already\n      exists in the table. However, this is sometimes not the case, such\n      as when you swap names or move them through a cycle. If a table\n      has columns named a, b, and\n      c, these are valid operations:\n    ",
                "Press CTRL+C to copy -- swap a and b\nALTER TABLE t1 RENAME COLUMN a TO b,\n               RENAME COLUMN b TO a;\n-- \"rotate\" a, b, c through a cycle\nALTER TABLE t1 RENAME COLUMN a TO b,\n               RENAME COLUMN b TO c,\n               RENAME COLUMN c TO a;",
                "\n      For column definition changes using CHANGE or\n      MODIFY, the definition must include the data\n      type and all attributes that should apply to the new column, other\n      than index attributes such as PRIMARY KEY or\n      UNIQUE. Attributes present in the original\n      definition but not specified for the new definition are not\n      carried forward. Suppose that a column col1 is\n      defined as INT UNSIGNED DEFAULT 1 COMMENT 'my\n      column' and you modify the column as follows, intending\n      to change only INT to\n      BIGINT:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 MODIFY col1 BIGINT;",
                "\n      That statement changes the data type from INT\n      to BIGINT, but it also drops the\n      UNSIGNED, DEFAULT, and\n      COMMENT attributes. To retain them, the\n      statement must include them explicitly:\n    ",
                "Press CTRL+C to copy ALTER TABLE t1 MODIFY col1 BIGINT UNSIGNED DEFAULT 1 COMMENT 'my column';",
                "\n      For data type changes using CHANGE or\n      MODIFY, MySQL tries to convert existing column\n      values to the new type as well as possible.\n",
                "\n\nWarning\n\n\n        This conversion may result in alteration of data. For example,\n        if you shorten a string column, values may be truncated. To\n        prevent the operation from succeeding if conversions to the new\n        data type would result in loss of data, enable strict SQL mode\n        before using ALTER TABLE (see\n        Section\u00a07.1.11, \u201cServer SQL Modes\u201d).\n\n",
                "\n      If you use CHANGE or MODIFY\n      to shorten a column for which an index exists on the column, and\n      the resulting column length is less than the index length, MySQL\n      shortens the index automatically.\n    ",
                "\n      For columns renamed by CHANGE or\n      RENAME COLUMN, MySQL automatically renames\n      these references to the renamed column:\n",
                "\n\n          Indexes that refer to the old column, including invisible\n          indexes and disabled MyISAM indexes.\n        \n          Foreign keys that refer to the old column.\n\n",
                "\n      For columns renamed by CHANGE or\n      RENAME COLUMN, MySQL does not automatically\n      rename these references to the renamed column:\n",
                "\n\n          Generated column and partition expressions that refer to the\n          renamed column. You must use CHANGE to\n          redefine such expressions in the same\n          ALTER TABLE statement as the\n          one that renames the column.\n        \n          Views and stored programs that refer to the renamed column.\n          You must manually alter the definition of these objects to\n          refer to the new column name.\n\n",
                "\n      To reorder columns within a table, use FIRST\n      and AFTER in CHANGE or\n      MODIFY operations.\n    ",
                "\nALTER ... SET DEFAULT or ALTER ...\n      DROP DEFAULT specify a new default value for a column or\n      remove the old default value, respectively. If the old default is\n      removed and the column can be NULL, the new\n      default is NULL. If the column cannot be\n      NULL, MySQL assigns a default value as\n      described in Section\u00a013.6, \u201cData Type Default Values\u201d.\n    ",
                "\nALTER ... SET VISIBLE and ALTER ...\n      SET INVISIBLE enable column visibility to be changed.\n      See Section\u00a015.1.20.10, \u201cInvisible Columns\u201d.\n"
            ]
        },
        {
            "Sub-title": "Primary Keys and Indexes",
            "Illustration": [
                "\nDROP PRIMARY KEY drops the\n      primary key. If there is\n      no primary key, an error occurs. For information about the\n      performance characteristics of primary keys, especially for\n      InnoDB tables, see\n      Section\u00a010.3.2, \u201cPrimary Key Optimization\u201d.\n    ",
                "\n      If the sql_require_primary_key\n      system variable is enabled, attempting to drop a primary key\n      produces an error.\n    ",
                "\n      If you add a UNIQUE INDEX or PRIMARY\n      KEY to a table, MySQL stores it before any nonunique\n      index to permit detection of duplicate keys as early as possible.\n    ",
                "\nDROP INDEX removes an index. This\n      is a MySQL extension to standard SQL. See\n      Section\u00a015.1.27, \u201cDROP INDEX Statement\u201d. To determine index names, use\n      SHOW INDEX FROM\n      tbl_name.\n    ",
                "\n      Some storage engines permit you to specify an index type when\n      creating an index. The syntax for the\n      index_type specifier is USING\n      type_name. For details about\n      USING, see Section\u00a015.1.15, \u201cCREATE INDEX Statement\u201d. The\n      preferred position is after the column list. Expect support for\n      use of the option before the column list to be removed in a future\n      MySQL release.\n    ",
                "\nindex_option values specify additional\n      options for an index. USING is one such option.\n      For details about permissible\n      index_option values, see\n      Section\u00a015.1.15, \u201cCREATE INDEX Statement\u201d.\n    ",
                "\nRENAME INDEX old_index_name TO\n      new_index_name renames an\n      index. This is a MySQL extension to standard SQL. The content of\n      the table remains unchanged.\n      old_index_name must be the name of an\n      existing index in the table that is not dropped by the same\n      ALTER TABLE statement.\n      new_index_name is the new index name,\n      which cannot duplicate the name of an index in the resulting table\n      after changes have been applied. Neither index name can be\n      PRIMARY.\n    ",
                "\n      If you use ALTER TABLE on a\n      MyISAM table, all nonunique indexes are created\n      in a separate batch (as for REPAIR\n      TABLE). This should make ALTER\n      TABLE much faster when you have many indexes.\n    ",
                "\n      For MyISAM tables, key updating can be\n      controlled explicitly. Use ALTER TABLE ... DISABLE\n      KEYS to tell MySQL to stop updating nonunique indexes.\n      Then use ALTER TABLE ... ENABLE KEYS to\n      re-create missing indexes. MyISAM does this\n      with a special algorithm that is much faster than inserting keys\n      one by one, so disabling keys before performing bulk insert\n      operations should give a considerable speedup. Using\n      ALTER TABLE ... DISABLE KEYS requires the\n      INDEX privilege in addition to the\n      privileges mentioned earlier.\n    ",
                "\n      While the nonunique indexes are disabled, they are ignored for\n      statements such as SELECT and\n      EXPLAIN that otherwise would use\n      them.\n    ",
                "\n      After an ALTER TABLE statement, it\n      may be necessary to run ANALYZE\n      TABLE to update index cardinality information. See\n      Section\u00a015.7.7.23, \u201cSHOW INDEX Statement\u201d.\n    ",
                "\n      The ALTER INDEX operation permits an index to\n      be made visible or invisible. An invisible index is not used by\n      the optimizer. Modification of index visibility applies to indexes\n      other than primary keys (either explicit or implicit), and cannot\n      be performed using ALGORITHM=INSTANT. This\n      feature is storage engine neutral (supported for any engine). For\n      more information, see Section\u00a010.3.12, \u201cInvisible Indexes\u201d.\n"
            ]
        },
        {
            "Sub-title": "Foreign Keys and Other Constraints",
            "Illustration": [
                "\n      The FOREIGN KEY and\n      REFERENCES clauses are supported by the\n      InnoDB and NDB storage\n      engines, which implement ADD [CONSTRAINT\n      [symbol]] FOREIGN KEY\n      [index_name] (...) REFERENCES ...\n      (...). See Section\u00a015.1.20.5, \u201cFOREIGN KEY Constraints\u201d.\n      For other storage engines, the clauses are parsed but ignored.\n    ",
                "\n      For ALTER TABLE, unlike\n      CREATE TABLE, ADD FOREIGN\n      KEY ignores index_name if\n      given and uses an automatically generated foreign key name. As a\n      workaround, include the CONSTRAINT clause to\n      specify the foreign key name:\n    ",
                "\n\nImportant\n\n\n        MySQL silently ignores inline REFERENCES\n        specifications, where the references are defined as part of the\n        column specification. MySQL accepts only\n        REFERENCES clauses defined as part of a\n        separate FOREIGN KEY specification.\n\n",
                "\n\nNote\n\n\n        Partitioned InnoDB tables do not support\n        foreign keys. This restriction does not apply to\n        NDB tables, including those explicitly\n        partitioned by [LINEAR] KEY. For more\n        information, see\n        Section\u00a026.6.2, \u201cPartitioning Limitations Relating to Storage Engines\u201d.\n\n",
                "\n      MySQL Server and NDB Cluster both support the use of\n      ALTER TABLE to drop foreign keys:\n    ",
                "Press CTRL+C to copy ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol;",
                "\n      Adding and dropping a foreign key in the same\n      ALTER TABLE statement is supported\n      for ALTER TABLE ...\n      ALGORITHM=INPLACE but not for\n      ALTER TABLE ...\n      ALGORITHM=COPY.\n    ",
                "\n      The server prohibits changes to foreign key columns that have the\n      potential to cause loss of referential integrity. A workaround is\n      to use ALTER TABLE\n      ... DROP FOREIGN KEY before changing the column\n      definition and ALTER\n      TABLE ... ADD FOREIGN KEY afterward. Examples of\n      prohibited changes include:\n",
                "\n\n          Changes to the data type of foreign key columns that may be\n          unsafe. For example, changing\n          VARCHAR(20) to\n          VARCHAR(30) is permitted, but\n          changing it to VARCHAR(1024) is\n          not because that alters the number of length bytes required to\n          store individual values.\n        \n          Changing a NULL column to NOT\n          NULL in non-strict mode is prohibited to prevent\n          converting NULL values to default\n          non-NULL values, for which there are no\n          corresponding values in the referenced table. The operation is\n          permitted in strict mode, but an error is returned if any such\n          conversion is required.\n\n",
                "\nALTER TABLE tbl_name RENAME\n      new_tbl_name changes\n      internally generated foreign key constraint names and user-defined\n      foreign key constraint names that begin with the string\n      \u201ctbl_name_ibfk_\u201d to\n      reflect the new table name. InnoDB interprets\n      foreign key constraint names that begin with the string\n      \u201ctbl_name_ibfk_\u201d as\n      internally generated names.\n    ",
                "\nALTER TABLE permits\n      CHECK constraints for existing tables to be\n      added, dropped, or altered:\n",
                "\n\n          Add a new CHECK constraint:\n        Press CTRL+C to copy ALTER TABLE tbl_name\n    ADD [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED];\n          The meaning of constraint syntax elements is the same as for\n          CREATE TABLE. See\n          Section\u00a015.1.20.6, \u201cCHECK Constraints\u201d.\n        \n          Drop an existing CHECK constraint named\n          symbol:\n        Press CTRL+C to copy ALTER TABLE tbl_name\n    DROP CHECK symbol;\n          Alter whether an existing CHECK constraint\n          named symbol is enforced:\n        Press CTRL+C to copy ALTER TABLE tbl_name\n    ALTER CHECK symbol [NOT] ENFORCED;\n",
                "\n      The DROP CHECK and ALTER\n      CHECK clauses are MySQL extensions to standard SQL.\n    ",
                "\nALTER TABLE permits more general\n      (and SQL standard) syntax for dropping and altering existing\n      constraints of any type, where the constraint type is determined\n      from the constraint name:\n",
                "\n\n          Drop an existing constraint named\n          symbol:\n        Press CTRL+C to copy ALTER TABLE tbl_name\n    DROP CONSTRAINT symbol;\n          If the\n          sql_require_primary_key\n          system variable is enabled, attempting to drop a primary key\n          produces an error.\n        \n          Alter whether an existing constraint named\n          symbol is enforced:\n        Press CTRL+C to copy ALTER TABLE tbl_name\n    ALTER CONSTRAINT symbol [NOT] ENFORCED;\n          Only CHECK constraints can be altered to be\n          unenforced. All other constraint types are always enforced.\n\n",
                "\n      The SQL standard specifies that all types of constraints (primary\n      key, unique index, foreign key, check) belong to the same\n      namespace. In MySQL, each constraint type has its own namespace\n      per schema. Consequently, names for each type of constraint must\n      be unique per schema, but constraints of different types can have\n      the same name. When multiple constraints have the same name,\n      DROP CONSTRAINT and ADD\n      CONSTRAINT are ambiguous and an error occurs. In such\n      cases, constraint-specific syntax must be used to modify the\n      constraint. For example, use DROP PRIMARY KEY\n      or DROP FOREIGN KEY to drop a primary key or foreign key.\n    ",
                "\n      If a table alteration causes a violation of an enforced\n      CHECK constraint, an error occurs and the table\n      is not modified. Examples of operations for which an error occurs:\n",
                "\n\n          Attempts to add the AUTO_INCREMENT\n          attribute to a column that is used in a\n          CHECK constraint.\n        \n          Attempts to add an enforced CHECK\n          constraint or enforce a nonenforced CHECK\n          constraint for which existing rows violate the constraint\n          condition.\n        \n          Attempts to modify, rename, or drop a column that is used in a\n          CHECK constraint, unless that constraint is\n          also dropped in the same statement. Exception: If a\n          CHECK constraint refers only to a single\n          column, dropping the column automatically drops the\n          constraint.\n\n",
                "\nALTER TABLE tbl_name RENAME\n      new_tbl_name changes\n      internally generated and user-defined CHECK\n      constraint names that begin with the string\n      \u201ctbl_name_chk_\u201d to reflect\n      the new table name. MySQL interprets CHECK\n      constraint names that begin with the string\n      \u201ctbl_name_chk_\u201d as\n      internally generated names.\n"
            ]
        },
        {
            "Sub-title": "Changing the Character Set",
            "Illustration": [
                "\n\n\n      To change the table default character set and all character\n      columns (CHAR,\n      VARCHAR,\n      TEXT) to a new character set, use a\n      statement like this:\n    ",
                "Press CTRL+C to copy ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;",
                "\n      The statement also changes the collation of all character columns.\n      If you specify no COLLATE clause to indicate\n      which collation to use, the statement uses default collation for\n      the character set. If this collation is inappropriate for the\n      intended table use (for example, if it would change from a\n      case-sensitive collation to a case-insensitive collation), specify\n      a collation explicitly.\n    ",
                "\n      For a column that has a data type of\n      VARCHAR or one of the\n      TEXT types, CONVERT TO\n      CHARACTER SET changes the data type as necessary to\n      ensure that the new column is long enough to store as many\n      characters as the original column. For example, a\n      TEXT column has two length bytes,\n      which store the byte-length of values in the column, up to a\n      maximum of 65,535. For a latin1\nTEXT column, each character\n      requires a single byte, so the column can store up to 65,535\n      characters. If the column is converted to\n      utf8mb4, each character might require up to 4\n      bytes, for a maximum possible length of 4 \u00d7 65,535 = 262,140\n      bytes. That length does not fit in a\n      TEXT column's length bytes, so\n      MySQL converts the data type to\n      MEDIUMTEXT, which is the smallest\n      string type for which the length bytes can record a value of\n      262,140. Similarly, a VARCHAR\n      column might be converted to\n      MEDIUMTEXT.\n    ",
                "\n      To avoid data type changes of the type just described, do not use\n      CONVERT TO CHARACTER SET. Instead, use\n      MODIFY to change individual columns. For\n      example:\n    ",
                "Press CTRL+C to copy ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8mb4;\nALTER TABLE t MODIFY latin1_varchar_col VARCHAR(M) CHARACTER SET utf8mb4;",
                "\n      If you specify CONVERT TO CHARACTER SET binary,\n      the CHAR,\n      VARCHAR, and\n      TEXT columns are converted to their\n      corresponding binary string types\n      (BINARY,\n      VARBINARY,\n      BLOB). This means that the columns\n      no longer have a character set and a subsequent CONVERT\n      TO operation does not apply to them.\n    ",
                "\n      If charset_name is\n      DEFAULT in a CONVERT TO CHARACTER\n      SET operation, the character set named by the\n      character_set_database system\n      variable is used.\n",
                "\n\nWarning\n\n\n        The CONVERT TO operation converts column\n        values between the original and named character sets. This is\n        not what you want if you have a column in\n        one character set (like latin1) but the\n        stored values actually use some other, incompatible character\n        set (like utf8mb4). In this case, you have to\n        do the following for each such column:\n      Press CTRL+C to copy ALTER TABLE t1 CHANGE c1 c1 BLOB;\nALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8mb4;\n        The reason this works is that there is no conversion when you\n        convert to or from BLOB columns.\n\n",
                "\n      To change only the default character set for\n      a table, use this statement:\n    ",
                "Press CTRL+C to copy ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;",
                "\n      The word DEFAULT is optional. The default\n      character set is the character set that is used if you do not\n      specify the character set for columns that you add to a table\n      later (for example, with ALTER TABLE ... ADD\n      column).\n    ",
                "\n      When the foreign_key_checks\n      system variable is enabled, which is the default setting,\n      character set conversion is not permitted on tables that include a\n      character string column used in a foreign key constraint. The\n      workaround is to disable\n      foreign_key_checks before\n      performing the character set conversion. You must perform the\n      conversion on both tables involved in the foreign key constraint\n      before re-enabling\n      foreign_key_checks. If you\n      re-enable foreign_key_checks\n      after converting only one of the tables, an ON DELETE\n      CASCADE or ON UPDATE CASCADE\n      operation could corrupt data in the referencing table due to\n      implicit conversion that occurs during these operations (Bug\n      #45290, Bug #74816).\n"
            ]
        },
        {
            "Sub-title": "Importing InnoDB Tables",
            "Illustration": [
                "\n      An InnoDB table created in its own\n      file-per-table\n      tablespace can be imported from a backup or from another MySQL\n      server instance using DISCARD TABLEPACE and\n      IMPORT TABLESPACE clauses. See\n      Section\u00a017.6.1.3, \u201cImporting InnoDB Tables\u201d.\n"
            ]
        },
        {
            "Sub-title": "Row Order for MyISAM Tables",
            "Illustration": [
                "\nORDER BY enables you to create the new table\n      with the rows in a specific order. This option is useful primarily\n      when you know that you query the rows in a certain order most of\n      the time. By using this option after major changes to the table,\n      you might be able to get higher performance. In some cases, it\n      might make sorting easier for MySQL if the table is in order by\n      the column that you want to order it by later.\n",
                "\n\nNote\n\n\n        The table does not remain in the specified order after inserts\n        and deletes.\n\n",
                "\nORDER BY syntax permits one or more column\n      names to be specified for sorting, each of which optionally can be\n      followed by ASC or DESC to\n      indicate ascending or descending sort order, respectively. The\n      default is ascending order. Only column names are permitted as\n      sort criteria; arbitrary expressions are not permitted. This\n      clause should be given last after any other clauses.\n    ",
                "\nORDER BY does not make sense for\n      InnoDB tables because InnoDB\n      always orders table rows according to the\n      clustered index.\n    ",
                "\n      When used on a partitioned table, ALTER TABLE ... ORDER\n      BY orders rows within each partition only.\n"
            ]
        },
        {
            "Sub-title": "Partitioning Options",
            "Illustration": [
                "\npartition_options signifies options\n      that can be used with partitioned tables for repartitioning, to\n      add, drop, discard, import, merge, and split partitions, and to\n      perform partitioning maintenance.\n    ",
                "\n      It is possible for an ALTER TABLE\n      statement to contain a PARTITION BY or\n      REMOVE PARTITIONING clause in an addition to\n      other alter specifications, but the PARTITION\n      BY or REMOVE PARTITIONING clause must\n      be specified last after any other specifications. The ADD\n      PARTITION, DROP PARTITION,\n      DISCARD PARTITION, IMPORT\n      PARTITION, COALESCE PARTITION,\n      REORGANIZE PARTITION, EXCHANGE\n      PARTITION, ANALYZE PARTITION,\n      CHECK PARTITION, and REPAIR\n      PARTITION options cannot be combined with other alter\n      specifications in a single ALTER TABLE, since\n      the options just listed act on individual partitions.\n    ",
                "\n      For more information about partition options, see\n      Section\u00a015.1.20, \u201cCREATE TABLE Statement\u201d, and\n      Section\u00a015.1.9.1, \u201cALTER TABLE Partition Operations\u201d. For\n      information about and examples of ALTER TABLE ...\n      EXCHANGE PARTITION statements, see\n      Section\u00a026.3.3, \u201cExchanging Partitions and Subpartitions with Tables\u201d.\n"
            ]
        }
    ],
    "Examples": [
        "ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;",
        "ALTER TABLE t1 ENGINE = InnoDB;",
        "ALTER TABLE t1 ROW_FORMAT = COMPRESSED;",
        "ALTER TABLE t1 AUTO_INCREMENT = 13;",
        "ALTER TABLE t1 CHARACTER SET = utf8mb4;",
        "ALTER TABLE t1 COMMENT = 'New table comment';",
        "ALTER TABLE t1 COMMENT = \"NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RA_BY_NODE\";",
        "ALTER TABLE t1 \n  CHANGE COLUMN c1 c1 BLOB \n    COMMENT = 'NDB_COLUMN=BLOB_INLINE_SIZE=4096,MAX_BLOB_PART_SIZE';",
        "ALTER TABLE t1 CHANGE a b BIGINT NOT NULL;",
        "ALTER TABLE t1 CHANGE b b INT NOT NULL;",
        "ALTER TABLE t1 MODIFY b INT NOT NULL;",
        "ALTER TABLE t1 CHANGE b a INT NOT NULL;",
        "ALTER TABLE t1 RENAME COLUMN b TO a;",
        "-- swap a and b\nALTER TABLE t1 RENAME COLUMN a TO b,\n               RENAME COLUMN b TO a;\n-- \"rotate\" a, b, c through a cycle\nALTER TABLE t1 RENAME COLUMN a TO b,\n               RENAME COLUMN b TO c,\n               RENAME COLUMN c TO a;",
        "ALTER TABLE t1 MODIFY col1 BIGINT;",
        "ALTER TABLE t1 MODIFY col1 BIGINT UNSIGNED DEFAULT 1 COMMENT 'my column';",
        "ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol;",
        "ALTER TABLE tbl_name\n    ADD [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED];",
        "ALTER TABLE tbl_name\n    DROP CHECK symbol;",
        "ALTER TABLE tbl_name\n    ALTER CHECK symbol [NOT] ENFORCED;",
        "ALTER TABLE tbl_name\n    DROP CONSTRAINT symbol;",
        "ALTER TABLE tbl_name\n    ALTER CONSTRAINT symbol [NOT] ENFORCED;",
        "ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;",
        "ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8mb4;\nALTER TABLE t MODIFY latin1_varchar_col VARCHAR(M) CHARACTER SET utf8mb4;",
        "ALTER TABLE t1 CHANGE c1 c1 BLOB;\nALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8mb4;",
        "ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;"
    ],
    "Category": [
        "Data Definition Statements"
    ]
}