{
    "HTML": [
        "https://dev.mysql.com/doc/refman/8.4/en/start-replica.html"
    ],
    "Title": [
        "15.4.2.4 START REPLICA Statement"
    ],
    "Feature": [
        "START REPLICA [thread_types] [until_option] [connection_options] [channel_option]\n\nthread_types:\n    [thread_type [, thread_type] ... ]\n\nthread_type:\n    IO_THREAD | SQL_THREAD\n\nuntil_option:\n    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = gtid_set\n          |   SOURCE_LOG_FILE = 'log_name', SOURCE_LOG_POS = log_pos\n          |   RELAY_LOG_FILE = 'log_name', RELAY_LOG_POS = log_pos\n          |   SQL_AFTER_MTS_GAPS  }\n\nconnection_options:\n    [USER='user_name'] [PASSWORD='user_pass'] [DEFAULT_AUTH='plugin_name'] [PLUGIN_DIR='plugin_dir']\n\n\nchannel_option:\n    FOR CHANNEL channel\n\ngtid_set:\n    uuid_set [, uuid_set] ...\n    | ''\n\nuuid_set:\n    uuid:interval[:interval]...\n\nuuid:\n    hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\n\nh:\n    [0-9,A-F]\n\ninterval:\n    n[-n]\n\n    (n >= 1)"
    ],
    "Description": [
        "\nSTART REPLICA starts the replication threads,\n        either together or separately.\n      ",
        "\nSTART REPLICA requires the\n        REPLICATION_SLAVE_ADMIN privilege\n        (or the deprecated SUPER\n        privilege). START REPLICA causes an implicit\n        commit of an ongoing transaction. See\n        Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n      ",
        "\n        For the thread type options, you can specify\n        IO_THREAD, SQL_THREAD,\n        both of these, or neither of them. Only the threads that are\n        started are affected by the statement.\n",
        "\n\nSTART REPLICA with no thread type options\n            starts all of the replication threads, and so does\n            START REPLICA with both of the thread\n            type options.\n          \nIO_THREAD starts the replication receiver\n            thread, which reads events from the source server and stores\n            them in the relay log.\n          \nSQL_THREAD starts the replication applier\n            thread, which reads events from the relay log and executes\n            them. A multithreaded replica (with\n            replica_parallel_workers\n            > 0) applies transactions using a coordinator thread and\n            multiple applier threads, and SQL_THREAD\n            starts all of these.\n\n",
        "\n\nImportant\n\n\nSTART REPLICA sends an acknowledgment to\n          the user after all the replication threads have started.\n          However, the replication receiver thread might not yet have\n          connected to the source successfully, or an applier thread\n          might stop when applying an event right after starting.\n          START REPLICA does not continue to monitor\n          the threads after they are started, so it does not warn you if\n          they subsequently stop or cannot connect. You must check the\n          replica's error log for error messages generated by the\n          replication threads, or check that they are running\n          satisfactorily with SHOW REPLICA\n          STATUS. A successful START\n          REPLICA statement causes SHOW\n          REPLICA STATUS to show\n          Replica_SQL_Running=Yes, but it might or\n          might not show Replica_IO_Running=Yes,\n          because Replica_IO_Running=Yes is only\n          shown if the receiver thread is both running and connected.\n          For more information, see\n          Section\u00a019.1.7.1, \u201cChecking Replication Status\u201d.\n\n",
        "\n        The optional FOR CHANNEL\n        channel clause enables you\n        to name which replication channel the statement applies to.\n        Providing a FOR CHANNEL\n        channel clause applies the\n        START REPLICA statement to a specific\n        replication channel. If no clause is named and no extra channels\n        exist, the statement applies to the default channel. If a\n        START REPLICA statement does not have a\n        channel defined when using multiple channels, this statement\n        starts the specified threads for all channels. See\n        Section\u00a019.2.2, \u201cReplication Channels\u201d for more information.\n      ",
        "\n        The replication channels for Group Replication\n        (group_replication_applier and\n        group_replication_recovery) are managed\n        automatically by the server instance. START\n        REPLICA cannot be used at all with the\n        group_replication_recovery channel, and\n        should only be used with the\n        group_replication_applier channel when Group\n        Replication is not running. The\n        group_replication_applier channel only has an\n        applier thread and has no receiver thread, so it can be started\n        if required by using the SQL_THREAD option\n        without the IO_THREAD option.\n      ",
        "\nSTART REPLICA supports pluggable\n        user-password authentication (see\n        Section\u00a08.2.17, \u201cPluggable Authentication\u201d) with the\n        USER, PASSWORD,\n        DEFAULT_AUTH and\n        PLUGIN_DIR options, as described in the\n        following list. When you use these options, you must start the\n        receiver thread (IO_THREAD option) or all the\n        replication threads; you cannot start the replication applier\n        thread (SQL_THREAD option) alone.\n",
        "\n\nUSER\n\n              The user name for the account. You must set this if\n              PASSWORD is used. The option cannot be\n              set to an empty or null string.\n            \nPASSWORD\n\n              The password for the named user account.\n            \nDEFAULT_AUTH\n\n              The name of the authentication plugin. The default is\n              MySQL native authentication.\n            \nPLUGIN_DIR\n\n              The location of the authentication plugin.\n\n",
        "\n\nImportant\n\n\n          The password that you set using START\n          REPLICA is masked when it is written to MySQL\n          Server\u2019s logs, Performance Schema tables, and\n          SHOW PROCESSLIST statements.\n          However, it is sent in plain text over the connection to the\n          replica server instance. To protect the password in transit,\n          use SSL/TLS encryption, an SSH tunnel, or another method of\n          protecting the connection from unauthorized viewing, for the\n          connection between the replica server instance and the client\n          that you use to issue START REPLICA.\n\n",
        "\n        The UNTIL clause makes the replica start\n        replication, then process transactions up to the point that you\n        specify in the UNTIL clause, then stop again.\n        The UNTIL clause can be used to make a\n        replica proceed until just before the point where you want to\n        skip a transaction that is unwanted, and then skip the\n        transaction as described in\n        Section\u00a019.1.7.3, \u201cSkipping Transactions\u201d. To identify a\n        transaction, you can use mysqlbinlog with the\n        source's binary log or the replica's relay log, or use a\n        SHOW BINLOG EVENTS statement.\n      ",
        "\n        You can also use the UNTIL clause for\n        debugging replication by processing transactions one at a time\n        or in sections. If you are using the UNTIL\n        clause to do this, start the replica with\n        --skip-replica-start to prevent\n        the SQL thread from running when the replica server starts.\n        Remove the option or system variable setting after the procedure\n        is complete, so that it is not forgotten in the event of an\n        unexpected server restart.\n      ",
        "\n        The SHOW REPLICA STATUS statement\n        includes output fields that display the current values of the\n        UNTIL condition. The UNTIL\n        condition lasts for as long as the affected threads are still\n        running, and is removed when they stop.\n      ",
        "\n        The UNTIL clause operates on the replication\n        applier thread (SQL_THREAD option). You can\n        use the SQL_THREAD option or let the replica\n        default to starting both threads. If you use the\n        IO_THREAD option alone, the\n        UNTIL clause is ignored because the applier\n        thread is not started.\n      ",
        "\n        The point that you specify in the UNTIL\n        clause can be any one (and only one) of the following options:\n",
        "\n\nSOURCE_LOG_FILE and\n            SOURCE_LOG_POS\n\n              These options make the replication applier process\n              transactions up to a position in its relay log, identified\n              by the file name and file position of the corresponding\n              point in the binary log on the source server. The applier\n              thread finds the nearest transaction boundary at or after\n              the specified position, finishes applying the transaction,\n              and stops there. For compressed transaction payloads,\n              specify the end position of the compressed\n              Transaction_payload_event.\n            \n              These options can still be used when the\n              GTID_ONLY option was set on the\n              CHANGE REPLICATION SOURCE\n              TO statement to stop the replication channel\n              from persisting file names and file positions in the\n              replication metadata repositories. The file names and file\n              positions are tracked in memory.\n            \nRELAY_LOG_FILE and\n            RELAY_LOG_POS\n\n              These options make the replication applier process\n              transactions up to a position in the replica\u2019s relay\n              log, identified by the relay log file name and a position\n              in that file. The applier thread finds the nearest\n              transaction boundary at or after the specified position,\n              finishes applying the transaction, and stops there. For\n              compressed transaction payloads, specify the end position\n              of the compressed\n              Transaction_payload_event.\n            \n              These options can still be used when the\n              GTID_ONLY option was set on the\n              CHANGE REPLICATION SOURCE\n              TO statement to stop the replication channel\n              from persisting file names and file positions in the\n              replication metadata repositories. The file names and file\n              positions are tracked in memory.\n            \nSQL_BEFORE_GTIDS\n\n              This option makes the replication applier start processing\n              transactions and stop when it encounters any transaction\n              that is in the specified GTID set. The encountered\n              transaction from the GTID set is not applied, and nor are\n              any of the other transactions in the GTID set. The option\n              takes a GTID set containing one or more global transaction\n              identifiers as an argument (see\n              GTID Sets).\n              Transactions in a GTID set do not necessarily appear in\n              the replication stream in the order of their GTIDs, so the\n              transaction before which the applier stops is not\n              necessarily the earliest.\n            \nSQL_AFTER_GTIDS\n\n              This option makes the replication applier start processing\n              transactions and stop when it has processed all of the\n              transactions in a specified GTID set. The option takes a\n              GTID set containing one or more global transaction\n              identifiers as an argument (see\n              GTID Sets).\n            \n              With SQL_AFTER_GTIDS, the replication\n              threads stop after they have processed all transactions in\n              the GTID set. Transactions are processed in the order\n              received, so it is possible that these include\n              transactions which are not part of the GTID set, but which\n              are received (and processed) before all transactions in\n              the set have been committed. For example, executing\n              START REPLICA UNTIL SQL_AFTER_GTIDS =\n              3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56\n              causes the replica to obtain (and process) all\n              transactions from the source until all of the transactions\n              having the sequence numbers 11 through 56 have been\n              processed, and then to stop without processing any\n              additional transactions after that point has been reached.\n            \n              In older versions of MySQL, this option could not be used\n              with replica_parallel_workers >\n              1. In MySQL 8.4, this is no longer\n              an issue, and SQL_AFTER_GTIDS can be\n              used without causing the replica to fall back into\n              single-threaded mode.\n            \nSQL_AFTER_MTS_GAPS\n\n              For a multithreaded replica only (with\n              replica_parallel_workers\n              > 0), this option makes the replica process\n              transactions up to the point where there are no more gaps\n              in the sequence of transactions executed from the relay\n              log. When using a multithreaded replica, there is a chance\n              of gaps occurring in the following situations:\n\n\n\n                  The coordinator thread is stopped.\n                \n                  An error occurs in the applier threads.\n                \nmysqld shuts down unexpectedly.\n\n\n\n              When a replication channel has gaps, the replica\u2019s\n              database is in a state that might never have existed on\n              the source. The replica tracks the gaps internally and\n              disallows CHANGE REPLICATION SOURCE\n              TO statements that would remove the gap\n              information if they executed.\n            \n              All replicas are multithreaded by default. When\n              replica_preserve_commit_order=ON\n              on the replica (the default), gaps should not occur except\n              in the specific situations listed in the description for\n              this variable. If\n              replica_preserve_commit_order is\n              OFF, the commit order of transactions\n              is not preserved, so the chance of gaps occurring is much\n              larger.\n            \n              If GTIDs are not in use and you need to change a failed\n              multithreaded replica to single-threaded mode, you can\n              issue the following series of statements, in the order\n              shown:\n            Press CTRL+C to copy START REPLICA UNTIL SQL_AFTER_MTS_GAPS;\nSET @@GLOBAL.replica_parallel_workers = 0;\nSTART REPLICA SQL_THREAD;\n"
    ],
    "Examples": [
        "START REPLICA UNTIL SQL_AFTER_MTS_GAPS;\nSET @@GLOBAL.replica_parallel_workers = 0;\nSTART REPLICA SQL_THREAD;"
    ],
    "Category": [
        "Replication Statements"
    ]
}