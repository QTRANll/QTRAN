{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/begin-end.html"], "Title": ["15.6.1 BEGIN ... END Compound Statement"], "Feature": ["[begin_label:] BEGIN\n    [statement_list]\nEND [end_label]"], "Description": ["\nBEGIN ... END\n      syntax is used for writing compound statements, which can appear\n      within stored programs (stored procedures and functions, triggers,\n      and events). A compound statement can contain multiple statements,\n      enclosed by the BEGIN and\n      END keywords.\n      statement_list represents a list of one\n      or more statements, each terminated by a semicolon\n      (;) statement delimiter. The\n      statement_list itself is optional, so\n      the empty compound statement (BEGIN END) is\n      legal.\n    ", "\nBEGIN ... END\n      blocks can be nested.\n    ", "\n      Use of multiple statements requires that a client is able to send\n      statement strings containing the ; statement\n      delimiter. In the mysql command-line client,\n      this is handled with the delimiter command.\n      Changing the ; end-of-statement delimiter (for\n      example, to //) permit ; to\n      be used in a program body. For an example, see\n      Section\u00a027.1, \u201cDefining Stored Programs\u201d.\n    ", "\n      A BEGIN ...\n      END block can be labeled. See\n      Section\u00a015.6.2, \u201cStatement Labels\u201d.\n    ", "\n      The optional [NOT] ATOMIC clause is not\n      supported. This means that no transactional savepoint is set at\n      the start of the instruction block and the\n      BEGIN clause used in this context has no effect\n      on the current transaction.\n", "\n\nNote\n\n\n        Within all stored programs, the parser treats\n        BEGIN [WORK]\n        as the beginning of a\n        BEGIN ...\n        END block. To begin a transaction in this context, use\n        START\n        TRANSACTION instead.\n\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/while.html"], "Title": ["15.6.5.8 WHILE Statement"], "Feature": ["[begin_label:] WHILE search_condition DO\n    statement_list\nEND WHILE [end_label]"], "Description": ["\n        The statement list within a WHILE\n        statement is repeated as long as the\n        search_condition expression is true.\n        statement_list consists of one or\n        more SQL statements, each terminated by a semicolon\n        (;) statement delimiter.\n      ", "\n        A WHILE statement can be labeled.\n        For the rules regarding label use, see\n        Section\u00a015.6.2, \u201cStatement Labels\u201d.\n      ", "\n        Example:\n      ", "Press CTRL+C to copy CREATE PROCEDURE dowhile()\nBEGIN\n  DECLARE v1 INT DEFAULT 5;\n\n  WHILE v1 > 0 DO\n    ...\n    SET v1 = v1 - 1;\n  END WHILE;\nEND;"], "Examples": ["CREATE PROCEDURE dowhile()\nBEGIN\n  DECLARE v1 INT DEFAULT 5;\n\n  WHILE v1 > 0 DO\n    ...\n    SET v1 = v1 - 1;\n  END WHILE;\nEND;"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/close.html"], "Title": ["15.6.6.1 Cursor CLOSE Statement"], "Feature": ["CLOSE cursor_name"], "Description": ["\n        This statement closes a previously opened cursor. For an\n        example, see Section\u00a015.6.6, \u201cCursors\u201d.\n      ", "\n        An error occurs if the cursor is not open.\n      ", "\n        If not closed explicitly, a cursor is closed at the end of the\n        BEGIN ...\n        END block in which it was declared.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/declare-cursor.html"], "Title": ["15.6.6.2 Cursor DECLARE Statement"], "Feature": ["DECLARE cursor_name CURSOR FOR select_statement"], "Description": ["\n        This statement declares a cursor and associates it with a\n        SELECT statement that retrieves\n        the rows to be traversed by the cursor. To fetch the rows later,\n        use a FETCH statement. The number\n        of columns retrieved by the\n        SELECT statement must match the\n        number of output variables specified in the\n        FETCH statement.\n      ", "\n        The SELECT statement cannot have\n        an INTO clause.\n      ", "\n        Cursor declarations must appear before handler declarations and\n        after variable and condition declarations.\n      ", "\n        A stored program may contain multiple cursor declarations, but\n        each cursor declared in a given block must have a unique name.\n        For an example, see Section\u00a015.6.6, \u201cCursors\u201d.\n      ", "\n        For information available through\n        SHOW statements, it is possible\n        in many cases to obtain equivalent information by using a cursor\n        with an INFORMATION_SCHEMA table.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/fetch.html"], "Title": ["15.6.6.3 Cursor FETCH Statement"], "Feature": ["FETCH [[NEXT] FROM] cursor_name INTO var_name [, var_name] ..."], "Description": ["\n        This statement fetches the next row for the\n        SELECT statement associated with\n        the specified cursor (which must be open), and advances the\n        cursor pointer. If a row exists, the fetched columns are stored\n        in the named variables. The number of columns retrieved by the\n        SELECT statement must match the\n        number of output variables specified in the\n        FETCH statement.\n      ", "\n        If no more rows are available, a No Data condition occurs with\n        SQLSTATE value '02000'. To detect this\n        condition, you can set up a handler for it (or for a\n        NOT FOUND condition). For an example, see\n        Section\u00a015.6.6, \u201cCursors\u201d.\n      ", "\n        Be aware that another operation, such as a\n        SELECT or another FETCH,\n        may also cause the handler to execute by raising the same\n        condition. If it is necessary to distinguish which operation\n        raised the condition, place the operation within its own\n        BEGIN ...\n        END block so that it can be associated with its own\n        handler.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/open.html"], "Title": ["15.6.6.4 Cursor OPEN Statement"], "Feature": ["OPEN cursor_name"], "Description": ["\n        This statement opens a previously declared cursor. For an\n        example, see Section\u00a015.6.6, \u201cCursors\u201d.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/declare-handler.html"], "Title": ["15.6.7.2 DECLARE ... HANDLER Statement"], "Feature": ["DECLARE handler_action HANDLER\n    FOR condition_value [, condition_value] ...\n    statement\n\nhandler_action: {\n    CONTINUE\n  | EXIT\n  | UNDO\n}\n\ncondition_value: {\n    mysql_error_code\n  | SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n  | SQLWARNING\n  | NOT FOUND\n  | SQLEXCEPTION\n}"], "Description": ["\n        The DECLARE ...\n        HANDLER statement specifies a handler that deals with\n        one or more conditions. If one of these conditions occurs, the\n        specified statement executes.\n        statement can be a simple statement\n        such as SET var_name =\n        value, or a compound\n        statement written using BEGIN and\n        END (see Section\u00a015.6.1, \u201cBEGIN ... END Compound Statement\u201d).\n      ", "\n        Handler declarations must appear after variable or condition\n        declarations.\n      ", "\n        The handler_action value indicates\n        what action the handler takes after execution of the handler\n        statement:\n", "\n\nCONTINUE: Execution of the current\n            program continues.\n          \nEXIT: Execution terminates for the\n            BEGIN ...\n            END compound statement in which the handler is\n            declared. This is true even if the condition occurs in an\n            inner block.\n          \nUNDO: Not supported.\n\n", "\n        The condition_value for\n        DECLARE ...\n        HANDLER indicates the specific condition or class of\n        conditions that activates the handler. It can take the following\n        forms:\n", "\n\nmysql_error_code: An integer\n            literal indicating a MySQL error code, such as 1051 to\n            specify \u201cunknown table\u201d:\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR 1051\n  BEGIN\n    -- body of handler\n  END;\n            Do not use MySQL error code 0 because that indicates success\n            rather than an error condition. For a list of MySQL error\n            codes, see Server Error Message Reference.\n          \n            SQLSTATE [VALUE] sqlstate_value:\n            A 5-character string literal indicating an SQLSTATE value,\n            such as '42S01' to specify \u201cunknown\n            table\u201d:\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'\n  BEGIN\n    -- body of handler\n  END;\n            Do not use SQLSTATE values that begin with\n            '00' because those indicate success\n            rather than an error condition. For a list of SQLSTATE\n            values, see Server Error Message Reference.\n          \ncondition_name: A condition name\n            previously specified with\n            DECLARE\n            ... CONDITION. A condition name can be associated\n            with a MySQL error code or SQLSTATE value. See\n            Section\u00a015.6.7.1, \u201cDECLARE ... CONDITION Statement\u201d.\n          \nSQLWARNING: Shorthand for the class of\n            SQLSTATE values that begin with '01'.\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    -- body of handler\n  END;\nNOT FOUND: Shorthand for the class of\n            SQLSTATE values that begin with '02'.\n            This is relevant within the context of cursors and is used\n            to control what happens when a cursor reaches the end of a\n            data set. If no more rows are available, a No Data condition\n            occurs with SQLSTATE value '02000'. To\n            detect this condition, you can set up a handler for it or\n            for a NOT FOUND condition.\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR NOT FOUND\n  BEGIN\n    -- body of handler\n  END;\n            For another example, see Section\u00a015.6.6, \u201cCursors\u201d. The\n            NOT FOUND condition also occurs for\n            SELECT ... INTO\n            var_list statements\n            that retrieve no rows.\n          \nSQLEXCEPTION: Shorthand for the class of\n            SQLSTATE values that do not begin with\n            '00', '01', or\n            '02'.\n          Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- body of handler\n  END;\n", "\n        For information about how the server chooses handlers when a\n        condition occurs, see Section\u00a015.6.7.6, \u201cScope Rules for Handlers\u201d.\n      ", "\n        If a condition occurs for which no handler has been declared,\n        the action taken depends on the condition class:\n", "\n\n            For SQLEXCEPTION conditions, the stored\n            program terminates at the statement that raised the\n            condition, as if there were an EXIT\n            handler. If the program was called by another stored\n            program, the calling program handles the condition using the\n            handler selection rules applied to its own handlers.\n          \n            For SQLWARNING conditions, the program\n            continues executing, as if there were a\n            CONTINUE handler.\n          \n            For NOT FOUND conditions, if the\n            condition was raised normally, the action is\n            CONTINUE. If it was raised by\n            SIGNAL or\n            RESIGNAL, the action is\n            EXIT.\n\n", "\n        The following example uses a handler for SQLSTATE\n        '23000', which occurs for a duplicate-key error:\n      ", "Press CTRL+C to copy mysql> CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter //\n\nmysql> CREATE PROCEDURE handlerdemo ()\n       BEGIN\n         DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;\n         SET @x = 1;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 2;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 3;\n       END;\n       //\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL handlerdemo()//\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @x//\n    +------+\n    | @x   |\n    +------+\n    | 3    |\n    +------+\n    1 row in set (0.00 sec)", "\n        Notice that @x is 3 after\n        the procedure executes, which shows that execution continued to\n        the end of the procedure after the error occurred. If the\n        DECLARE ...\n        HANDLER statement had not been present, MySQL would\n        have taken the default action (EXIT) after\n        the second INSERT failed due to\n        the PRIMARY KEY constraint, and\n        SELECT @x would have returned\n        2.\n      ", "\n        To ignore a condition, declare a CONTINUE\n        handler for it and associate it with an empty block. For\n        example:\n      ", "Press CTRL+C to copy DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;", "\n        The scope of a block label does not include the code for\n        handlers declared within the block. Therefore, the statement\n        associated with a handler cannot use\n        ITERATE or\n        LEAVE to refer to labels for\n        blocks that enclose the handler declaration. Consider the\n        following example, where the\n        REPEAT block has a label of\n        retry:\n      ", "Press CTRL+C to copy CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            ITERATE retry;    # illegal\n          END;\n        IF i < 0 THEN\n          LEAVE retry;        # legal\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;", "\n        The retry label is in scope for the\n        IF statement within the block. It\n        is not in scope for the CONTINUE handler, so\n        the reference there is invalid and results in an error:\n      ", "\n        To avoid references to outer labels in handlers, use one of\n        these strategies:\n", "\n\n            To leave the block, use an EXIT handler.\n            If no block cleanup is required, the\n            BEGIN ...\n            END handler body can be empty:\n          Press CTRL+C to copy DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;\n            Otherwise, put the cleanup statements in the handler body:\n          Press CTRL+C to copy DECLARE EXIT HANDLER FOR SQLWARNING\n  BEGIN\n    block cleanup statements\n  END;\n            To continue execution, set a status variable in a\n            CONTINUE handler that can be checked in\n            the enclosing block to determine whether the handler was\n            invoked. The following example uses the variable\n            done for this purpose:\n          Press CTRL+C to copy CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  DECLARE done INT DEFAULT FALSE;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            SET done = TRUE;\n          END;\n        IF done OR i < 0 THEN\n          LEAVE retry;\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;\n"], "Examples": ["DECLARE CONTINUE HANDLER FOR 1051\n  BEGIN\n    -- body of handler\n  END;", "DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'\n  BEGIN\n    -- body of handler\n  END;", "DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    -- body of handler\n  END;", "DECLARE CONTINUE HANDLER FOR NOT FOUND\n  BEGIN\n    -- body of handler\n  END;", "DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- body of handler\n  END;", "mysql> CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter //\n\nmysql> CREATE PROCEDURE handlerdemo ()\n       BEGIN\n         DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;\n         SET @x = 1;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 2;\n         INSERT INTO test.t VALUES (1);\n         SET @x = 3;\n       END;\n       //\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL handlerdemo()//\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @x//\n    +------+\n    | @x   |\n    +------+\n    | 3    |\n    +------+\n    1 row in set (0.00 sec)", "DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;", "CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            ITERATE retry;    # illegal\n          END;\n        IF i < 0 THEN\n          LEAVE retry;        # legal\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;", "DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;", "DECLARE EXIT HANDLER FOR SQLWARNING\n  BEGIN\n    block cleanup statements\n  END;", "CREATE PROCEDURE p ()\nBEGIN\n  DECLARE i INT DEFAULT 3;\n  DECLARE done INT DEFAULT FALSE;\n  retry:\n    REPEAT\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            SET done = TRUE;\n          END;\n        IF done OR i < 0 THEN\n          LEAVE retry;\n        END IF;\n        SET i = i - 1;\n      END;\n    UNTIL FALSE END REPEAT;\nEND;"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/get-diagnostics.html"], "Title": ["15.6.7.3 GET DIAGNOSTICS Statement"], "Feature": ["GET [CURRENT | STACKED] DIAGNOSTICS {\n    statement_information_item\n    [, statement_information_item] ...\n  | CONDITION condition_number\n    condition_information_item\n    [, condition_information_item] ...\n}\n\nstatement_information_item:\n    target = statement_information_item_name\n\ncondition_information_item:\n    target = condition_information_item_name\n\nstatement_information_item_name: {\n    NUMBER\n  | ROW_COUNT\n}\n\ncondition_information_item_name: {\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | RETURNED_SQLSTATE\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n}\n\ncondition_number, target:\n    (see following discussion)"], "Description": ["\n        SQL statements produce diagnostic information that populates the\n        diagnostics area. The GET\n        DIAGNOSTICS statement enables applications to inspect\n        this information. (You can also use SHOW\n        WARNINGS or SHOW ERRORS\n        to see conditions or errors.)\n      ", "\n        No special privileges are required to execute\n        GET DIAGNOSTICS.\n      ", "\n        The keyword CURRENT means to retrieve\n        information from the current diagnostics area. The keyword\n        STACKED means to retrieve information from\n        the second diagnostics area, which is available only if the\n        current context is a condition handler. If neither keyword is\n        given, the default is to use the current diagnostics area.\n      ", "\n        The GET DIAGNOSTICS statement is\n        typically used in a handler within a stored program. It is a\n        MySQL extension that\n        GET [CURRENT]\n        DIAGNOSTICS is permitted outside handler context to\n        check the execution of any SQL statement. For example, if you\n        invoke the mysql client program, you can\n        enter these statements at the prompt:\n      ", "Press CTRL+C to copy mysql> DROP TABLE test.no_such_table;\nERROR 1051 (42S02): Unknown table 'test.no_such_table'\nmysql> GET DIAGNOSTICS CONDITION 1\n         @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;\nmysql> SELECT @p1, @p2;\n+-------+------------------------------------+\n| @p1   | @p2                                |\n+-------+------------------------------------+\n| 42S02 | Unknown table 'test.no_such_table' |\n+-------+------------------------------------+", "\n        This extension applies only to the current diagnostics area. It\n        does not apply to the second diagnostics area because\n        GET STACKED DIAGNOSTICS is permitted only if\n        the current context is a condition handler. If that is not the\n        case, a GET STACKED DIAGNOSTICS when handler not\n        active error occurs.\n      ", "\n        For a description of the diagnostics area, see\n        Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d. Briefly, it contains two\n        kinds of information:\n", "\n\n            Statement information, such as the number of conditions that\n            occurred or the affected-rows count.\n          \n            Condition information, such as the error code and message.\n            If a statement raises multiple conditions, this part of the\n            diagnostics area has a condition area for each one. If a\n            statement raises no conditions, this part of the diagnostics\n            area is empty.\n\n", "\n        For a statement that produces three conditions, the diagnostics\n        area contains statement and condition information like this:\n      ", "\nGET DIAGNOSTICS can obtain either\n        statement or condition information, but not both in the same\n        statement:\n", "\n\n            To obtain statement information, retrieve the desired\n            statement items into target variables. This instance of\n            GET DIAGNOSTICS assigns the\n            number of available conditions and the rows-affected count\n            to the user variables @p1 and\n            @p2:\n          Press CTRL+C to copy GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;\n            To obtain condition information, specify the condition\n            number and retrieve the desired condition items into target\n            variables. This instance of GET\n            DIAGNOSTICS assigns the SQLSTATE value and error\n            message to the user variables @p3 and\n            @p4:\n          Press CTRL+C to copy GET DIAGNOSTICS CONDITION 1\n  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;\n", "\n        The retrieval list specifies one or more\n        target =\n        item_name assignments,\n        separated by commas. Each assignment names a target variable and\n        either a\n        statement_information_item_name or\n        condition_information_item_name\n        designator, depending on whether the statement retrieves\n        statement or condition information.\n      ", "\n        Valid target designators for storing\n        item information can be stored procedure or function parameters,\n        stored program local variables declared with\n        DECLARE, or user-defined\n        variables.\n      ", "\n        Valid condition_number designators\n        can be stored procedure or function parameters, stored program\n        local variables declared with\n        DECLARE, user-defined variables,\n        system variables, or literals. A character literal may include a\n        _charset introducer. A warning occurs\n        if the condition number is not in the range from 1 to the number\n        of condition areas that have information. In this case, the\n        warning is added to the diagnostics area without clearing it.\n      ", "\n        When a condition occurs, MySQL does not populate all condition\n        items recognized by GET\n        DIAGNOSTICS. For example:\n      ", "Press CTRL+C to copy mysql> GET DIAGNOSTICS CONDITION 1\n         @p5 = SCHEMA_NAME, @p6 = TABLE_NAME;\nmysql> SELECT @p5, @p6;\n+------+------+\n| @p5  | @p6  |\n+------+------+\n|      |      |\n+------+------+", "\n        In standard SQL, if there are multiple conditions, the first\n        condition relates to the SQLSTATE value\n        returned for the previous SQL statement. In MySQL, this is not\n        guaranteed. To get the main error, you cannot do this:\n      ", "Press CTRL+C to copy GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;", "\n        Instead, retrieve the condition count first, then use it to\n        specify which condition number to inspect:\n      ", "Press CTRL+C to copy GET DIAGNOSTICS @cno = NUMBER;\nGET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;", "\n        For information about permissible statement and condition\n        information items, and which ones are populated when a condition\n        occurs, see\n        Diagnostics Area Information Items.\n      ", "\n        Here is an example that uses GET\n        DIAGNOSTICS and an exception handler in stored\n        procedure context to assess the outcome of an insert operation.\n        If the insert was successful, the procedure uses\n        GET DIAGNOSTICS to get the\n        rows-affected count. This shows that you can use\n        GET DIAGNOSTICS multiple times to\n        retrieve information about a statement as long as the current\n        diagnostics area has not been cleared.\n      ", "Press CTRL+C to copy CREATE PROCEDURE do_insert(value INT)\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE code CHAR(5) DEFAULT '00000';\n  DECLARE msg TEXT;\n  DECLARE nrows INT;\n  DECLARE result TEXT;\n  -- Declare exception handler for failed insert\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n      GET DIAGNOSTICS CONDITION 1\n        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;\n    END;\n\n  -- Perform the insert\n  INSERT INTO t1 (int_col) VALUES(value);\n  -- Check whether the insert was successful\n  IF code = '00000' THEN\n    GET DIAGNOSTICS nrows = ROW_COUNT;\n    SET result = CONCAT('insert succeeded, row count = ',nrows);\n  ELSE\n    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);\n  END IF;\n  -- Say what happened\n  SELECT result;\nEND;", "\n        Suppose that t1.int_col is an integer column\n        that is declared as NOT NULL. The procedure\n        produces these results when invoked to insert\n        non-NULL and NULL values,\n        respectively:\n      ", "Press CTRL+C to copy mysql> CALL do_insert(1);\n+---------------------------------+\n| result                          |\n+---------------------------------+\n| insert succeeded, row count = 1 |\n+---------------------------------+\n\nmysql> CALL do_insert(NULL);\n+-------------------------------------------------------------------------+\n| result                                                                  |\n+-------------------------------------------------------------------------+\n| insert failed, error = 23000, message = Column 'int_col' cannot be null |\n+-------------------------------------------------------------------------+", "\n        When a condition handler activates, a push to the diagnostics\n        area stack occurs:\n", "\n\n            The first (current) diagnostics area becomes the second\n            (stacked) diagnostics area and a new current diagnostics\n            area is created as a copy of it.\n          \nGET\n            [CURRENT] DIAGNOSTICS and\n            GET STACKED\n            DIAGNOSTICS can be used within the handler to\n            access the contents of the current and stacked diagnostics\n            areas.\n          \n            Initially, both diagnostics areas return the same result, so\n            it is possible to get information from the current\n            diagnostics area about the condition that activated the\n            handler, as long as you execute no\n            statements within the handler that change its current\n            diagnostics area.\n          \n            However, statements executing within the handler can modify\n            the current diagnostics area, clearing and setting its\n            contents according to the normal rules (see\n            How the Diagnostics Area is Cleared and Populated).\n          \n            A more reliable way to obtain information about the\n            handler-activating condition is to use the stacked\n            diagnostics area, which cannot be modified by statements\n            executing within the handler except\n            RESIGNAL. For information\n            about when the current diagnostics area is set and cleared,\n            see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n\n", "\n        The next example shows how GET STACKED\n        DIAGNOSTICS can be used within a handler to obtain\n        information about the handled exception, even after the current\n        diagnostics area has been modified by handler statements.\n      ", "\n        Within a stored procedure p(), we attempt to\n        insert two values into a table that contains a TEXT NOT\n        NULL column. The first value is a\n        non-NULL string and the second is\n        NULL. The column prohibits\n        NULL values, so the first insert succeeds but\n        the second causes an exception. The procedure includes an\n        exception handler that maps attempts to insert\n        NULL into inserts of the empty string:\n      ", "Press CTRL+C to copy DROP TABLE IF EXISTS t1;\nCREATE TABLE t1 (c1 TEXT NOT NULL);\nDROP PROCEDURE IF EXISTS p;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE errcount INT;\n  DECLARE errno INT;\n  DECLARE msg TEXT;\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- Here the current DA is nonempty because no prior statements\n    -- executing within the handler have cleared it\n    GET CURRENT DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'current DA before mapped insert' AS op, errno, msg;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA before mapped insert' AS op, errno, msg;\n\n    -- Map attempted NULL insert to empty string insert\n    INSERT INTO t1 (c1) VALUES('');\n\n    -- Here the current DA should be empty (if the INSERT succeeded),\n    -- so check whether there are conditions before attempting to\n    -- obtain condition information\n    GET CURRENT DIAGNOSTICS errcount = NUMBER;\n    IF errcount = 0\n    THEN\n      SELECT 'mapped insert succeeded, current DA is empty' AS op;\n    ELSE\n      GET CURRENT DIAGNOSTICS CONDITION 1\n        errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n      SELECT 'current DA after mapped insert' AS op, errno, msg;\n    END IF ;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA after mapped insert' AS op, errno, msg;\n  END;\n  INSERT INTO t1 (c1) VALUES('string 1');\n  INSERT INTO t1 (c1) VALUES(NULL);\nEND;\n//\ndelimiter ;\nCALL p();\nSELECT * FROM t1;", "\n        When the handler activates, a copy of the current diagnostics\n        area is pushed to the diagnostics area stack. The handler first\n        displays the contents of the current and stacked diagnostics\n        areas, which are both the same initially:\n      ", "\n        Statements executing after the GET\n        DIAGNOSTICS statements may reset the current\n        diagnostics area. statements may reset the current diagnostics\n        area. For example, the handler maps the NULL\n        insert to an empty-string insert and displays the result. The\n        new insert succeeds and clears the current diagnostics area, but\n        the stacked diagnostics area remains unchanged and still\n        contains information about the condition that activated the\n        handler:\n      ", "\n        When the condition handler ends, its current diagnostics area is\n        popped from the stack and the stacked diagnostics area becomes\n        the current diagnostics area in the stored procedure.\n      ", "\n        After the procedure returns, the table contains two rows. The\n        empty row results from the attempt to insert\n        NULL that was mapped to an empty-string\n        insert:\n      "], "Examples": ["mysql> DROP TABLE test.no_such_table;\nERROR 1051 (42S02): Unknown table 'test.no_such_table'\nmysql> GET DIAGNOSTICS CONDITION 1\n         @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;\nmysql> SELECT @p1, @p2;\n+-------+------------------------------------+\n| @p1   | @p2                                |\n+-------+------------------------------------+\n| 42S02 | Unknown table 'test.no_such_table' |\n+-------+------------------------------------+", "GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;", "GET DIAGNOSTICS CONDITION 1\n  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;", "mysql> GET DIAGNOSTICS CONDITION 1\n         @p5 = SCHEMA_NAME, @p6 = TABLE_NAME;\nmysql> SELECT @p5, @p6;\n+------+------+\n| @p5  | @p6  |\n+------+------+\n|      |      |\n+------+------+", "GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;", "GET DIAGNOSTICS @cno = NUMBER;\nGET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;", "CREATE PROCEDURE do_insert(value INT)\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE code CHAR(5) DEFAULT '00000';\n  DECLARE msg TEXT;\n  DECLARE nrows INT;\n  DECLARE result TEXT;\n  -- Declare exception handler for failed insert\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n      GET DIAGNOSTICS CONDITION 1\n        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;\n    END;\n\n  -- Perform the insert\n  INSERT INTO t1 (int_col) VALUES(value);\n  -- Check whether the insert was successful\n  IF code = '00000' THEN\n    GET DIAGNOSTICS nrows = ROW_COUNT;\n    SET result = CONCAT('insert succeeded, row count = ',nrows);\n  ELSE\n    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);\n  END IF;\n  -- Say what happened\n  SELECT result;\nEND;", "mysql> CALL do_insert(1);\n+---------------------------------+\n| result                          |\n+---------------------------------+\n| insert succeeded, row count = 1 |\n+---------------------------------+\n\nmysql> CALL do_insert(NULL);\n+-------------------------------------------------------------------------+\n| result                                                                  |\n+-------------------------------------------------------------------------+\n| insert failed, error = 23000, message = Column 'int_col' cannot be null |\n+-------------------------------------------------------------------------+", "DROP TABLE IF EXISTS t1;\nCREATE TABLE t1 (c1 TEXT NOT NULL);\nDROP PROCEDURE IF EXISTS p;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  -- Declare variables to hold diagnostics area information\n  DECLARE errcount INT;\n  DECLARE errno INT;\n  DECLARE msg TEXT;\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    -- Here the current DA is nonempty because no prior statements\n    -- executing within the handler have cleared it\n    GET CURRENT DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'current DA before mapped insert' AS op, errno, msg;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA before mapped insert' AS op, errno, msg;\n\n    -- Map attempted NULL insert to empty string insert\n    INSERT INTO t1 (c1) VALUES('');\n\n    -- Here the current DA should be empty (if the INSERT succeeded),\n    -- so check whether there are conditions before attempting to\n    -- obtain condition information\n    GET CURRENT DIAGNOSTICS errcount = NUMBER;\n    IF errcount = 0\n    THEN\n      SELECT 'mapped insert succeeded, current DA is empty' AS op;\n    ELSE\n      GET CURRENT DIAGNOSTICS CONDITION 1\n        errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n      SELECT 'current DA after mapped insert' AS op, errno, msg;\n    END IF ;\n    GET STACKED DIAGNOSTICS CONDITION 1\n      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;\n    SELECT 'stacked DA after mapped insert' AS op, errno, msg;\n  END;\n  INSERT INTO t1 (c1) VALUES('string 1');\n  INSERT INTO t1 (c1) VALUES(NULL);\nEND;\n//\ndelimiter ;\nCALL p();\nSELECT * FROM t1;"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/resignal.html"], "Title": ["15.6.7.4 RESIGNAL Statement"], "Feature": ["RESIGNAL [condition_value]\n    [SET signal_information_item\n    [, signal_information_item] ...]\n\ncondition_value: {\n    SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n}\n\nsignal_information_item:\n    condition_information_item_name = simple_value_specification\n\ncondition_information_item_name: {\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n}\n\ncondition_name, simple_value_specification:\n    (see following discussion)"], "Description": ["\nRESIGNAL passes on the error\n        condition information that is available during execution of a\n        condition handler within a compound statement inside a stored\n        procedure or function, trigger, or event.\n        RESIGNAL may change some or all\n        information before passing it on.\n        RESIGNAL is related to\n        SIGNAL, but instead of\n        originating a condition as SIGNAL\n        does, RESIGNAL relays existing\n        condition information, possibly after modifying it.\n      ", "\nRESIGNAL makes it possible to\n        both handle an error and return the error information.\n        Otherwise, by executing an SQL statement within the handler,\n        information that caused the handler's activation is destroyed.\n        RESIGNAL also can make some\n        procedures shorter if a given handler can handle part of a\n        situation, then pass the condition \u201cup the line\u201d to\n        another handler.\n      ", "\n        No privileges are required to execute the\n        RESIGNAL statement.\n      ", "\n        All forms of RESIGNAL require\n        that the current context be a condition handler. Otherwise,\n        RESIGNAL is illegal and a\n        RESIGNAL when handler not active error\n        occurs.\n      ", "\n        To retrieve information from the diagnostics area, use the\n        GET DIAGNOSTICS statement (see\n        Section\u00a015.6.7.3, \u201cGET DIAGNOSTICS Statement\u201d). For information about the\n        diagnostics area, see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n", "\nRESIGNAL OverviewRESIGNAL AloneRESIGNAL with New Signal InformationRESIGNAL with a Condition Value and Optional New Signal InformationRESIGNAL Requires Condition Handler Context\n", "\n\n\n\nRESIGNAL Overview\n\n\n\n\n          For condition_value and\n          signal_information_item, the\n          definitions and rules are the same for\n          RESIGNAL as for\n          SIGNAL. For example, the\n          condition_value can be an\n          SQLSTATE value, and the value can indicate\n          errors, warnings, or \u201cnot found.\u201d For additional\n          information, see Section\u00a015.6.7.5, \u201cSIGNAL Statement\u201d.\n        \n          The RESIGNAL statement takes\n          condition_value and\n          SET clauses, both of which are optional.\n          This leads to several possible uses:\n\n\n\nRESIGNAL alone:\n            Press CTRL+C to copy RESIGNAL;\nRESIGNAL with new signal\n              information:\n            Press CTRL+C to copy RESIGNAL SET signal_information_item [, signal_information_item] ...;\nRESIGNAL with a condition\n              value and possibly new signal information:\n            Press CTRL+C to copy RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];\n\n\n          These use cases all cause changes to the diagnostics and\n          condition areas:\n\n\n\n              A diagnostics area contains one or more condition areas.\n            \n              A condition area contains condition information items,\n              such as the SQLSTATE value,\n              MYSQL_ERRNO, or\n              MESSAGE_TEXT.\n\n\n\n          There is a stack of diagnostics areas. When a handler takes\n          control, it pushes a diagnostics area to the top of the stack,\n          so there are two diagnostics areas during handler execution:\n\n\n\n              The first (current) diagnostics area, which starts as a\n              copy of the last diagnostics area, but is overwritten by\n              the first statement in the handler that changes the\n              current diagnostics area.\n            \n              The last (stacked) diagnostics area, which has the\n              condition areas that were set up before the handler took\n              control.\n\n\n\n          The maximum number of condition areas in a diagnostics area is\n          determined by the value of the\n          max_error_count system\n          variable. See\n          Diagnostics Area-Related System Variables.\n\n", "\n\n\n\nRESIGNAL Alone\n\n\n\n\n          A simple RESIGNAL alone means\n          \u201cpass on the error with no change.\u201d It restores\n          the last diagnostics area and makes it the current diagnostics\n          area. That is, it \u201cpops\u201d the diagnostics area\n          stack.\n        \n          Within a condition handler that catches a condition, one use\n          for RESIGNAL alone is to\n          perform some other actions, and then pass on without change\n          the original condition information (the information that\n          existed before entry into the handler).\n        \n          Example:\n        Press CTRL+C to copy DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();\n          Suppose that the DROP TABLE xx statement\n          fails. The diagnostics area stack looks like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\n          Then execution enters the EXIT handler. It\n          starts by pushing a diagnostics area to the top of the stack,\n          which now looks like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\nDA 2. ERROR 1051 (42S02): Unknown table 'xx'\n          At this point, the contents of the first (current) and second\n          (stacked) diagnostics areas are the same. The first\n          diagnostics area may be modified by statements executing\n          subsequently within the handler.\n        \n          Usually a procedure statement clears the first diagnostics\n          area. BEGIN is an exception, it does not\n          clear, it does nothing. SET is not an\n          exception, it clears, performs the operation, and produces a\n          result of \u201csuccess.\u201d The diagnostics area stack\n          now looks like this:\n        Press CTRL+C to copy DA 1. ERROR 0000 (00000): Successful operation\nDA 2. ERROR 1051 (42S02): Unknown table 'xx'\n          At this point, if @a = 0,\n          RESIGNAL pops the diagnostics\n          area stack, which now looks like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\n          And that is what the caller sees.\n        \n          If @a is not 0, the handler simply ends,\n          which means that there is no more use for the current\n          diagnostics area (it has been \u201chandled\u201d), so it\n          can be thrown away, causing the stacked diagnostics area to\n          become the current diagnostics area again. The diagnostics\n          area stack looks like this:\n        Press CTRL+C to copy DA 1. ERROR 0000 (00000): Successful operation\n          The details make it look complex, but the end result is quite\n          useful: Handlers can execute without destroying information\n          about the condition that caused activation of the handler.\n\n", "\n\n\n\nRESIGNAL with New Signal Information\n\n\n\n\nRESIGNAL with a\n          SET clause provides new signal information,\n          so the statement means \u201cpass on the error with\n          changes\u201d:\n        Press CTRL+C to copy RESIGNAL SET signal_information_item [, signal_information_item] ...;\n          As with RESIGNAL alone, the\n          idea is to pop the diagnostics area stack so that the original\n          information goes out. Unlike\n          RESIGNAL alone, anything\n          specified in the SET clause changes.\n        \n          Example:\n        Press CTRL+C to copy DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();\n          Remember from the previous discussion that\n          RESIGNAL alone results in a\n          diagnostics area stack like this:\n        Press CTRL+C to copy DA 1. ERROR 1051 (42S02): Unknown table 'xx'\n          The RESIGNAL SET MYSQL_ERRNO = 5 statement\n          results in this stack instead, which is what the caller sees:\n        Press CTRL+C to copy DA 1. ERROR 5 (42S02): Unknown table 'xx'\n          In other words, it changes the error number, and nothing else.\n        \n          The RESIGNAL statement can\n          change any or all of the signal information items, making the\n          first condition area of the diagnostics area look quite\n          different.\n\n", "\n\n\n\nRESIGNAL with a Condition Value and Optional New Signal Information\n\n\n\n\nRESIGNAL with a condition value\n          means \u201cpush a condition into the current diagnostics\n          area.\u201d If the SET clause is present,\n          it also changes the error information.\n        Press CTRL+C to copy RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];\n          This form of RESIGNAL restores\n          the last diagnostics area and makes it the current diagnostics\n          area. That is, it \u201cpops\u201d the diagnostics area\n          stack, which is the same as what a simple\n          RESIGNAL alone would do.\n          However, it also changes the diagnostics area depending on the\n          condition value or signal information.\n        \n          Example:\n        Press CTRL+C to copy DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nSET @@max_error_count = 2;\nCALL p();\nSHOW ERRORS;\n          This is similar to the previous example, and the effects are\n          the same, except that if\n          RESIGNAL happens, the current\n          condition area looks different at the end. (The reason the\n          condition adds to rather than replaces the existing condition\n          is the use of a condition value.)\n        \n          The RESIGNAL statement includes\n          a condition value (SQLSTATE '45000'), so it\n          adds a new condition area, resulting in a diagnostics area\n          stack that looks like this:\n        Press CTRL+C to copy DA 1. (condition 2) ERROR 1051 (42S02): Unknown table 'xx'\n      (condition 1) ERROR 5 (45000) Unknown table 'xx'\n          The result of CALL\n          p() and SHOW ERRORS\n          for this example is:\n        Press CTRL+C to copy mysql> CALL p();\nERROR 5 (45000): Unknown table 'xx'\nmysql> SHOW ERRORS;\n+-------+------+----------------------------------+\n| Level | Code | Message                          |\n+-------+------+----------------------------------+\n| Error | 1051 | Unknown table 'xx'               |\n| Error |    5 | Unknown table 'xx'               |\n+-------+------+----------------------------------+\n", "\n\n\n\nRESIGNAL Requires Condition Handler Context\n\n\n\n\n          All forms of RESIGNAL require\n          that the current context be a condition handler. Otherwise,\n          RESIGNAL is illegal and a\n          RESIGNAL when handler not active error\n          occurs. For example:\n        Press CTRL+C to copy mysql> CREATE PROCEDURE p () RESIGNAL;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL p();\nERROR 1645 (0K000): RESIGNAL when handler not active\n          Here is a more difficult example:\n        Press CTRL+C to copy delimiter //\nCREATE FUNCTION f () RETURNS INT\nBEGIN\n  RESIGNAL;\n  RETURN 5;\nEND//\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();\n  SIGNAL SQLSTATE '55555';\nEND//\ndelimiter ;\nCALL p();\nRESIGNAL occurs within the\n          stored function f(). Although\n          f() itself is invoked within the context of\n          the EXIT handler, execution within\n          f() has its own context, which is not\n          handler context. Thus, RESIGNAL within\n          f() results in a \u201chandler not\n          active\u201d error.\n\n"], "Examples": ["RESIGNAL;", "RESIGNAL SET signal_information_item [, signal_information_item] ...;", "RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];", "DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();", "RESIGNAL SET signal_information_item [, signal_information_item] ...;", "DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nCALL p();", "RESIGNAL condition_value\n    [SET signal_information_item [, signal_information_item] ...];", "DROP TABLE IF EXISTS xx;\ndelimiter //\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SET @error_count = @error_count + 1;\n    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;\n  END;\n  DROP TABLE xx;\nEND//\ndelimiter ;\nSET @error_count = 0;\nSET @a = 0;\nSET @@max_error_count = 2;\nCALL p();\nSHOW ERRORS;", "mysql> CALL p();\nERROR 5 (45000): Unknown table 'xx'\nmysql> SHOW ERRORS;\n+-------+------+----------------------------------+\n| Level | Code | Message                          |\n+-------+------+----------------------------------+\n| Error | 1051 | Unknown table 'xx'               |\n| Error |    5 | Unknown table 'xx'               |\n+-------+------+----------------------------------+", "mysql> CREATE PROCEDURE p () RESIGNAL;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL p();\nERROR 1645 (0K000): RESIGNAL when handler not active", "delimiter //\nCREATE FUNCTION f () RETURNS INT\nBEGIN\n  RESIGNAL;\n  RETURN 5;\nEND//\nCREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();\n  SIGNAL SQLSTATE '55555';\nEND//\ndelimiter ;\nCALL p();"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/signal.html"], "Title": ["15.6.7.5 SIGNAL Statement"], "Feature": ["SIGNAL condition_value\n    [SET signal_information_item\n    [, signal_information_item] ...]\n\ncondition_value: {\n    SQLSTATE [VALUE] sqlstate_value\n  | condition_name\n}\n\nsignal_information_item:\n    condition_information_item_name = simple_value_specification\n\ncondition_information_item_name: {\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n}\n\ncondition_name, simple_value_specification:\n    (see following discussion)"], "Description": ["\nSIGNAL is the way to\n        \u201creturn\u201d an error.\n        SIGNAL provides error information\n        to a handler, to an outer portion of the application, or to the\n        client. Also, it provides control over the error's\n        characteristics (error number, SQLSTATE\n        value, message). Without SIGNAL,\n        it is necessary to resort to workarounds such as deliberately\n        referring to a nonexistent table to cause a routine to return an\n        error.\n      ", "\n        No privileges are required to execute the\n        SIGNAL statement.\n      ", "\n        To retrieve information from the diagnostics area, use the\n        GET DIAGNOSTICS statement (see\n        Section\u00a015.6.7.3, \u201cGET DIAGNOSTICS Statement\u201d). For information about the\n        diagnostics area, see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n", "\nSIGNAL OverviewSignal Condition Information ItemsEffect of Signals on Handlers, Cursors, and Statements\n", "\n\n\n\nSIGNAL Overview\n\n\n\n\n          The condition_value in a\n          SIGNAL statement indicates the\n          error value to be returned. It can be an\n          SQLSTATE value (a 5-character string\n          literal) or a condition_name that\n          refers to a named condition previously defined with\n          DECLARE ...\n          CONDITION (see Section\u00a015.6.7.1, \u201cDECLARE ... CONDITION Statement\u201d).\n        \n          An SQLSTATE value can indicate errors,\n          warnings, or \u201cnot found.\u201d The first two\n          characters of the value indicate its error class, as discussed\n          in Signal Condition Information Items. Some\n          signal values cause statement termination; see\n          Effect of Signals on Handlers, Cursors, and Statements.\n        \n          The SQLSTATE value for a\n          SIGNAL statement should not\n          start with '00' because such values\n          indicate success and are not valid for signaling an error.\n          This is true whether the SQLSTATE value is\n          specified directly in the\n          SIGNAL statement or in a named\n          condition referred to in the statement. If the value is\n          invalid, a Bad SQLSTATE error occurs.\n        \n          To signal a generic SQLSTATE value, use\n          '45000', which means \u201cunhandled\n          user-defined exception.\u201d\n\n          The SIGNAL statement optionally\n          includes a SET clause that contains\n          multiple signal items, in a list of\n          condition_information_item_name =\n          simple_value_specification\n          assignments, separated by commas.\n        \n          Each\n          condition_information_item_name may\n          be specified only once in the SET clause.\n          Otherwise, a Duplicate condition information\n          item error occurs.\n        \n          Valid simple_value_specification\n          designators can be specified using stored procedure or\n          function parameters, stored program local variables declared\n          with DECLARE, user-defined\n          variables, system variables, or literals. A character literal\n          may include a _charset introducer.\n        \n          For information about permissible\n          condition_information_item_name\n          values, see\n          Signal Condition Information Items.\n        \n          The following procedure signals an error or warning depending\n          on the value of pval, its input parameter:\n        Press CTRL+C to copy CREATE PROCEDURE p (pval INT)\nBEGIN\n  DECLARE specialty CONDITION FOR SQLSTATE '45000';\n  IF pval = 0 THEN\n    SIGNAL SQLSTATE '01000';\n  ELSEIF pval = 1 THEN\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSEIF pval = 2 THEN\n    SIGNAL specialty\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSE\n    SIGNAL SQLSTATE '01000'\n      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;\n  END IF;\nEND;\n          If pval is 0, p()\n          signals a warning because SQLSTATE values\n          that begin with '01' are signals in the\n          warning class. The warning does not terminate the procedure,\n          and can be seen with SHOW\n          WARNINGS after the procedure returns.\n        \n          If pval is 1, p()\n          signals an error and sets the MESSAGE_TEXT\n          condition information item. The error terminates the\n          procedure, and the text is returned with the error\n          information.\n        \n          If pval is 2, the same error is signaled,\n          although the SQLSTATE value is specified\n          using a named condition in this case.\n        \n          If pval is anything else,\n          p() first signals a warning and sets the\n          message text and error number condition information items.\n          This warning does not terminate the procedure, so execution\n          continues and p() then signals an error.\n          The error does terminate the procedure. The message text and\n          error number set by the warning are replaced by the values set\n          by the error, which are returned with the error information.\n        \nSIGNAL is typically used within\n          stored programs, but it is a MySQL extension that it is\n          permitted outside handler context. For example, if you invoke\n          the mysql client program, you can enter any\n          of these statements at the prompt:\n        Press CTRL+C to copy SIGNAL SQLSTATE '77777';\n\nCREATE TRIGGER t_bi BEFORE INSERT ON t\n  FOR EACH ROW SIGNAL SQLSTATE '77777';\n\nCREATE EVENT e ON SCHEDULE EVERY 1 SECOND\n  DO SIGNAL SQLSTATE '77777';\nSIGNAL executes according to\n          the following rules:\n        \n          If the SIGNAL statement\n          indicates a particular SQLSTATE value, that\n          value is used to signal the condition specified. Example:\n        Press CTRL+C to copy CREATE PROCEDURE p (divisor INT)\nBEGIN\n  IF divisor = 0 THEN\n    SIGNAL SQLSTATE '22012';\n  END IF;\nEND;\n          If the SIGNAL statement uses a\n          named condition, the condition must be declared in some scope\n          that applies to the SIGNAL\n          statement, and must be defined using an\n          SQLSTATE value, not a MySQL error number.\n          Example:\n        Press CTRL+C to copy CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';\n  IF divisor = 0 THEN\n    SIGNAL divide_by_zero;\n  END IF;\nEND;\n          If the named condition does not exist in the scope of the\n          SIGNAL statement, an\n          Undefined CONDITION error occurs.\n        \n          If SIGNAL refers to a named\n          condition that is defined with a MySQL error number rather\n          than an SQLSTATE value, a\n          SIGNAL/RESIGNAL can only use a CONDITION defined with\n          SQLSTATE error occurs. The following statements\n          cause that error because the named condition is associated\n          with a MySQL error number:\n        Press CTRL+C to copy DECLARE no_such_table CONDITION FOR 1051;\nSIGNAL no_such_table;\n          If a condition with a given name is declared multiple times in\n          different scopes, the declaration with the most local scope\n          applies. Consider the following procedure:\n        Press CTRL+C to copy CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE my_error CONDITION FOR SQLSTATE '45000';\n  IF divisor = 0 THEN\n    BEGIN\n      DECLARE my_error CONDITION FOR SQLSTATE '22012';\n      SIGNAL my_error;\n    END;\n  END IF;\n  SIGNAL my_error;\nEND;\n          If divisor is 0, the first\n          SIGNAL statement executes. The\n          innermost my_error condition declaration\n          applies, raising SQLSTATE\n'22012'.\n        \n          If divisor is not 0, the second\n          SIGNAL statement executes. The\n          outermost my_error condition declaration\n          applies, raising SQLSTATE\n'45000'.\n        \n          For information about how the server chooses handlers when a\n          condition occurs, see Section\u00a015.6.7.6, \u201cScope Rules for Handlers\u201d.\n        \n          Signals can be raised within exception handlers:\n        Press CTRL+C to copy CREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SIGNAL SQLSTATE VALUE '99999'\n      SET MESSAGE_TEXT = 'An error occurred';\n  END;\n  DROP TABLE no_such_table;\nEND;\nCALL p() reaches the\n          DROP TABLE statement. There is\n          no table named no_such_table, so the error\n          handler is activated. The error handler destroys the original\n          error (\u201cno such table\u201d) and makes a new error\n          with SQLSTATE '99999'\n          and message An error occurred.\n\n", "\n\n\n\nSignal Condition Information Items\n\n\n\n\n          The following table lists the names of diagnostics area\n          condition information items that can be set in a\n          SIGNAL (or\n          RESIGNAL) statement. All items\n          are standard SQL except MYSQL_ERRNO, which\n          is a MySQL extension. For more information about these items\n          see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n        Press CTRL+C to copy Item Name             Definition\n---------             ----------\nCLASS_ORIGIN          VARCHAR(64)\nSUBCLASS_ORIGIN       VARCHAR(64)\nCONSTRAINT_CATALOG    VARCHAR(64)\nCONSTRAINT_SCHEMA     VARCHAR(64)\nCONSTRAINT_NAME       VARCHAR(64)\nCATALOG_NAME          VARCHAR(64)\nSCHEMA_NAME           VARCHAR(64)\nTABLE_NAME            VARCHAR(64)\nCOLUMN_NAME           VARCHAR(64)\nCURSOR_NAME           VARCHAR(64)\nMESSAGE_TEXT          VARCHAR(128)\nMYSQL_ERRNO           SMALLINT UNSIGNED\n          The character set for character items is UTF-8.\n        \n          It is illegal to assign NULL to a condition\n          information item in a SIGNAL\n          statement.\n        \n          A SIGNAL statement always\n          specifies an SQLSTATE value, either\n          directly, or indirectly by referring to a named condition\n          defined with an SQLSTATE value. The first\n          two characters of an SQLSTATE value are its\n          class, and the class determines the default value for the\n          condition information items:\n\n\n\n              Class = '00' (success)\n            \n              Illegal. SQLSTATE values that begin\n              with '00' indicate success and are not\n              valid for SIGNAL.\n            \n              Class = '01' (warning)\n            Press CTRL+C to copy MESSAGE_TEXT = 'Unhandled user-defined warning condition';\nMYSQL_ERRNO = ER_SIGNAL_WARN\n              Class = '02' (not found)\n            Press CTRL+C to copy MESSAGE_TEXT = 'Unhandled user-defined not found condition';\nMYSQL_ERRNO = ER_SIGNAL_NOT_FOUND\n              Class > '02' (exception)\n            Press CTRL+C to copy MESSAGE_TEXT = 'Unhandled user-defined exception condition';\nMYSQL_ERRNO = ER_SIGNAL_EXCEPTION\n\n\n          For legal classes, the other condition information items are\n          set as follows:\n        Press CTRL+C to copy CLASS_ORIGIN = SUBCLASS_ORIGIN = '';\nCONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';\nCATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';\nCURSOR_NAME = '';\n          The error values that are accessible after\n          SIGNAL executes are the\n          SQLSTATE value raised by the\n          SIGNAL statement and the\n          MESSAGE_TEXT and\n          MYSQL_ERRNO items. These values are\n          available from the C API:\n\n\n\nmysql_sqlstate() returns\n              the SQLSTATE value.\n            \nmysql_errno() returns the\n              MYSQL_ERRNO value.\n            \nmysql_error() returns the\n              MESSAGE_TEXT value.\n\n\n\n          At the SQL level, the output from SHOW\n          WARNINGS and SHOW\n          ERRORS indicates the MYSQL_ERRNO\n          and MESSAGE_TEXT values in the\n          Code and Message\n          columns.\n        \n          To retrieve information from the diagnostics area, use the\n          GET DIAGNOSTICS statement (see\n          Section\u00a015.6.7.3, \u201cGET DIAGNOSTICS Statement\u201d). For information about the\n          diagnostics area, see Section\u00a015.6.7.7, \u201cThe MySQL Diagnostics Area\u201d.\n\n", "\n\n\n\nEffect of Signals on Handlers, Cursors, and Statements\n\n\n\n\n          Signals have different effects on statement execution\n          depending on the signal class. The class determines how severe\n          an error is. MySQL ignores the value of the\n          sql_mode system variable; in\n          particular, strict SQL mode does not matter. MySQL also\n          ignores IGNORE: The intent of\n          SIGNAL is to raise a\n          user-generated error explicitly, so a signal is never ignored.\n        \n          In the following descriptions, \u201cunhandled\u201d means\n          that no handler for the signaled SQLSTATE\n          value has been defined with\n          DECLARE ...\n          HANDLER.\n\n\n\n              Class = '00' (success)\n            \n              Illegal. SQLSTATE values that begin\n              with '00' indicate success and are not\n              valid for SIGNAL.\n            \n              Class = '01' (warning)\n            \n              The value of the\n              warning_count system\n              variable goes up. SHOW\n              WARNINGS shows the signal.\n              SQLWARNING handlers catch the signal.\n            \n              Warnings cannot be returned from stored functions because\n              the RETURN statement that\n              causes the function to return clears the diagnostic area.\n              The statement thus clears any warnings that may have been\n              present there (and resets\n              warning_count to 0).\n            \n              Class = '02' (not found)\n            \nNOT FOUND handlers catch the signal.\n              There is no effect on cursors. If the signal is unhandled\n              in a stored function, statements end.\n            \n              Class > '02' (exception)\n            \nSQLEXCEPTION handlers catch the signal.\n              If the signal is unhandled in a stored function,\n              statements end.\n            \n              Class = '40'\n\n              Treated as an ordinary exception.\n\n\n"], "Examples": ["CREATE PROCEDURE p (pval INT)\nBEGIN\n  DECLARE specialty CONDITION FOR SQLSTATE '45000';\n  IF pval = 0 THEN\n    SIGNAL SQLSTATE '01000';\n  ELSEIF pval = 1 THEN\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSEIF pval = 2 THEN\n    SIGNAL specialty\n      SET MESSAGE_TEXT = 'An error occurred';\n  ELSE\n    SIGNAL SQLSTATE '01000'\n      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;\n    SIGNAL SQLSTATE '45000'\n      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;\n  END IF;\nEND;", "SIGNAL SQLSTATE '77777';\n\nCREATE TRIGGER t_bi BEFORE INSERT ON t\n  FOR EACH ROW SIGNAL SQLSTATE '77777';\n\nCREATE EVENT e ON SCHEDULE EVERY 1 SECOND\n  DO SIGNAL SQLSTATE '77777';", "CREATE PROCEDURE p (divisor INT)\nBEGIN\n  IF divisor = 0 THEN\n    SIGNAL SQLSTATE '22012';\n  END IF;\nEND;", "CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';\n  IF divisor = 0 THEN\n    SIGNAL divide_by_zero;\n  END IF;\nEND;", "DECLARE no_such_table CONDITION FOR 1051;\nSIGNAL no_such_table;", "CREATE PROCEDURE p (divisor INT)\nBEGIN\n  DECLARE my_error CONDITION FOR SQLSTATE '45000';\n  IF divisor = 0 THEN\n    BEGIN\n      DECLARE my_error CONDITION FOR SQLSTATE '22012';\n      SIGNAL my_error;\n    END;\n  END IF;\n  SIGNAL my_error;\nEND;", "CREATE PROCEDURE p ()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SIGNAL SQLSTATE VALUE '99999'\n      SET MESSAGE_TEXT = 'An error occurred';\n  END;\n  DROP TABLE no_such_table;\nEND;", "MESSAGE_TEXT = 'Unhandled user-defined warning condition';\nMYSQL_ERRNO = ER_SIGNAL_WARN", "MESSAGE_TEXT = 'Unhandled user-defined not found condition';\nMYSQL_ERRNO = ER_SIGNAL_NOT_FOUND", "MESSAGE_TEXT = 'Unhandled user-defined exception condition';\nMYSQL_ERRNO = ER_SIGNAL_EXCEPTION", "CLASS_ORIGIN = SUBCLASS_ORIGIN = '';\nCONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';\nCATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';\nCURSOR_NAME = '';"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/statement-labels.html"], "Title": ["15.6.2 Statement Labels"], "Feature": ["[begin_label:] BEGIN\n    [statement_list]\nEND [end_label]\n\n[begin_label:] LOOP\n    statement_list\nEND LOOP [end_label]\n\n[begin_label:] REPEAT\n    statement_list\nUNTIL search_condition\nEND REPEAT [end_label]\n\n[begin_label:] WHILE search_condition DO\n    statement_list\nEND WHILE [end_label]"], "Description": ["\n      Labels are permitted for\n      BEGIN ... END\n      blocks and for the LOOP,\n      REPEAT, and\n      WHILE statements. Label use for\n      those statements follows these rules:\n", "\n\nbegin_label must be followed by a\n          colon.\n        \nbegin_label can be given without\n          end_label. If\n          end_label is present, it must be\n          the same as begin_label.\n        \nend_label cannot be given without\n          begin_label.\n        \n          Labels at the same nesting level must be distinct.\n        \n          Labels can be up to 16 characters long.\n\n", "\n      To refer to a label within the labeled construct, use an\n      ITERATE or\n      LEAVE statement. The following\n      example uses those statements to continue iterating or terminate\n      the loop:\n    ", "Press CTRL+C to copy CREATE PROCEDURE doiterate(p1 INT)\nBEGIN\n  label1: LOOP\n    SET p1 = p1 + 1;\n    IF p1 < 10 THEN ITERATE label1; END IF;\n    LEAVE label1;\n  END LOOP label1;\nEND;", "\n      The scope of a block label does not include the code for handlers\n      declared within the block. For details, see\n      Section\u00a015.6.7.2, \u201cDECLARE ... HANDLER Statement\u201d.\n"], "Examples": ["CREATE PROCEDURE doiterate(p1 INT)\nBEGIN\n  label1: LOOP\n    SET p1 = p1 + 1;\n    IF p1 < 10 THEN ITERATE label1; END IF;\n    LEAVE label1;\n  END LOOP label1;\nEND;"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/declare-local-variable.html"], "Title": ["15.6.4.1 Local Variable DECLARE Statement"], "Feature": ["DECLARE var_name [, var_name] ... type [DEFAULT value]"], "Description": ["\n        This statement declares local variables within stored programs.\n        To provide a default value for a variable, include a\n        DEFAULT clause. The value can be specified as\n        an expression; it need not be a constant. If the\n        DEFAULT clause is missing, the initial value\n        is NULL.\n      ", "\n        Local variables are treated like stored routine parameters with\n        respect to data type and overflow checking. See\n        Section\u00a015.1.17, \u201cCREATE PROCEDURE and CREATE FUNCTION Statements\u201d.\n      ", "\n        Variable declarations must appear before cursor or handler\n        declarations.\n      ", "\n        Local variable names are not case-sensitive. Permissible\n        characters and quoting rules are the same as for other\n        identifiers, as described in Section\u00a011.2, \u201cSchema Object Names\u201d.\n      ", "\n        The scope of a local variable is the\n        BEGIN ...\n        END block within which it is declared. The variable\n        can be referred to in blocks nested within the declaring block,\n        except those blocks that declare a variable with the same name.\n      ", "\n        For examples of variable declarations, see\n        Section\u00a015.6.4.2, \u201cLocal Variable Scope and Resolution\u201d.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/case.html"], "Title": ["15.6.5.1 CASE Statement"], "Feature": ["CASE case_value\n    WHEN when_value THEN statement_list\n    [WHEN when_value THEN statement_list] ...\n    [ELSE statement_list]\nEND CASE", "CASE\n    WHEN search_condition THEN statement_list\n    [WHEN search_condition THEN statement_list] ...\n    [ELSE statement_list]\nEND CASE"], "Description": ["\n        Or:\n      ", "\n        The CASE statement for stored\n        programs implements a complex conditional construct.\n", "\n\nNote\n\n\n          There is also a CASE\noperator, which differs from the\n          CASE\nstatement described here. See\n          Section\u00a014.5, \u201cFlow Control Functions\u201d. The\n          CASE statement cannot have an\n          ELSE NULL clause, and it is terminated with\n          END CASE instead of END.\n\n", "\n        For the first syntax, case_value is\n        an expression. This value is compared to the\n        when_value expression in each\n        WHEN clause until one of them is equal. When\n        an equal when_value is found, the\n        corresponding THEN clause\n        statement_list executes. If no\n        when_value is equal, the\n        ELSE clause\n        statement_list executes, if there is\n        one.\n      ", "\n        This syntax cannot be used to test for equality with\n        NULL because NULL = NULL\n        is false. See Section\u00a05.3.4.6, \u201cWorking with NULL Values\u201d.\n      ", "\n        For the second syntax, each WHEN clause\n        search_condition expression is\n        evaluated until one is true, at which point its corresponding\n        THEN clause\n        statement_list executes. If no\n        search_condition is equal, the\n        ELSE clause\n        statement_list executes, if there is\n        one.\n      ", "\n        If no when_value or\n        search_condition matches the value\n        tested and the CASE statement\n        contains no ELSE clause, a Case\n        not found for CASE statement error results.\n      ", "\n        Each statement_list consists of one\n        or more SQL statements; an empty\n        statement_list is not permitted.\n      ", "\n        To handle situations where no value is matched by any\n        WHEN clause, use an ELSE\n        containing an empty\n        BEGIN ...\n        END block, as shown in this example. (The indentation\n        used here in the ELSE clause is for purposes\n        of clarity only, and is not otherwise significant.)\n      ", "Press CTRL+C to copy DELIMITER |\n\nCREATE PROCEDURE p()\n  BEGIN\n    DECLARE v INT DEFAULT 1;\n\n    CASE v\n      WHEN 2 THEN SELECT v;\n      WHEN 3 THEN SELECT 0;\n      ELSE\n        BEGIN\n        END;\n    END CASE;\n  END;\n  |"], "Examples": ["DELIMITER |\n\nCREATE PROCEDURE p()\n  BEGIN\n    DECLARE v INT DEFAULT 1;\n\n    CASE v\n      WHEN 2 THEN SELECT v;\n      WHEN 3 THEN SELECT 0;\n      ELSE\n        BEGIN\n        END;\n    END CASE;\n  END;\n  |"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/if.html"], "Title": ["15.6.5.2 IF Statement"], "Feature": ["IF search_condition THEN statement_list\n    [ELSEIF search_condition THEN statement_list] ...\n    [ELSE statement_list]\nEND IF"], "Description": ["\n        The IF statement for stored\n        programs implements a basic conditional construct.\n", "\n\nNote\n\n\n          There is also an IF()\nfunction, which differs from the\n          IF\nstatement described here. See\n          Section\u00a014.5, \u201cFlow Control Functions\u201d. The\n          IF statement can have\n          THEN, ELSE, and\n          ELSEIF clauses, and it is terminated with\n          END IF.\n\n", "\n        If a given search_condition evaluates\n        to true, the corresponding THEN or\n        ELSEIF clause\n        statement_list executes. If no\n        search_condition matches, the\n        ELSE clause\n        statement_list executes.\n      ", "\n        Each statement_list consists of one\n        or more SQL statements; an empty\n        statement_list is not permitted.\n      ", "\n        An IF ... END IF block, like all other\n        flow-control blocks used within stored programs, must be\n        terminated with a semicolon, as shown in this example:\n      ", "Press CTRL+C to copy DELIMITER //\n\nCREATE FUNCTION SimpleCompare(n INT, m INT)\n  RETURNS VARCHAR(20)\n\n  BEGIN\n    DECLARE s VARCHAR(20);\n\n    IF n > m THEN SET s = '>';\n    ELSEIF n = m THEN SET s = '=';\n    ELSE SET s = '<';\n    END IF;\n\n    SET s = CONCAT(n, ' ', s, ' ', m);\n\n    RETURN s;\n  END //\n\nDELIMITER ;", "\n        As with other flow-control constructs, IF ... END\n        IF blocks may be nested within other flow-control\n        constructs, including other IF\n        statements. Each IF must be\n        terminated by its own END IF followed by a\n        semicolon. You can use indentation to make nested flow-control\n        blocks more easily readable by humans (although this is not\n        required by MySQL), as shown here:\n      ", "Press CTRL+C to copy DELIMITER //\n\nCREATE FUNCTION VerboseCompare (n INT, m INT)\n  RETURNS VARCHAR(50)\n\n  BEGIN\n    DECLARE s VARCHAR(50);\n\n    IF n = m THEN SET s = 'equals';\n    ELSE\n      IF n > m THEN SET s = 'greater';\n      ELSE SET s = 'less';\n      END IF;\n\n      SET s = CONCAT('is ', s, ' than');\n    END IF;\n\n    SET s = CONCAT(n, ' ', s, ' ', m, '.');\n\n    RETURN s;\n  END //\n\nDELIMITER ;", "\n        In this example, the inner IF is\n        evaluated only if n is not equal to\n        m.\n"], "Examples": ["DELIMITER //\n\nCREATE FUNCTION SimpleCompare(n INT, m INT)\n  RETURNS VARCHAR(20)\n\n  BEGIN\n    DECLARE s VARCHAR(20);\n\n    IF n > m THEN SET s = '>';\n    ELSEIF n = m THEN SET s = '=';\n    ELSE SET s = '<';\n    END IF;\n\n    SET s = CONCAT(n, ' ', s, ' ', m);\n\n    RETURN s;\n  END //\n\nDELIMITER ;", "DELIMITER //\n\nCREATE FUNCTION VerboseCompare (n INT, m INT)\n  RETURNS VARCHAR(50)\n\n  BEGIN\n    DECLARE s VARCHAR(50);\n\n    IF n = m THEN SET s = 'equals';\n    ELSE\n      IF n > m THEN SET s = 'greater';\n      ELSE SET s = 'less';\n      END IF;\n\n      SET s = CONCAT('is ', s, ' than');\n    END IF;\n\n    SET s = CONCAT(n, ' ', s, ' ', m, '.');\n\n    RETURN s;\n  END //\n\nDELIMITER ;"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/iterate.html"], "Title": ["15.6.5.3 ITERATE Statement"], "Feature": ["ITERATE label"], "Description": ["\nITERATE can appear only within\n        LOOP,\n        REPEAT, and\n        WHILE statements.\n        ITERATE means \u201cstart the\n        loop again.\u201d\n", "\n        For an example, see Section\u00a015.6.5.5, \u201cLOOP Statement\u201d.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/leave.html"], "Title": ["15.6.5.4 LEAVE Statement"], "Feature": ["LEAVE label"], "Description": ["\n        This statement is used to exit the flow control construct that\n        has the given label. If the label is for the outermost stored\n        program block, LEAVE exits the\n        program.\n      ", "\nLEAVE can be used within\n        BEGIN ...\n        END or loop constructs\n        (LOOP,\n        REPEAT,\n        WHILE).\n      ", "\n        For an example, see Section\u00a015.6.5.5, \u201cLOOP Statement\u201d.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/loop.html"], "Title": ["15.6.5.5 LOOP Statement"], "Feature": ["[begin_label:] LOOP\n    statement_list\nEND LOOP [end_label]"], "Description": ["\nLOOP implements a simple loop\n        construct, enabling repeated execution of the statement list,\n        which consists of one or more statements, each terminated by a\n        semicolon (;) statement delimiter. The\n        statements within the loop are repeated until the loop is\n        terminated. Usually, this is accomplished with a\n        LEAVE statement. Within a stored\n        function, RETURN can also be\n        used, which exits the function entirely.\n      ", "\n        Neglecting to include a loop-termination statement results in an\n        infinite loop.\n      ", "\n        A LOOP statement can be labeled.\n        For the rules regarding label use, see\n        Section\u00a015.6.2, \u201cStatement Labels\u201d.\n      ", "\n        Example:\n      ", "Press CTRL+C to copy CREATE PROCEDURE doiterate(p1 INT)\nBEGIN\n  label1: LOOP\n    SET p1 = p1 + 1;\n    IF p1 < 10 THEN\n      ITERATE label1;\n    END IF;\n    LEAVE label1;\n  END LOOP label1;\n  SET @x = p1;\nEND;"], "Examples": ["CREATE PROCEDURE doiterate(p1 INT)\nBEGIN\n  label1: LOOP\n    SET p1 = p1 + 1;\n    IF p1 < 10 THEN\n      ITERATE label1;\n    END IF;\n    LEAVE label1;\n  END LOOP label1;\n  SET @x = p1;\nEND;"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/repeat.html"], "Title": ["15.6.5.6 REPEAT Statement"], "Feature": ["[begin_label:] REPEAT\n    statement_list\nUNTIL search_condition\nEND REPEAT [end_label]"], "Description": ["\n        The statement list within a\n        REPEAT statement is repeated\n        until the search_condition expression\n        is true. Thus, a REPEAT always\n        enters the loop at least once.\n        statement_list consists of one or\n        more statements, each terminated by a semicolon\n        (;) statement delimiter.\n      ", "\n        A REPEAT statement can be\n        labeled. For the rules regarding label use, see\n        Section\u00a015.6.2, \u201cStatement Labels\u201d.\n      ", "\n        Example:\n      ", "Press CTRL+C to copy mysql> delimiter //\n\nmysql> CREATE PROCEDURE dorepeat(p1 INT)\n       BEGIN\n         SET @x = 0;\n         REPEAT\n           SET @x = @x + 1;\n         UNTIL @x > p1 END REPEAT;\n       END\n       //\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL dorepeat(1000)//\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @x//\n+------+\n| @x   |\n+------+\n| 1001 |\n+------+\n1 row in set (0.00 sec)"], "Examples": ["mysql> delimiter //\n\nmysql> CREATE PROCEDURE dorepeat(p1 INT)\n       BEGIN\n         SET @x = 0;\n         REPEAT\n           SET @x = @x + 1;\n         UNTIL @x > p1 END REPEAT;\n       END\n       //\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> CALL dorepeat(1000)//\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @x//\n+------+\n| @x   |\n+------+\n| 1001 |\n+------+\n1 row in set (0.00 sec)"], "Category": ["Compound Statement Syntax"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/return.html"], "Title": ["15.6.5.7 RETURN Statement"], "Feature": ["RETURN expr"], "Description": ["\n        The RETURN statement terminates\n        execution of a stored function and returns the value\n        expr to the function caller. There\n        must be at least one RETURN\n        statement in a stored function. There may be more than one if\n        the function has multiple exit points.\n      ", "\n        This statement is not used in stored procedures, triggers, or\n        events. The LEAVE statement can\n        be used to exit a stored program of those types.\n"], "Examples": [], "Category": ["Compound Statement Syntax"]}
