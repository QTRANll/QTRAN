{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/row-subqueries.html"], "Title": ["15.2.15.5 Row Subqueries"], "Feature": ["=  >  <  >=  <=  <>  !=  <=>", "SELECT * FROM t1 WHERE ROW(1) = (SELECT column1 FROM t2)"], "Description": ["\n        Scalar or column subqueries return a single value or a column of\n        values. A row subquery is a subquery\n        variant that returns a single row and can thus return more than\n        one column value. Legal operators for row subquery comparisons\n        are:\n      ", "\n        Here are two examples:\n      ", "Press CTRL+C to copy SELECT * FROM t1\n  WHERE (col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);\nSELECT * FROM t1\n  WHERE ROW(col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);", "\n        For both queries, if the table t2 contains a\n        single row with id = 10, the subquery returns\n        a single row. If this row has col3 and\n        col4 values equal to the\n        col1 and col2 values of\n        any rows in t1, the WHERE\n        expression is TRUE and each query returns\n        those t1 rows. If the t2\n        row col3 and col4 values\n        are not equal the col1 and\n        col2 values of any t1 row,\n        the expression is FALSE and the query returns\n        an empty result set. The expression is\n        unknown (that is, NULL)\n        if the subquery produces no rows. An error occurs if the\n        subquery produces multiple rows because a row subquery can\n        return at most one row.\n      ", "\n        For information about how each operator works for row\n        comparisons, see Section\u00a014.4.2, \u201cComparison Functions and Operators\u201d.\n      ", "\n        The expressions (1,2) and\n        ROW(1,2) are sometimes called\n        row constructors. The two\n        are equivalent. The row constructor and the row returned by the\n        subquery must contain the same number of values.\n      ", "\n        A row constructor is used for comparisons with subqueries that\n        return two or more columns. When a subquery returns a single\n        column, this is regarded as a scalar value and not as a row, so\n        a row constructor cannot be used with a subquery that does not\n        return at least two columns. Thus, the following query fails\n        with a syntax error:\n      ", "\n        Row constructors are legal in other contexts. For example, the\n        following two statements are semantically equivalent (and are\n        handled in the same way by the optimizer):\n      ", "Press CTRL+C to copy SELECT * FROM t1 WHERE (column1,column2) = (1,1);\nSELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;", "\n        The following query answers the request, \u201cfind all rows in\n        table t1 that also exist in table\n        t2\u201d:\n      ", "Press CTRL+C to copy SELECT column1,column2,column3\n  FROM t1\n  WHERE (column1,column2,column3) IN\n         (SELECT column1,column2,column3 FROM t2);", "\n        For more information about the optimizer and row constructors,\n        see Section\u00a010.2.1.22, \u201cRow Constructor Expression Optimization\u201d\n"], "Examples": ["SELECT * FROM t1\n  WHERE (col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);\nSELECT * FROM t1\n  WHERE ROW(col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);", "SELECT * FROM t1 WHERE (column1,column2) = (1,1);\nSELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;", "SELECT column1,column2,column3\n  FROM t1\n  WHERE (column1,column2,column3) IN\n         (SELECT column1,column2,column3 FROM t2);"], "Category": ["Prepared Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/prepare.html"], "Title": ["15.5.1 PREPARE Statement"], "Feature": ["PREPARE stmt_name FROM preparable_stmt"], "Description": ["\n      The PREPARE statement prepares a\n      SQL statement and assigns it a name,\n      stmt_name, by which to refer to the\n      statement later. The prepared statement is executed with\n      EXECUTE and released with\n      DEALLOCATE PREPARE. For examples,\n      see Section\u00a015.5, \u201cPrepared Statements\u201d.\n    ", "\n      Statement names are not case-sensitive.\n      preparable_stmt is either a string\n      literal or a user variable that contains the text of the SQL\n      statement. The text must represent a single statement, not\n      multiple statements. Within the statement, ?\n      characters can be used as parameter markers to indicate where data\n      values are to be bound to the query later when you execute it. The\n      ? characters should not be enclosed within\n      quotation marks, even if you intend to bind them to string values.\n      Parameter markers can be used only where data values should\n      appear, not for SQL keywords, identifiers, and so forth.\n    ", "\n      If a prepared statement with the given name already exists, it is\n      deallocated implicitly before the new statement is prepared. This\n      means that if the new statement contains an error and cannot be\n      prepared, an error is returned and no statement with the given\n      name exists.\n    ", "\n      The scope of a prepared statement is the session within which it\n      is created, which as several implications:\n", "\n\n          A prepared statement created in one session is not available\n          to other sessions.\n        \n          When a session ends, whether normally or abnormally, its\n          prepared statements no longer exist. If auto-reconnect is\n          enabled, the client is not notified that the connection was\n          lost. For this reason, clients may wish to disable\n          auto-reconnect. See Automatic Reconnection Control.\n        \n          A prepared statement created within a stored program continues\n          to exist after the program finishes executing and can be\n          executed outside the program later.\n        \n          A statement prepared in stored program context cannot refer to\n          stored procedure or function parameters or local variables\n          because they go out of scope when the program ends and would\n          be unavailable were the statement to be executed later outside\n          the program. As a workaround, refer instead to user-defined\n          variables, which also have session scope; see\n          Section\u00a011.4, \u201cUser-Defined Variables\u201d.\n\n", "\n      The type of a parameter used in a prepared statement is determined\n      when the statement is first prepared; it retains this type\n      whenever EXECUTE is invoked for\n      this prepared statement (unless the statement is reprepared, as\n      explained later in this section). Rules for determining a\n      parameter's type are listed here:\n", "\n\n          A parameter which is an operand of a binary arithmetic\n          operator has the same data type as the other operand.\n        \n          If both operands of a binary arithmetic operator are\n          parameters, the type of the parameters is decided by the\n          context of the operator.\n        \n          If a parameter is the operand of a unary arithmetic operator,\n          the parameter's type is decided by the context of the\n          operator.\n        \n          If an arithmetic operator has no type-determining context, the\n          derived type for any parameters involved is\n          DOUBLE PRECISION. This can\n          happen, for example, when the parameter is a top-level node in\n          a SELECT list, or when it is\n          part of a comparison operator.\n        \n          A parameter which is an operand of a character string operator\n          has the same derived type as the aggregated type of the other\n          operands. If all operands of the operator are parameters, the\n          derived type is VARCHAR; its\n          collation is determined by the value of\n          collation_connection.\n        \n          A parameter which is an operand of a temporal operator has\n          type DATETIME if the operator\n          returns a DATETIME,\n          TIME if the operator returns a\n          TIME, and\n          DATE if the operator returns a\n          DATE.\n        \n          A parameter which is an operand of a binary comparison\n          operator has the same derived type as the other operand of the\n          comparison.\n        \n          A parameter that is an operand of a ternary comparison\n          operator such as BETWEEN has the\n          same derived type as the aggregated type of the other\n          operands.\n        \n          If all operands of a comparison operator are parameters, the\n          derived type for each of them is\n          VARCHAR, with collation\n          determined by the value of\n          collation_connection.\n        \n          A parameter that is an output operand of any of\n          CASE,\n          COALESCE,\n          IF,\n          IFNULL, or\n          NULLIF has the same derived\n          type as the aggregated type of the operator's other\n          output operands.\n        \n          If all output operands of any of\n          CASE,\n          COALESCE,\n          IF,\n          IFNULL, or\n          NULLIF are parameters, or they\n          are all NULL, the type of the parameter is\n          decided by the context of the operator.\n        \n          If the parameter is an operand of any of\n          CASE,\n          COALESCE(),\n          IF, or\n          IFNULL, and has no\n          type-determining context, the derived type for each of the\n          parameters involved is VARCHAR,\n          and its collation is determined by the value of\n          collation_connection.\n        \n          A parameter which is the operand of a\n          CAST() has the same type as\n          specified by the CAST().\n        \n          If a parameter is an immediate member of a\n          SELECT list that is not part of\n          an INSERT statement, the\n          derived type of the parameter is\n          VARCHAR, and its collation is\n          determined by the value of\n          collation_connection.\n        \n          If a parameter is an immediate member of a\n          SELECT list that is part of an\n          INSERT statement, the derived\n          type of the parameter is the type of the corresponding column\n          into which the parameter is inserted.\n        \n          If a parameter is used as source for an assignment in a\n          SET clause of an\n          UPDATE statement or in the\n          ON DUPLICATE KEY UPDATE clause of an\n          INSERT statement, the derived\n          type of the parameter is the type of the corresponding column\n          which is updated by the SET or ON\n          DUPLICATE KEY UPDATE clause.\n        \n          If a parameter is an argument of a function, the derived type\n          depends on the function's return type.\n\n", "\n      For some combinations of actual type and derived type, an\n      automatic repreparation of the statement is triggered, to ensure\n      closer compatibility with previous versions of MySQL.\n      Repreparation does not occur if any of the following conditions\n      are true:\n", "\n\nNULL is used as the actual parameter value.\n        \n          A parameter is an operand of a\n          CAST(). (Instead, a cast to the\n          derived type is attempted, and an exception raised if the cast\n          fails.)\n        \n          A parameter is a string. (In this case, an implicit\n          CAST(? AS\n          derived_type) is\n          performed.)\n        \n          The derived type and actual type of the parameter are both\n          INTEGER and have the same sign.\n        \n          The parameter's derived type is\n          DECIMAL and its actual type is\n          either DECIMAL or\n          INTEGER.\n        \n          The derived type is DOUBLE and\n          the actual type is any numeric type.\n        \n          Both the derived type and the actual type are string types.\n        \n          If the derived type is temporal and the actual type is\n          temporal. Exceptions: The derived type is\n          TIME and the actual type is not\n          TIME; the derived type is\n          DATE and the actual type is not\n          DATE.\n        \n          The derived type is temporal and the actual type is numeric.\n\n", "\n      For cases other than those just listed, the statement is\n      reprepared and the actual parameter types are used instead of the\n      derived parameter types.\n    ", "\n      These rules also apply to a user variable referenced in a prepared\n      statement.\n    ", "\n      Using a different data type for a given parameter or user variable\n      within a prepared statement for executions of the statement\n      subsequent to the first execution causes the statement to be\n      reprepared. This is less efficient; it may also lead to the\n      parameter's (or variable's) actual type to vary, and\n      thus for results to be inconsistent, with subsequent executions of\n      the prepared statement. For these reasons, it is advisable to use\n      the same data type for a given parameter when re-executing a\n      prepared statement.\n"], "Examples": [], "Category": ["Prepared Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/execute.html"], "Title": ["15.5.2 EXECUTE Statement"], "Feature": ["EXECUTE stmt_name\n    [USING @var_name [, @var_name] ...]"], "Description": ["\n      After preparing a statement with\n      PREPARE, you execute it with an\n      EXECUTE statement that refers to\n      the prepared statement name. If the prepared statement contains\n      any parameter markers, you must supply a USING\n      clause that lists user variables containing the values to be bound\n      to the parameters. Parameter values can be supplied only by user\n      variables, and the USING clause must name\n      exactly as many variables as the number of parameter markers in\n      the statement.\n    ", "\n      You can execute a given prepared statement multiple times, passing\n      different variables to it or setting the variables to different\n      values before each execution.\n    ", "\n      For examples, see Section\u00a015.5, \u201cPrepared Statements\u201d.\n"], "Examples": [], "Category": ["Prepared Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/deallocate-prepare.html"], "Title": ["15.5.3 DEALLOCATE PREPARE Statement"], "Feature": ["{DEALLOCATE | DROP} PREPARE stmt_name"], "Description": ["\n      To deallocate a prepared statement produced with\n      PREPARE, use a\n      DEALLOCATE PREPARE statement that\n      refers to the prepared statement name. Attempting to execute a\n      prepared statement after deallocating it results in an error. If\n      too many prepared statements are created and not deallocated by\n      either the DEALLOCATE PREPARE statement or the\n      end of the session, you might encounter the upper limit enforced\n      by the max_prepared_stmt_count\n      system variable.\n    ", "\n      For examples, see Section\u00a015.5, \u201cPrepared Statements\u201d.\n"], "Examples": [], "Category": ["Prepared Statements"]}
