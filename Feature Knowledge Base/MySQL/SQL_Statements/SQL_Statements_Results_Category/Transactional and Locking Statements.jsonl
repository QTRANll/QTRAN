{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/any-in-some-subqueries.html"], "Title": ["15.2.15.3 Subqueries with ANY, IN, or SOME"], "Feature": ["operand comparison_operator ANY (subquery)\noperand IN (subquery)\noperand comparison_operator SOME (subquery)", "=  >  <  >=  <=  <>  !="], "Description": ["\n        Syntax:\n      ", "\n        Where comparison_operator is one of\n        these operators:\n      ", "\n        The ANY keyword, which must follow a\n        comparison operator, means \u201creturn TRUE\n        if the comparison is TRUE for\n        ANY of the values in the column that the\n        subquery returns.\u201d For example:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 > ANY (SELECT s1 FROM t2);", "\n        Suppose that there is a row in table t1\n        containing (10). The expression is\n        TRUE if table t2 contains\n        (21,14,7) because there is a value\n        7 in t2 that is less than\n        10. The expression is\n        FALSE if table t2 contains\n        (20,10), or if table t2 is\n        empty. The expression is unknown (that is,\n        NULL) if table t2 contains\n        (NULL,NULL,NULL).\n      ", "\n        When used with a subquery, the word IN is an\n        alias for = ANY. Thus, these two statements\n        are the same:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);\nSELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);", "\nIN and = ANY are not\n        synonyms when used with an expression list.\n        IN can take an expression list, but\n        = ANY cannot. See\n        Section\u00a014.4.2, \u201cComparison Functions and Operators\u201d.\n      ", "\nNOT IN is not an alias for <>\n        ANY, but for <> ALL. See\n        Section\u00a015.2.15.4, \u201cSubqueries with ALL\u201d.\n      ", "\n        The word SOME is an alias for\n        ANY. Thus, these two statements are the same:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 <> ANY  (SELECT s1 FROM t2);\nSELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);", "\n        Use of the word SOME is rare, but this\n        example shows why it might be useful. To most people, the\n        English phrase \u201ca is not equal to any b\u201d means\n        \u201cthere is no b which is equal to a,\u201d but that is\n        not what is meant by the SQL syntax. The syntax means\n        \u201cthere is some b to which a is not equal.\u201d Using\n        <> SOME instead helps ensure that\n        everyone understands the true meaning of the query.\n      ", "\n        You can use TABLE in a scalar\n        IN, ANY, or\n        SOME subquery provided the table contains\n        only a single column. If t2 has only one\n        column, the statements shown previously in this section can be\n        written as shown here, in each case substituting TABLE\n        t2 for SELECT s1 FROM t2:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 > ANY (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 = ANY (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 IN (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 <> ANY  (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 <> SOME (TABLE t2);"], "Examples": ["SELECT s1 FROM t1 WHERE s1 > ANY (SELECT s1 FROM t2);", "SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);\nSELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);", "SELECT s1 FROM t1 WHERE s1 <> ANY  (SELECT s1 FROM t2);\nSELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);", "SELECT s1 FROM t1 WHERE s1 > ANY (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 = ANY (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 IN (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 <> ANY  (TABLE t2);\n\nSELECT s1 FROM t1 WHERE s1 <> SOME (TABLE t2);"], "Category": ["Transactional and Locking Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/commit.html"], "Title": ["15.3.1 START TRANSACTION, COMMIT, and ROLLBACK Statements"], "Feature": ["START TRANSACTION\n    [transaction_characteristic [, transaction_characteristic] ...]\n\ntransaction_characteristic: {\n    WITH CONSISTENT SNAPSHOT\n  | READ WRITE\n  | READ ONLY\n}\n\nBEGIN [WORK]\nCOMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]\nROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]\nSET autocommit = {0 | 1}"], "Description": ["\n      These statements provide control over use of\n      transactions:\n", "\n\nSTART TRANSACTION or\n          BEGIN start a new transaction.\n        \nCOMMIT commits the current transaction,\n          making its changes permanent.\n        \nROLLBACK rolls back the current\n          transaction, canceling its changes.\n        \nSET autocommit disables or enables the\n          default autocommit mode for the current session.\n\n", "\n      By default, MySQL runs with\n      autocommit mode enabled.\n      This means that, when not otherwise inside a transaction, each\n      statement is atomic, as if it were surrounded by START\n      TRANSACTION and COMMIT. You cannot\n      use ROLLBACK to undo the effect; however, if an\n      error occurs during statement execution, the statement is rolled\n      back.\n    ", "\n      To disable autocommit mode implicitly for a single series of\n      statements, use the START TRANSACTION\n      statement:\n    ", "Press CTRL+C to copy START TRANSACTION;\nSELECT @A:=SUM(salary) FROM table1 WHERE type=1;\nUPDATE table2 SET summary=@A WHERE type=1;\nCOMMIT;", "\n      With START TRANSACTION, autocommit remains\n      disabled until you end the transaction with\n      COMMIT or ROLLBACK. The\n      autocommit mode then reverts to its previous state.\n    ", "\nSTART TRANSACTION permits several modifiers\n      that control transaction characteristics. To specify multiple\n      modifiers, separate them by commas.\n", "\n\n          The WITH CONSISTENT SNAPSHOT modifier\n          starts a consistent\n          read for storage engines that are capable of it. This\n          applies only to InnoDB. The effect is the\n          same as issuing a START TRANSACTION\n          followed by a SELECT from any\n          InnoDB table. See\n          Section\u00a017.7.2.3, \u201cConsistent Nonlocking Reads\u201d. The WITH\n          CONSISTENT SNAPSHOT modifier does not change the\n          current transaction\n          isolation level,\n          so it provides a consistent snapshot only if the current\n          isolation level is one that permits a consistent read. The\n          only isolation level that permits a consistent read is\n          REPEATABLE READ. For all\n          other isolation levels, the WITH CONSISTENT\n          SNAPSHOT clause is ignored. A warning is generated\n          when the WITH CONSISTENT SNAPSHOT clause is\n          ignored.\n        \n          The READ WRITE and READ\n          ONLY modifiers set the transaction access mode. They\n          permit or prohibit changes to tables used in the transaction.\n          The READ ONLY restriction prevents the\n          transaction from modifying or locking both transactional and\n          nontransactional tables that are visible to other\n          transactions; the transaction can still modify or lock\n          temporary tables.\n        \n          MySQL enables extra optimizations for queries on\n          InnoDB tables when the transaction is known\n          to be read-only. Specifying READ ONLY\n          ensures these optimizations are applied in cases where the\n          read-only status cannot be determined automatically. See\n          Section\u00a010.5.3, \u201cOptimizing InnoDB Read-Only Transactions\u201d for more\n          information.\n        \n          If no access mode is specified, the default mode applies.\n          Unless the default has been changed, it is read/write. It is\n          not permitted to specify both READ WRITE\n          and READ ONLY in the same statement.\n        \n          In read-only mode, it remains possible to change tables\n          created with the TEMPORARY keyword using\n          DML statements. Changes made with DDL statements are not\n          permitted, just as with permanent tables.\n        \n          For additional information about transaction access mode,\n          including ways to change the default mode, see\n          Section\u00a015.3.7, \u201cSET TRANSACTION Statement\u201d.\n        \n          If the read_only system\n          variable is enabled, explicitly starting a transaction with\n          START TRANSACTION READ WRITE requires the\n          CONNECTION_ADMIN privilege (or\n          the deprecated SUPER\n          privilege).\n\n", "\n\nImportant\n\n\n        Many APIs used for writing MySQL client applications (such as\n        JDBC) provide their own methods for starting transactions that\n        can (and sometimes should) be used instead of sending a\n        START TRANSACTION statement from the client.\n        See Chapter\u00a031, Connectors and APIs, or the documentation for\n        your API, for more information.\n\n", "\n      To disable autocommit mode explicitly, use the following\n      statement:\n    ", "Press CTRL+C to copy SET autocommit=0;", "\n      After disabling autocommit mode by setting the\n      autocommit variable to zero,\n      changes to transaction-safe tables (such as those for\n      InnoDB or\n      NDB) are not made permanent\n      immediately. You must use COMMIT to\n      store your changes to disk or ROLLBACK to\n      ignore the changes.\n    ", "\nautocommit is a session variable\n      and must be set for each session. To disable autocommit mode for\n      each new connection, see the description of the\n      autocommit system variable at\n      Section\u00a07.1.8, \u201cServer System Variables\u201d.\n    ", "\nBEGIN and BEGIN WORK are\n      supported as aliases of START TRANSACTION for\n      initiating a transaction. START TRANSACTION is\n      standard SQL syntax, is the recommended way to start an ad-hoc\n      transaction, and permits modifiers that BEGIN\n      does not.\n    ", "\n      The BEGIN statement differs from the use of the\n      BEGIN keyword that starts a\n      BEGIN ... END\n      compound statement. The latter does not begin a transaction. See\n      Section\u00a015.6.1, \u201cBEGIN ... END Compound Statement\u201d.\n", "\n\nNote\n\n\n        Within all stored programs (stored procedures and functions,\n        triggers, and events), the parser treats BEGIN\n        [WORK] as the beginning of a\n        BEGIN ...\n        END block. Begin a transaction in this context with\n        START\n        TRANSACTION instead.\n\n", "\n      The optional WORK keyword is supported for\n      COMMIT and ROLLBACK, as are\n      the CHAIN and RELEASE\n      clauses. CHAIN and RELEASE\n      can be used for additional control over transaction completion.\n      The value of the completion_type\n      system variable determines the default completion behavior. See\n      Section\u00a07.1.8, \u201cServer System Variables\u201d.\n    ", "\n      The AND CHAIN clause causes a new transaction\n      to begin as soon as the current one ends, and the new transaction\n      has the same isolation level as the just-terminated transaction.\n      The new transaction also uses the same access mode (READ\n      WRITE or READ ONLY) as the\n      just-terminated transaction. The RELEASE clause\n      causes the server to disconnect the current client session after\n      terminating the current transaction. Including the\n      NO keyword suppresses CHAIN\n      or RELEASE completion, which can be useful if\n      the completion_type system\n      variable is set to cause chaining or release completion by\n      default.\n    ", "\n      Beginning a transaction causes any pending transaction to be\n      committed. See Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d, for more\n      information.\n    ", "\n      Beginning a transaction also causes table locks acquired with\n      LOCK TABLES to be released, as\n      though you had executed\n      UNLOCK\n      TABLES. Beginning a transaction does not release a\n      global read lock acquired with FLUSH TABLES\n      WITH READ LOCK.\n    ", "\n      For best results, transactions should be performed using only\n      tables managed by a single transaction-safe storage engine.\n      Otherwise, the following problems can occur:\n", "\n\n          If you use tables from more than one transaction-safe storage\n          engine (such as InnoDB), and the\n          transaction isolation level is not\n          SERIALIZABLE, it is\n          possible that when one transaction commits, another ongoing\n          transaction that uses the same tables sees only some of the\n          changes made by the first transaction. That is, the atomicity\n          of transactions is not guaranteed with mixed engines and\n          inconsistencies can result. (If mixed-engine transactions are\n          infrequent, you can use\n          SET\n          TRANSACTION ISOLATION LEVEL to set the isolation\n          level to SERIALIZABLE on a\n          per-transaction basis as necessary.)\n        \n          If you use tables that are not transaction-safe within a\n          transaction, changes to those tables are stored at once,\n          regardless of the status of autocommit mode.\n        \n          If you issue a\n          ROLLBACK\n          statement after updating a nontransactional table within a\n          transaction, an\n          ER_WARNING_NOT_COMPLETE_ROLLBACK\n          warning occurs. Changes to transaction-safe tables are rolled\n          back, but not changes to nontransaction-safe tables.\n\n", "\n      Each transaction is stored in the binary log in one chunk, upon\n      COMMIT. Transactions that are\n      rolled back are not logged.\n      (Exception: Modifications to\n      nontransactional tables cannot be rolled back. If a transaction\n      that is rolled back includes modifications to nontransactional\n      tables, the entire transaction is logged with a\n      ROLLBACK\n      statement at the end to ensure that modifications to the\n      nontransactional tables are replicated.) See\n      Section\u00a07.4.4, \u201cThe Binary Log\u201d.\n    ", "\n      You can change the isolation level or access mode for transactions\n      with the SET TRANSACTION statement.\n      See Section\u00a015.3.7, \u201cSET TRANSACTION Statement\u201d.\n    ", "\n      Rolling back can be a slow operation that may occur implicitly\n      without the user having explicitly asked for it (for example, when\n      an error occurs). Because of this, SHOW\n      PROCESSLIST displays Rolling back in\n      the State column for the session, not only for\n      explicit rollbacks performed with the\n      ROLLBACK\n      statement but also for implicit rollbacks.\n", "\n\nNote\n\n\n        In MySQL 8.4, BEGIN,\n        COMMIT, and ROLLBACK are\n        not affected by --replicate-do-db\n        or --replicate-ignore-db rules.\n\n", "\n      When InnoDB performs a complete rollback of a\n      transaction, all locks set by the transaction are released. If a\n      single SQL statement within a transaction rolls back as a result\n      of an error, such as a duplicate key error, locks set by the\n      statement are preserved while the transaction remains active. This\n      happens because InnoDB stores row locks in a\n      format such that it cannot know afterward which lock was set by\n      which statement.\n    ", "\n      If a SELECT statement within a\n      transaction calls a stored function, and a statement within the\n      stored function fails, that statement rolls back. If\n      ROLLBACK is\n      executed for the transaction subsequently, the entire transaction\n      rolls back.\n"], "Examples": ["START TRANSACTION;\nSELECT @A:=SUM(salary) FROM table1 WHERE type=1;\nUPDATE table2 SET summary=@A WHERE type=1;\nCOMMIT;", "SET autocommit=0;"], "Category": ["Transactional and Locking Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/savepoint.html"], "Title": ["15.3.4 SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Statements"], "Feature": ["SAVEPOINT identifier\nROLLBACK [WORK] TO [SAVEPOINT] identifier\nRELEASE SAVEPOINT identifier"], "Description": ["\nInnoDB supports the SQL statements\n      SAVEPOINT,\n      ROLLBACK TO\n      SAVEPOINT,\n      RELEASE\n      SAVEPOINT and the optional WORK\n      keyword for\n      ROLLBACK.\n    ", "\n      The SAVEPOINT statement sets a\n      named transaction savepoint with a name of\n      identifier. If the current transaction\n      has a savepoint with the same name, the old savepoint is deleted\n      and a new one is set.\n    ", "\n      The ROLLBACK TO\n      SAVEPOINT statement rolls back a transaction to the\n      named savepoint without terminating the transaction. Modifications\n      that the current transaction made to rows after the savepoint was\n      set are undone in the rollback, but InnoDB does\n      not release the row locks that were stored in\n      memory after the savepoint. (For a new inserted row, the lock\n      information is carried by the transaction ID stored in the row;\n      the lock is not separately stored in memory. In this case, the row\n      lock is released in the undo.) Savepoints that were set at a later\n      time than the named savepoint are deleted.\n    ", "\n      If the ROLLBACK TO\n      SAVEPOINT statement returns the following error, it\n      means that no savepoint with the specified name exists:\n    ", "\n      The RELEASE\n      SAVEPOINT statement removes the named savepoint from the\n      set of savepoints of the current transaction. No commit or\n      rollback occurs. It is an error if the savepoint does not exist.\n    ", "\n      All savepoints of the current transaction are deleted if you\n      execute a COMMIT, or a\n      ROLLBACK that\n      does not name a savepoint.\n    ", "\n      A new savepoint level is created when a stored function is invoked\n      or a trigger is activated. The savepoints on previous levels\n      become unavailable and thus do not conflict with savepoints on the\n      new level. When the function or trigger terminates, any savepoints\n      it created are released and the previous savepoint level is\n      restored.\n"], "Examples": [], "Category": ["Transactional and Locking Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/lock-instance-for-backup.html"], "Title": ["15.3.5 LOCK INSTANCE FOR BACKUP and UNLOCK INSTANCE Statements"], "Feature": ["LOCK INSTANCE FOR BACKUP\n\nUNLOCK INSTANCE"], "Description": ["\nLOCK INSTANCE FOR BACKUP acquires an\n      instance-level backup lock that permits DML\n      during an online backup while preventing operations that could\n      result in an inconsistent snapshot.\n    ", "\n      Executing the LOCK INSTANCE FOR BACKUP\n      statement requires the BACKUP_ADMIN\n      privilege. The BACKUP_ADMIN\n      privilege is automatically granted to users with the\n      RELOAD privilege when performing an\n      in-place upgrade to MySQL 8.4 from an earlier\n      version.\n    ", "\n      Multiple sessions can hold a backup lock simultaneously.\n    ", "\nUNLOCK INSTANCE releases a backup lock held by\n      the current session. A backup lock held by a session is also\n      released if the session is terminated.\n    ", "\nLOCK INSTANCE FOR BACKUP prevents files from\n      being created, renamed, or removed. REPAIR\n      TABLE TRUNCATE TABLE,\n      OPTIMIZE TABLE, and account\n      management statements are blocked. See\n      Section\u00a015.7.1, \u201cAccount Management Statements\u201d. Operations that\n      modify InnoDB files that are not recorded in\n      the InnoDB redo log are also blocked.\n    ", "\nLOCK INSTANCE FOR BACKUP permits DDL operations\n      that only affect user-created temporary tables. In effect, files\n      that belong to user-created temporary tables can be created,\n      renamed, or removed while a backup lock is held. Creation of\n      binary log files is also permitted.\n    ", "\nPURGE BINARY LOGS cannot be issued\n      while a LOCK INSTANCE FOR BACKUP\n      statement is in effect for the instance, because it contravenes\n      the rules of the backup lock by removing files from the server.\n    ", "\n      A backup lock acquired by LOCK INSTANCE FOR\n      BACKUP is independent of transactional locks and locks\n      taken by\n      FLUSH\n      TABLES tbl_name [,\n      tbl_name] ... WITH READ LOCK,\n      and the following sequences of statements are permitted:\n    ", "Press CTRL+C to copy LOCK INSTANCE FOR BACKUP;\nFLUSH TABLES tbl_name [, tbl_name] ... WITH READ LOCK;\nUNLOCK TABLES;\nUNLOCK INSTANCE;", "Press CTRL+C to copy FLUSH TABLES tbl_name [, tbl_name] ... WITH READ LOCK;\nLOCK INSTANCE FOR BACKUP;\nUNLOCK INSTANCE;\nUNLOCK TABLES;", "\n      The lock_wait_timeout setting\n      defines the amount of time that a LOCK INSTANCE FOR\n      BACKUP statement waits to acquire a lock before giving\n      up.\n"], "Examples": ["LOCK INSTANCE FOR BACKUP;\nFLUSH TABLES tbl_name [, tbl_name] ... WITH READ LOCK;\nUNLOCK TABLES;\nUNLOCK INSTANCE;", "FLUSH TABLES tbl_name [, tbl_name] ... WITH READ LOCK;\nLOCK INSTANCE FOR BACKUP;\nUNLOCK INSTANCE;\nUNLOCK TABLES;"], "Category": ["Transactional and Locking Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/lock-tables.html"], "Title": ["15.3.6 LOCK TABLES and UNLOCK TABLES Statements"], "Feature": ["LOCK {TABLE | TABLES}\n    tbl_name [[AS] alias] lock_type\n    [, tbl_name [[AS] alias] lock_type] ...\n\nlock_type: {\n    READ [LOCAL]\n  | WRITE\n}\n\nUNLOCK {TABLE | TABLES}"], "Description": ["\n      MySQL enables client sessions to acquire table locks explicitly\n      for the purpose of cooperating with other sessions for access to\n      tables, or to prevent other sessions from modifying tables during\n      periods when a session requires exclusive access to them. A\n      session can acquire or release locks only for itself. One session\n      cannot acquire locks for another session or release locks held by\n      another session.\n    ", "\n      Locks may be used to emulate transactions or to get more speed\n      when updating tables. This is explained in more detail in\n      Table-Locking Restrictions and Conditions.\n    ", "\nLOCK TABLES explicitly acquires\n      table locks for the current client session. Table locks can be\n      acquired for base tables or views. You must have the\n      LOCK TABLES privilege, and the\n      SELECT privilege for each object to\n      be locked.\n    ", "\n      For view locking, LOCK TABLES adds\n      all base tables used in the view to the set of tables to be locked\n      and locks them automatically. For tables underlying any view being\n      locked, LOCK TABLES checks that the\n      view definer (for SQL SECURITY DEFINER views)\n      or invoker (for all views) has the proper privileges on the\n      tables.\n    ", "\n      If you lock a table explicitly with LOCK\n      TABLES, any tables used in triggers are also locked\n      implicitly, as described in\n      LOCK TABLES and Triggers.\n    ", "\n      If you lock a table explicitly with LOCK\n      TABLES, any tables related by a foreign key constraint\n      are opened and locked implicitly. For foreign key checks, a shared\n      read-only lock (LOCK\n      TABLES READ) is taken on related tables. For cascading\n      updates, a shared-nothing write lock\n      (LOCK TABLES\n      WRITE) is taken on related tables that are involved in\n      the operation.\n    ", "\nUNLOCK\n      TABLES explicitly releases any table locks held by the\n      current session. LOCK TABLES\n      implicitly releases any table locks held by the current session\n      before acquiring new locks.\n    ", "\n      Another use for\n      UNLOCK\n      TABLES is to release the global read lock acquired with\n      the FLUSH TABLES WITH READ LOCK\n      statement, which enables you to lock all tables in all databases.\n      See Section\u00a015.7.8.3, \u201cFLUSH Statement\u201d. (This is a very convenient way to get\n      backups if you have a file system such as Veritas that can take\n      snapshots in time.)\n    ", "\nLOCK TABLE is a synonym for LOCK\n      TABLES; UNLOCK TABLE is a synonym for\n      UNLOCK TABLES.\n    ", "\n      A table lock protects only against inappropriate reads or writes\n      by other sessions. A session holding a WRITE\n      lock can perform table-level operations such as\n      DROP TABLE or\n      TRUNCATE TABLE. For sessions\n      holding a READ lock, DROP\n      TABLE and TRUNCATE TABLE\n      operations are not permitted.\n    ", "\n      The following discussion applies only to\n      non-TEMPORARY tables. LOCK\n      TABLES is permitted (but ignored) for a\n      TEMPORARY table. The table can be accessed\n      freely by the session within which it was created, regardless of\n      what other locking may be in effect. No lock is necessary because\n      no other session can see the table.\n", "\nTable Lock AcquisitionTable Lock ReleaseInteraction of Table Locking and TransactionsLOCK TABLES and TriggersTable-Locking Restrictions and Conditions\n", "\n\n\n\nTable Lock Acquisition\n\n\n\n\n        To acquire table locks within the current session, use the\n        LOCK TABLES statement, which\n        acquires metadata locks (see\n        Section\u00a010.11.4, \u201cMetadata Locking\u201d).\n      \n        The following lock types are available:\n      \nREAD [LOCAL] lock:\n\n\n\n            The session that holds the lock can read the table (but not\n            write it).\n          \n            Multiple sessions can acquire a READ lock\n            for the table at the same time.\n          \n            Other sessions can read the table without explicitly\n            acquiring a READ lock.\n          \n            The LOCAL modifier enables nonconflicting\n            INSERT statements (concurrent\n            inserts) by other sessions to execute while the lock is\n            held. (See Section\u00a010.11.3, \u201cConcurrent Inserts\u201d.) However,\n            READ LOCAL cannot be used if you are\n            going to manipulate the database using processes external to\n            the server while you hold the lock. For\n            InnoDB tables, READ\n            LOCAL is the same as READ.\n\n\n\nWRITE lock:\n\n\n\n            The session that holds the lock can read and write the\n            table.\n          \n            Only the session that holds the lock can access the table.\n            No other session can access it until the lock is released.\n          \n            Lock requests for the table by other sessions block while\n            the WRITE lock is held.\n\n\n\nWRITE locks normally have higher priority\n        than READ locks to ensure that updates are\n        processed as soon as possible. This means that if one session\n        obtains a READ lock and then another session\n        requests a WRITE lock, subsequent\n        READ lock requests wait until the session\n        that requested the WRITE lock has obtained\n        the lock and released it. (An exception to this policy can occur\n        for small values of the\n        max_write_lock_count system\n        variable; see Section\u00a010.11.4, \u201cMetadata Locking\u201d.)\n      \n        If the LOCK TABLES statement must\n        wait due to locks held by other sessions on any of the tables,\n        it blocks until all locks can be acquired.\n      \n        A session that requires locks must acquire all the locks that it\n        needs in a single LOCK TABLES\n        statement. While the locks thus obtained are held, the session\n        can access only the locked tables. For example, in the following\n        sequence of statements, an error occurs for the attempt to\n        access t2 because it was not locked in the\n        LOCK TABLES statement:\n      Press CTRL+C to copy mysql> LOCK TABLES t1 READ;\nmysql> SELECT COUNT(*) FROM t1;\n+----------+\n| COUNT(*) |\n+----------+\n|        3 |\n+----------+\nmysql> SELECT COUNT(*) FROM t2;\nERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES\n        Tables in the INFORMATION_SCHEMA database are\n        an exception. They can be accessed without being locked\n        explicitly even while a session holds table locks obtained with\n        LOCK TABLES.\n      \n        You cannot refer to a locked table multiple times in a single\n        query using the same name. Use aliases instead, and obtain a\n        separate lock for the table and each alias:\n      Press CTRL+C to copy mysql> LOCK TABLE t WRITE, t AS t1 READ;\nmysql> INSERT INTO t SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> INSERT INTO t SELECT * FROM t AS t1;\n        The error occurs for the first\n        INSERT because there are two\n        references to the same name for a locked table. The second\n        INSERT succeeds because the\n        references to the table use different names.\n      \n        If your statements refer to a table by means of an alias, you\n        must lock the table using that same alias. It does not work to\n        lock the table without specifying the alias:\n      Press CTRL+C to copy mysql> LOCK TABLE t READ;\nmysql> SELECT * FROM t AS myalias;\nERROR 1100: Table 'myalias' was not locked with LOCK TABLES\n        Conversely, if you lock a table using an alias, you must refer\n        to it in your statements using that alias:\n      Press CTRL+C to copy mysql> LOCK TABLE t AS myalias READ;\nmysql> SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> SELECT * FROM t AS myalias;\n", "\n\n\n\nTable Lock Release\n\n\n\n\n        When the table locks held by a session are released, they are\n        all released at the same time. A session can release its locks\n        explicitly, or locks may be released implicitly under certain\n        conditions.\n\n\n\n            A session can release its locks explicitly with\n            UNLOCK\n            TABLES.\n          \n            If a session issues a LOCK\n            TABLES statement to acquire a lock while already\n            holding locks, its existing locks are released implicitly\n            before the new locks are granted.\n          \n            If a session begins a transaction (for example, with\n            START\n            TRANSACTION), an implicit\n            UNLOCK\n            TABLES is performed, which causes existing locks\n            to be released. (For additional information about the\n            interaction between table locking and transactions, see\n            Interaction of Table Locking and Transactions.)\n\n\n\n        If the connection for a client session terminates, whether\n        normally or abnormally, the server implicitly releases all table\n        locks held by the session (transactional and nontransactional).\n        If the client reconnects, the locks are no longer in effect. In\n        addition, if the client had an active transaction, the server\n        rolls back the transaction upon disconnect, and if reconnect\n        occurs, the new session begins with autocommit enabled. For this\n        reason, clients may wish to disable auto-reconnect. With\n        auto-reconnect in effect, the client is not notified if\n        reconnect occurs but any table locks or current transaction are\n        lost. With auto-reconnect disabled, if the connection drops, an\n        error occurs for the next statement issued. The client can\n        detect the error and take appropriate action such as reacquiring\n        the locks or redoing the transaction. See\n        Automatic Reconnection Control.\n\n\n\nNote\n\n\n          If you use ALTER TABLE on a\n          locked table, it may become unlocked. For example, if you\n          attempt a second ALTER TABLE\n          operation, the result may be an error Table\n          'tbl_name' was not locked with LOCK\n          TABLES. To handle this, lock the table again prior\n          to the second alteration. See also\n          Section\u00a0B.3.6.1, \u201cProblems with ALTER TABLE\u201d.\n\n\n", "\n\n\n\nInteraction of Table Locking and Transactions\n\n\n\n\nLOCK TABLES and\n        UNLOCK\n        TABLES interact with the use of transactions as\n        follows:\n\n\n\nLOCK TABLES is not\n            transaction-safe and implicitly commits any active\n            transaction before attempting to lock the tables.\n          \nUNLOCK\n            TABLES implicitly commits any active transaction,\n            but only if LOCK TABLES has\n            been used to acquire table locks. For example, in the\n            following set of statements,\n            UNLOCK\n            TABLES releases the global read lock but does not\n            commit the transaction because no table locks are in effect:\n          Press CTRL+C to copy FLUSH TABLES WITH READ LOCK;\nSTART TRANSACTION;\nSELECT ... ;\nUNLOCK TABLES;\n            Beginning a transaction (for example, with\n            START\n            TRANSACTION) implicitly commits any current\n            transaction and releases existing table locks.\n          \nFLUSH TABLES WITH READ LOCK\n            acquires a global read lock and not table locks, so it is\n            not subject to the same behavior as\n            LOCK TABLES and\n            UNLOCK\n            TABLES with respect to table locking and implicit\n            commits. For example,\n            START\n            TRANSACTION does not release the global read lock.\n            See Section\u00a015.7.8.3, \u201cFLUSH Statement\u201d.\n          \n            Other statements that implicitly cause transactions to be\n            committed do not release existing table locks. For a list of\n            such statements, see Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n          \n            The correct way to use LOCK\n            TABLES and\n            UNLOCK\n            TABLES with transactional tables, such as\n            InnoDB tables, is to begin a transaction\n            with SET autocommit = 0 (not\n            START\n            TRANSACTION) followed by LOCK\n            TABLES, and to not call\n            UNLOCK\n            TABLES until you commit the transaction\n            explicitly. For example, if you need to write to table\n            t1 and read from table\n            t2, you can do this:\n          Press CTRL+C to copy SET autocommit=0;\nLOCK TABLES t1 WRITE, t2 READ, ...;\n... do something with tables t1 and t2 here ...\nCOMMIT;\nUNLOCK TABLES;\n            When you call LOCK TABLES,\n            InnoDB internally takes its own table\n            lock, and MySQL takes its own table lock.\n            InnoDB releases its internal table lock\n            at the next commit, but for MySQL to release its table lock,\n            you have to call\n            UNLOCK\n            TABLES. You should not have\n            autocommit = 1, because\n            then InnoDB releases its internal table\n            lock immediately after the call of LOCK\n            TABLES, and deadlocks can very easily happen.\n            InnoDB does not acquire the internal\n            table lock at all if autocommit =\n            1, to help old applications avoid unnecessary\n            deadlocks.\n          \nROLLBACK\n            does not release table locks.\n\n\n", "\n\n\n\nLOCK TABLES and Triggers\n\n\n\n\n        If you lock a table explicitly with LOCK\n        TABLES, any tables used in triggers are also locked\n        implicitly:\n\n\n\n            The locks are taken as the same time as those acquired\n            explicitly with the LOCK\n            TABLES statement.\n          \n            The lock on a table used in a trigger depends on whether the\n            table is used only for reading. If so, a read lock suffices.\n            Otherwise, a write lock is used.\n          \n            If a table is locked explicitly for reading with\n            LOCK TABLES, but needs to be\n            locked for writing because it might be modified within a\n            trigger, a write lock is taken rather than a read lock.\n            (That is, an implicit write lock needed due to the table's\n            appearance within a trigger causes an explicit read lock\n            request for the table to be converted to a write lock\n            request.)\n\n\n\n        Suppose that you lock two tables, t1 and\n        t2, using this statement:\n      Press CTRL+C to copy LOCK TABLES t1 WRITE, t2 READ;\n        If t1 or t2 have any\n        triggers, tables used within the triggers are also locked.\n        Suppose that t1 has a trigger defined like\n        this:\n      Press CTRL+C to copy CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW\nBEGIN\n  UPDATE t4 SET count = count+1\n      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);\n  INSERT INTO t2 VALUES(1, 2);\nEND;\n        The result of the LOCK TABLES\n        statement is that t1 and\n        t2 are locked because they appear in the\n        statement, and t3 and t4\n        are locked because they are used within the trigger:\n\n\n\nt1 is locked for writing per the\n            WRITE lock request.\n          \nt2 is locked for writing, even though the\n            request is for a READ lock. This occurs\n            because t2 is inserted into within the\n            trigger, so the READ request is converted\n            to a WRITE request.\n          \nt3 is locked for reading because it is\n            only read from within the trigger.\n          \nt4 is locked for writing because it might\n            be updated within the trigger.\n\n\n", "\n\n\n\nTable-Locking Restrictions and Conditions\n\n\n\n\n        You can safely use KILL to\n        terminate a session that is waiting for a table lock. See\n        Section\u00a015.7.8.4, \u201cKILL Statement\u201d.\n      \nLOCK TABLES and\n        UNLOCK\n        TABLES cannot be used within stored programs.\n      \n        Tables in the performance_schema database\n        cannot be locked with LOCK\n        TABLES, except the\n        setup_xxx tables.\n      \n        The scope of a lock generated by LOCK TABLES\n        is a single MySQL server. It is not compatible with NDB Cluster,\n        which has no way of enforcing an SQL-level lock across multiple\n        instances of mysqld. You can enforce locking\n        in an API application instead. See\n        Section\u00a025.2.7.10, \u201cLimitations Relating to Multiple NDB Cluster Nodes\u201d, for\n        more information.\n      \n        The following statements are prohibited while a\n        LOCK TABLES statement is in\n        effect: CREATE TABLE,\n        CREATE TABLE ...\n        LIKE, CREATE VIEW,\n        DROP VIEW, and DDL statements on\n        stored functions and procedures and events.\n      \n        For some operations, system tables in the\n        mysql database must be accessed. For example,\n        the HELP statement requires the\n        contents of the server-side help tables, and\n        CONVERT_TZ() might need to read\n        the time zone tables. The server implicitly locks the system\n        tables for reading as necessary so that you need not lock them\n        explicitly. These tables are treated as just described:\n      Press CTRL+C to copy mysql.help_category\nmysql.help_keyword\nmysql.help_relation\nmysql.help_topic\nmysql.time_zone\nmysql.time_zone_leap_second\nmysql.time_zone_name\nmysql.time_zone_transition\nmysql.time_zone_transition_type\n        If you want to explicitly place a WRITE lock\n        on any of those tables with a LOCK\n        TABLES statement, the table must be the only one\n        locked; no other table can be locked with the same statement.\n      \n        Normally, you do not need to lock tables, because all single\n        UPDATE statements are atomic; no\n        other session can interfere with any other currently executing\n        SQL statement. However, there are a few cases when locking\n        tables may provide an advantage:\n\n\n\n            If you are going to run many operations on a set of\n            MyISAM tables, it is much faster to lock\n            the tables you are going to use. Locking\n            MyISAM tables speeds up inserting,\n            updating, or deleting on them because MySQL does not flush\n            the key cache for the locked tables until\n            UNLOCK\n            TABLES is called. Normally, the key cache is\n            flushed after each SQL statement.\n          \n            The downside to locking the tables is that no session can\n            update a READ-locked table (including the\n            one holding the lock) and no session can access a\n            WRITE-locked table other than the one\n            holding the lock.\n          \n            If you are using tables for a nontransactional storage\n            engine, you must use LOCK\n            TABLES if you want to ensure that no other session\n            modifies the tables between a\n            SELECT and an\n            UPDATE. The example shown\n            here requires LOCK TABLES to\n            execute safely:\n          Press CTRL+C to copy LOCK TABLES trans READ, customer WRITE;\nSELECT SUM(value) FROM trans WHERE customer_id=some_id;\nUPDATE customer\n  SET total_value=sum_from_previous_statement\n  WHERE customer_id=some_id;\nUNLOCK TABLES;\n            Without LOCK TABLES, it is\n            possible that another session might insert a new row in the\n            trans table between execution of the\n            SELECT and\n            UPDATE statements.\n\n\n\n        You can avoid using LOCK TABLES\n        in many cases by using relative updates (UPDATE\n        customer SET\n        value=value+new_value)\n        or the LAST_INSERT_ID() function.\n      \n        You can also avoid locking tables in some cases by using the\n        user-level advisory lock functions\n        GET_LOCK() and\n        RELEASE_LOCK(). These locks are\n        saved in a hash table in the server and implemented with\n        pthread_mutex_lock() and\n        pthread_mutex_unlock() for high speed. See\n        Section\u00a014.14, \u201cLocking Functions\u201d.\n      \n        See Section\u00a010.11.1, \u201cInternal Locking Methods\u201d, for more information on\n        locking policy.\n\n"], "Examples": ["mysql> LOCK TABLES t1 READ;\nmysql> SELECT COUNT(*) FROM t1;\n+----------+\n| COUNT(*) |\n+----------+\n|        3 |\n+----------+\nmysql> SELECT COUNT(*) FROM t2;\nERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES", "mysql> LOCK TABLE t WRITE, t AS t1 READ;\nmysql> INSERT INTO t SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> INSERT INTO t SELECT * FROM t AS t1;", "mysql> LOCK TABLE t READ;\nmysql> SELECT * FROM t AS myalias;\nERROR 1100: Table 'myalias' was not locked with LOCK TABLES", "mysql> LOCK TABLE t AS myalias READ;\nmysql> SELECT * FROM t;\nERROR 1100: Table 't' was not locked with LOCK TABLES\nmysql> SELECT * FROM t AS myalias;", "FLUSH TABLES WITH READ LOCK;\nSTART TRANSACTION;\nSELECT ... ;\nUNLOCK TABLES;", "SET autocommit=0;\nLOCK TABLES t1 WRITE, t2 READ, ...;\n... do something with tables t1 and t2 here ...\nCOMMIT;\nUNLOCK TABLES;", "LOCK TABLES t1 WRITE, t2 READ;", "CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW\nBEGIN\n  UPDATE t4 SET count = count+1\n      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);\n  INSERT INTO t2 VALUES(1, 2);\nEND;", "LOCK TABLES trans READ, customer WRITE;\nSELECT SUM(value) FROM trans WHERE customer_id=some_id;\nUPDATE customer\n  SET total_value=sum_from_previous_statement\n  WHERE customer_id=some_id;\nUNLOCK TABLES;"], "Category": ["Transactional and Locking Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/set-transaction.html"], "Title": ["15.3.7 SET TRANSACTION Statement"], "Feature": ["SET [GLOBAL | SESSION] TRANSACTION\n    transaction_characteristic [, transaction_characteristic] ...\n\ntransaction_characteristic: {\n    ISOLATION LEVEL level\n  | access_mode\n}\n\nlevel: {\n     REPEATABLE READ\n   | READ COMMITTED\n   | READ UNCOMMITTED\n   | SERIALIZABLE\n}\n\naccess_mode: {\n     READ WRITE\n   | READ ONLY\n}"], "Description": ["\n      This statement specifies\n      transaction\n      characteristics. It takes a list of one or more characteristic\n      values separated by commas. Each characteristic value sets the\n      transaction isolation\n      level or access mode. The isolation level is used for\n      operations on InnoDB tables. The\n      access mode specifies whether transactions operate in read/write\n      or read-only mode.\n    ", "\n      In addition, SET TRANSACTION can\n      include an optional GLOBAL or\n      SESSION keyword to indicate the scope of the\n      statement.\n", "\nTransaction Isolation LevelsTransaction Access ModeTransaction Characteristic Scope\n", "\n\n\n\nTransaction Isolation Levels\n\n\n\n\n        To set the transaction isolation level, use an\n        ISOLATION LEVEL\n        level clause. It is not\n        permitted to specify multiple ISOLATION LEVEL\n        clauses in the same SET\n        TRANSACTION statement.\n      \n        The default isolation level is\n        REPEATABLE READ. Other\n        permitted values are READ\n        COMMITTED, READ\n        UNCOMMITTED, and\n        SERIALIZABLE. For information\n        about these isolation levels, see\n        Section\u00a017.7.2.1, \u201cTransaction Isolation Levels\u201d.\n\n", "\n\n\n\nTransaction Access Mode\n\n\n\n\n        To set the transaction access mode, use a READ\n        WRITE or READ ONLY clause. It is\n        not permitted to specify multiple access-mode clauses in the\n        same SET TRANSACTION statement.\n      \n        By default, a transaction takes place in read/write mode, with\n        both reads and writes permitted to tables used in the\n        transaction. This mode may be specified explicitly using\n        SET TRANSACTION with an access\n        mode of READ WRITE.\n      \n        If the transaction access mode is set to READ\n        ONLY, changes to tables are prohibited. This may\n        enable storage engines to make performance improvements that are\n        possible when writes are not permitted.\n      \n        In read-only mode, it remains possible to change tables created\n        with the TEMPORARY keyword using DML\n        statements. Changes made with DDL statements are not permitted,\n        just as with permanent tables.\n      \n        The READ WRITE and READ\n        ONLY access modes also may be specified for an\n        individual transaction using the\n        START\n        TRANSACTION statement.\n\n", "\n\n\n\nTransaction Characteristic Scope\n\n\n\n\n        You can set transaction characteristics globally, for the\n        current session, or for the next transaction only:\n\n\n\n            With the GLOBAL keyword:\n\n\n\n                The statement applies globally for all subsequent\n                sessions.\n              \n                Existing sessions are unaffected.\n\n\n\n            With the SESSION keyword:\n\n\n\n                The statement applies to all subsequent transactions\n                performed within the current session.\n              \n                The statement is permitted within transactions, but does\n                not affect the current ongoing transaction.\n              \n                If executed between transactions, the statement\n                overrides any preceding statement that sets the\n                next-transaction value of the named characteristics.\n\n\n\n            Without any SESSION or\n            GLOBAL keyword:\n\n\n\n                The statement applies only to the next single\n                transaction performed within the session.\n              \n                Subsequent transactions revert to using the session\n                value of the named characteristics.\n              \n                The statement is not permitted within transactions:\n              Press CTRL+C to copy mysql> START TRANSACTION;\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\nERROR 1568 (25001): Transaction characteristics can't be changed\nwhile a transaction is in progress\n\n\n\n\n        A change to global transaction characteristics requires the\n        CONNECTION_ADMIN privilege (or\n        the deprecated SUPER privilege).\n        Any session is free to change its session characteristics (even\n        in the middle of a transaction), or the characteristics for its\n        next transaction (prior to the start of that transaction).\n      \n        To set the global isolation level at server startup, use the\n        --transaction-isolation=level\n        option on the command line or in an option file. Values of\n        level for this option use dashes\n        rather than spaces, so the permissible values are\n        READ-UNCOMMITTED,\n        READ-COMMITTED,\n        REPEATABLE-READ, or\n        SERIALIZABLE.\n      \n        Similarly, to set the global transaction access mode at server\n        startup, use the\n        --transaction-read-only option.\n        The default is OFF (read/write mode) but the\n        value can be set to ON for a mode of read\n        only.\n      \n        For example, to set the isolation level to\n        REPEATABLE READ and the\n        access mode to READ WRITE, use these lines in\n        the [mysqld] section of an option file:\n      Press CTRL+C to copy [mysqld]\ntransaction-isolation = REPEATABLE-READ\ntransaction-read-only = OFF\n        At runtime, characteristics at the global, session, and\n        next-transaction scope levels can be set indirectly using the\n        SET TRANSACTION statement, as\n        described previously. They can also be set directly using the\n        SET\n        statement to assign values to the\n        transaction_isolation and\n        transaction_read_only system\n        variables:\n\n\n\nSET TRANSACTION permits\n            optional GLOBAL and\n            SESSION keywords for setting transaction\n            characteristics at different scope levels.\n          \n            The\n            SET\n            statement for assigning values to the\n            transaction_isolation and\n            transaction_read_only\n            system variables has syntaxes for setting these variables at\n            different scope levels.\n\n\n\n        The following tables show the characteristic scope level set by\n        each SET TRANSACTION and\n        variable-assignment syntax.\n\n\nTable\u00a015.9\u00a0SET TRANSACTION Syntax for Transaction Characteristics\n\n\nSyntax\nAffected Characteristic Scope\n\nSET GLOBAL TRANSACTION\n              transaction_characteristic\nGlobal\n\nSET SESSION TRANSACTION\n              transaction_characteristic\nSession\n\nSET TRANSACTION\n              transaction_characteristic\nNext transaction only\n\n\n\n\n\nTable\u00a015.10\u00a0SET Syntax for Transaction Characteristics\n\n\nSyntax\nAffected Characteristic Scope\n\nSET GLOBAL var_name =\n              value\nGlobal\n\nSET @@GLOBAL.var_name =\n              value\nGlobal\n\nSET PERSIST var_name =\n              value\nGlobal\n\nSET @@PERSIST.var_name =\n              value\nGlobal\n\nSET PERSIST_ONLY var_name =\n              value\nNo runtime effect\n\nSET @@PERSIST_ONLY.var_name =\n              value\nNo runtime effect\n\nSET SESSION var_name =\n              value\nSession\n\nSET @@SESSION.var_name =\n              value\nSession\n\nSET var_name =\n              value\nSession\n\nSET @@var_name =\n              value\nNext transaction only\n\n\nSyntax\nAffected Characteristic Scope\n\n\n\n        It is possible to check the global and session values of\n        transaction characteristics at runtime:\n      Press CTRL+C to copy SELECT @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;\nSELECT @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;\n"], "Examples": ["mysql> START TRANSACTION;\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\nERROR 1568 (25001): Transaction characteristics can't be changed\nwhile a transaction is in progress", "SELECT @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;\nSELECT @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;"], "Category": ["Transactional and Locking Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/xa-statements.html"], "Title": ["15.3.8.1 XA Transaction SQL Statements"], "Feature": ["XA {START|BEGIN} xid [JOIN|RESUME]\n\nXA END xid [SUSPEND [FOR MIGRATE]]\n\nXA PREPARE xid\n\nXA COMMIT xid [ONE PHASE]\n\nXA ROLLBACK xid\n\nXA RECOVER [CONVERT XID]"], "Description": ["\n        To perform XA transactions in MySQL, use the following\n        statements:\n      ", "\n        For XA\n        START, the JOIN and\n        RESUME clauses are recognized but have no\n        effect.\n      ", "\n        For XA\n        END the SUSPEND [FOR MIGRATE]\n        clause is recognized but has no effect.\n      ", "\n        Each XA statement begins with the XA keyword,\n        and most of them require an xid\n        value. An xid is an XA transaction\n        identifier. It indicates which transaction the statement applies\n        to. xid values are supplied by the\n        client, or generated by the MySQL server. An\n        xid value has from one to three\n        parts:\n      ", "\ngtrid is a global transaction\n        identifier, bqual is a branch\n        qualifier, and formatID is a number\n        that identifies the format used by the\n        gtrid and\n        bqual values. As indicated by the\n        syntax, bqual and\n        formatID are optional. The default\n        bqual value is ''\n        if not given. The default formatID\n        value is 1 if not given.\n      ", "\ngtrid and\n        bqual must be string literals, each\n        up to 64 bytes (not characters) long.\n        gtrid and\n        bqual can be specified in several\n        ways. You can use a quoted string ('ab'), hex\n        string (X'6162', 0x6162),\n        or bit value\n        (b'nnnn').\n      ", "\nformatID is an unsigned integer.\n      ", "\n        The gtrid and\n        bqual values are interpreted in bytes\n        by the MySQL server's underlying XA support routines. However,\n        while an SQL statement containing an XA statement is being\n        parsed, the server works with some specific character set. To be\n        safe, write gtrid and\n        bqual as hex strings.\n      ", "\nxid values typically are generated by\n        the Transaction Manager. Values generated by one TM must be\n        different from values generated by other TMs. A given TM must be\n        able to recognize its own xid values\n        in a list of values returned by the\n        XA\n        RECOVER statement.\n      ", "\nXA START\n        xid starts an XA\n        transaction with the given xid value.\n        Each XA transaction must have a unique\n        xid value, so the value must not\n        currently be used by another XA transaction. Uniqueness is\n        assessed using the gtrid and\n        bqual values. All following XA\n        statements for the XA transaction must be specified using the\n        same xid value as that given in the\n        XA\n        START statement. If you use any of those statements\n        but specify an xid value that does\n        not correspond to some existing XA transaction, an error occurs.\n      ", "\nXA START, XA BEGIN,\n        XA END, XA COMMIT, and\n        XA ROLLBACK statements are not filtered by\n        the default database when the server is running with\n        --replicate-do-db or\n        --replicate-ignore-db.\n      ", "\n        One or more XA transactions can be part of the same global\n        transaction. All XA transactions within a given global\n        transaction must use the same gtrid\n        value in the xid value. For this\n        reason, gtrid values must be globally\n        unique so that there is no ambiguity about which global\n        transaction a given XA transaction is part of. The\n        bqual part of the\n        xid value must be different for each\n        XA transaction within a global transaction. (The requirement\n        that bqual values be different is a\n        limitation of the current MySQL XA implementation. It is not\n        part of the XA specification.)\n      ", "\n        The XA\n        RECOVER statement returns information for those XA\n        transactions on the MySQL server that are in the\n        PREPARED state. (See\n        Section\u00a015.3.8.2, \u201cXA Transaction States\u201d.) The output includes a row for each\n        such XA transaction on the server, regardless of which client\n        started it.\n      ", "\nXA\n        RECOVER requires the\n        XA_RECOVER_ADMIN privilege. This\n        privilege requirement prevents users from discovering the XID\n        values for outstanding prepared XA transactions other than their\n        own. It does not affect normal commit or rollback of an XA\n        transaction because the user who started it knows its XID.\n      ", "\nXA\n        RECOVER output rows look like this (for an example\n        xid value consisting of the parts\n        'abc', 'def', and\n        7):\n      ", "Press CTRL+C to copy mysql> XA RECOVER;\n+----------+--------------+--------------+--------+\n| formatID | gtrid_length | bqual_length | data   |\n+----------+--------------+--------------+--------+\n|        7 |            3 |            3 | abcdef |\n+----------+--------------+--------------+--------+", "\n        The output columns have the following meanings:\n", "\n\nformatID is the\n            formatID part of the transaction\n            xid\n\ngtrid_length is the length in bytes of\n            the gtrid part of the\n            xid\n\nbqual_length is the length in bytes of\n            the bqual part of the\n            xid\n\ndata is the concatenation of the\n            gtrid and\n            bqual parts of the\n            xid\n\n", "\n        XID values may contain nonprintable characters.\n        XA\n        RECOVER permits an optional CONVERT\n        XID clause so that clients can request XID values in\n        hexadecimal.\n"], "Examples": ["mysql> XA RECOVER;\n+----------+--------------+--------------+--------+\n| formatID | gtrid_length | bqual_length | data   |\n+----------+--------------+--------------+--------+\n|        7 |            3 |            3 | abcdef |\n+----------+--------------+--------------+--------+"], "Category": ["Transactional and Locking Statements"]}
