{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/all-subqueries.html"], "Title": ["15.2.15.4 Subqueries with ALL"], "Feature": ["operand comparison_operator ALL (subquery)"], "Description": ["\n        Syntax:\n      ", "\n        The word ALL, which must follow a comparison\n        operator, means \u201creturn TRUE if the\n        comparison is TRUE for ALL\n        of the values in the column that the subquery returns.\u201d\n        For example:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 > ALL (SELECT s1 FROM t2);", "\n        Suppose that there is a row in table t1\n        containing (10). The expression is\n        TRUE if table t2 contains\n        (-5,0,+5) because 10 is\n        greater than all three values in t2. The\n        expression is FALSE if table\n        t2 contains\n        (12,6,NULL,-100) because there is a single\n        value 12 in table t2 that\n        is greater than 10. The expression is\n        unknown (that is, NULL)\n        if table t2 contains\n        (0,NULL,1).\n      ", "\n        Finally, the expression is TRUE if table\n        t2 is empty. So, the following expression is\n        TRUE when table t2 is\n        empty:\n      ", "Press CTRL+C to copy SELECT * FROM t1 WHERE 1 > ALL (SELECT s1 FROM t2);", "\n        But this expression is NULL when table\n        t2 is empty:\n      ", "Press CTRL+C to copy SELECT * FROM t1 WHERE 1 > (SELECT s1 FROM t2);", "\n        In addition, the following expression is NULL\n        when table t2 is empty:\n      ", "Press CTRL+C to copy SELECT * FROM t1 WHERE 1 > ALL (SELECT MAX(s1) FROM t2);", "\n        In general, tables containing NULL\n        values and empty tables are\n        \u201cedge cases.\u201d When writing subqueries, always\n        consider whether you have taken those two possibilities into\n        account.\n      ", "\nNOT IN is an alias for <>\n        ALL. Thus, these two statements are the same:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 <> ALL (SELECT s1 FROM t2);\nSELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);", "\n        As with IN, ANY, and\n        SOME, you can use\n        TABLE with ALL\n        and NOT IN provided that the following two\n        conditions are met:\n", "\n\n            The table in the subquery contains only one column\n          \n            The subquery does not depend on a column expression\n\n", "\n        For example, assuming that table t2 consists\n        of a single column, the last two statements shown previously can\n        be written using TABLE t2 like this:\n      ", "Press CTRL+C to copy SELECT s1 FROM t1 WHERE s1 <> ALL (TABLE t2);\nSELECT s1 FROM t1 WHERE s1 NOT IN (TABLE t2);", "\n        A query such as SELECT * FROM t1 WHERE 1 > ALL\n        (SELECT MAX(s1) FROM t2); cannot be written using\n        TABLE t2 because the subquery depends on a\n        column expression.\n"], "Examples": ["SELECT s1 FROM t1 WHERE s1 > ALL (SELECT s1 FROM t2);", "SELECT * FROM t1 WHERE 1 > ALL (SELECT s1 FROM t2);", "SELECT * FROM t1 WHERE 1 > (SELECT s1 FROM t2);", "SELECT * FROM t1 WHERE 1 > ALL (SELECT MAX(s1) FROM t2);", "SELECT s1 FROM t1 WHERE s1 <> ALL (SELECT s1 FROM t2);\nSELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);", "SELECT s1 FROM t1 WHERE s1 <> ALL (TABLE t2);\nSELECT s1 FROM t1 WHERE s1 NOT IN (TABLE t2);"], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/purge-binary-logs.html"], "Title": ["15.4.1.1 PURGE BINARY LOGS Statement"], "Feature": ["PURGE BINARY LOGS {\n    TO 'log_name'\n  | BEFORE datetime_expr\n}"], "Description": ["\n        The binary log is a set of files that contain information about\n        data modifications made by the MySQL server. The log consists of\n        a set of binary log files, plus an index file (see\n        Section\u00a07.4.4, \u201cThe Binary Log\u201d).\n      ", "\n        The PURGE BINARY LOGS statement\n        deletes all the binary log files listed in the log index file\n        prior to the specified log file name or date. Deleted log files\n        also are removed from the list recorded in the index file, so\n        that the given log file becomes the first in the list.\n      ", "\nPURGE BINARY LOGS requires the\n        BINLOG_ADMIN privilege. This\n        statement has no effect if the server was not started with the\n        --log-bin option to enable binary\n        logging.\n      ", "\n        Examples:\n      ", "Press CTRL+C to copy PURGE BINARY LOGS TO 'mysql-bin.010';\nPURGE BINARY LOGS BEFORE '2019-04-02 22:46:26';", "\n        The BEFORE variant's\n        datetime_expr argument should\n        evaluate to a DATETIME value (a\n        value in 'YYYY-MM-DD\n        hh:mm:ss' format).\n      ", "\nPURGE BINARY LOGS is safe to run\n        while replicas are replicating. You need not stop them. If you\n        have an active replica that currently is reading one of the log\n        files you are trying to delete, this statement does not delete\n        the log file that is in use or any log files later than that\n        one, but it deletes any earlier log files. A warning message is\n        issued in this situation. However, if a replica is not connected\n        and you happen to purge one of the log files it has yet to read,\n        the replica cannot replicate after it reconnects.\n      ", "\nPURGE BINARY LOGS cannot be\n        issued while a LOCK INSTANCE FOR\n        BACKUP statement is in effect for the instance,\n        because it contravenes the rules of the backup lock by removing\n        files from the server.\n      ", "\n        To safely purge binary log files, follow this procedure:\n", "\n\n            On each replica, use\n            SHOW\n            REPLICA STATUS to check which log file it is\n            reading.\n          \n            Obtain a listing of the binary log files on the source with\n            SHOW BINARY LOGS.\n          \n            Determine the earliest log file among all the replicas. This\n            is the target file. If all the replicas are up to date, this\n            is the last log file on the list.\n          \n            Make a backup of all the log files you are about to delete.\n            (This step is optional, but always advisable.)\n          \n            Purge all log files up to but not including the target file.\n\n", "\nPURGE BINARY LOGS TO and PURGE\n        BINARY LOGS BEFORE both fail with an error when binary\n        log files listed in the .index file had\n        been removed from the system by some other means (such as using\n        rm on Linux). (Bug #18199, Bug #18453) To\n        handle such errors, edit the .index file\n        (which is a simple text file) manually to ensure that it lists\n        only the binary log files that are actually present, then run\n        again the PURGE BINARY LOGS\n        statement that failed.\n      ", "\n        Binary log files are automatically removed after the server's\n        binary log expiration period. Removal of the files can take\n        place at startup and when the binary log is flushed. The default\n        binary log expiration period is 30 days. You can specify an\n        alternative expiration period using the\n        binlog_expire_logs_seconds\n        system variable. If you are using replication, you should\n        specify an expiration period that is no lower than the maximum\n        amount of time your replicas might lag behind the source.\n"], "Examples": ["PURGE BINARY LOGS TO 'mysql-bin.010';\nPURGE BINARY LOGS BEFORE '2019-04-02 22:46:26';"], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html"], "Title": ["15.4.1.2 RESET BINARY LOGS AND GTIDS Statement"], "Feature": ["RESET BINARY LOGS AND GTIDS [TO binary_log_file_index_number]"], "Description": ["\n\nWarning\n\n\n          Use this statement with caution to ensure you do not lose any\n          wanted binary log file data and GTID execution history.\n\n", "\nRESET BINARY LOGS AND GTIDS requires the\n        RELOAD privilege.\n      ", "\n        For a server where binary logging is enabled\n        (log_bin is\n        ON), RESET BINARY LOGS AND\n        GTIDS deletes all existing binary log files and resets\n        the binary log index file, resetting the server to its state\n        before binary logging was started. A new empty binary log file\n        is created so that binary logging can be restarted.\n      ", "\n        For a server where GTIDs are in use\n        (gtid_mode is\n        ON), issuing RESET BINARY LOGS AND\n        GTIDS resets the GTID execution history. The value of\n        the gtid_purged system variable\n        is set to an empty string (''), the global\n        value (but not the session value) of the\n        gtid_executed system variable\n        is set to an empty string, and the\n        mysql.gtid_executed table is cleared (see\n        mysql.gtid_executed Table). If the\n        GTID-enabled server has binary logging enabled, RESET\n        BINARY LOGS AND GTIDS also resets the binary log as\n        described above. Note that RESET BINARY LOGS AND\n        GTIDS is the method to reset the GTID execution\n        history even if the GTID-enabled server is a replica where\n        binary logging is disabled;\n        RESET\n        REPLICA has no effect on the GTID execution history.\n        For more information on resetting the GTID execution history,\n        see Resetting the GTID Execution History.\n      ", "\n        Issuing RESET BINARY LOGS AND GTIDS without\n        the optional TO clause deletes all binary log\n        files listed in the index file, resets the binary log index file\n        to be empty, and creates a new binary log file starting at\n        1. Use the optional TO\n        clause to start the binary log file index from a number other\n        than 1 after the reset.\n      ", "\n        Check that you are using a reasonable value for the index\n        number. If you enter an incorrect value, you can correct this by\n        issuing another RESET BINARY LOGS AND GTIDS\n        statement with or without the TO clause. If\n        you do not correct a value that is out of range, the server\n        cannot be restarted.\n      ", "\n        The following example demonstrates TO clause\n        usage:\n      ", "Press CTRL+C to copy RESET BINARY LOGS AND GTIDS TO 1234;\n\nSHOW BINARY LOGS;\n+-------------------+-----------+-----------+\n| Log_name          | File_size | Encrypted |\n+-------------------+-----------+-----------+\n| source-bin.001234 |       154 | No        |\n+-------------------+-----------+-----------+", "\n\nImportant\n\n\n          The effects of RESET BINARY LOGS AND GTIDS\n          without the TO clause differ from those of\n          PURGE BINARY LOGS in 2 key\n          ways:\n\n\n\nRESET BINARY LOGS AND GTIDS removes\n              all binary log files that are listed\n              in the index file, leaving only a single, empty binary log\n              file with a numeric suffix of .000001,\n              whereas the numbering is not reset by\n              PURGE BINARY LOGS.\n            \nRESET BINARY LOGS AND GTIDS is\n              not intended to be used while any\n              replicas are running. The behavior of RESET\n              BINARY LOGS AND GTIDS when used while replicas\n              are running is undefined (and thus unsupported), whereas\n              PURGE BINARY LOGS may be\n              safely used while replicas are running.\n\n\n\n          See also Section\u00a015.4.1.1, \u201cPURGE BINARY LOGS Statement\u201d.\n\n", "\nRESET BINARY LOGS AND GTIDS without the\n        TO clause can prove useful when you first set\n        up a source and replica, so that you can verify the setup as\n        follows:\n", "\n\n            Start the source and replica, and start replication (see\n            Section\u00a019.1.2, \u201cSetting Up Binary Log File Position Based Replication\u201d).\n          \n            Execute a few test queries on the source.\n          \n            Check that the queries were replicated to the replica.\n          \n            When replication is running correctly, issue\n            STOP REPLICA followed by\n            RESET REPLICA (both on the\n            replica), then verify that no unwanted data from the test\n            queries exists on the replica. Following this, issue\n            RESET BINARY LOGS AND GTIDS (also on the\n            replica) to remove binary logs and and associated\n            transaction IDs.\n          \n            Remove the unwanted data from the source, then issue\n            RESET BINARY LOGS AND GTIDS to purge any\n            binary log entries and identifiers associated with it.\n\n", "\n        After verifying the setup, resetting the source and replica and\n        ensuring that no unwanted data or binary log files generated by\n        testing remain on the source or replica, you can start the\n        replica and begin replicating.\n"], "Examples": ["RESET BINARY LOGS AND GTIDS TO 1234;\n\nSHOW BINARY LOGS;\n+-------------------+-----------+-----------+\n| Log_name          | File_size | Encrypted |\n+-------------------+-----------+-----------+\n| source-bin.001234 |       154 | No        |\n+-------------------+-----------+-----------+"], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/set-sql-log-bin.html"], "Title": ["15.4.1.3 SET sql_log_bin Statement"], "Feature": ["SET sql_log_bin = {OFF|ON}"], "Description": ["\n        The sql_log_bin variable\n        controls whether logging to the binary log is enabled for the\n        current session (assuming that the binary log itself is\n        enabled). The default value is ON. To disable\n        or enable binary logging for the current session, set the\n        session sql_log_bin variable to\n        OFF or ON.\n      ", "\n        Set this variable to OFF for a session to\n        temporarily disable binary logging while making changes to the\n        source that you do not want replicated to the replica.\n      ", "\n        Setting the session value of this system variable is a\n        restricted operation. The session user must have privileges\n        sufficient to set restricted session variables. See\n        Section\u00a07.1.9.1, \u201cSystem Variable Privileges\u201d.\n      ", "\n        It is not possible to set the session value of\n        sql_log_bin within a\n        transaction or subquery.\n      ", "\nSetting this variable to OFF\n        prevents new GTIDs from being assigned to transactions in the\n        binary log. If you are using GTIDs for replication,\n        this means that even when binary logging is later enabled again,\n        the GTIDs written into the log from this point do not account\n        for any transactions that occurred in the meantime, so in effect\n        those transactions are lost.\n      ", "\nmysqldump adds a SET\n        @@SESSION.sql_log_bin=0 statement to a dump file from\n        a server where GTIDs are in use, which disables binary logging\n        while the dump file is being reloaded. The statement prevents\n        new GTIDs from being generated and assigned to the transactions\n        in the dump file as they are executed, so that the original\n        GTIDs for the transactions are used.\n"], "Examples": [], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/change-replication-filter.html"], "Title": ["15.4.2.1 CHANGE REPLICATION FILTER Statement"], "Feature": ["CHANGE REPLICATION FILTER filter[, filter]\n\t[, ...] [FOR CHANNEL channel]\n\nfilter: {\n    REPLICATE_DO_DB = (db_list)\n  | REPLICATE_IGNORE_DB = (db_list)\n  | REPLICATE_DO_TABLE = (tbl_list)\n  | REPLICATE_IGNORE_TABLE = (tbl_list)\n  | REPLICATE_WILD_DO_TABLE = (wild_tbl_list)\n  | REPLICATE_WILD_IGNORE_TABLE = (wild_tbl_list)\n  | REPLICATE_REWRITE_DB = (db_pair_list)\n}\n\ndb_list:\n    db_name[, db_name][, ...]\n\ntbl_list:\n    db_name.table_name[, db_name.table_name][, ...]\nwild_tbl_list:\n    'db_pattern.table_pattern'[, 'db_pattern.table_pattern'][, ...]\n\ndb_pair_list:\n    (db_pair)[, (db_pair)][, ...]\n\ndb_pair:\n    from_db, to_db"], "Description": ["\nCHANGE REPLICATION FILTER sets one or more\n        replication filtering rules on the replica in the same way as\n        starting the replica mysqld with replication\n        filtering options such as\n        --replicate-do-db or\n        --replicate-wild-ignore-table.\n        Filters set using this statement differ from those set using the\n        server options in two key respects:\n", "\n\n            The statement does not require restarting the server to take\n            effect, only that the replication SQL thread be stopped\n            using STOP\n            REPLICA SQL_THREAD first (and restarted with\n            START REPLICA\n            SQL_THREAD afterwards).\n          \n            The effects of the statement are not persistent; any filters\n            set using CHANGE REPLICATION FILTER are\n            lost following a restart of the replica\n            mysqld.\n\n", "\nCHANGE REPLICATION FILTER\n        requires the\n        REPLICATION_SLAVE_ADMIN privilege\n        (or the deprecated SUPER\n        privilege).\n      ", "\n        Use the FOR CHANNEL\n        channel clause to make a\n        replication filter specific to a replication channel, for\n        example on a multi-source replica. Filters applied without a\n        specific FOR CHANNEL clause are considered\n        global filters, meaning that they are applied to all replication\n        channels.\n      ", "\n", "\n\nNote\n\n\n            Global replication filters cannot be set on a MySQL server\n            instance that is configured for Group Replication, because\n            filtering transactions on some servers would make the group\n            unable to reach agreement on a consistent state. Channel\n            specific replication filters can be set on replication\n            channels that are not directly involved with Group\n            Replication, such as where a group member also acts as a\n            replica to a source that is outside the group. They cannot\n            be set on the group_replication_applier\n            or group_replication_recovery channels.\n\n", "\n", "\n        The following list shows the CHANGE REPLICATION\n        FILTER options and how they relate to\n        --replicate-* server options:\n", "\n\nREPLICATE_DO_DB: Include updates based on\n            database name. Equivalent to\n            --replicate-do-db.\n          \nREPLICATE_IGNORE_DB: Exclude updates\n            based on database name. Equivalent to\n            --replicate-ignore-db.\n          \nREPLICATE_DO_TABLE: Include updates based\n            on table name. Equivalent to\n            --replicate-do-table.\n          \nREPLICATE_IGNORE_TABLE: Exclude updates\n            based on table name. Equivalent to\n            --replicate-ignore-table.\n          \nREPLICATE_WILD_DO_TABLE: Include updates\n            based on wildcard pattern matching table name. Equivalent to\n            --replicate-wild-do-table.\n          \nREPLICATE_WILD_IGNORE_TABLE: Exclude\n            updates based on wildcard pattern matching table name.\n            Equivalent to\n            --replicate-wild-ignore-table.\n          \nREPLICATE_REWRITE_DB: Perform updates on\n            replica after substituting new name on replica for specified\n            database on source. Equivalent to\n            --replicate-rewrite-db.\n\n", "\n        The precise effects of REPLICATE_DO_DB and\n        REPLICATE_IGNORE_DB filters are dependent on\n        whether statement-based or row-based replication is in effect.\n        See Section\u00a019.2.5, \u201cHow Servers Evaluate Replication Filtering Rules\u201d, for more information.\n      ", "\n        Multiple replication filtering rules can be created in a single\n        CHANGE REPLICATION FILTER statement by\n        separating the rules with commas, as shown here:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (d1), REPLICATE_IGNORE_DB = (d2);", "\n        Issuing the statement just shown is equivalent to starting the\n        replica mysqld with the options\n        --replicate-do-db=d1\n--replicate-ignore-db=d2.\n      ", "\n        On a multi-source replica, which uses multiple replication\n        channels to process transaction from different sources, use the\n        FOR CHANNEL\n        channel clause to set a\n        replication filter on a replication channel:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER REPLICATE_DO_DB = (d1) FOR CHANNEL channel_1;", "\n        This enables you to create a channel specific replication filter\n        to filter out selected data from a source. When a FOR\n        CHANNEL clause is provided, the replication filter\n        statement acts on that replication channel, removing any\n        existing replication filter which has the same filter type as\n        the specified replication filters, and replacing them with the\n        specified filter. Filter types not explicitly listed in the\n        statement are not modified. If issued against a replication\n        channel which is not configured, the statement fails with an\n        ER_SLAVE_CONFIGURATION error. If issued\n        against Group Replication channels, the statement fails with an\n        ER_SLAVE_CHANNEL_OPERATION_NOT_ALLOWED\n        error.\n      ", "\n        On a replica with multiple replication channels configured,\n        issuing CHANGE REPLICATION FILTER\n        with no FOR CHANNEL clause configures the\n        replication filter for every configured replication channel, and\n        for the global replication filters. For every filter type, if\n        the filter type is listed in the statement, then any existing\n        filter rules of that type are replaced by the filter rules\n        specified in the most recently issued statement, otherwise the\n        old value of the filter type is retained. For more information\n        see Section\u00a019.2.5.4, \u201cReplication Channel Based Filters\u201d.\n      ", "\n        If the same filtering rule is specified multiple times, only the\n        last such rule is actually used. For\n        example, the two statements shown here have exactly the same\n        effect, because the first REPLICATE_DO_DB\n        rule in the first statement is ignored:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (db1, db2), REPLICATE_DO_DB = (db3, db4);\n\nCHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (db3, db4);", "\n\nCaution\n\n\n          This behavior differs from that of the\n          --replicate-* filter options where specifying\n          the same option multiple times causes the creation of multiple\n          filter rules.\n\n", "\n        Names of tables and database not containing any special\n        characters need not be quoted. Values used with\n        REPLICATION_WILD_TABLE and\n        REPLICATION_WILD_IGNORE_TABLE are string\n        expressions, possibly containing (special) wildcard characters,\n        and so must be quoted. This is shown in the following example\n        statements:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER\n    REPLICATE_WILD_DO_TABLE = ('db1.old%');\n\nCHANGE REPLICATION FILTER\n    REPLICATE_WILD_IGNORE_TABLE = ('db1.new%', 'db2.new%');", "\n        Values used with REPLICATE_REWRITE_DB\n        represent pairs of database names; each\n        such value must be enclosed in parentheses. The following\n        statement rewrites statements occurring on database\n        db1 on the source to database\n        db2 on the replica:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB = ((db1, db2));", "\n        The statement just shown contains two sets of parentheses, one\n        enclosing the pair of database names, and the other enclosing\n        the entire list. This is perhaps more easily seen in the\n        following example, which creates two\n        rewrite-db rules, one rewriting database\n        dbA to dbB, and one\n        rewriting database dbC to\n        dbD:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER\n  REPLICATE_REWRITE_DB = ((dbA, dbB), (dbC, dbD));", "\n        The CHANGE REPLICATION FILTER\n        statement replaces replication filtering rules only for the\n        filter types and replication channels affected by the statement,\n        and leaves other rules and channels unchanged. If you want to\n        unset all filters of a given type, set the filter's value\n        to an explicitly empty list, as shown in this example, which\n        removes all existing REPLICATE_DO_DB and\n        REPLICATE_IGNORE_DB rules:\n      ", "Press CTRL+C to copy CHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (), REPLICATE_IGNORE_DB = ();", "\n        Setting a filter to empty in this way removes all existing\n        rules, does not create any new ones, and does not restore any\n        rules set at mysqld startup using --replicate-*\n        options on the command line or in the configuration file.\n      ", "\n        The RESET REPLICA\n        ALL statement removes channel specific replication\n        filters that were set on channels deleted by the statement. When\n        the deleted channel or channels are recreated, any global\n        replication filters specified for the replica are copied to\n        them, and no channel specific replication filters are applied.\n      ", "\n        For more information, see Section\u00a019.2.5, \u201cHow Servers Evaluate Replication Filtering Rules\u201d.\n"], "Examples": ["CHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (d1), REPLICATE_IGNORE_DB = (d2);", "CHANGE REPLICATION FILTER REPLICATE_DO_DB = (d1) FOR CHANNEL channel_1;", "CHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (db1, db2), REPLICATE_DO_DB = (db3, db4);\n\nCHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (db3, db4);", "CHANGE REPLICATION FILTER\n    REPLICATE_WILD_DO_TABLE = ('db1.old%');\n\nCHANGE REPLICATION FILTER\n    REPLICATE_WILD_IGNORE_TABLE = ('db1.new%', 'db2.new%');", "CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB = ((db1, db2));", "CHANGE REPLICATION FILTER\n  REPLICATE_REWRITE_DB = ((dbA, dbB), (dbC, dbD));", "CHANGE REPLICATION FILTER\n    REPLICATE_DO_DB = (), REPLICATE_IGNORE_DB = ();"], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html"], "Title": ["15.4.2.2 CHANGE REPLICATION SOURCE TO Statement"], "Feature": ["CHANGE REPLICATION SOURCE TO option [, option] ... [ channel_option ]\n\noption: {\n    SOURCE_BIND = 'interface_name'\n  | SOURCE_HOST = 'host_name'\n  | SOURCE_USER = 'user_name'\n  | SOURCE_PASSWORD = 'password'\n  | SOURCE_PORT = port_num\n  | PRIVILEGE_CHECKS_USER = {NULL | 'account'}\n  | REQUIRE_ROW_FORMAT = {0|1}\n  | REQUIRE_TABLE_PRIMARY_KEY_CHECK = {STREAM | ON | OFF | GENERATE}\n  | ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS = {OFF | LOCAL | uuid}\n  | SOURCE_LOG_FILE = 'source_log_name'\n  | SOURCE_LOG_POS = source_log_pos\n  | SOURCE_AUTO_POSITION = {0|1}\n  | RELAY_LOG_FILE = 'relay_log_name'\n  | RELAY_LOG_POS = relay_log_pos\n  | SOURCE_HEARTBEAT_PERIOD = interval\n  | SOURCE_CONNECT_RETRY = interval\n  | SOURCE_RETRY_COUNT = count\n  | SOURCE_CONNECTION_AUTO_FAILOVER = {0|1}\n  | SOURCE_DELAY = interval\n  | SOURCE_COMPRESSION_ALGORITHMS = 'algorithm[,algorithm][,algorithm]'\n  | SOURCE_ZSTD_COMPRESSION_LEVEL = level\n  | SOURCE_SSL = {0|1}\n  | SOURCE_SSL_CA = 'ca_file_name'\n  | SOURCE_SSL_CAPATH = 'ca_directory_name'\n  | SOURCE_SSL_CERT = 'cert_file_name'\n  | SOURCE_SSL_CRL = 'crl_file_name'\n  | SOURCE_SSL_CRLPATH = 'crl_directory_name'\n  | SOURCE_SSL_KEY = 'key_file_name'\n  | SOURCE_SSL_CIPHER = 'cipher_list'\n  | SOURCE_SSL_VERIFY_SERVER_CERT = {0|1}\n  | SOURCE_TLS_VERSION = 'protocol_list'\n  | SOURCE_TLS_CIPHERSUITES = 'ciphersuite_list'\n  | SOURCE_PUBLIC_KEY_PATH = 'key_file_name'\n  | GET_SOURCE_PUBLIC_KEY = {0|1}\n  | NETWORK_NAMESPACE = 'namespace'\n  | IGNORE_SERVER_IDS = (server_id_list),\n  | GTID_ONLY = {0|1}\n}\n\nchannel_option:\n    FOR CHANNEL channel\n\nserver_id_list:\n    [server_id [, server_id] ... ]"], "Description": ["\nCHANGE REPLICATION SOURCE TO\n        changes the parameters that the replica server uses for\n        connecting to the source and reading data from the source. It\n        also updates the contents of the replication metadata\n        repositories (see Section\u00a019.2.4, \u201cRelay Log and Replication Metadata Repositories\u201d).\n      ", "\nCHANGE REPLICATION SOURCE TO\n        requires the\n        REPLICATION_SLAVE_ADMIN privilege\n        (or the deprecated SUPER\n        privilege).\n      ", "\n        Options that you do not specify on a CHANGE\n        REPLICATION SOURCE TO statement retain their value,\n        except as indicated in the following discussion. In most cases,\n        there is therefore no need to specify options that do not\n        change.\n      ", "\n        Values used for SOURCE_HOST and other\n        CHANGE REPLICATION SOURCE TO\n        options are checked for linefeed (\\n or\n        0x0A) characters. The presence of such\n        characters in these values causes the statement to fail with an\n        error.\n      ", "\n        The optional FOR CHANNEL\n        channel clause lets you\n        name which replication channel the statement applies to.\n        Providing a FOR CHANNEL\n        channel clause applies the\n        CHANGE REPLICATION SOURCE TO\n        statement to a specific replication channel, and is used to add\n        a new channel or modify an existing channel. For example, to add\n        a new channel called channel2:\n      ", "Press CTRL+C to copy CHANGE REPLICATION SOURCE TO SOURCE_HOST=host1, SOURCE_PORT=3002 FOR CHANNEL 'channel2';", "\n        If no clause is named and no extra channels exist, a\n        CHANGE REPLICATION SOURCE TO\n        statement applies to the default channel, whose name is the\n        empty string (\"\"). When you have set up multiple replication\n        channels, every CHANGE REPLICATION SOURCE\n        TO statement must name a channel using the\n        FOR CHANNEL\n        channel clause. See\n        Section\u00a019.2.2, \u201cReplication Channels\u201d for more information.\n      ", "\n        For some of the options of the CHANGE\n        REPLICATION SOURCE TO statement, you must issue a\n        STOP REPLICA statement prior to\n        issuing a CHANGE REPLICATION SOURCE\n        TO statement (and a START\n        REPLICA statement afterwards). Sometimes, you only\n        need to stop the replication SQL (applier) thread or the\n        replication I/O (receiver) thread, not both:\n", "\n\n            When the applier thread is stopped, you can execute\n            CHANGE REPLICATION SOURCE TO\n            using any combination that is otherwise allowed of\n            RELAY_LOG_FILE,\n            RELAY_LOG_POS, and\n            SOURCE_DELAY options, even if the\n            replication receiver thread is running. No other options may\n            be used with this statement when the receiver thread is\n            running.\n          \n            When the receiver thread is stopped, you can execute\n            CHANGE REPLICATION SOURCE TO\n            using any of the options for this statement (in any allowed\n            combination) except\nRELAY_LOG_FILE,\n            RELAY_LOG_POS,\n            SOURCE_DELAY, or\n            SOURCE_AUTO_POSITION = 1 even when the\n            applier thread is running.\n          \n            Both the receiver thread and the applier thread must be\n            stopped before issuing a CHANGE\n            REPLICATION SOURCE TO statement that employs\n            SOURCE_AUTO_POSITION = 1,\n            GTID_ONLY = 1, or\n            ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS.\n\n", "\n        You can check the current state of the replication applier\n        thread and replication receiver thread using\n        SHOW\n        REPLICA STATUS. Note that the Group Replication\n        applier channel (group_replication_applier)\n        has no receiver thread, only an applier thread.\n      ", "\nCHANGE REPLICATION SOURCE TO\n        statements have a number of side-effects and interactions that\n        you should be aware of beforehand:\n", "\n\nCHANGE REPLICATION SOURCE TO\n            causes an implicit commit of an ongoing transaction. See\n            Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n          \nCHANGE REPLICATION SOURCE TO\n            causes the previous values for\n            SOURCE_HOST,\n            SOURCE_PORT,\n            SOURCE_LOG_FILE, and\n            SOURCE_LOG_POS to be written to the error\n            log, along with other information about the replica's\n            state prior to execution.\n          \n            If you are using statement-based replication and temporary\n            tables, it is possible for a CHANGE\n            REPLICATION SOURCE TO statement following a\n            STOP\n            REPLICA statement to leave behind temporary tables\n            on the replica. A warning\n            (ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO)\n            is issued whenever this occurs. You can avoid this in such\n            cases by making sure that the value of the\n            Replica_open_temp_tables\n            system status variable is equal to 0 prior to executing such\n            a CHANGE REPLICATION SOURCE\n            TO statement.\n          \n            When using a multithreaded replica\n            (replica_parallel_workers\n            > 0), stopping the replica can cause gaps in the sequence\n            of transactions that have been executed from the relay log,\n            regardless of whether the replica was stopped intentionally\n            or otherwise. In MySQL 8.4, these can be\n            resolved using GTID auto-positioning.\n\n", "\n        The following options are available for\n        CHANGE REPLICATION SOURCE TO\n        statements:\n", "\n\nASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS\n            = {OFF | LOCAL | uuid}\n\n            Makes the replication channel assign a GTID to replicated\n            transactions that do not have one, enabling replication from\n            a source that does not use GTID-based replication, to a\n            replica that does. For a multi-source replica, you can have\n            a mix of channels that use\n            ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS,\n            and channels that do not. The default is\n            OFF, meaning that the feature is not\n            used.\n          \nLOCAL assigns a GTID including the\n            replica's own UUID (the\n            server_uuid setting).\n            uuid assigns a\n            GTID including the specified UUID, such as the\n            server_uuid setting for the\n            replication source server. Using a nonlocal UUID lets you\n            differentiate between transactions that originated on the\n            replica and transactions that originated on the source, and\n            for a multi-source replica, between transactions that\n            originated on different sources. The UUID you choose only\n            has significance for the replica's own use. If any of the\n            transactions sent by the source do have a GTID already, that\n            GTID is retained.\n          \n            Channels specific to Group Replication cannot use\n            ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS,\n            but an asynchronous replication channel for another source\n            on a server instance that is a Group Replication group\n            member can do so. In that case, do not specify the Group\n            Replication group name as the UUID for creating the GTIDs.\n          \n            To set\n            ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS to\n            LOCAL or\n            uuid, the\n            replica must have\n            gtid_mode=ON set, and this\n            cannot be changed afterwards. This option is for use with a\n            source that has binary log file position based replication,\n            so SOURCE_AUTO_POSITION=1 cannot be set\n            for the channel. Both the replication SQL thread and the\n            replication I/O (receiver) thread must be stopped before\n            setting this option.\n\n\n\nImportant\n\n\n              A replica set up with\n              ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS\n              on any channel cannot be promoted to replace the\n              replication source server in the event that a failover is\n              required, and a backup taken from the replica cannot be\n              used to restore the replication source server. The same\n              restriction applies to replacing or restoring other\n              replicas that use\n              ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS\n              on any channel.\n\n\n\n            For further restrictions and information, see\n            Section\u00a019.1.3.6, \u201cReplication From a Source Without GTIDs to a Replica With GTIDs\u201d.\n          \nGET_SOURCE_PUBLIC_KEY =\n            {0|1}\n\n            Enables RSA key pair-based password exchange by requesting\n            the public key from the source. The option is disabled by\n            default.\n          \n            This option applies to replicas that authenticate with the\n            caching_sha2_password authentication\n            plugin. For connections by accounts that authenticate using\n            this plugin, the source does not send the public key unless\n            requested, so it must be requested or specified in the\n            client. If SOURCE_PUBLIC_KEY_PATH is\n            given and specifies a valid public key file, it takes\n            precedence over GET_SOURCE_PUBLIC_KEY. If\n            you are using a replication user account that authenticates\n            with the caching_sha2_password plugin\n            (the default), and you are not using a secure connection,\n            you must specify either this option or the\n            SOURCE_PUBLIC_KEY_PATH option to provide\n            the RSA public key to the replica.\n          \nGTID_ONLY = {0|1}\n\n            Stops the replication channel persisting file names and file\n            positions in the replication metadata repositories.\n            GTID_ONLY is disabled by default for\n            asynchronous replication channels, but is enabled by default\n            for Group Replication channels, for which it cannot be\n            disabled.\n          \n            For replication channels with this setting, in-memory file\n            positions are still tracked, and file positions can still be\n            observed for debugging purposes in error messages and\n            through interfaces such as SHOW REPLICA\n            STATUS statements (where they are shown as being\n            invalid if they are out of date). However, the writes and\n            reads required to persist and check the file positions are\n            avoided in situations where GTID-based replication does not\n            actually require them, including the transaction queuing and\n            application process.\n          \n            This option can be used only if both the replication SQL\n            (applier) thread and replication I/O (receiver) thread are\n            stopped. To set GTID_ONLY = 1 for a\n            replication channel, GTIDs must be in use on the server\n            (gtid_mode = ON), and\n            row-based binary logging must be in use on the source\n            (statement-based replication is not supported). The options\n            REQUIRE_ROW_FORMAT = 1 and\n            SOURCE_AUTO_POSITION = 1 must be set for\n            the replication channel.\n          \n            When GTID_ONLY = 1 is set, the replica\n            uses\n            replica_parallel_workers=1\n            if that system variable is set to zero for the server, so it\n            is always technically a multi-threaded applier. This is\n            because a multi-threaded applier uses saved positions rather\n            than the replication metadata repositories to locate the\n            start of a transaction that it needs to reapply.\n          \n            If you disable GTID_ONLY after setting\n            it, the existing relay logs are deleted and the existing\n            known binary log file positions are persisted, even if they\n            are stale. The file positions for the binary log and relay\n            log in the replication metadata repositories might be\n            invalid, and a warning is returned if this is the case.\n            Provided that SOURCE_AUTO_POSITION is\n            still enabled, GTID auto-positioning is used to provide the\n            correct positioning.\n          \n            If you also disable SOURCE_AUTO_POSITION,\n            the file positions for the binary log and relay log in the\n            replication metadata repositories are used for positioning\n            if they are valid. If they are marked as invalid, you must\n            provide a valid binary log file name and position\n            (SOURCE_LOG_FILE and\n            SOURCE_LOG_POS). If you also provide a\n            relay log file name and position\n            (RELAY_LOG_FILE and\n            RELAY_LOG_POS), the relay logs are\n            preserved and the applier position is set to the stated\n            position. GTID auto-skip ensures that any transactions\n            already applied are skipped even if the eventual applier\n            position is not correct.\n          \nIGNORE_SERVER_IDS =\n            (server_id_list)\n\n            Makes the replica ignore events originating from the\n            specified servers. The option takes a comma-separated list\n            of 0 or more server IDs. Log rotation and deletion events\n            from the servers are not ignored, and are recorded in the\n            relay log.\n          \n            In circular replication, the originating server normally\n            acts as the terminator of its own events, so that they are\n            not applied more than once. Thus, this option is useful in\n            circular replication when one of the servers in the circle\n            is removed. Suppose that you have a circular replication\n            setup with 4 servers, having server IDs 1, 2, 3, and 4, and\n            server 3 fails. When bridging the gap by starting\n            replication from server 2 to server 4, you can include\n            IGNORE_SERVER_IDS = (3) in the\n            CHANGE REPLICATION SOURCE TO\n            statement that you issue on server 4 to tell it to use\n            server 2 as its source instead of server 3. Doing so causes\n            it to ignore and not to propagate any statements that\n            originated with the server that is no longer in use.\n          \n            If IGNORE_SERVER_IDS contains the\n            server's own ID and the server was started with the\n            --replicate-same-server-id\n            option enabled, an error results.\n          \n            The source metadata repository and the output of\n            SHOW\n            REPLICA STATUS provide the list of servers that\n            are currently ignored. For more information, see\n            Section\u00a019.2.4.2, \u201cReplication Metadata Repositories\u201d, and\n            Section\u00a015.7.7.34, \u201cSHOW REPLICA STATUS Statement\u201d.\n          \n            If a CHANGE REPLICATION SOURCE\n            TO statement is issued without\n            IGNORE_SERVER_IDS, any existing list is\n            preserved. To clear the list of ignored servers, it is\n            necessary to use the option with an empty list, like this:\n          Press CTRL+C to copy CHANGE REPLICATION SOURCE TO IGNORE_SERVER_IDS = ();\nRESET REPLICA\n            ALL also clears\n            IGNORE_SERVER_IDS.\n          \n            When global transaction identifiers (GTIDs) are used for\n            replication, transactions that have already been applied are\n            automatically ignored. Because of this,\n            IGNORE_SERVER_IDS is not compatible with\n            gtid_mode=ON. If\n            gtid_mode is ON,\n            CHANGE REPLICATION SOURCE TO with a\n            non-empty IGNORE_SERVER_IDS list is\n            rejected with an error. Likewise, if any existing\n            replication channel was created with a list of server IDs to\n            be ignored, SET gtid_mode=ON is also\n            rejected. Before starting GTID-based replication, check for\n            and clear any ignored server ID lists on the servers\n            involved; you can do this by checking the output from\n            SHOW REPLICA STATUS. In such\n            cases, you can clear the list by issuing CHANGE\n            REPLICATION SOURCE TO with an empty list of server\n            IDs as shown previously.\n          \nNETWORK_NAMESPACE =\n            'namespace'\n\n            The network namespace to use for TCP/IP connections to the\n            replication source server or, if the MySQL communication\n            stack is in use, for Group Replication\u2019s group\n            communication connections. The maximum length of the string\n            value is 64 characters. If this option is omitted,\n            connections from the replica use the default (global)\n            namespace. On platforms that do not implement network\n            namespace support, failure occurs when the replica attempts\n            to connect to the source. For information about network\n            namespaces, see Section\u00a07.1.14, \u201cNetwork Namespace Support\u201d.\n          \nPRIVILEGE_CHECKS_USER = {NULL |\n            'account'}\n\n            Names a user account that supplies a security context for\n            the specified channel. NULL, which is the\n            default, means no security context is used.\n          \n            The user name and host name for the user account must follow\n            the syntax described in Section\u00a08.2.4, \u201cSpecifying Account Names\u201d, and\n            the user must not be an anonymous user (with a blank user\n            name) or the CURRENT_USER. The account\n            must have the\n            REPLICATION_APPLIER\n            privilege, plus the required privileges to execute the\n            transactions replicated on the channel. For details of the\n            privileges required by the account, see\n            Section\u00a019.3.3, \u201cReplication Privilege Checks\u201d. When you\n            restart the replication channel, the privilege checks are\n            applied from that point on. If you do not specify a channel\n            and no other channels exist, the statement is applied to the\n            default channel.\n          \n            The use of row-based binary logging is strongly recommended\n            when PRIVILEGE_CHECKS_USER is set, and\n            you can set REQUIRE_ROW_FORMAT to enforce\n            this. For example, to start privilege checks on the channel\n            channel_1 on a running replica, issue the\n            following statements:\n          Press CTRL+C to copy STOP REPLICA FOR CHANNEL 'channel_1';\n\nCHANGE REPLICATION SOURCE TO\n    PRIVILEGE_CHECKS_USER = 'user'@'host',\n    REQUIRE_ROW_FORMAT = 1,\n    FOR CHANNEL 'channel_1';\n\nSTART REPLICA FOR CHANNEL 'channel_1';\nRELAY_LOG_FILE =\n            'relay_log_file' ,\n            RELAY_LOG_POS =\n            'relay_log_pos'\n\n            The relay log file name, and the location in that file, at\n            which the replication SQL thread begins reading from the\n            replica's relay log the next time the thread starts.\n            RELAY_LOG_FILE can use either an absolute\n            or relative path, and uses the same base name as\n            SOURCE_LOG_FILE. The maximum length of\n            the string value is 511 characters.\n          \n            A CHANGE REPLICATION SOURCE TO statement\n            using RELAY_LOG_FILE,\n            RELAY_LOG_POS, or both options can be\n            executed on a running replica when the replication SQL\n            (applier) thread is stopped. Relay logs are preserved if at\n            least one of the replication applier thread and the\n            replication I/O (receiver) thread is running. If both\n            threads are stopped, all relay log files are deleted unless\n            at least one of RELAY_LOG_FILE or\n            RELAY_LOG_POS is specified. For the Group\n            Replication applier channel\n            (group_replication_applier), which only\n            has an applier thread and no receiver thread, this is the\n            case if the applier thread is stopped, but with that channel\n            you cannot use the RELAY_LOG_FILE and\n            RELAY_LOG_POS options.\n          \nREQUIRE_ROW_FORMAT = {0|1}\n\n            Permits only row-based replication events to be processed by\n            the replication channel. This option prevents the\n            replication applier from taking actions such as creating\n            temporary tables and executing LOAD DATA\n            INFILE requests, which increases the security of\n            the channel. The REQUIRE_ROW_FORMAT\n            option is disabled by default for asynchronous replication\n            channels, but it is enabled by default for Group Replication\n            channels, and it cannot be disabled for them. For more\n            information, see\n            Section\u00a019.3.3, \u201cReplication Privilege Checks\u201d.\n          \nREQUIRE_TABLE_PRIMARY_KEY_CHECK =\n            {STREAM | ON | OFF | GENERATE}\n\n            This option lets a replica set its own policy for primary\n            key checks, as follows:\n\n\n\nON: The replica sets\n                sql_require_primary_key =\n                ON; any replicated CREATE\n                TABLE or ALTER\n                TABLE statement must result in a table that\n                contains a primary key.\n              \nOFF: The replica sets\n                sql_require_primary_key = OFF; no\n                replicated CREATE TABLE or\n                ALTER TABLE statement is checked for\n                the presence of a primary key.\n              \nSTREAM: The replica uses whatever\n                value of sql_require_primary_key is\n                replicated from the source for each transaction. This is\n                the default value, and the default behavior.\n              \nGENERATE: Causes the replica to\n                generate an invisible primary key for any\n                InnoDB table that, as\n                replicated, lacks a primary key. See\n                Section\u00a015.1.20.11, \u201cGenerated Invisible Primary Keys\u201d, for more\n                information.\n              \nGENERATE is not compatible with Group\n                Replication; you can use ON,\n                OFF, or STREAM.\n\n\n\n            A divergence based on the presence of a generated invisible\n            primary key solely on a source or replica table is supported\n            by MySQL Replication as long as the source supports GIPKs\n            and the replica uses MySQL version 8.0.32 or later. If you\n            use GIPKs on a replica with the source using an earlier\n            version of MySQL, such divergences in schema, other than the\n            extra GIPK on the replica, are not supported and may result\n            in replication errors.\n          \n            For multisource replication, setting\n            REQUIRE_TABLE_PRIMARY_KEY_CHECK to\n            ON or OFF lets the\n            replica normalize behavior across replication channels for\n            different sources, and to keep a consistent setting for\n            sql_require_primary_key.\n            Using ON safeguards against the\n            accidental loss of primary keys when multiple sources update\n            the same set of tables. Using OFF lets\n            sources that can manipulate primary keys to work alongside\n            sources that cannot.\n          \n            In the case of multiple replicas, when\n            REQUIRE_TABLE_PRIMARY_KEY_CHECK is set to\n            GENERATE, the generated invisible primary\n            key added by a given replica is independent of any such key\n            added on any other replica. This means that, if generated\n            invisible primary keys are in use, the values in the\n            generated primary key columns on different replicas are not\n            guaranteed to be the same. This may be an issue when failing\n            over to such a replica.\n          \n            When PRIVILEGE_CHECKS_USER is\n            NULL (the default), the user account does\n            not need administration level privileges to set restricted\n            session variables. Setting this option to a value other than\n            NULL means that, when\n            REQUIRE_TABLE_PRIMARY_KEY_CHECK is\n            ON, OFF, or\n            GENERATE, the user account does not\n            require session administration level privileges to set\n            restricted session variables such as\n            sql_require_primary_key,\n            avoiding the need to grant the account such privileges. For\n            more information, see\n            Section\u00a019.3.3, \u201cReplication Privilege Checks\u201d.\n          \nSOURCE_AUTO_POSITION =\n            {0|1}\n\n            Makes the replica attempt to connect to the source using the\n            auto-positioning feature of GTID-based replication, rather\n            than a binary log file based position. This option is used\n            to start a replica using GTID-based replication. The default\n            is 0, meaning that GTID auto-positioning and GTID-based\n            replication are not used. This option can be used with\n            CHANGE REPLICATION SOURCE TO only if both\n            the replication SQL (applier) thread and replication I/O\n            (receiver) thread are stopped.\n          \n            Both the replica and the source must have GTIDs enabled\n            (GTID_MODE=ON,\n            ON_PERMISSIVE, or\n            OFF_PERMISSIVE on the replica, and\n            GTID_MODE=ON on the\n            source). SOURCE_LOG_FILE,\n            SOURCE_LOG_POS,\n            RELAY_LOG_FILE, and\n            RELAY_LOG_POS cannot be specified\n            together with SOURCE_AUTO_POSITION = 1.\n            If multi-source replication is enabled on the replica, you\n            need to set the SOURCE_AUTO_POSITION = 1\n            option for each applicable replication channel.\n          \n            With SOURCE_AUTO_POSITION = 1 set, in the\n            initial connection handshake, the replica sends a GTID set\n            containing the transactions that it has already received,\n            committed, or both. The source responds by sending all\n            transactions recorded in its binary log whose GTID is not\n            included in the GTID set sent by the replica. This exchange\n            ensures that the source only sends the transactions with a\n            GTID that the replica has not already recorded or committed.\n            If the replica receives transactions from more than one\n            source, as in the case of a diamond topology, the auto-skip\n            function ensures that the transactions are not applied\n            twice. For details of how the GTID set sent by the replica\n            is computed, see\n            Section\u00a019.1.3.3, \u201cGTID Auto-Positioning\u201d.\n          \n            If any of the transactions that should be sent by the source\n            have been purged from the source's binary log, or added to\n            the set of GTIDs in the\n            gtid_purged system variable\n            by another method, the source sends the error\n            ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS\n            to the replica, and replication does not start. The GTIDs of\n            the missing purged transactions are identified and listed in\n            the source's error log in the warning message\n            ER_FOUND_MISSING_GTIDS.\n            Also, if during the exchange of transactions it is found\n            that the replica has recorded or committed transactions with\n            the source's UUID in the GTID, but the source itself has not\n            committed them, the source sends the error\n            ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE\n            to the replica and replication does not start. For\n            information on how to handle these situations, see\n            Section\u00a019.1.3.3, \u201cGTID Auto-Positioning\u201d.\n          \n            You can see whether replication is running with GTID\n            auto-positioning enabled by checking the Performance Schema\n            replication_connection_status\n            table or the output of\n            SHOW\n            REPLICA STATUS. Disabling the\n            SOURCE_AUTO_POSITION option again makes\n            the replica revert to file-based replication.\n          \nSOURCE_BIND =\n            'interface_name'\n\n            Determines which of the replica's network interfaces is\n            chosen for connecting to the source, for use on replicas\n            that have multiple network interfaces. Specify the IP\n            address of the network interface. The maximum length of the\n            string value is 255 characters.\n          \n            The IP address configured with this option, if any, can be\n            seen in the Source_Bind column of the\n            output from\n            SHOW\n            REPLICA STATUS. In the source metadata repository\n            table mysql.slave_master_info, the value\n            can be seen as the Source_bind column.\n            The ability to bind a replica to a specific network\n            interface is also supported by NDB Cluster.\n          \nSOURCE_COMPRESSION_ALGORITHMS =\n            'algorithm[,algorithm][,algorithm]'\n\n            Specifies one, two, or three of the permitted compression\n            algorithms for connections to the replication source server,\n            separated by commas. The maximum length of the string value\n            is 99 characters. The default value is\n            uncompressed.\n          \n            The available algorithms are zlib,\n            zstd, and\n            uncompressed, the same as for the\n            protocol_compression_algorithms\n            system variable. The algorithms can be specified in any\n            order, but it is not an order of preference - the algorithm\n            negotiation process attempts to use zlib,\n            then zstd, then\n            uncompressed, if they are specified.\n          \n            The value of\n            SOURCE_COMPRESSION_ALGORITHMS applies\n            only if the\n            replica_compressed_protocol\n            system variable is disabled. If\n            replica_compressed_protocol is enabled,\n            it takes precedence over\n            SOURCE_COMPRESSION_ALGORITHMS and\n            connections to the source use zlib\n            compression if both source and replica support that\n            algorithm. For more information, see\n            Section\u00a06.2.8, \u201cConnection Compression Control\u201d.\n          \n            Binary log transaction compression is activated by the\n            binlog_transaction_compression\n            system variable, and can also be used to save bandwidth. If\n            you do this in combination with connection compression,\n            connection compression has less opportunity to act on the\n            data, but can still compress headers and those events and\n            transaction payloads that are uncompressed. For more\n            information on binary log transaction compression, see\n            Section\u00a07.4.4.5, \u201cBinary Log Transaction Compression\u201d.\n          \nSOURCE_CONNECT_RETRY =\n            interval\n\n            Specifies the interval in seconds between the reconnection\n            attempts that the replica makes after the connection to the\n            source times out. The default interval is 60.\n          \n            The number of attempts is limited by the\n            SOURCE_RETRY_COUNT option. If both the\n            default settings are used, the replica waits 60 seconds\n            between reconnection attempts\n            (SOURCE_CONNECT_RETRY=60), and keeps\n            attempting to reconnect at this rate for 10 minutes\n            (SOURCE_RETRY_COUNT=10). These values are\n            recorded in the source metadata repository and shown in the\n            replication_connection_configuration\n            Performance Schema table.\n          \nSOURCE_CONNECTION_AUTO_FAILOVER =\n            {0|1}\n\n            Activates the asynchronous connection failover mechanism for\n            a replication channel if one or more alternative replication\n            source servers are available (so when there are multiple\n            MySQL servers or groups of servers that share the replicated\n            data). The default is 0, meaning that the mechanism is not\n            activated. For full information and instructions to set up\n            this feature, see\n            Section\u00a019.4.9.2, \u201cAsynchronous Connection Failover for Replicas\u201d.\n          \n            The asynchronous connection failover mechanism takes over\n            after the reconnection attempts controlled by\n            SOURCE_CONNECT_RETRY and\n            SOURCE_RETRY_COUNT are exhausted. It\n            reconnects the replica to an alternative source chosen from\n            a specified source list, which you can manage using the\n            functions\n            asynchronous_connection_failover_add_source()\n            and\n            asynchronous_connection_failover_delete_source().\n            To add and remove managed groups of servers, use\n            asynchronous_connection_failover_add_managed()\n            and\n            asynchronous_connection_failover_delete_managed()\n            instead. For more information, see\n            Section\u00a019.4.9, \u201cSwitching Sources and Replicas with Asynchronous Connection Failover\u201d.\n\n\n\nImportant\n\n\n\n                  You can only set\n                  SOURCE_CONNECTION_AUTO_FAILOVER = 1\n                  when GTID auto-positioning is in use\n                  (SOURCE_AUTO_POSITION = 1).\n                \n                  When you set SOURCE_CONNECTION_AUTO_FAILOVER\n                  = 1, set\n                  SOURCE_RETRY_COUNT and\n                  SOURCE_CONNECT_RETRY to minimal\n                  numbers that just allow a few retry attempts with the\n                  same source, in case the connection failure is caused\n                  by a transient network outage. Otherwise the\n                  asynchronous connection failover mechanism cannot be\n                  activated promptly. Suitable values are\n                  SOURCE_RETRY_COUNT=3 and\n                  SOURCE_CONNECT_RETRY=10, which make\n                  the replica retry the connection 3 times with\n                  10-second intervals between.\n                \n                  When you set SOURCE_CONNECTION_AUTO_FAILOVER\n                  = 1, the replication metadata repositories\n                  must contain the credentials for a replication user\n                  account that can be used to connect to all the servers\n                  on the source list for the replication channel. The\n                  account must also have SELECT\n                  permissions on the Performance Schema tables. These\n                  credentials can be set using the\n                  CHANGE REPLICATION SOURCE\n                  TO statement with the\n                  SOURCE_USER and\n                  SOURCE_PASSWORD options. For more\n                  information, see\n                  Section\u00a019.4.9, \u201cSwitching Sources and Replicas with Asynchronous Connection Failover\u201d.\n                \n                  When you set SOURCE_CONNECTION_AUTO_FAILOVER\n                  = 1, asynchronous connection failover for\n                  replicas is automatically activated if this\n                  replication channel is on a Group Replication primary\n                  in a group in single-primary mode. With this function\n                  active, if the primary that is replicating goes\n                  offline or into an error state, the new primary starts\n                  replication on the same channel when it is elected. If\n                  you want to use the function, this replication channel\n                  must also be set up on all the secondary servers in\n                  the replication group, and on any new joining members.\n                  (If the servers are provisioned using MySQL\u2019s clone\n                  functionality, this all happens automatically.) If you\n                  do not want to use the function, disable it by using\n                  the\n                  group_replication_disable_member_action()\n                  function to disable the Group Replication member\n                  action\n                  mysql_start_failover_channels_if_primary,\n                  which is enabled by default. For more information, see\n                  Section\u00a019.4.9.2, \u201cAsynchronous Connection Failover for Replicas\u201d.\n\n\n\n\nSOURCE_DELAY =\n            interval\n\n            Specifies how many seconds behind the source the replica\n            must lag. An event received from the source is not executed\n            until at least interval seconds\n            later than its execution on the source.\n            interval must be a nonnegative\n            integer in the range from 0 to\n            231\u22121. The default is 0.\n            For more information, see\n            Section\u00a019.4.11, \u201cDelayed Replication\u201d.\n          \n            A CHANGE REPLICATION SOURCE TO statement\n            using the SOURCE_DELAY option can be\n            executed on a running replica when the replication SQL\n            thread is stopped.\n          \nSOURCE_HEARTBEAT_PERIOD =\n            interval\n\n            Controls the heartbeat interval, which stops the connection\n            timeout occurring in the absence of data if the connection\n            is still good. A heartbeat signal is sent to the replica\n            after that number of seconds, and the waiting period is\n            reset whenever the source's binary log is updated with an\n            event. Heartbeats are therefore sent by the source only if\n            there are no unsent events in the binary log file for a\n            period longer than this.\n          \n            The heartbeat interval interval\n            is a decimal value having the range 0 to 4294967 seconds and\n            a resolution in milliseconds; the smallest nonzero value is\n            0.001. Setting interval to 0\n            disables heartbeats altogether. The heartbeat interval\n            defaults to half the value of the\n            replica_net_timeout system\n            variable. It is recorded in the source metadata repository\n            and shown in the\n            replication_connection_configuration\n            Performance Schema table.\n          \n            The replica_net_timeout\n            system variable specifies the number of seconds that the\n            replica waits for either more data or a heartbeat signal\n            from the source, before the replica considers the connection\n            broken, aborts the read, and tries to reconnect. The default\n            value is 60 seconds (one minute). Note that a change to the\n            value or default setting of\n            replica_net_timeout does\n            not automatically change the heartbeat interval, whether\n            that has been set explicitly or is using a previously\n            calculated default. A warning is issued if you set the\n            global value of replica_net_timeout to a\n            value less than that of the current heartbeat interval. If\n            replica_net_timeout is changed, you must\n            also issue CHANGE REPLICATION SOURCE\n            TO to adjust the heartbeat interval to an\n            appropriate value so that the heartbeat signal occurs before\n            the connection timeout. If you do not do this, the heartbeat\n            signal has no effect, and if no data is received from the\n            source, the replica can make repeated reconnection attempts,\n            creating zombie dump threads.\n          \nSOURCE_HOST =\n            'host_name'\n\n            The host name or IP address of the replication source\n            server. The replica uses this to connect to the source. The\n            maximum length of the string value is 255 characters.\n          \n            If you specify SOURCE_HOST or\n            SOURCE_PORT, the replica assumes that the\n            source server is different from before (even if the option\n            value is the same as its current value.) In this case, the\n            old values for the source's binary log file name and\n            position are considered no longer applicable, so if you do\n            not specify SOURCE_LOG_FILE and\n            SOURCE_LOG_POS in the statement,\n            SOURCE_LOG_FILE='' and\n            SOURCE_LOG_POS=4 are silently appended to\n            it.\n          \n            Setting SOURCE_HOST='' (that is, setting\n            its value explicitly to an empty string) is\n            not the same as not setting\n            SOURCE_HOST at all. Trying to set\n            SOURCE_HOST to an empty string fails with\n            an error.\n          \nSOURCE_LOG_FILE =\n            'source_log_name',\n            SOURCE_LOG_POS =\n            source_log_pos\n\n            The binary log file name, and the location in that file, at\n            which the replication I/O (receiver) thread begins reading\n            from the source's binary log the next time the thread\n            starts. Specify these options if you are using binary log\n            file position based replication.\n          \nSOURCE_LOG_FILE must include the numeric\n            suffix of a specific binary log file that is available on\n            the source server, for example,\n            SOURCE_LOG_FILE='binlog.000145'. The\n            maximum length of the string value is 511 characters.\n          \nSOURCE_LOG_POS is the numeric position\n            for the replica to start reading in that file.\n            SOURCE_LOG_POS=4 represents the start of\n            the events in a binary log file.\n          \n            If you specify either of SOURCE_LOG_FILE\n            or SOURCE_LOG_POS, you cannot specify\n            SOURCE_AUTO_POSITION = 1, which is for\n            GTID-based replication.\n          \n            If neither of SOURCE_LOG_FILE or\n            SOURCE_LOG_POS is specified, the replica\n            uses the last coordinates of the replication SQL\n            thread before CHANGE REPLICATION SOURCE\n            TO was issued. This ensures that there is no\n            discontinuity in replication, even if the replication SQL\n            (applier) thread was late compared to the replication I/O\n            (receiver) thread.\n          \nSOURCE_PASSWORD =\n            'password'\n\n            The password for the replication user account to use for\n            connecting to the replication source server. The maximum\n            length of the string value is 32 characters. If you specify\n            SOURCE_PASSWORD,\n            SOURCE_USER is also required.\n          \n            The password used for a replication user account in a\n            CHANGE REPLICATION SOURCE TO statement is\n            limited to 32 characters in length. Trying to use a password\n            of more than 32 characters causes CHANGE\n            REPLICATION SOURCE TO to fail.\n          \n            The password is masked in MySQL Server\u2019s logs, Performance\n            Schema tables, and SHOW\n            PROCESSLIST statements.\n          \nSOURCE_PORT =\n            port_num\n\n            The TCP/IP port number that the replica uses to connect to\n            the replication source server.\n\n\n\nNote\n\n\n              Replication cannot use Unix socket files. You must be able\n              to connect to the replication source server using TCP/IP.\n\n\n\n            If you specify SOURCE_HOST or\n            SOURCE_PORT, the replica assumes that the\n            source server is different from before (even if the option\n            value is the same as its current value.) In this case, the\n            old values for the source's binary log file name and\n            position are considered no longer applicable, so if you do\n            not specify SOURCE_LOG_FILE and\n            SOURCE_LOG_POS in the statement,\n            SOURCE_LOG_FILE='' and\n            SOURCE_LOG_POS=4 are silently appended to\n            it.\n          \nSOURCE_PUBLIC_KEY_PATH =\n            'key_file_name'\n\n            Enables RSA key pair-based password exchange by providing\n            the path name to a file containing a replica-side copy of\n            the public key required by the source. The file must be in\n            PEM format. The maximum length of the string value is 511\n            characters.\n          \n            This option applies to replicas that authenticate with the\n            sha256_password (deprecated) or\n            caching_sha2_password authentication\n            plugin. (For sha256_password,\n            SOURCE_PUBLIC_KEY_PATH can be used only\n            if MySQL was built using OpenSSL.) If you are using a\n            replication user account that authenticates with the\n            caching_sha2_password plugin (the\n            default), and you are not using a secure connection, you\n            must specify either this option or the\n            GET_SOURCE_PUBLIC_KEY=1 option to provide\n            the RSA public key to the replica.\n          \nSOURCE_RETRY_COUNT =\n            count\n\n            Sets the maximum number of reconnection attempts that the\n            replica makes after the connection to the source times out,\n            as determined by the\n            replica_net_timeout system\n            variable. If the replica does need to reconnect, the first\n            retry occurs immediately after the timeout. The default is\n            10 attempts.\n          \n            The interval between the attempts is specified by the\n            SOURCE_CONNECT_RETRY option. If both the\n            default settings are used, the replica waits 60 seconds\n            between reconnection attempts\n            (SOURCE_CONNECT_RETRY=60), and keeps\n            attempting to reconnect at this rate for 10 minutes\n            (SOURCE_RETRY_COUNT=10). A setting of 0\n            for SOURCE_RETRY_COUNT means that there\n            is no limit on the number of reconnection attempts, so the\n            replica keeps trying to reconnect indefinitely.\n          \n            The values for SOURCE_CONNECT_RETRY and\n            SOURCE_RETRY_COUNT are recorded in the\n            source metadata repository and shown in the\n            replication_connection_configuration\n            Performance Schema table.\n            SOURCE_RETRY_COUNT supersedes the\n            --master-retry-count server\n            startup option.\n          \nSOURCE_SSL = {0|1}\n\n            Specify whether the replica encrypts the replication\n            connection. The default is 0, meaning that the replica does\n            not encrypt the replication connection. If you set\n            SOURCE_SSL=1, you can configure the\n            encryption using the\n            SOURCE_SSL_xxx\n            and\n            SOURCE_TLS_xxx\n            options.\n          \n            Setting SOURCE_SSL=1 for a replication\n            connection and then setting no further\n            SOURCE_SSL_xxx\n            options corresponds to setting\n            --ssl-mode=REQUIRED for the client, as\n            described in\n            Command Options for Encrypted Connections.\n            With SOURCE_SSL=1, the connection attempt\n            only succeeds if an encrypted connection can be established.\n            A replication connection does not fall back to an\n            unencrypted connection, so there is no setting corresponding\n            to the --ssl-mode=PREFERRED setting for\n            replication. If SOURCE_SSL=0 is set, this\n            corresponds to --ssl-mode=DISABLED.\n\n\n\nImportant\n\n\n              To help prevent sophisticated man-in-the-middle attacks,\n              it is important for the replica to verify the server\u2019s\n              identity. You can specify additional\n              SOURCE_SSL_xxx\n              options to correspond to the settings\n              --ssl-mode=VERIFY_CA and\n              --ssl-mode=VERIFY_IDENTITY, which are a\n              better choice than the default setting to help prevent\n              this type of attack. With these settings, the replica\n              checks that the server\u2019s certificate is valid, and\n              checks that the host name the replica is using matches the\n              identity in the server\u2019s certificate. To implement one\n              of these levels of verification, you must first ensure\n              that the CA certificate for the server is reliably\n              available to the replica, otherwise availability issues\n              will result. For this reason, they are not the default\n              setting.\n\n\n\nSOURCE_SSL_xxx,\n            SOURCE_TLS_xxx\n\n            Specify how the replica uses encryption and ciphers to\n            secure the replication connection. These options can be\n            changed even on replicas that are compiled without SSL\n            support. They are saved to the source metadata repository,\n            but are ignored if the replica does not have SSL support\n            enabled. The maximum length of the value for the\n            string-valued\n            SOURCE_SSL_xxx\n            and\n            SOURCE_TLS_xxx\n            options is 511 characters, with the exception of\n            SOURCE_TLS_CIPHERSUITES,\n            for which it is 4000 characters.\n          \n            The\n            SOURCE_SSL_xxx\n            and\n            SOURCE_TLS_xxx\n            options perform the same functions as the\n            --ssl-xxx and\n            --tls-xxx client\n            options described in\n            Command Options for Encrypted Connections. The\n            correspondence between the two sets of options, and the use\n            of the\n            SOURCE_SSL_xxx\n            and\n            SOURCE_TLS_xxx\n            options to set up a secure connection, is explained in\n            Section\u00a019.3.1, \u201cSetting Up Replication to Use Encrypted Connections\u201d.\n          \nSOURCE_USER =\n            'user_name'\n\n            The user name for the replication user account to use for\n            connecting to the replication source server. The maximum\n            length of the string value is 96 characters.\n          \n            For Group Replication, this account must exist on every\n            member of the replication group. It is used for distributed\n            recovery if the XCom communication stack is in use for the\n            group, and also used for group communication connections if\n            the MySQL communication stack is in use for the group. With\n            the MySQL communication stack, the account must have the\n            GROUP_REPLICATION_STREAM\n            permission.\n          \n            It is possible to set an empty user name by specifying\n            SOURCE_USER='', but the replication\n            channel cannot be started with an empty user name. It is\n            valid to set an empty SOURCE_USER user\n            name and use the channel afterwards if you always provide\n            user credentials using the START\n            REPLICA statement or START\n            GROUP_REPLICATION statement that starts the\n            replication channel. This approach means that the\n            replication channel always needs operator intervention to\n            restart, but the user credentials are not recorded in the\n            replication metadata repositories.\n\n\n\nImportant\n\n\n              To connect to the source using a replication user account\n              that authenticates with the\n              caching_sha2_password plugin, you must\n              either set up a secure connection as described in\n              Section\u00a019.3.1, \u201cSetting Up Replication to Use Encrypted Connections\u201d, or\n              enable the unencrypted connection to support password\n              exchange using an RSA key pair. The\n              caching_sha2_password authentication\n              plugin is the default for new users (see\n              Section\u00a08.4.1.2, \u201cCaching SHA-2 Pluggable Authentication\u201d).\n              If the user account that you create or use for replication\n              uses this authentication plugin, and you are not using a\n              secure connection, you must enable RSA key pair-based\n              password exchange for a successful connection. You can do\n              this using either the\n              SOURCE_PUBLIC_KEY_PATH option or the\n              GET_SOURCE_PUBLIC_KEY=1 option for this\n              statement.\n\n\n\nSOURCE_ZSTD_COMPRESSION_LEVEL =\n            level\n\n            The compression level to use for connections to the\n            replication source server that use the\n            zstd compression algorithm. The permitted\n            levels are from 1 to 22, with larger values indicating\n            increasing levels of compression. The default level is 3.\n          \n            The compression level setting has no effect on connections\n            that do not use zstd compression. For\n            more information, see\n            Section\u00a06.2.8, \u201cConnection Compression Control\u201d.\n\n", "\n\n\n\nExamples\n\n\n\n\nCHANGE REPLICATION SOURCE TO is\n          useful for setting up a replica when you have the snapshot of\n          the source and have recorded the source's binary log\n          coordinates corresponding to the time of the snapshot. After\n          loading the snapshot into the replica to synchronize it with\n          the source, you can run CHANGE REPLICATION SOURCE TO\n          SOURCE_LOG_FILE='log_name',\n          SOURCE_LOG_POS=log_pos on\n          the replica to specify the coordinates at which the replica\n          should begin reading the source's binary log. The following\n          example changes the source server the replica uses and\n          establishes the source's binary log coordinates from which the\n          replica begins reading:\n        Press CTRL+C to copy CHANGE REPLICATION SOURCE TO\n  SOURCE_HOST='source2.example.com',\n  SOURCE_USER='replication',\n  SOURCE_PASSWORD='password',\n  SOURCE_PORT=3306,\n  SOURCE_LOG_FILE='source2-bin.001',\n  SOURCE_LOG_POS=4,\n  SOURCE_CONNECT_RETRY=10;\n          For the procedure to switch an existing replica to a new\n          source during failover, see\n          Section\u00a019.4.8, \u201cSwitching Sources During Failover\u201d.\n        \n          When GTIDs are in use on the source and the replica, specify\n          GTID auto-positioning instead of giving the binary log file\n          position, as in the following example. For full instructions\n          to configure and start GTID-based replication on new or\n          stopped servers, online servers, or additional replicas, see\n          Section\u00a019.1.3, \u201cReplication with Global Transaction Identifiers\u201d.\n        Press CTRL+C to copy CHANGE REPLICATION SOURCE TO\n  SOURCE_HOST='source3.example.com',\n  SOURCE_USER='replication',\n  SOURCE_PASSWORD='password',\n  SOURCE_PORT=3306,\n  SOURCE_AUTO_POSITION = 1,\n  FOR CHANNEL \"source_3\";\n          In this example, multi-source replication is in use, and the\n          CHANGE REPLICATION SOURCE TO\n          statement is applied to the replication channel\n          \"source_3\" that connects the replica to the\n          specified host. For guidance on setting up multi-source\n          replication, see Section\u00a019.1.5, \u201cMySQL Multi-Source Replication\u201d.\n        \n          The next example shows how to make the replica apply\n          transactions from relay log files that you want to repeat. To\n          do this, the source need not be reachable. You can use\n          CHANGE REPLICATION SOURCE TO to\n          locate the relay log position where you want the replica to\n          start reapplying transactions, and then start the SQL thread:\n        Press CTRL+C to copy CHANGE REPLICATION SOURCE TO\n  RELAY_LOG_FILE='replica-relay-bin.006',\n  RELAY_LOG_POS=4025;\nSTART REPLICA SQL_THREAD;\nCHANGE REPLICATION SOURCE TO\n          can also be used to skip over transactions in the binary log\n          that are causing replication to stop. The appropriate method\n          to do this depends on whether GTIDs are in use or not. For\n          instructions to skip transactions using\n          CHANGE REPLICATION SOURCE TO or\n          another method, see\n          Section\u00a019.1.7.3, \u201cSkipping Transactions\u201d.\n\n"], "Examples": ["CHANGE REPLICATION SOURCE TO SOURCE_HOST=host1, SOURCE_PORT=3002 FOR CHANNEL 'channel2';", "CHANGE REPLICATION SOURCE TO IGNORE_SERVER_IDS = ();", "STOP REPLICA FOR CHANNEL 'channel_1';\n\nCHANGE REPLICATION SOURCE TO\n    PRIVILEGE_CHECKS_USER = 'user'@'host',\n    REQUIRE_ROW_FORMAT = 1,\n    FOR CHANNEL 'channel_1';\n\nSTART REPLICA FOR CHANNEL 'channel_1';", "CHANGE REPLICATION SOURCE TO\n  SOURCE_HOST='source2.example.com',\n  SOURCE_USER='replication',\n  SOURCE_PASSWORD='password',\n  SOURCE_PORT=3306,\n  SOURCE_LOG_FILE='source2-bin.001',\n  SOURCE_LOG_POS=4,\n  SOURCE_CONNECT_RETRY=10;", "CHANGE REPLICATION SOURCE TO\n  SOURCE_HOST='source3.example.com',\n  SOURCE_USER='replication',\n  SOURCE_PASSWORD='password',\n  SOURCE_PORT=3306,\n  SOURCE_AUTO_POSITION = 1,\n  FOR CHANNEL \"source_3\";", "CHANGE REPLICATION SOURCE TO\n  RELAY_LOG_FILE='replica-relay-bin.006',\n  RELAY_LOG_POS=4025;\nSTART REPLICA SQL_THREAD;"], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html"], "Title": ["15.4.2.3 RESET REPLICA Statement"], "Feature": ["RESET REPLICA [ALL] [channel_option]\n\nchannel_option:\n    FOR CHANNEL channel"], "Description": ["\nRESET REPLICA makes the replica forget its\n        position in the source's binary log.\n      ", "\n        This statement is meant to be used for a clean start; it clears\n        the replication metadata repositories, deletes all the relay log\n        files, and starts a new relay log file. It also resets to 0 the\n        replication delay specified with the\n        SOURCE_DELAY option of the\n        CHANGE REPLICATION SOURCE TO\n        statement.\n", "\n\nNote\n\n\n          All relay log files are deleted, even if they have not been\n          completely executed by the replication SQL thread. (This is a\n          condition likely to exist on a replica if you have issued a\n          STOP\n          REPLICA statement or if the replica is highly\n          loaded.)\n\n", "\n        For a server where GTIDs are in use\n        (gtid_mode is\n        ON), issuing RESET REPLICA\n        has no effect on the GTID execution history. The statement does\n        not change the values of gtid_executed or\n        gtid_purged, or the\n        mysql.gtid_executed table. If you need to\n        reset the GTID execution history, use RESET\n        BINARY LOGS AND GTIDS, even if the GTID-enabled server\n        is a replica where binary logging is disabled.\n      ", "\nRESET REPLICA requires the\n        RELOAD privilege.\n      ", "\n        To use RESET REPLICA, the replication SQL\n        thread and replication I/O (receiver) thread must be stopped, so\n        on a running replica use\n        STOP\n        REPLICA before issuing RESET\n        REPLICA. To use RESET REPLICA on a\n        Group Replication group member, the member status must be\n        OFFLINE, meaning that the plugin is loaded\n        but the member does not currently belong to any group. A group\n        member can be taken offline by using a STOP\n        GROUP REPLICATION statement.\n      ", "\n        The optional FOR CHANNEL\n        channel clause enables you\n        to name which replication channel the statement applies to.\n        Providing a FOR CHANNEL\n        channel clause applies the\n        RESET REPLICA statement to a specific\n        replication channel. Combining a FOR CHANNEL\n        channel clause with the\n        ALL option deletes the specified channel. If\n        no channel is named and no extra channels exist, the statement\n        applies to the default channel. Issuing a RESET REPLICA\n        ALL statement without a FOR CHANNEL\n        channel clause when\n        multiple replication channels exist deletes\n        all replication channels and recreates only\n        the default channel. See Section\u00a019.2.2, \u201cReplication Channels\u201d\n        for more information.\n      ", "\nRESET REPLICA does not change any replication\n        connection parameters, which include the source's host name and\n        port, the replication user account and its password, the\n        PRIVILEGE_CHECKS_USER account, the\n        REQUIRE_ROW_FORMAT option, the\n        REQUIRE_TABLE_PRIMARY_KEY_CHECK option,and\n        the ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS\n        option. If you want to change any of the replication connection\n        parameters, you can do this using a CHANGE\n        REPLICATION SOURCE TO statement after the server\n        starts. If you want to remove all of the replication connection\n        parameters, use RESET REPLICA ALL.\n        RESET REPLICA ALL also clears the\n        IGNORE_SERVER_IDS list set by\n        CHANGE REPLICATION SOURCE TO.\n        When you have used RESET REPLICA ALL, if you\n        want to use the instance as a replica again, you need to issue a\n        CHANGE REPLICATION SOURCE TO\n        statement after the server start to specify new connection\n        parameters.\n      ", "\n        You can set the GTID_ONLY option on the\n        CHANGE REPLICATION SOURCE TO\n        statement to stop a replication channel from persisting file\n        names and file positions in the replication metadata\n        repositories. When you issue RESET\n        REPLICA, the replication metadata repositories are\n        synchronized. RESET REPLICA ALL deletes\n        rather than updates the repositories, so they are synchronized\n        implicitly.\n      ", "\n        In the event of an unexpected server exit or deliberate restart\n        after issuing RESET REPLICA but before\n        issuing START REPLICA,\n        replication connection parameters are preserved in the\n        crash-safe InnoDB tables\n        mysql.slave_master_info and\n        mysql.slave_relay_log_info as part of the\n        RESET REPLICA operation. They are also\n        retained in memory. In the event of an unexpected server exit or\n        deliberate restart after issuing RESET\n        REPLICA but before issuing START\n        REPLICA, the replication connection parameters are\n        retrieved from the tables and reapplied to the channel. This\n        applies for both the connection and applier metadata\n        repositories.\n      ", "\nRESET REPLICA does not change any replication\n        filter settings (such as\n        --replicate-ignore-table) for\n        channels affected by the statement. However, RESET\n        REPLICA ALL removes the replication filters that were\n        set on the channels deleted by the statement. When the deleted\n        channel or channels are recreated, any global replication\n        filters specified for the replica are copied to them, and no\n        channel specific replication filters are applied. For more\n        information see\n        Section\u00a019.2.5.4, \u201cReplication Channel Based Filters\u201d.\n      ", "\nRESET REPLICA causes an implicit commit of an\n        ongoing transaction. See Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n      ", "\n        If the replication SQL thread was in the middle of replicating\n        temporary tables when it was stopped, and RESET\n        REPLICA is issued, these replicated temporary tables\n        are deleted on the replica.\n", "\n\nNote\n\n\n          When used on an NDB Cluster replica SQL node, RESET\n          REPLICA clears the\n          mysql.ndb_apply_status table. You should\n          keep in mind when using this statement that\n          ndb_apply_status uses the\n          NDB storage engine and so is\n          shared by all SQL nodes attached to the cluster.\n        \n          You can override this behavior by issuing\n          SET\nGLOBAL\n          @@ndb_clear_apply_status=OFF\n          prior to executing RESET REPLICA, which\n          keeps the replica from purging the\n          ndb_apply_status table in such cases.\n\n"], "Examples": [], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/start-replica.html"], "Title": ["15.4.2.4 START REPLICA Statement"], "Feature": ["START REPLICA [thread_types] [until_option] [connection_options] [channel_option]\n\nthread_types:\n    [thread_type [, thread_type] ... ]\n\nthread_type:\n    IO_THREAD | SQL_THREAD\n\nuntil_option:\n    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = gtid_set\n          |   SOURCE_LOG_FILE = 'log_name', SOURCE_LOG_POS = log_pos\n          |   RELAY_LOG_FILE = 'log_name', RELAY_LOG_POS = log_pos\n          |   SQL_AFTER_MTS_GAPS  }\n\nconnection_options:\n    [USER='user_name'] [PASSWORD='user_pass'] [DEFAULT_AUTH='plugin_name'] [PLUGIN_DIR='plugin_dir']\n\n\nchannel_option:\n    FOR CHANNEL channel\n\ngtid_set:\n    uuid_set [, uuid_set] ...\n    | ''\n\nuuid_set:\n    uuid:interval[:interval]...\n\nuuid:\n    hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\n\nh:\n    [0-9,A-F]\n\ninterval:\n    n[-n]\n\n    (n >= 1)"], "Description": ["\nSTART REPLICA starts the replication threads,\n        either together or separately.\n      ", "\nSTART REPLICA requires the\n        REPLICATION_SLAVE_ADMIN privilege\n        (or the deprecated SUPER\n        privilege). START REPLICA causes an implicit\n        commit of an ongoing transaction. See\n        Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n      ", "\n        For the thread type options, you can specify\n        IO_THREAD, SQL_THREAD,\n        both of these, or neither of them. Only the threads that are\n        started are affected by the statement.\n", "\n\nSTART REPLICA with no thread type options\n            starts all of the replication threads, and so does\n            START REPLICA with both of the thread\n            type options.\n          \nIO_THREAD starts the replication receiver\n            thread, which reads events from the source server and stores\n            them in the relay log.\n          \nSQL_THREAD starts the replication applier\n            thread, which reads events from the relay log and executes\n            them. A multithreaded replica (with\n            replica_parallel_workers\n            > 0) applies transactions using a coordinator thread and\n            multiple applier threads, and SQL_THREAD\n            starts all of these.\n\n", "\n\nImportant\n\n\nSTART REPLICA sends an acknowledgment to\n          the user after all the replication threads have started.\n          However, the replication receiver thread might not yet have\n          connected to the source successfully, or an applier thread\n          might stop when applying an event right after starting.\n          START REPLICA does not continue to monitor\n          the threads after they are started, so it does not warn you if\n          they subsequently stop or cannot connect. You must check the\n          replica's error log for error messages generated by the\n          replication threads, or check that they are running\n          satisfactorily with SHOW REPLICA\n          STATUS. A successful START\n          REPLICA statement causes SHOW\n          REPLICA STATUS to show\n          Replica_SQL_Running=Yes, but it might or\n          might not show Replica_IO_Running=Yes,\n          because Replica_IO_Running=Yes is only\n          shown if the receiver thread is both running and connected.\n          For more information, see\n          Section\u00a019.1.7.1, \u201cChecking Replication Status\u201d.\n\n", "\n        The optional FOR CHANNEL\n        channel clause enables you\n        to name which replication channel the statement applies to.\n        Providing a FOR CHANNEL\n        channel clause applies the\n        START REPLICA statement to a specific\n        replication channel. If no clause is named and no extra channels\n        exist, the statement applies to the default channel. If a\n        START REPLICA statement does not have a\n        channel defined when using multiple channels, this statement\n        starts the specified threads for all channels. See\n        Section\u00a019.2.2, \u201cReplication Channels\u201d for more information.\n      ", "\n        The replication channels for Group Replication\n        (group_replication_applier and\n        group_replication_recovery) are managed\n        automatically by the server instance. START\n        REPLICA cannot be used at all with the\n        group_replication_recovery channel, and\n        should only be used with the\n        group_replication_applier channel when Group\n        Replication is not running. The\n        group_replication_applier channel only has an\n        applier thread and has no receiver thread, so it can be started\n        if required by using the SQL_THREAD option\n        without the IO_THREAD option.\n      ", "\nSTART REPLICA supports pluggable\n        user-password authentication (see\n        Section\u00a08.2.17, \u201cPluggable Authentication\u201d) with the\n        USER, PASSWORD,\n        DEFAULT_AUTH and\n        PLUGIN_DIR options, as described in the\n        following list. When you use these options, you must start the\n        receiver thread (IO_THREAD option) or all the\n        replication threads; you cannot start the replication applier\n        thread (SQL_THREAD option) alone.\n", "\n\nUSER\n\n              The user name for the account. You must set this if\n              PASSWORD is used. The option cannot be\n              set to an empty or null string.\n            \nPASSWORD\n\n              The password for the named user account.\n            \nDEFAULT_AUTH\n\n              The name of the authentication plugin. The default is\n              MySQL native authentication.\n            \nPLUGIN_DIR\n\n              The location of the authentication plugin.\n\n", "\n\nImportant\n\n\n          The password that you set using START\n          REPLICA is masked when it is written to MySQL\n          Server\u2019s logs, Performance Schema tables, and\n          SHOW PROCESSLIST statements.\n          However, it is sent in plain text over the connection to the\n          replica server instance. To protect the password in transit,\n          use SSL/TLS encryption, an SSH tunnel, or another method of\n          protecting the connection from unauthorized viewing, for the\n          connection between the replica server instance and the client\n          that you use to issue START REPLICA.\n\n", "\n        The UNTIL clause makes the replica start\n        replication, then process transactions up to the point that you\n        specify in the UNTIL clause, then stop again.\n        The UNTIL clause can be used to make a\n        replica proceed until just before the point where you want to\n        skip a transaction that is unwanted, and then skip the\n        transaction as described in\n        Section\u00a019.1.7.3, \u201cSkipping Transactions\u201d. To identify a\n        transaction, you can use mysqlbinlog with the\n        source's binary log or the replica's relay log, or use a\n        SHOW BINLOG EVENTS statement.\n      ", "\n        You can also use the UNTIL clause for\n        debugging replication by processing transactions one at a time\n        or in sections. If you are using the UNTIL\n        clause to do this, start the replica with\n        --skip-replica-start to prevent\n        the SQL thread from running when the replica server starts.\n        Remove the option or system variable setting after the procedure\n        is complete, so that it is not forgotten in the event of an\n        unexpected server restart.\n      ", "\n        The SHOW REPLICA STATUS statement\n        includes output fields that display the current values of the\n        UNTIL condition. The UNTIL\n        condition lasts for as long as the affected threads are still\n        running, and is removed when they stop.\n      ", "\n        The UNTIL clause operates on the replication\n        applier thread (SQL_THREAD option). You can\n        use the SQL_THREAD option or let the replica\n        default to starting both threads. If you use the\n        IO_THREAD option alone, the\n        UNTIL clause is ignored because the applier\n        thread is not started.\n      ", "\n        The point that you specify in the UNTIL\n        clause can be any one (and only one) of the following options:\n", "\n\nSOURCE_LOG_FILE and\n            SOURCE_LOG_POS\n\n              These options make the replication applier process\n              transactions up to a position in its relay log, identified\n              by the file name and file position of the corresponding\n              point in the binary log on the source server. The applier\n              thread finds the nearest transaction boundary at or after\n              the specified position, finishes applying the transaction,\n              and stops there. For compressed transaction payloads,\n              specify the end position of the compressed\n              Transaction_payload_event.\n            \n              These options can still be used when the\n              GTID_ONLY option was set on the\n              CHANGE REPLICATION SOURCE\n              TO statement to stop the replication channel\n              from persisting file names and file positions in the\n              replication metadata repositories. The file names and file\n              positions are tracked in memory.\n            \nRELAY_LOG_FILE and\n            RELAY_LOG_POS\n\n              These options make the replication applier process\n              transactions up to a position in the replica\u2019s relay\n              log, identified by the relay log file name and a position\n              in that file. The applier thread finds the nearest\n              transaction boundary at or after the specified position,\n              finishes applying the transaction, and stops there. For\n              compressed transaction payloads, specify the end position\n              of the compressed\n              Transaction_payload_event.\n            \n              These options can still be used when the\n              GTID_ONLY option was set on the\n              CHANGE REPLICATION SOURCE\n              TO statement to stop the replication channel\n              from persisting file names and file positions in the\n              replication metadata repositories. The file names and file\n              positions are tracked in memory.\n            \nSQL_BEFORE_GTIDS\n\n              This option makes the replication applier start processing\n              transactions and stop when it encounters any transaction\n              that is in the specified GTID set. The encountered\n              transaction from the GTID set is not applied, and nor are\n              any of the other transactions in the GTID set. The option\n              takes a GTID set containing one or more global transaction\n              identifiers as an argument (see\n              GTID Sets).\n              Transactions in a GTID set do not necessarily appear in\n              the replication stream in the order of their GTIDs, so the\n              transaction before which the applier stops is not\n              necessarily the earliest.\n            \nSQL_AFTER_GTIDS\n\n              This option makes the replication applier start processing\n              transactions and stop when it has processed all of the\n              transactions in a specified GTID set. The option takes a\n              GTID set containing one or more global transaction\n              identifiers as an argument (see\n              GTID Sets).\n            \n              With SQL_AFTER_GTIDS, the replication\n              threads stop after they have processed all transactions in\n              the GTID set. Transactions are processed in the order\n              received, so it is possible that these include\n              transactions which are not part of the GTID set, but which\n              are received (and processed) before all transactions in\n              the set have been committed. For example, executing\n              START REPLICA UNTIL SQL_AFTER_GTIDS =\n              3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56\n              causes the replica to obtain (and process) all\n              transactions from the source until all of the transactions\n              having the sequence numbers 11 through 56 have been\n              processed, and then to stop without processing any\n              additional transactions after that point has been reached.\n            \n              In older versions of MySQL, this option could not be used\n              with replica_parallel_workers >\n              1. In MySQL 8.4, this is no longer\n              an issue, and SQL_AFTER_GTIDS can be\n              used without causing the replica to fall back into\n              single-threaded mode.\n            \nSQL_AFTER_MTS_GAPS\n\n              For a multithreaded replica only (with\n              replica_parallel_workers\n              > 0), this option makes the replica process\n              transactions up to the point where there are no more gaps\n              in the sequence of transactions executed from the relay\n              log. When using a multithreaded replica, there is a chance\n              of gaps occurring in the following situations:\n\n\n\n                  The coordinator thread is stopped.\n                \n                  An error occurs in the applier threads.\n                \nmysqld shuts down unexpectedly.\n\n\n\n              When a replication channel has gaps, the replica\u2019s\n              database is in a state that might never have existed on\n              the source. The replica tracks the gaps internally and\n              disallows CHANGE REPLICATION SOURCE\n              TO statements that would remove the gap\n              information if they executed.\n            \n              All replicas are multithreaded by default. When\n              replica_preserve_commit_order=ON\n              on the replica (the default), gaps should not occur except\n              in the specific situations listed in the description for\n              this variable. If\n              replica_preserve_commit_order is\n              OFF, the commit order of transactions\n              is not preserved, so the chance of gaps occurring is much\n              larger.\n            \n              If GTIDs are not in use and you need to change a failed\n              multithreaded replica to single-threaded mode, you can\n              issue the following series of statements, in the order\n              shown:\n            Press CTRL+C to copy START REPLICA UNTIL SQL_AFTER_MTS_GAPS;\nSET @@GLOBAL.replica_parallel_workers = 0;\nSTART REPLICA SQL_THREAD;\n"], "Examples": ["START REPLICA UNTIL SQL_AFTER_MTS_GAPS;\nSET @@GLOBAL.replica_parallel_workers = 0;\nSTART REPLICA SQL_THREAD;"], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html"], "Title": ["15.4.2.5 STOP REPLICA Statement"], "Feature": ["STOP REPLICA [thread_types] [channel_option]\n\nthread_types:\n    [thread_type [, thread_type] ... ]\n\nthread_type: IO_THREAD | SQL_THREAD\n\nchannel_option:\n    FOR CHANNEL channel"], "Description": ["\n        Stops the replication threads.\n      ", "\nSTOP REPLICA requires the\n        REPLICATION_SLAVE_ADMIN privilege\n        (or the deprecated SUPER\n        privilege). Recommended best practice is to execute\n        STOP REPLICA on the replica before stopping\n        the replica server (see Section\u00a07.1.19, \u201cThe Server Shutdown Process\u201d, for\n        more information).\n      ", "\n        Like START REPLICA, this\n        statement may be used with the IO_THREAD and\n        SQL_THREAD options to name the replication\n        thread or threads to be stopped. Note that the Group Replication\n        applier channel (group_replication_applier)\n        has no replication I/O (receiver) thread, only a replication SQL\n        (applier) thread. Using the SQL_THREAD option\n        therefore stops this channel completely.\n      ", "\nSTOP REPLICA causes an implicit commit of an\n        ongoing transaction. See Section\u00a015.3.3, \u201cStatements That Cause an Implicit Commit\u201d.\n      ", "\ngtid_next must be set to\n        AUTOMATIC before issuing this statement.\n      ", "\n        You can control how long STOP REPLICA waits\n        before timing out by setting the system variable\n        rpl_stop_replica_timeout. This\n        can be used to avoid deadlocks between STOP\n        REPLICA and other SQL statements using different\n        client connections to the replica. When the timeout value is\n        reached, the issuing client returns an error message and stops\n        waiting, but the STOP REPLICA instruction\n        remains in effect. Once the replication threads are no longer\n        busy, the STOP REPLICA statement is executed\n        and the replica stops.\n      ", "\n        Some CHANGE REPLICATION SOURCE TO\n        statements are allowed while the replica is running, depending\n        on the states of the replication threads. However, using\n        STOP REPLICA prior to executing a\n        CHANGE REPLICATION SOURCE TO\n        statement in such cases is still supported. See\n        Section\u00a015.4.2.2, \u201cCHANGE REPLICATION SOURCE TO Statement\u201d, and\n        Section\u00a019.4.8, \u201cSwitching Sources During Failover\u201d, for more\n        information.\n      ", "\n        The optional FOR CHANNEL\n        channel clause enables you\n        to name which replication channel the statement applies to.\n        Providing a FOR CHANNEL\n        channel clause applies the\n        STOP REPLICA statement to a specific\n        replication channel. If no channel is named and no extra\n        channels exist, the statement applies to the default channel. If\n        a STOP REPLICA statement does not name a\n        channel when using multiple channels, this statement stops the\n        specified threads for all channels. See\n        Section\u00a019.2.2, \u201cReplication Channels\u201d for more\n        information.\n      ", "\n        The replication channels for Group Replication\n        (group_replication_applier and\n        group_replication_recovery) are managed\n        automatically by the server instance. STOP\n        REPLICA cannot be used at all with the\n        group_replication_recovery channel, and\n        should only be used with the\n        group_replication_applier channel when Group\n        Replication is not running. The\n        group_replication_applier channel only has an\n        applier thread and has no receiver thread, so it can be stopped\n        if required by using the SQL_THREAD option\n        without the IO_THREAD option.\n      ", "\n        When the replica is multithreaded\n        (replica_parallel_workers is a\n        nonzero value), any gaps in the sequence of transactions\n        executed from the relay log are closed as part of stopping the\n        worker threads. If the replica is stopped unexpectedly (for\n        example due to an error in a worker thread, or another thread\n        issuing KILL) while a\n        STOP REPLICA statement is executing, the\n        sequence of executed transactions from the relay log may become\n        inconsistent. See\n        Section\u00a019.5.1.34, \u201cReplication and Transaction Inconsistencies\u201d,\n        for more information.\n      ", "\n        When the source is using the row-based binary logging format,\n        you should execute STOP REPLICA or\n        STOP REPLICA SQL_THREAD on the replica prior\n        to shutting down the replica server if you are replicating any\n        tables that use a nontransactional storage engine. If the\n        current replication event group has modified one or more\n        nontransactional tables, STOP REPLICA waits\n        for up to 60 seconds for the event group to complete, unless you\n        issue a KILL\n        QUERY or KILL\n        CONNECTION statement for the replication SQL thread.\n        If the event group remains incomplete after the timeout, an\n        error message is logged.\n      ", "\n        When the source is using the statement-based binary logging\n        format, changing the source while it has open temporary tables\n        is potentially unsafe. This is one of the reasons why\n        statement-based replication of temporary tables is not\n        recommended. You can find out whether there are any temporary\n        tables on the replica by checking the value of\n        Replica_open_temp_tables. When\n        using statement-based replication, this value should be 0 before\n        executing CHANGE REPLICATION SOURCE\n        TO. If there are any temporary tables open on the\n        replica, issuing a CHANGE REPLICATION\n        SOURCE TO statement after issuing a STOP\n        REPLICA causes an\n        ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO\n        warning.\n"], "Examples": [], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/start-group-replication.html"], "Title": ["15.4.3.1 START GROUP_REPLICATION Statement"], "Feature": ["  START GROUP_REPLICATION\n          [USER='user_name']\n          [, PASSWORD='user_pass']\n          [, DEFAULT_AUTH='plugin_name']"], "Description": ["\n        Starts group replication. This statement requires the\n        GROUP_REPLICATION_ADMIN privilege\n        (or the deprecated SUPER\n        privilege). If\n        super_read_only=ON is set and\n        the member should join as a primary,\n        super_read_only is set to\n        OFF once Group Replication successfully\n        starts.\n      ", "\n        A server that participates in a group in single-primary mode\n        should use\n        skip_replica_start=ON.\n        Otherwise, the server is not allowed to join a group as a\n        secondary.\n      ", "\n        You can specify user credentials for distributed recovery in the\n        START GROUP_REPLICATION statement using the\n        USER, PASSWORD, and\n        DEFAULT_AUTH options, as follows:\n", "\n\nUSER: The replication user for\n            distributed recovery. For instructions to set up this\n            account, see\n            Section\u00a020.2.1.3, \u201cUser Credentials For Distributed Recovery\u201d. You\n            cannot specify an empty or null string, or omit the\n            USER option if\n            PASSWORD is specified.\n          \nPASSWORD: The password for the\n            replication user account. The password cannot be encrypted,\n            but it is masked in the query log.\n          \nDEFAULT_AUTH: The name of the\n            authentication plugin used for the replication user account.\n            If you do not specify this option, MySQL native\n            authentication (the mysql_native_password\n            plugin) is assumed. This option acts as a hint to the\n            server, and the donor for distributed recovery overrides it\n            if a different plugin is associated with the user account on\n            that server. The authentication plugin used by default when\n            you create user accounts in MySQL 8 is the caching SHA-2\n            authentication plugin\n            (caching_sha2_password). See\n            Section\u00a08.2.17, \u201cPluggable Authentication\u201d for more\n            information on authentication plugins.\n\n", "\n        These credentials are used for distributed recovery on the\n        group_replication_recovery channel. When you\n        specify user credentials on START\n        GROUP_REPLICATION, the credentials are saved in memory\n        only, and are removed by a STOP\n        GROUP_REPLICATION statement or server shutdown. You\n        must issue a START GROUP_REPLICATION\n        statement to provide the credentials again. This method is\n        therefore not compatible with starting Group Replication\n        automatically on server start, as specified by the\n        group_replication_start_on_boot\n        system variable.\n      ", "\n        User credentials specified on START\n        GROUP_REPLICATION take precedence over any user\n        credentials set for the\n        group_replication_recovery channel using a\n        CHANGE REPLICATION SOURCE TO.\n        Note that user credentials set using these statements are stored\n        in the replication metadata repositories, and are used when\n        START GROUP_REPLICATION is specified without\n        user credentials, including automatic starts if the\n        group_replication_start_on_boot\n        system variable is set to ON. To gain the\n        security benefits of specifying user credentials on\n        START GROUP_REPLICATION, ensure that\n        group_replication_start_on_boot\n        is set to OFF (the default is\n        ON), and clear any user credentials\n        previously set for the\n        group_replication_recovery channel, following\n        the instructions in\n        Section\u00a020.6.3, \u201cSecuring Distributed Recovery Connections\u201d.\n      ", "\n        While a member is rejoining a replication group, its status can\n        be displayed as OFFLINE or\n        ERROR before the group completes the\n        compatibility checks and accepts it as a member. When the member\n        is catching up with the group's transactions, its status is\n        RECOVERING.\n"], "Examples": [], "Category": ["Replication Statements"]}
{"HTML": ["https://dev.mysql.com/doc/refman/8.4/en/stop-group-replication.html"], "Title": ["15.4.3.2 STOP GROUP_REPLICATION Statement"], "Feature": ["STOP GROUP_REPLICATION"], "Description": ["\n        Stops Group Replication. This statement requires the\n        GROUP_REPLICATION_ADMIN privilege\n        (or the deprecated SUPER\n        privilege). As soon as you issue STOP\n        GROUP_REPLICATION the member is set to\n        super_read_only=ON, which\n        ensures that no writes can be made to the member while Group\n        Replication stops. Any other asynchronous replication channels\n        running on the member are also stopped. Any user credentials\n        that you specified in the START\n        GROUP_REPLICATION statement when starting Group\n        Replication on this member are removed from memory, and must be\n        supplied when you start Group Replication again.\n", "\n\nWarning\n\n\n          Use this statement with extreme caution because it removes the\n          server instance from the group, meaning it is no longer\n          protected by Group Replication's consistency guarantee\n          mechanisms. To be completely safe, ensure that your\n          applications can no longer connect to the instance before\n          issuing this statement to avoid any chance of stale reads.\n\n", "\n        The STOP GROUP_REPLICATION\n        statement stops asynchronous replication channels on the group\n        member, but it does not implicitly commit transactions that are\n        in progress on them like STOP\n        REPLICA does. This is because on a Group Replication\n        group member, an additional transaction committed during the\n        shutdown operation would leave the member inconsistent with the\n        group and cause an issue with rejoining. To avoid failed commits\n        for transactions that are in progress while stopping Group\n        Replication, the STOP\n        GROUP_REPLICATION statement cannot be issued while a\n        GTID is assigned as the value of the\n        gtid_next system variable.\n      ", "\n        The\n        group_replication_components_stop_timeout\n        system variable specifies the time for which Group Replication\n        waits for each of its modules to complete ongoing processes\n        after this statement is issued. The timeout is used to resolve\n        situations in which Group Replication components cannot be\n        stopped normally, which can happen if the member is expelled\n        from the group while it is in an error state, or while a process\n        such as MySQL Enterprise Backup is holding a global lock on\n        tables on the member. In such situations, the member cannot stop\n        the applier thread or complete the distributed recovery process\n        to rejoin. STOP GROUP_REPLICATION does not\n        complete until either the situation is resolved (for example, by\n        the lock being released), or the component timeout expires and\n        the modules are shut down regardless of their status. The\n        default value is 300 seconds; this means that Group Replication\n        components are stopped after 5 minutes if the situation is not\n        resolved before that time, allowing the member to be restarted\n        and rejoin.\n"], "Examples": [], "Category": ["Replication Statements"]}
