{"HTML": ["https://sqlite.org/json1.html#jquote"], "Title": ["JSON Functions"], "Feature": ["json_quote(X)"], "Description": ["The json_quote(X) function converts the SQL value X, which can be a number or a string, into its corresponding JSON representation. If the input X is already a JSON value returned by another JSON function, then json_quote() has no effect and returns the JSON value as is."], "Examples": ["json_quote(3.14159) \u2192 3.14159", "json_quote('verdant') \u2192 '\"verdant\"'", "json_quote('[1]') \u2192 '\"[1]\"'", "json_quote(json('[1]')) \u2192 '[1]'", "json_quote('[1,') \u2192 '\"[1,\"'"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#json_valid"], "Title": ["JSON Functions"], "Feature": ["json_valid(X, Y)"], "Description": ["The json_valid(X, Y) function checks if the argument X is well-formed JSON and returns 1 for valid JSON or 0 for invalid JSON. The Y parameter is an optional integer bitmask that defines the criteria for 'well-formed', with default value 1 implying strict adherence to RFC-8259 JSON standards without extensions. Various bitmask values allow for JSON5 extensions, JSONB superficial or strict conformity, and combinations thereof. Any Y value outside the range of 1 to 15 raises an error, and NULL inputs result in a NULL return."], "Examples": ["json_valid('{\"x\":35}') \u2192 1", "json_valid('{x:35}') \u2192 0", "json_valid('{x:35}', 6) \u2192 1", "json_valid('{\"x\":35', 1) \u2192 0", "json_valid(NULL) \u2192 NULL"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jtype"], "Title": ["JSON Functions"], "Feature": ["json_type(X), json_type(X, P)"], "Description": ["The json_type(X) function returns the type of the outermost element of the JSON or JSONB object X as an SQL text value, such as 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. The json_type(X, P) function extends this functionality to return the type of a specific element within X that is selected by the JSON path P. If the specified path P does not identify an existing element within X, the function returns NULL. An error is thrown if the input X is not well-formed JSON or JSONB, or if the path P is not a well-formed JSON path."], "Examples": ["json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}') \u2192 'object'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$') \u2192 'object'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a') \u2192 'array'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[0]') \u2192 'integer'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[1]') \u2192 'real'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[2]') \u2192 'true'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[3]') \u2192 'false'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[4]') \u2192 'null'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[5]') \u2192 'text'", "json_type('{\"a\":[2,3.5,true,false,null,\"x\"]}','$.a[6]') \u2192 NULL"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jsetb"], "Title": ["JSON Functions"], "Feature": ["jsonb_insert()"], "Description": ["The jsonb_insert(), jsonb_replace(), and jsonb_set() functions operate similarly to their json_ counterparts, such as json_insert(), json_replace(), and json_set(), respectively. The key difference is that the jsonb_ prefixed versions of these functions return their results in the binary JSONB format, which can offer performance benefits for certain operations that involve JSON data in SQLite."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jset"], "Title": ["JSON Functions"], "Feature": ["json_replace()"], "Description": ["The json_insert(), json_replace(), and json_set() functions are designed to modify a given JSON value by taking it as the first argument, followed by an odd number of path and value pairs. These functions differ in their behavior regarding the creation of new values and the overwriting of existing ones: json_insert() will create new values without overwriting existing ones, json_replace() will overwrite existing values but won't create new ones if the path doesn't exist, and json_set() will both overwrite existing values and create new ones if the path doesn't exist. All edits occur sequentially and can affect subsequent operations due to the prior changes in the JSON structure. If a value in a path/value pair is of TEXT type, it is normally inserted as a quoted JSON string unless it is the result of another JSON function or the -> operator, in which case it retains its JSON structure. These functions throw an error if the initial JSON or any PATH argument is malformed or if any argument is a BLOB."], "Examples": ["json_insert('[1,2,3,4]', '$[#]', 99) \u2192 '[1,2,3,4,99]'", "json_insert('[1,[2,3],4]', '$[1][#]', 99) \u2192 '[1,[2,3,99],4]'", "json_insert('{\"a\":2,\"c\":4}', '$.a', 99) \u2192 '{\"a\":2,\"c\":4}'", "json_insert('{\"a\":2,\"c\":4}', '$.e', 99) \u2192 '{\"a\":2,\"c\":4,\"e\":99}'", "json_replace('{\"a\":2,\"c\":4}', '$.a', 99) \u2192 '{\"a\":99,\"c\":4}'", "json_replace('{\"a\":2,\"c\":4}', '$.e', 99) \u2192 '{\"a\":2,\"c\":4}'", "json_set('{\"a\":2,\"c\":4}', '$.a', 99) \u2192 '{\"a\":99,\"c\":4}'", "json_set('{\"a\":2,\"c\":4}', '$.e', 99) \u2192 '{\"a\":2,\"c\":4,\"e\":99}'", "json_set('{\"a\":2,\"c\":4}', '$.c', '[97,96]') \u2192 '{\"a\":2,\"c\":\"[97,96]\"}'", "json_set('{\"a\":2,\"c\":4}', '$.c', json('[97,96]')) \u2192 '{\"a\":2,\"c\":[97,96]}", "json_set('{\"a\":2,\"c\":4}', '$.c', json_array(97,96)) \u2192 '{\"a\":2,\"c\":[97,96]}"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jreplb"], "Title": ["JSON Functions"], "Feature": ["jsonb_replace()"], "Description": ["The jsonb_insert(), jsonb_replace(), and jsonb_set() functions operate analogously to their json_ prefixed counterparts, namely json_insert(), json_replace(), and json_set(). These jsonb_ prefixed functions are designed to manipulate JSON data, allowing for insertion, replacement, and setting of values at specified paths within a JSON object. A key distinction, however, is that the jsonb_ versions return their results in the binary JSONB format, which can offer performance optimizations for operations involving JSON data in SQLite. This is particularly beneficial when dealing with a series of JSON data manipulations, as the binary format can reduce the overhead associated with parsing and converting JSON text."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jrepl"], "Title": ["JSON Functions"], "Feature": ["json_set()"], "Description": ["The json_insert(), json_replace(), and json_set() functions are used to modify JSON data. They take a JSON value as the first argument, followed by path/value pairs that determine the modifications to be made to the JSON structure. The primary difference between the functions lies in their behavior regarding existing and new values: json_insert() will create new values without overwriting existing ones, json_replace() will overwrite existing values but will not create new ones, and json_set() will both overwrite existing values and create new ones if necessary. The functions process edits from left to right, with each edit potentially affecting the outcome of subsequent ones. If a path/value pair's value is a TEXT type, it is treated as a quoted JSON string unless it is derived from another JSON function or operator, in which case it retains its JSON structure. An error is thrown for malformed JSON or PATH arguments or if any argument is a BLOB."], "Examples": ["json_insert('[1,2,3,4]', '$[#]', 99) returns '[1,2,3,4,99]'", "json_insert('[1,[2,3],4]', '$[1][#]', 99) returns '[1,[2,3,99],4]'", "json_insert('{\"a\":2,\"c\":4}', '$.a', 99) does not modify the original JSON", "json_insert('{\"a\":2,\"c\":4}', '$.e', 99) returns '{\"a\":2,\"c\":4,\"e\":99}'", "json_replace('{\"a\":2,\"c\":4}', '$.a', 99) returns '{\"a\":99,\"c\":4}'", "json_replace('{\"a\":2,\"c\":4}', '$.e', 99) does not modify the original JSON", "json_set('{\"a\":2,\"c\":4}', '$.a', 99) returns '{\"a\":99,\"c\":4}'", "json_set('{\"a\":2,\"c\":4}', '$.e', 99) returns '{\"a\":2,\"c\":4,\"e\":99}'", "json_set('{\"a\":2,\"c\":4}', '$.c', '[97,96]') returns '{\"a\":2,\"c\":\"[97,96]\"}'", "json_set('{\"a\":2,\"c\":4}', '$.c', json('[97,96]')) returns '{\"a\":2,\"c\":[97,96]}'", "json_set('{\"a\":2,\"c\":4}', '$.c', json_array(97,96)) returns '{\"a\":2,\"c\":[97,96]}'"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jmini"], "Title": ["JSON Functions"], "Feature": ["json(X)"], "Description": ["The json(X) function checks if the provided argument X is a valid JSON string or JSONB blob. If valid, it returns a minified version of the JSON string, removing all unnecessary whitespace. In cases where the input X is not well-formed, the function throws an error. The function also ensures that any JSON5 text is converted into the canonical RFC-8259 format before being returned. It is important to note that the handling of JSON objects with duplicate labels within the argument X is currently such that duplicates are preserved; however, this behavior might change in future updates of the function, possibly with silent removal of duplicates."], "Examples": ["json(' { \"this\" : \"is\", \"a\": [ \"test\" ] } ') returns '{\"this\":\"is\",\"a\":[\"test\"]}'"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jminib"], "Title": ["JSON Functions"], "Feature": ["jsonb(X)"], "Description": ["The jsonb(X) function is designed to return the binary JSONB representation of the JSON content provided in argument X. If the argument X is a TEXT string that does not adhere to valid JSON syntax, the function will raise an error. In cases where X is a BLOB that resembles JSONB, the function will return a copy of X, but it is important to note that only the outer-most element is examined, and the internal structure of the JSONB is not thoroughly validated."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jarray"], "Title": ["JSON Functions"], "Feature": ["json_array()"], "Description": ["The json_array() SQL function is designed to construct a JSON array from zero or more arguments provided to it. It returns a well-formed JSON array without any BLOB arguments, as a BLOB argument would result in an error. If an argument is of SQL TEXT type, it is conventionally converted into a quoted JSON string, unless it is the result from another json1 function, in which case it is treated as JSON, allowing for nested calls to json_array() and json_object(). The json() function can be utilized to explicitly instruct the interpretation of strings as JSON objects or arrays."], "Examples": ["json_array(1,2,'3',4) returns '[1,2,\"3\",4]'", "json_array('[1,2]') returns '[\"[1,2]\"]'", "json_array(json_array(1,2)) returns '[[1,2]]'", "json_array(1,null,'3','[4,5]','{\"six\":7.7}') returns '[1,null,\"3\",\"[4,5]\",\"{\\\"six\\\":7.7}\"]'", "json_array(1,null,'3',json('[4,5]'),json('{\"six\":7.7}')) returns '[1,null,\"3\",[4,5],{\"six\":7.7}]"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jarrayb"], "Title": ["JSON Functions"], "Feature": ["jsonb_array()"], "Description": ["The jsonb_array() SQL function operates similarly to the json_array() function, with a key distinction in the output format. While json_array() produces a JSON array in the standard RFC 8259 text format, jsonb_array() returns the constructed JSON array in SQLite's private binary JSONB format. This binary format can offer performance advantages for certain operations involving JSON data within SQLite."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jarraylen"], "Title": ["JSON Functions"], "Feature": ["json_array_length(X), json_array_length(X,P)"], "Description": ["The json_array_length() function is used to determine the count of elements present in a JSON array. When provided with a single argument X, which is expected to be a JSON array, the function returns the number of elements in that array, or returns 0 if X is not an array type. If the function is called with two arguments, json_array_length(X,P), it will look for an array at the JSON path P within the JSON object X, and return the length of that specific array. If the path P does not correspond to an array, the function returns 0, and if the path does not exist within X, the function returns NULL. An error is raised if the input X is not valid JSON or if the path P is not correctly formed."], "Examples": ["json_array_length('[1,2,3,4]') returns 4", "json_array_length('[1,2,3,4]', '$') returns 4", "json_array_length('[1,2,3,4]', '$[2]') returns 0", "json_array_length('{\"one\":[1,2,3]}') returns 0", "json_array_length('{\"one\":[1,2,3]}', '$.one') returns 3", "json_array_length('{\"one\":[1,2,3]}', '$.two') returns NULL"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jerr"], "Title": ["JSON Functions"], "Feature": ["json_error_position(X)"], "Description": ["The json_error_position(X) function is designed to identify syntax errors in JSON or JSON5 strings. It returns 0 if the input X is a well-formed JSON or JSON5 string, indicating no syntax errors are present. Conversely, if the input X contains syntax errors, the function returns the 1-based character position of the first syntax error encountered. For BLOB inputs, the function operates similarly, returning 0 for a well-formed JSONB blob and a positive value representing the approximate 1-based position of the first error if one exists. This function was introduced in SQLite version 3.42.0 (2023-05-16)."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jex"], "Title": ["JSON Functions"], "Feature": ["json_extract(X,P1,P2,...)"], "Description": ["The json_extract() function in SQLite is used to extract values from a well-formed JSON string at X. Depending on the number of path arguments provided, the function operates in two modes: If a single path argument P1 is given, the function returns the value at that path in its corresponding SQL datatype. This can be SQL NULL for JSON null, INTEGER or REAL for numeric values, INTEGER zero for JSON false, INTEGER one for JSON true, dequoted text for JSON strings, and text representation for JSON objects and arrays. When multiple path arguments are provided, the function returns a well-formed JSON array containing the extracted values. It's important to note that SQLite's json_extract() differs from MySQL's in terms of the datatype returned when accessing individual string or NULL values within the JSON. SQLite returns the actual SQL datatype, whereas MySQL always returns JSON."], "Examples": ["json_extract('{\"a\":2,\"c\":[4,5,{\"f\":7}]}', '$') returns '{\"a\":2,\"c\":[4,5,{\"f\":7}]}'", "json_extract('{\"a\":2,\"c\":[4,5,{\"f\":7}]}', '$.c') returns '[4,5,{\"f\":7}]'", "json_extract('{\"a\":2,\"c\":[4,5,{\"f\":7}]}', '$.c[2]') returns '{\"f\":7}'", "json_extract('{\"a\":2,\"c\":[4,5,{\"f\":7}]}', '$.c[2].f') returns 7", "json_extract('{\"a\":2,\"c\":[4,5],\"f\":7}','$.c','$.a') returns '[[4,5],2]'", "json_extract('{\"a\":2,\"c\":[4,5],\"f\":7}','$.c[#-1]') returns 5", "json_extract('{\"a\":2,\"c\":[4,5,{\"f\":7}]}', '$.x') returns NULL", "json_extract('{\"a\":2,\"c\":[4,5,{\"f\":7}]}', '$.x', '$.a') returns '[null,2]'", "json_extract('{\"a\":\"xyz\"}', '$.a') returns 'xyz'", "json_extract('{\"a\":null}', '$.a') returns NULL"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jexb"], "Title": ["JSON Functions"], "Feature": ["jsonb_extract(X,P1,P2,...)"], "Description": ["The jsonb_extract() function operates in a similar manner to the json_extract() function with a distinct behavior when it comes to returning array objects. While json_extract() would return a text JSON array object, jsonb_extract() returns the array or object in the binary JSONB format, which can be beneficial for performance in certain scenarios involving JSON data manipulation in SQLite. For cases where the JSON element being returned is of a text, numeric, null, or boolean type, jsonb_extract() functions identically to json_extract()."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jins"], "Title": ["JSON Functions"], "Feature": ["json_insert()"], "Description": ["The json_insert(), json_replace(), and json_set() functions are designed to modify JSON content. They accept a JSON value as the first argument, followed by an odd number of path/value pairs that specify the modifications. json_insert() adds new values without overwriting existing ones, json_replace() overwrites existing values but does not create new ones, and json_set() both overwrites and creates new values as needed. These functions process edits from left to right, and the first argument must be a well-formed JSON. If a path/value pair's value is a TEXT type, it is treated as a quoted JSON string unless it is the result of another JSON function or the -> operator, in which case it is treated as JSON. The ->> operator is always treated as TEXT. An error is thrown for malformed JSON or PATH arguments or if any argument is a BLOB. To append to an array, json_insert() can be used with the '$[#]' index."], "Examples": ["json_insert('[1,2,3,4]', '$[#]', 99) returns '[1,2,3,4,99]'", "json_insert('[1,[2,3],4]', '$[1][#]', 99) returns '[1,[2,3,99],4]'", "json_insert('{\"a\":2,\"c\":4}', '$.a', 99) does not modify the original JSON", "json_insert('{\"a\":2,\"c\":4}', '$.e', 99) returns '{\"a\":2,\"c\":4,\"e\":99}'", "json_replace('{\"a\":2,\"c\":4}', '$.a', 99) returns '{\"a\":99,\"c\":4}'", "json_replace('{\"a\":2,\"c\":4}', '$.e', 99) does not modify the original JSON", "json_set('{\"a\":2,\"c\":4}', '$.a', 99) returns '{\"a\":99,\"c\":4}'", "json_set('{\"a\":2,\"c\":4}', '$.e', 99) returns '{\"a\":2,\"c\":4,\"e\":99}'", "json_set('{\"a\":2,\"c\":4}', '$.c', '[97,96]') returns '{\"a\":2,\"c\":\"[97,96]\"}'", "json_set('{\"a\":2,\"c\":4}', '$.c', json('[97,96]')) returns '{\"a\":2,\"c\":[97,96]}'", "json_set('{\"a\":2,\"c\":4}', '$.c', json_array(97,96)) returns '{\"a\":2,\"c\":[97,96]}"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jinsb"], "Title": ["JSON Functions"], "Feature": ["jsonb_set()"], "Description": ["The jsonb_insert(), jsonb_replace(), and jsonb_set() functions operate in a manner analogous to their json_ counterparts, specifically json_insert(), json_replace(), and json_set(). These binary JSONB format functions are designed to perform the same JSON value modifications as their text-based counterparts, with the key distinction that they return the results in the binary JSONB format. This can be advantageous for performance and efficiency when working with JSON data in SQLite, as the binary format reduces the overhead associated with parsing and handling JSON text."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jobj"], "Title": ["JSON Functions"], "Feature": ["json_object()"], "Description": ["The json_object() SQL function constructs a JSON object from pairs of label and value arguments. It accepts zero or more such pairs, with the label as the first argument of each pair and the value as the second. If any argument provided to json_object() is a BLOB, an error is thrown. Currently, the function allows duplicate labels without issue, but this behavior may change in future updates. By default, an SQL type TEXT argument is converted into a quoted JSON string, unless it is the direct result from another JSON function or the -> operator, in which case its JSON type information and substructure are preserved, enabling nested calls to json_object() and json_array(). The json() function can be used to explicitly force recognition of strings as JSON."], "Examples": ["json_object('a', 2, 'c', 4) returns '{\"a\":2,\"c\":4}'", "json_object('a', 2, 'c', '{e:5}') returns '{\"a\":2,\"c\":\"{e:5}\"}'", "json_object('a', 2, 'c', json_object('e', 5)) returns '{\"a\":2,\"c\":{\"e\":5}}'"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jobjb"], "Title": ["JSON Functions"], "Feature": ["jsonb_object()"], "Description": ["The jsonb_object() function is analogous to the json_object() function, with a key difference in the format of the output. While json_object() constructs and returns a JSON object in the standard text format, jsonb_object() generates the object in the binary JSONB format. This binary format can offer performance benefits for certain operations involving JSON data in SQLite, as it may reduce parsing time and improve data handling efficiency within the database."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jpatch"], "Title": ["JSON Functions"], "Feature": ["json_patch(T, P)"], "Description": ["The json_patch() SQL function implements the RFC-7396 MergePatch algorithm to apply a patch P to an input JSON object T. It returns a patched copy of T. The MergePatch algorithm can add, modify, or delete elements within a JSON object, making json_patch() a versatile tool for updating JSON data. However, it treats JSON arrays as immutable, meaning it cannot modify elements within an array but only replace the entire array. This function is particularly useful for generalizing replacements and removals within JSON objects but has limitations when dealing with arrays."], "Examples": ["json_patch('{\"a\":1,\"b\":2}', '{\"c\":3,\"d\":4}') returns '{\"a\":1,\"b\":2,\"c\":3,\"d\":4}'", "json_patch('{\"a\":[1,2],\"b\":2}', '{\"a\":9}') returns '{\"a\":9,\"b\":2}'", "json_patch('{\"a\":[1,2],\"b\":2}', '{\"a\":null}') returns '{\"b\":2}'", "json_patch('{\"a\":1,\"b\":2}', '{\"a\":9,\"b\":null,\"c\":8}') returns '{\"a\":9,\"c\":8}'", "json_patch('{\"a\":{\"x\":1,\"y\":2},\"b\":3}', '{\"a\":{\"y\":9},\"c\":8}') returns '{\"a\":{\"x\":1,\"y\":9},\"b\":3,\"c\":8}'"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jpatchb"], "Title": ["JSON Functions"], "Feature": ["jsonb_patch(T, P)"], "Description": ["The jsonb_patch() function operates similarly to the json_patch() function, with a primary distinction in the format of the output. It implements the RFC-7396 MergePatch algorithm to apply a patch P to an input JSON object T. However, unlike json_patch(), which returns the patched JSON in text format, jsonb_patch() returns the patched JSON in the binary JSONB format. This binary format can offer performance improvements for applications that require efficient handling of JSON data within SQLite."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jrm"], "Title": ["JSON Functions"], "Feature": ["json_remove(X, P, ...)"], "Description": ["The json_remove() function is designed to remove elements from a JSON object or array. It accepts a JSON value as the first argument and is followed by zero or more path arguments that identify the elements to be removed. The function returns a copy of the original JSON value with the specified elements removed. If a path does not match any element, it is ignored without error. The removal process is sequential and can affect subsequent path searches due to changes made by earlier removals. If called without path arguments, json_remove() returns the input JSON reformatted with excess whitespace removed. The function will throw an error if the initial argument is not well-formed JSON or if any path argument is not a well-formed path."], "Examples": ["json_remove('[0,1,2,3,4]', '$[2]') returns '[0,1,3,4]'", "json_remove('[0,1,2,3,4]', '$[2]', '$[0]') returns '[1,3,4]'", "json_remove('[0,1,2,3,4]', '$[0]', '$[2]') returns '[1,2,4]'", "json_remove('[0,1,2,3,4]', '$[#-1]', '$[0]') returns '[1,2,3]'", "json_remove('{\"x\":25,\"y\":42}') returns '{\"x\":25,\"y\":42}'", "json_remove('{\"x\":25,\"y\":42}', '$.z') returns '{\"x\":25,\"y\":42}'", "json_remove('{\"x\":25,\"y\":42}', '$.y') returns '{\"x\":25}'", "json_remove('{\"x\":25,\"y\":42}', '$') returns NULL"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jrmb"], "Title": ["JSON Functions"], "Feature": ["jsonb_remove(X, P, ...)"], "Description": ["The jsonb_remove() function operates in a similar fashion to the json_remove() function, with a key difference in the format of the returned result. It takes a JSON value as its first argument, followed by one or more path arguments that specify which elements to remove from the JSON. The function returns a copy of the JSON with the specified elements removed, in the binary JSONB format. If a path does not match any element, it is ignored without error. The removal process is sequential and can affect the outcome of subsequent path arguments. If called without path arguments, jsonb_remove() returns the input JSON reformatted with excess whitespace removed. The function will throw an error if the initial argument is not well-formed JSON or if any path argument is not a well-formed path."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jvalid"], "Title": ["JSON Functions"], "Feature": ["json_valid(X, Y)"], "Description": ["The json_valid() function checks if the input X is a well-formed JSON string or BLOB. It returns 1 if X is well-formed according to the bitmask specified by Y, or 0 if it is not. The Y parameter is an optional integer bitmask that defines the criteria for 'well-formed', with a default value of 1, which corresponds to strict compliance with canonical RFC-8259 JSON without extensions. The bitmask allows for various combinations to define what constitutes well-formed JSON, including support for JSON5 extensions and JSONB format. If either X or Y is NULL, the function returns NULL. The function is designed to be compatible with older versions of SQLite and can be enhanced in future versions to accept new flag values."], "Examples": ["json_valid('{\"x\":35}') returns 1", "json_valid('{x:35}') returns 0", "json_valid('{x:35}', 6) returns 1", "json_valid('{\"x\":35') returns 0", "json_valid(NULL) returns NULL"], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jvalid"], "Title": ["JSON Functions"], "Feature": ["json_group_array(X)"], "Description": ["The json_group_array(X) function is an aggregate SQL function that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation. The \"jsonb_\" variants are the same except that they return their result in the binary JSONB format."], "Examples": [], "Category": ["JSON Functions"]}
{"HTML": ["https://sqlite.org/json1.html#jeach"], "Title": ["JSON Functions"], "Feature": ["json_each(X, P), json_tree(X, P)"], "Description": ["The json_each(X) and json_tree(X) functions are table-valued functions that traverse JSON values. json_each(X) returns rows for each immediate child of the top-level array or object, or the top-level element for primitive values. json_tree(X) recursively explores the entire JSON structure. Both functions can take a second argument P, treating the element at path P as the top-level element. The returned table schema includes columns for key, value, type, atom, id, parent, fullkey, path, and hidden columns for the raw JSON and root path, offering a detailed breakdown of JSON elements.", "The json_each() function returns a table with columns: key, value, type, atom, id, parent, fullkey, path, json, and root.", "The json_tree() function returns a similar table but includes parent ids and represents the full JSON structure."], "Examples": ["To find users with a '704' area code phone number: SELECT DISTINCT user.name FROM user, json_each(user.phone) WHERE json_each.value LIKE '704-%';", "To decompose all data line-by-line and suppress containers: SELECT big.rowid, fullkey, value FROM big, json_tree(big.json) WHERE json_tree.type NOT IN ('object', 'array');", "To find an entry with a specific uuid in a nested 'partlist': SELECT DISTINCT json_extract(big.json, '$.id') FROM big, json_tree(big.json, '$.partlist') WHERE json_tree.key='uuid' AND json_tree.value='6fa5181e-5721-11e5-a04e-57f3d7b32808';"], "Category": ["JSON Functions"]}
