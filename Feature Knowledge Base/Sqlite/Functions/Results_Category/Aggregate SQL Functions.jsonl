{"HTML": ["https://sqlite.org/lang_aggfunc.html"], "Title": ["avg(X)"], "Feature": ["avg(X)"], "Description": ["\n  The avg() function\n  returns the average value of all non-NULL X within a\n  group.  String and BLOB values that do not look like numbers are\n  interpreted as 0.\n  The result of avg() is always a floating point value whenever\n  there is at least one non-NULL input even if all\n  inputs are integers.  The result of avg() is NULL if\n  there are no non-NULL inputs.  The result of avg() is computed\n  as total()/count() so all of the constraints that apply to\n  total() also apply to avg().\n"], "Examples": [], "Category": ["Aggregate SQL Functions"]}
{"HTML": ["https://sqlite.org/lang_aggfunc.html"], "Title": ["count(X)count(*)"], "Feature": ["count(X)count(*)"], "Description": ["\n  The count(X) function returns\n  a count of the number of times\n  that X is not NULL in a group.  The count(*) function\n  (with no arguments) returns the total number of rows in the group.\n"], "Examples": [], "Category": ["Aggregate SQL Functions"]}
{"HTML": ["https://sqlite.org/lang_aggfunc.html"], "Title": ["group_concat(X)group_concat(X,Y)string_agg(X,Y)"], "Feature": ["group_concat(X)group_concat(X,Y)string_agg(X,Y)"], "Description": ["\n  The group_concat() function returns\n  a string which is the concatenation of\n  all non-NULL values of X.  If parameter Y is present then\n  it is used as the separator\n  between instances of X.A comma (\",\") is used as the separator\n  if Y is omitted.\n  \n  The string_agg(X,Y) function is an alias\n  for group_concat(X,Y).  String_agg() is compatible with PostgreSQL\n  and SQL-Server and group_concat() is compatible with MySQL.\n  \n  The order of the concatenated elements is arbitrary unless an\n  ORDER BY argument is included immediately after the last parameter.\n"], "Examples": [], "Category": ["Aggregate SQL Functions"]}
{"HTML": ["https://sqlite.org/lang_aggfunc.html"], "Title": ["max(X)"], "Feature": ["max(X)"], "Description": ["\n  The max() aggregate function\n  returns the maximum value of all values in the group.\n  The maximum value is the value that would be returned last in an\n  ORDER BY on the same column.  Aggregate max() returns NULL \n  if and only if there are no non-NULL values in the group.\n"], "Examples": [], "Category": ["Aggregate SQL Functions"]}
{"HTML": ["https://sqlite.org/lang_aggfunc.html"], "Title": ["min(X)"], "Feature": ["min(X)"], "Description": ["\n  The min() aggregate function\n  returns the minimum non-NULL value of all values in the group.\n  The minimum value is the first non-NULL value that would appear\n  in an ORDER BY of the column.\n  Aggregate min() returns NULL if and only if there are no non-NULL\n  values in the group.\n"], "Examples": [], "Category": ["Aggregate SQL Functions"]}
{"HTML": ["https://sqlite.org/lang_aggfunc.html"], "Title": ["sum(X)total(X)"], "Feature": ["sum(X)total(X)"], "Description": ["\n  The sum() and total() aggregate functions\n  return the sum of all non-NULL values in the group.\n  If there are no non-NULL input rows then sum() returns\n  NULL but total() returns 0.0.\n  NULL is not normally a helpful result for the sum of no rows\n  but the SQL standard requires it and most other\n  SQL database engines implement sum() that way so SQLite does it in the\n  same way in order to be compatible.   The non-standard total() function\n  is provided as a convenient way to work around this design problem\n  in the SQL language.\nThe result of total() is always a floating point value.\n  The result of sum() is an integer value if all non-NULL inputs are integers.\n  If any input to sum() is neither an integer nor a NULL,\n  then sum() returns a floating point value\n  which is an approximation of the mathematical sum.\nSum() will throw an \"integer overflow\" exception if all inputs\n  are integers or NULL\n  and an integer overflow occurs at any point during the computation.\n  No overflow error is ever raised if any prior input was a floating point\n  value.\n  Total() never throws an integer overflow.\n\n  When summing floating-point values, if the magnitudes of the values\n  differ wildly then the resulting sum might be imprecise due to the fact that\n  IEEE 754 floating point values are approximations.\n  Use the decimal_sum(X) aggregate in the decimal extension to obtain\n  an exact summation of floating point numbers.  Consider this test case:\n\nCREATE TABLE t1(x REAL);\nINSERT INTO t1 VALUES(1.55e+308),(1.23),(3.2e-16),(-1.23),(-1.55e308);\nSELECT sum(x), decimal_sum(x) FROM t1;\n\nThe large values \u00b11.55e+308 cancel each other out, but the\n  cancellation does not occur until the end of the sum and in the meantime\n  the large +1.55e+308 swamps the tiny 3.2e-16 value.  The end result is\n  an imprecise result for the sum().  The decimal_sum() aggregate\n  generates an exact answer, at the cost of additional CPU and memory usage.\n  Note also that decimal_sum() is not built into the SQLite core; it is a\n  loadable extension.\n\n  If sum of inputs is too large to represent as a IEEE 754 floating\n  point value, then a +Infinity or -Infinity result may be returned.\n  If very large values with differing signs are used\n  such that the SUM() or TOTAL() function is\n  unable to determine if the correct result is +Infinity or -Infinity\n  or some other value in between, then the result is NULL.  Hence, for\n  example, the following query returns NULL:\n\nWITH t1(x) AS (VALUES(1.0),(-9e+999),(2.0),(+9e+999),(3.0))\n SELECT sum(x) FROM t1;\n\n"], "Examples": [], "Category": ["Aggregate SQL Functions"]}
