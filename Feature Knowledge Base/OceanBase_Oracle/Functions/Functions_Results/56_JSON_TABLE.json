{
    "HTML": [
        "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823501"
    ],
    "Title": [
        "JSON_TABLE"
    ],
    "Feature": [
        "JSON_TABLE(\n        expr [FORMAT JSON]\n        [, json_path_literal]\n        [ERROR | NULL ON ERROR]\n        COLUMNS (\n          [column_name [json_value_return_type] EXISTS [PATH path_literal] [json_exists_on_error_clause] [json_exists_on_emtpy_clause]]\n          [column_name [json_query_return_type] FORMAT JSON [ALLOW|DISALLOW SCALARS] [json_query_wrapper_clause] [PATH path_literal] [json_query_on_error_clause]]\n          [column_name [json_value_return_type] [TRUNCATE] [PATH path_literal] [json_exists_on_error_clause] [json_exists_on_emtpy_clause]]\n          [column_name FOR ORDINALITY]\n          [NESTED PATH path_literal COLUMNS (\n            # 嵌套结构，重复父一级语法\n            ...\n          )]\n        )\n       )\n"
    ],
    "Description": [
        "JSON_TABLE() 函数提供了一种联系关系表和 JSON 结构数据的途径。可以在 SQL 中像使用虚拟关系表一样来使用 JSON_TABLE() 的输出结果。JSON_TABLE() 为每一个 JSON 值提供了列输出，对于 JSON 内的数组，提供了多行（列）输出。 JSON_TABLE() 必须用在 SELECT 语句的 FROM 子句中。"
    ],
    "Examples": [
        "# 使用 NESTED COLUMN 嵌套语句\nDROP TABLE jsonb_table_test;\nCREATE TABLE jsonb_table_test (js VARCHAR2 (4000));\n\nDELETE FROM jsonb_table_test;\nINSERT INTO jsonb_table_test VALUES (\n  '[\n  \t{\"c\": [7], \"d\": [3], \"a\": 2,  \"b\": [3,4]}\n  ]'\n);\n\nobclient> SELECT jt.* FROM jsonb_table_test jtt,\n      json_table (jtt.js, '$[*]'\n          columns (\n            nested path '$.c[*]' COLUMNS (c int path '$'),\n            nested path '$.d[*]' COLUMNS (d int path '$'),\n            nested path '$.b[*]' COLUMNS (b int path '$'),\n            a int path '$.a'\n          )\n      ) jt;\n+------+------+------+------+\n| C    | D    | B    | A    |\n+------+------+------+------+\n| NULL | NULL |    3 |    2 |\n| NULL | NULL |    4 |    2 |\n| NULL |    3 | NULL |    2 |\n|    7 | NULL | NULL |    2 |\n+------+------+------+------+\n4 rows in set\n\n\n# 使用 NESTED COLUMN 嵌套和 ORDINALITY 列\nobclient> INSERT INTO jsonb_table_test VALUES (\n        '[\n        {\"a\":  1,  \"b\": [], \"c\": []},\n        {\"a\":  2,  \"b\": [1, 2, 3], \"c\": [10, null, 20]},\n        {\"a\":  3,  \"b\": [1, 2], \"c\": []},\n        {\"a\":  4, \"b\": [1, 2], \"c\": [123]}\n        ]'\n      );\nQuery OK, 1 row affected\n\nobclient> SELECT jt.* FROM jsonb_table_test jtt,\n        json_table (jtt.js, '$[*]'\n          columns (\n            nested path '$.c[*]' COLUMNS (c int path '$'),\n            nested path '$.b[*]' COLUMNS (b int path '$'),\n            n FOR ORDINALITY,\n            a int path '$.a'\n          )\n        ) jt;\n+------+------+------+------+\n| C    | B    | N    | A    |\n+------+------+------+------+\n| NULL | NULL |    1 |    1 |\n| NULL |    1 |    2 |    2 |\n| NULL |    2 |    2 |    2 |\n| NULL |    3 |    2 |    2 |\n|   10 | NULL |    2 |    2 |\n| NULL | NULL |    2 |    2 |\n|   20 | NULL |    2 |    2 |\n| NULL |    1 |    3 |    3 |\n| NULL |    2 |    3 |    3 |\n| NULL |    1 |    4 |    4 |\n| NULL |    2 |    4 |    4 |\n|  123 | NULL |    4 |    4 |\n+------+------+------+------+\n12 rows in set\n\n# 查询 json_table 的 json_value 列，以及使用 EMTPY 子句\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": 123.45}',\n        '$'\n         columns (a CLOB path '$.nokey' default 'abc' on EMPTY)\n        ) jt;\n+------+\n| A    |\n+------+\n| abc  |\n+------+\n1 row in set\n\n# 查询 json_table 的 json_value 列，以及使用 EMTPY 子句\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": 123.45}',\n        '$'\n         columns (a CLOB path '$.nokey' NULL on EMPTY)\n        ) jt;\n+------+\n| A    |\n+------+\n| NULL |\n+------+\n1 row in set\n\nobclient> SELECT jt.* FROM\n   json_table(\n   '{\"details\":\n     [ {\"branch_code\": \"3020300\", \"products\": [\n                                           \"23D0980000000000\",\n                                           \"23E2980000000000\",\n                                           \"23E3980000000004\"]},\n      {\"branch_code\": \"3090100\", \"products\": [\n                                           \"23D0980000000000\",\n                                           \"23E2980000000000\"]}],\n      \"extras\": [\"AWUX1201293111\", \"AWUX1201293112\"]\n     }',\n     '$.details[*]'\n     columns (\n       branch_code varchar2(100) path '$.branch_code',\n       nested path '$.products[*]' columns (product varchar2(100) path '$[*]')\n       )\n     ) jt;\n\n+-------------+------------------+\n| BRANCH_CODE | PRODUCT          |\n+-------------+------------------+\n| 3020300     | 23D0980000000000 |\n| 3020300     | 23E2980000000000 |\n| 3020300     | 23E3980000000004 |\n| 3090100     | 23D0980000000000 |\n| 3090100     | 23E2980000000000 |\n+-------------+------------------+\n5 rows in set\n\n# 查询 json_table 的 JSON_EXISTS 列\n obclient> SELECT jt.* FROM json_table (\n        '{\n          \"a\": \"1997-8-14 11:11:11\",\n          \"b\" : 123,\n          \"c\": \"varchar2\"\n         }',\n        '$' columns (\n            a date EXISTS path '$.a',\n            b int EXISTS path '$.b' ERROR ON EMPTY,\n            c varchar2(32) format json path '$.c' NULL ON EMPTY\n          )\n        ) jt;\n+---------------------+------+----------+\n| A                   | B    | C        |\n+---------------------+------+----------+\n| 1997-08-14 11:11:11 |  123 | varchar2 |\n+---------------------+------+----------+\n1 row in set\n\n# 查询 json_table 的 json_query 列\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": [1, 2, 3, 3]}',\n        '$'\n         columns (a varchar2(1024) FORMAT JSON path '$.data[*]')\n        ) jt;\n+--------------+\n| A            |\n+--------------+\n| [1, 2, 3, 3] |\n+--------------+\n1 row in set\n"
    ],
    "Category": [
        "JSON Functions"
    ]
}