{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822872"], "Title": ["RANK"], "Feature": ["/*聚合语法*/\nRANK(expr [, expr ]...) WITHIN GROUP\n  ( ORDER BY\n            expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n            [, expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n  )\n\n/*分析语法*/\nRANK() OVER ([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数用于计算一个值在一组值的排名。当有相同排序值时，将会有相同的排名，并且值相同的行数会被记录到下个排名中。可以将此函数用作聚合或分析函数。", "\n说明\n\n作为聚合函数，RANK 计算由参数 expr 标识的假设行相对于指定排序规范的排名。参数表达式 expr 和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的数据类型必须兼容。\n作为一个解析函数，RANK 计算从查询相对于由查询返回的其他行返回的每一行的秩，基于所述值 value_exprs 中 order_by_clause。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------+\n| RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------+\n|                                13 |\n+-----------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename,sal,\n                   RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    3 |\n|     20 | ADAMS  | 1400 |    4 |\n|     20 | SMITH  | 1100 |    5 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    7 |\n+--------+--------+------+------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822871"], "Title": ["REGR_ (Linear Regression)"], "Feature": ["{ REGR_SLOPE\n | REGR_INTERCEPT\n | REGR_COUNT\n | REGR_R2\n | REGR_AVGX\n | REGR_AVGY\n | REGR_SXX\n | REGR_SYY\n | REGR_SXY\n}(expr1 , expr2)\n  [ OVER (analytic_clause) ]\n"], "Description": ["该函数是线性回归函数，将普通最小二乘法回归线拟合到一组数字对上。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nREGR_SLOPE\n返回直线的坡度（斜率）。返回值是数值数据类型，可以为 NULL。 忽略空数值对（expr1,expr2）后，它进行以下计算： sql COVAR_POP(expr1, expr2) / VAR_POP(expr2)\n\n\nREGR_INTERCEPT\n返回回归线的 y 截距。返回值是数值数据类型，可以为 NULL。忽略空数值对（expr1,expr2）后，它进行以下计算： sql AVG(expr1) - REGR_SLOPE(expr1, expr2) * AVG(expr2)\n\n\nREGR_COUNT\n返回用于填充回归线的非空数值对的数目，是一个整数。\n\n\nREGR_R2\n返回回归的确定系数（也称为 R 平方或拟合优度）。返回值是数值数据类型，可以为 NULL。忽略 VAR_POP(expr1) 和 VAR_POP(expr2) 的空值后进行评估。返回值为： sql NULL if VAR_POP(expr2) = 0 1 if VAR_POP(expr1) = 0 and VAR_POP(expr2) != 0 POWER(CORR(expr1,expr),2) if VAR_POP(expr1) > 0 and VAR_POP(expr2 != 0\n\n\nREGR_AVGX\n返回回归线的自变量（expr2）的平均值。忽略空数值对（expr1,expr2）后，进行以下计算： sql AVG(expr2)\n\n\nREGR_AVGY\n返回回归线的因变量（expr1）的平均值。忽略空数值对（expr1,expr2）后，进行以下计算： sql AVG(expr1)\n\n\nREGR_SXX\n返回值等于在忽略空数值对（expr1,expr2）后数值对的个数乘以自变量的值的总体方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * VAR_POP(expr2)\n\n\nREGR_SYY\n返回值等于在忽略空数值对（expr1,expr2）后数值对的个数乘以因变量的值的总体方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * VAR_POP(expr1)\n\n\nREGR_SXY\n返回值等于在忽略空数值对（expr1,expr2）后的数值对的个数乘以总体协方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2)\n\n\nexpr1\n指定因变量的值（y 值）。\n\n\nexpr2\n指定自变量的值（x 值）。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\nREGR_SXX 、REGR_SYY 和 REGR_SXY 是用于计算各种诊断统计数据的辅助函数。\n", "返回值是数值数据类型或 NULL。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n", "obclient> SELECT col1,REGR_SXX(col3,col4) \"REGR_SXX\",\n            REGR_SYY(col3,col4) \"REGR_SYY\",\n            REGR_SXY(col3,col4) \"REGR_SXY\"\n          FROM tbl1\n          GROUP BY col1;\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n| COL1 | REGR_SXX                               | REGR_SYY                                 | REGR_SXY                               |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n|    1 | 8.666666666666666666666666666666666667 | 4.66666666666666666666666666666666666701 | 6.333333333333333333333333333333333333 |\n|    2 |                                      5 |                                        5 |                                      5 |\n|    3 |                                   40.8 |                                       10 |                                    -20 |\n|    4 |                                      0 |                                        0 |                                      0 |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n4 rows in set\n", "obclient> SELECT col1,col2,col3,col4,\n            REGR_SLOPE(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"REGR_SLOPE\"\n          FROM tbl1;\n+------+------+------+------+--------------------------------------------+\n| COL1 | COL2 | COL3 | COL4 | REGR_SLOPE                                 |\n+------+------+------+------+--------------------------------------------+\n|    1 | A1   |    8 |   12 |                                       NULL |\n|    1 | A2   |   10 |   15 |  .6666666666666666666666666666666666666667 |\n|    1 | A3   |   11 |   16 |  .7307692307692307692307692307692307691642 |\n|    2 | B1   |    9 |   14 |                                       NULL |\n|    2 | B2   |   10 |   15 |                                          1 |\n|    2 | B3   |    8 |   13 |                                          1 |\n|    2 | B4   |   11 |   16 |                                          1 |\n|    3 | C1   |    8 |   18 |                                       NULL |\n|    3 | C2   |    9 |   16 |                                        -.5 |\n|    3 | C3   |   10 |   15 | -.6428571428571428571428571428571428570956 |\n|    3 | C4   |   11 |   12 | -.5066666666666666666666666666666666666667 |\n|    3 | C5   |   12 |   10 | -.4901960784313725490196078431372549019608 |\n|    4 | d1   |    8 | NULL |                                       NULL |\n|    4 | d1   |    9 |   10 |                                       NULL |\n|    4 | d1   |   10 | NULL |                                       NULL |\n+------+------+------+------+--------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822878"], "Title": ["ROLLUP"], "Feature": ["SELECT ... GROUP BY ROLLUP(col_name [,col_name...])\n"], "Description": ["该函数是一个聚合函数，功能是可以为每个分组返回一个小计，同时为所有分组返回总计。它是 GROUP BY 语句的简单扩展，在数据统计和报表生成过程中比 GROUP BY 和 UNION 组合方法效率高。在涉及分组统计的任务中使用 ROLLUP 函数非常高效。例如，沿着时间或地理等层次维度进行小计，只需要查询 ROLLUP(y, m, day) 或 ROLLUP(country, state, city)。数据仓库管理员使用 ROLLUP 函数可以简化和加快汇总表的维护。", "ROLLUP 函数的执行顺序如下：", "根据参数指定的列从右到左递减分组。", "对每个分组小计，再对所有分组合计。", "按照 ORDER BY col1 (，col2，col3，col4 ...) 排序。", "col_name 是指进行分组操作的列名。如果 ROLLUP 参数为 N 个 col_name，则相当于 N+1 个 GROUP BY 分组的 UNION 的结合。"], "Examples": ["obclient> CREATE TABLE group_tbl1 (group_id INT,job VARCHAR2(10),name VARCHAR2(10),salary INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO group_tbl1 VALUES\n    (10,'Coding','Bruce',1000),\n    (10,'Programmer','Clair',1000),\n    (20,'Coding','Jason',2000),\n    (20,'Programmer','Joey',2000),\n    (30,'Coding','Rebecca',3000),\n    (30,'Programmer','Rex',3000),\n    (40,'Coding','Samuel',4000),\n    (40,'Programmer','Susy',4000);\nQuery OK, 8 rows affected (0.01 sec)\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM group_tbl1;\n+----------+------------+---------+--------+\n| GROUP_ID | JOB        | NAME    | SALARY |\n+----------+------------+---------+--------+\n|       10 | Coding     | Bruce   |   1000 |\n|       10 | Programmer | Clair   |   1000 |\n|       20 | Coding     | Jason   |   2000 |\n|       20 | Programmer | Joey    |   2000 |\n|       30 | Coding     | Rebecca |   3000 |\n|       30 | Programmer | Rex     |   3000 |\n|       40 | Coding     | Samuel  |   4000 |\n|       40 | Programmer | Susy    |   4000 |\n+----------+------------+---------+--------+\n8 rows in set\n", "obclient> SELECT group_id,SUM(salary) FROM group_tbl1 GROUP BY group_id;\n+----------+-------------+\n| GROUP_ID | SUM(SALARY) |\n+----------+-------------+\n|       10 |        2000 |\n|       20 |        4000 |\n|       30 |        6000 |\n|       40 |        8000 |\n+----------+-------------+\n4 rows in set\n", "obclient> SELECT group_id,SUM(salary) FROM group_tbl1 GROUP BY ROLLUP (group_id);\n+----------+-------------+\n| GROUP_ID | SUM(SALARY) |\n+----------+-------------+\n|       10 |        2000 |\n|       20 |        4000 |\n|       30 |        6000 |\n|       40 |        8000 |\n|     NULL |       20000 |\n+----------+-------------+\n5 rows in set\n", "obclient> SELECT group_id,job,SUM(salary) FROM group_tbl1 GROUP BY ROLLUP (group_id,job);\n+----------+------------+-------------+\n| GROUP_ID | JOB        | SUM(SALARY) |\n+----------+------------+-------------+\n|       10 | Coding     |        1000 |\n|       10 | Programmer |        1000 |\n|       10 | NULL       |        2000 |\n|       20 | Coding     |        2000 |\n|       20 | Programmer |        2000 |\n|       20 | NULL       |        4000 |\n|       30 | Coding     |        3000 |\n|       30 | Programmer |        3000 |\n|       30 | NULL       |        6000 |\n|       40 | Coding     |        4000 |\n|       40 | Programmer |        4000 |\n|       40 | NULL       |        8000 |\n|     NULL | NULL       |       20000 |\n+----------+------------+-------------+\n13 rows in set\n", "obclient> SELECT group_id,job,SUM(salary) FROM group_tbl1 GROUP BY group_id, job\n    UNION ALL\n    SELECT group_id,NULL,SUM(salary) FROM group_tbl1 GROUP BY group_id\n    UNION ALL\n    SELECT NULL,NULL,SUM(salary) FROM group_tbl1 ORDER BY 1,2;\n+----------+------------+-------------+\n| GROUP_ID | JOB        | SUM(SALARY) |\n+----------+------------+-------------+\n|       10 | Coding     |        1000 |\n|       10 | Programmer |        1000 |\n|       10 | NULL       |        2000 |\n|       20 | Coding     |        2000 |\n|       20 | Programmer |        2000 |\n|       20 | NULL       |        4000 |\n|       30 | Coding     |        3000 |\n|       30 | Programmer |        3000 |\n|       30 | NULL       |        6000 |\n|       40 | Coding     |        4000 |\n|       40 | Programmer |        4000 |\n|       40 | NULL       |        8000 |\n|     NULL | NULL       |       20000 |\n+----------+------------+-------------+\n13 rows in set\n"], "Category": ["Aggregate Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822891"], "Title": ["STDDEV"], "Feature": ["STDDEV([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值型数据标准差。它与函数 STDDEV_SAMP 的不同之处在于，STDDEV 只有一行输入数据时返回 0，而 STDDEV_SAMP 返回 NULL。OceanBase 数据库中标准差的值是函数 VARIANCE 计算出的方差的算术平方根。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：全部数值列。\nDISTINCT：去重关键字，表示计算唯一值的总体标准差。\nUNIQUE：去重关键字，表示计算唯一值的总体标准差。\n\n\n\nexpr\n数值类型或者可以转换成数值类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n", "返回 NUMBER 类型的数据。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT STDDEV(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV(SALARY)                            |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT last_name,hiredate,salary,STDDEV(salary) OVER (ORDER BY hiredate) \"StdDev\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | StdDev                                    |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |  212.132034355964257320253308631454711785 |\n| Raphaely  | 2017-07-22 |   1700 |  173.205080756887729352744634150587236694 |\n| De Haan   | 2018-05-01 |  11000 | 4702.127178203498995615489088200868644482 |\n| Partners  | 2018-12-01 |  14000 | 6064.899009876421676804205219406952308814 |\n| Russell   | 2019-07-11 |  13000 |  6138.94670661561181357873224397795992899 |\n| Hartstein | 2019-10-05 |  14000 | 6026.474330580265330900400184969999384459 |\n| Weiss     | 2019-10-05 |  13500 | 6026.474330580265330900400184969999384459 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822862"], "Title": ["STDDEV_POP"], "Feature": ["STDDEV_POP( [ALL] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数将数值型数据作为参数计算总体标准差。总体标准差是总体方差的算术平方根。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nALL\n指定全部数值列，为可选项。默认值为 ALL。\n\n\nexpr\n数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或者可以转换成数值类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回类型与参数 expr 的数据类型相同。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT STDDEV_POP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_POP(SALARY)                        |\n+-------------------------------------------+\n| 5637.250548804798333699350384281939588505 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT department_id,last_name,salary,STDDEV_POP(salary) OVER (PARTITION BY department_id) AS pop_std\n          FROM employees\n          ORDER BY department_id,last_name,salary;\n+---------------+-----------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | POP_STD                                   |\n+---------------+-----------+--------+-------------------------------------------+\n|            30 | De Haan   |  11000 |                                      4650 |\n|            30 | Raphaely  |   1700 |                                      4650 |\n|            40 | Errazuriz |   1400 |                                         0 |\n|            50 | Hartstein |  14000 | 5684.090858606052304285807872404592677763 |\n|            50 | Raphaely  |   1700 | 5684.090858606052304285807872404592677763 |\n|            50 | Weiss     |  13500 | 5684.090858606052304285807872404592677763 |\n|            90 | Partners  |  14000 |                                       500 |\n|            90 | Russell   |  13000 |                                       500 |\n+---------------+-----------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822869"], "Title": ["STDDEV_SAMP"], "Feature": ["STDDEV_SAMP([ALL] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数将数值型数据作为参数计算样本标准差，样本标准差是样本方差的算术平方根。STDDEV_SAMP 与函数 STDDEV 的不同之处在于，STDDEV 只有一行输入数据时返回 0，而 STDDEV_SAMP 返回 NULL。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nALL\n全部数值列。为可选项，默认值 ALL。\n\n\nexpr\n数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或者可以转换成数值类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回类型与参数 expr 的数据类型相同。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT STDDEV_SAMP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_SAMP(SALARY)                       |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT department_id, last_name, hiredate, salary,\n                 STDDEV_SAMP(salary) OVER (PARTITION BY department_id\n                  ORDER BY hiredate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s_samp\n          FROM employees;\n+---------------+-----------+------------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | S_SAMP                                    |\n+---------------+-----------+------------+--------+-------------------------------------------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |                                      NULL |\n|            30 | De Haan   | 2018-05-01 |  11000 | 6576.093065034891976927852567575096065349 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |                                      NULL |\n|            50 | Raphaely  | 2017-07-22 |   1700 |                                      NULL |\n|            50 | Hartstein | 2019-10-05 |  14000 | 8697.413408594534550130385653889643183203 |\n|            50 | Weiss     | 2019-10-05 |  13500 | 6961.561127601576503543602300090640831831 |\n|            90 | Partners  | 2018-12-01 |  14000 |                                      NULL |\n|            90 | Russell   | 2019-07-11 |  13000 |  707.106781186547524400844362104849039285 |\n+---------------+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822877"], "Title": ["SUM"], "Feature": ["SUM([ DISTINCT | UNQIUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回指定参数的总和。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNQIUE | ALL\n计算时是否去重。为可选项，默认值 ALL。 \n      \nALL：计算所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：去除重复行，且忽略值为 NULL 的行。\nUNIQUE：去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n数值数据类型或任何可以隐式转换为数值数据类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause 参数。\n", "返回与 expr 相同数据类型的值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n", "obclient> SELECT department_id, last_name, salary,\n              SUM(salary) OVER\n                  (PARTITION BY department_id ORDER BY salary RANGE UNBOUNDED PRECEDING) s_sum\n    FROM employees\n    ORDER BY department_id,s_sum;\n+---------------+-----------+--------+-------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | S_SUM |\n+---------------+-----------+--------+-------+\n|            30 | Raphaely  |   1700 |  1700 |\n|            30 | De Haan   |  11000 | 12700 |\n|            40 | Errazuriz |   1400 |  1400 |\n|            50 | Raphaely  |   1700 |  1700 |\n|            50 | Weiss     |  13500 | 15200 |\n|            50 | Hartstein |  14000 | 29200 |\n|            90 | Russell   |  13000 | 13000 |\n|            90 | Partners  |  14000 | 27000 |\n+---------------+-----------+--------+-------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822879"], "Title": ["VARIANCE"], "Feature": ["VARIANCE([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数功能是返回指定列的方差。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：查询时不去除数据中的重复值，且忽略数据中的 NULL 值。\nDISTINCT：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\nUNIQUE：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\n\n\n\nexpr\n数值数据类型或任何可以隐式转换为数值数据类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n", "返回与参数 expr 相同的数据类型。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n", "obclient> SELECT last_name,hiredate,salary,VARIANCE(salary) OVER (ORDER BY hiredate) \"Variance\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | Variance                                  |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |                                     45000 |\n| Raphaely  | 2017-07-22 |   1700 |                                     30000 |\n| De Haan   | 2018-05-01 |  11000 |                                  22110000 |\n| Partners  | 2018-12-01 |  14000 |                                  36783000 |\n| Russell   | 2019-07-11 |  13000 |  37686666.6666666666666666666666666666666 |\n| Hartstein | 2019-10-05 |  14000 | 36318392.85714285714285714285714285714286 |\n| Weiss     | 2019-10-05 |  13500 | 36318392.85714285714285714285714285714286 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822885"], "Title": ["VAR_POP"], "Feature": ["VAR_POP(expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回一组数值集合的总体方差（忽略 NULL）。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定参与计算的数值表达式。属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n如果该函数应用于空集，则返回 NULL。返回结果计算公式为：SUM((expr - (SUM(expr) / COUNT(expr)))²)/ COUNT(expr)。\n", "返回与参数 expr 相同的数据类型或 NULL。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n", "obclient> SELECT VAR_POP(col4) FROM tbl1;\n+------------------------------------------+\n| VAR_POP(COL4)                            |\n+------------------------------------------+\n| 5.53846153846153846153846153846153846154 |\n+------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col2,col4,VAR_POP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                        0 |\n|    1 | A2   |   15 |                                     2.25 |\n|    1 | A3   |   16 |   2.888888888888888888888888888888888889 |\n|    2 | B1   |   14 |                                   2.1875 |\n|    2 | B2   |   15 |                                     1.84 |\n|    2 | B3   |   13 |  1.8055555555555555555555555555555555555 |\n|    2 | B4   |   16 | 1.95918367346938775510204081632653061229 |\n|    3 | C1   |   18 |                                 3.109375 |\n|    3 | C2   |   16 | 2.88888888888888888888888888888888888889 |\n|    3 | C3   |   15 |                                      2.6 |\n|    3 | C4   |   12 | 3.10743801652892561983471074380165289255 |\n|    3 | C5   |   10 | 4.55555555555555555555555555555555555558 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n|    4 | d1   |   10 | 5.53846153846153846153846153846153846154 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822867"], "Title": ["VAR_SAMP"], "Feature": ["VAR_SAMP(expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回一组数值集合的样本方差（忽略 NULL）。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定参与计算的数值表达式。属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n如果该函数应用于空集，则返回 NULL。返回结果计算公式为：(SUM(expr - (SUM(expr) / COUNT(expr)))²) /(COUNT(expr) - 1)。\n", "返回与参数 expr 相同的数据类型或 NULL。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n", "obclient> SELECT VAR_SAMP(col4) FROM tbl1;\n+----------------+\n| VAR_SAMP(COL4) |\n+----------------+\n|              6 |\n+----------------+\n1 row in set\n", "obclient> SELECT col1,col2,col4,VAR_SAMP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                     NULL |\n|    1 | A2   |   15 |                                      4.5 |\n|    1 | A3   |   16 |  4.3333333333333333333333333333333333335 |\n|    2 | B1   |   14 | 2.91666666666666666666666666666666666667 |\n|    2 | B2   |   15 |                                      2.3 |\n|    2 | B3   |   13 |  2.1666666666666666666666666666666666666 |\n|    2 | B4   |   16 | 2.28571428571428571428571428571428571433 |\n|    3 | C1   |   18 | 3.55357142857142857142857142857142857143 |\n|    3 | C2   |   16 |                                     3.25 |\n|    3 | C3   |   15 | 2.88888888888888888888888888888888888889 |\n|    3 | C4   |   12 |  3.4181818181818181818181818181818181818 |\n|    3 | C5   |   10 |   4.969696969696969696969696969696969697 |\n|    4 | d1   | NULL |                                        6 |\n|    4 | d1   |   10 |                                        6 |\n|    4 | d1   | NULL |                                        6 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822884"], "Title": ["WMSYS.WM_CONCAT/WM_CONCAT"], "Feature": ["WM_CONCAT ([DISTINCT] measure_expr) [OVER query_partition_clause]\n"], "Description": ["该函数用于列转行，将度量列的值进行合并。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，不需要加 OVER 关键字。 \n     \n作为单个集合的聚合函数，WM_CONCAT 对所有行进行操作并返回单个输出行。\n作为组集聚合，WM_CONCAT 将对 GROUP BY 子句定义的每个组进行操作并返回输出行。\n\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT\n如果指定 DISTINCT，会在返回结果中删除重复值。为可选项。\n\n\nmeasure_expr\n可以是任何表达式。度量列中的空值将被忽略。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 CLOB 类型的数据值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT WM_CONCAT(last_name) \"Emp_list\" FROM employees;\n+----------------------------------------------------------------------+\n| Emp_list                                                             |\n+----------------------------------------------------------------------+\n| Raphaely,De Haan,Errazuriz,Hartstein,Raphaely,Weiss,Russell,Partners |\n+----------------------------------------------------------------------+\n1 row in set\n", "obclient> SELECT department_id,hiredate,last_name,\n              WM_CONCAT(last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n    FROM employees\n    ORDER BY 1,2;\n+---------------+------------+-----------+--------------------------+\n| DEPARTMENT_ID | HIREDATE   | LAST_NAME | Emp_list                 |\n+---------------+------------+-----------+--------------------------+\n|            30 | 2017-07-01 | Raphaely  | Raphaely,De Haan         |\n|            30 | 2018-05-01 | De Haan   | Raphaely,De Haan         |\n|            40 | 2017-07-21 | Errazuriz | Errazuriz                |\n|            50 | 2017-07-22 | Raphaely  | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Hartstein | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Weiss     | Hartstein,Raphaely,Weiss |\n|            90 | 2018-12-01 | Partners  | Russell,Partners         |\n|            90 | 2019-07-11 | Russell   | Russell,Partners         |\n+---------------+------------+-----------+--------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822865"], "Title": ["CORR"], "Feature": ["CORR(expr1, expr2) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值对的相关系数。相关系数代表数值对的关联强度，范围为 [-1,1]，其中 0 表示不相关，小于 0 代表负相关，大于 0 代表正相关。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个参数，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个参数，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果。\n返回结果计算公式为：COVAR_POP(expr1, expr2) / (STDDEV_POP(expr1) * STDDEV_POP(expr2))。\n\n", "如果有任意一个参数为空或只有一行数据，则返回 NULL。否则返回一个 NUMBER 类型的值。"], "Examples": ["obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT CORR(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col3,col4,CORR(col3,col4) OVER(PARTITION BY col1) \"corr\" FROM tbl1;\n+------+------+------+--------------------------------------------+\n| COL1 | COL3 | COL4 | corr                                       |\n+------+------+------+--------------------------------------------+\n|    1 |    8 |   12 |  .9958705948858223809835060513429288056548 |\n|    1 |   10 |   15 |  .9958705948858223809835060513429288056548 |\n|    1 |   11 |   16 |  .9958705948858223809835060513429288056548 |\n|    2 |    9 |   14 |                                          1 |\n|    2 |   10 |   15 |                                          1 |\n|    2 |    8 |   13 |                                          1 |\n|    2 |   11 |   16 |                                          1 |\n|    3 |    8 |   18 | -.9901475429766743091532731291244706579003 |\n|    3 |    9 |   16 | -.9901475429766743091532731291244706579003 |\n|    3 |   10 |   15 | -.9901475429766743091532731291244706579003 |\n|    3 |   11 |   12 | -.9901475429766743091532731291244706579003 |\n|    3 |   12 |   10 | -.9901475429766743091532731291244706579003 |\n+------+------+------+--------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822887"], "Title": ["COUNT"], "Feature": ["COUNT({ * | [ DISTINCT | UNIQUE | ALL ] expr }) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于返回查询 expr 的行数。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\n*\n表示返回满足条件的所有行，且包含重复行和空行。\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略空行。\nDISTINCT：返回的行中去除重复行，且忽略空行。\nUNIQUE：返回的行中去除重复行，且忽略空行。\n\n\n\nexpr\n指定参与计算的列名。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n\n对于 COUNT 函数，从不返回 NULL，如果指定了 expr，即返回 expr 不为 NULL 的统计个数，如果指定 COUNT(*) 返回所有行的统计数目。使用参数 DISTINCT 、UNIQUE 或 ALL 时需要与 expr 用空格隔开。\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n\n", "返回一个自然数。"], "Examples": ["obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES\n    (1,'aa',10),(2,'bb',12),(3,'cc',15),(4,'dd',18),(5,'ee',20),\n    (6,'ff',23),(7,'gg',25),(8,'hh',30),(9,'ii',40),(10,'jj',15),\n    (11,'kk',NULL),(12,'oo',NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | aa   |   10 |\n|    2 | bb   |   12 |\n|    3 | cc   |   15 |\n|    4 | dd   |   18 |\n|    5 | ee   |   20 |\n|    6 | ff   |   23 |\n|    7 | gg   |   25 |\n|    8 | hh   |   30 |\n|    9 | ii   |   40 |\n|   10 | jj   |   15 |\n|   11 | kk   | NULL |\n|   12 | oo   | NULL |\n+------+------+------+\n12 rows in set\n", "obclient> SELECT COUNT(col3),COUNT(*) FROM tbl1;\n+-------------+----------+\n| COUNT(COL3) | COUNT(*) |\n+-------------+----------+\n|          10 |       12 |\n+-------------+----------+\n1 row in set\n", "obclient> SELECT col1,col2,\n                 COUNT(*) OVER (ORDER BY col3 RANGE BETWEEN 1 PRECEDING AND 3 FOLLOWING) AS mov_count\n          FROM tbl1;\n+------+------+-----------+\n| COL1 | COL2 | MOV_COUNT |\n+------+------+-----------+\n|    1 | aa   |         2 |\n|    2 | bb   |         3 |\n|    3 | cc   |         3 |\n|   10 | jj   |         3 |\n|    4 | dd   |         2 |\n|    5 | ee   |         2 |\n|    6 | ff   |         2 |\n|    7 | gg   |         1 |\n|    8 | hh   |         1 |\n|    9 | ii   |         1 |\n|   11 | kk   |         2 |\n|   12 | oo   |         2 |\n+------+------+-----------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822864"], "Title": ["COVAR_POP"], "Feature": ["COVAR_POP(expr1, expr2)[ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值对的总体协方差。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果，即 COVAR_POP(expr1, expr2) 等于 COVAR_POP(expr2, expr1)。\n返回结果计算公式为：(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n，其中 n 是（expr1,expr2）表达式对的数量，expr1 和 expr2 均不为空。\n\n", "如果有任意一个参数为空，则返回 NULL；否则返回一个 NUMBER 类型的值。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT COVAR_POP(col3,col4) FROM tbl1;\n+----------------------+\n| COVAR_POP(COL3,COL4) |\n+----------------------+\n|                 -.75 |\n+----------------------+\n1 row in set\n", "obclient> SELECT col1,col3,col4,\n            COVAR_POP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_POP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_POP                                 |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                         0 |\n|    1 |   10 |   15 |                                       1.5 |\n|    1 |   11 |   16 |    2.111111111111111111111111111111111111 |\n|    2 |    9 |   14 |                                         0 |\n|    2 |   10 |   15 |                                       .25 |\n|    2 |    8 |   13 | .6666666666666666666666666666666666666667 |\n|    2 |   11 |   16 |                                      1.25 |\n|    3 |    8 |   18 |                                         0 |\n|    3 |    9 |   16 |                                       -.5 |\n|    3 |   10 |   15 |                                        -1 |\n|    3 |   11 |   12 |                                    -2.375 |\n|    3 |   12 |   10 |                                        -4 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822876"], "Title": ["COVAR_SAMP"], "Feature": ["COVAR_SAMP(expr1, expr2) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值对的样本协方差。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果，即 COVAR_POP(expr1, expr2) 等于 COVAR_POP(expr2, expr1)。\n返回结果计算公式为：(SUM(expr1 * expr2) - SUM(expr1) * SUM(expr2) / n) / (n-1)，其中 n 是（expr1,expr2）表达式对的数量，expr1 和 expr2 均不为空。\n\n", "如果有任意一个参数为空或只有一行数据，则返回 NULL；否则返回一个 NUMBER 类型的值。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT COVAR_SAMP(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col3,col4,\n            COVAR_SAMP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_SAMP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_SAMP                                |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                      NULL |\n|    1 |   10 |   15 |                                         3 |\n|    1 |   11 |   16 |   3.1666666666666666666666666666666666665 |\n|    2 |    9 |   14 |                                      NULL |\n|    2 |   10 |   15 |                                        .5 |\n|    2 |    8 |   13 |                                         1 |\n|    2 |   11 |   16 |  1.66666666666666666666666666666666666667 |\n|    3 |    8 |   18 |                                      NULL |\n|    3 |    9 |   16 |                                        -1 |\n|    3 |   10 |   15 |                                      -1.5 |\n|    3 |   11 |   12 | -3.16666666666666666666666666666666666667 |\n|    3 |   12 |   10 |                                        -5 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822886"], "Title": ["CUME_DIST"], "Feature": ["/*聚合语法*/\nCUME_DIST( expr[,expr]...)\n  WITHIN GROUP (ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                       [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n          )\n\n/*分析语法*/\nCUME_DIST() OVER ([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数用于计算一组值中的某个值的累积分布，返回值的范围为 (0,1]。可以将此函数用作聚合或分析函数。", "\n说明\n\n作为分析函数，该函数计算指定值在一组值中的相对位置。对于行 row，假设按升序排列，row 的 cume_dist 是值低于或等于 row 值的行数除以被计算的行数（整个查询结果集或分区）。\n作为聚合函数，该函数的参数标识每个聚合组中的单个假设行。因此，它们必须全部计算为每个聚合组内的常量表达式。常量参数表达式和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的类型必须兼容。如果指定值与分组序列中某值重复，则将两个重复的值视为一个值处理。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 ASC 为升序排序，为默认值。 DESC 为降序排序。\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 NULLS FIRST 表示 NULL 值排在非空值的前面。 NULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值为 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT CUME_DIST(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+----------------------------------------+\n| CUME_DIST(3300)WITHINGROUP(ORDERBYSAL) |\n+----------------------------------------+\n|                                  .9375 |\n+----------------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename,sal,\n              CUME_DIST ( ) over (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | RANK                                      |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 | .3333333333333333333333333333333333333333 |\n|     10 | CLARK  | 2750 | .6666666666666666666666666666666666666667 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                        .4 |\n|     20 | SCOTT  | 3300 |                                        .4 |\n|     20 | JONES  | 3275 |                                        .6 |\n|     20 | ADAMS  | 1400 |                                        .8 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 | .1428571428571428571428571428571428571429 |\n|     30 | ALLEN  | 1900 | .2857142857142857142857142857142857142857 |\n|     30 | TURNER | 1800 | .4285714285714285714285714285714285714286 |\n|     30 | SCLARK | 1750 | .5714285714285714285714285714285714285714 |\n|     30 | MARTIN | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | WARD   | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822870"], "Title": ["DENSE_RANK"], "Feature": ["/*聚合语法*/\nDENSE_RANK(expr [, expr ...])\n  WITHIN GROUP ( ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                        [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n                )\n\n/*分析语法*/\nDENSE_RANK( ) OVER([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数功能是计算有序行组中行的秩。秩的值是从 1 开始的连续整数，最大的秩值是符合查询结果的数值。具有相同值的排序标准的行接收相同的秩，相同的行数不会被记录到下个排名中。可以将其用作聚合或分析函数。", "\n说明\n\n作为聚合函数，DENSE_RANK 根据指定的排序规范计算由函数的参数标识的假设行的密集等级。常量参数表达式 expr 和 order_by_clause 聚合中的表达式按位置匹配。因此，参数的数量必须相同并且类型必须兼容。\n作为一个分析函数，DENSE_RANK 根据 order_by_clause 中 value_exprs 的值，计算从查询返回的每一行相对于其他行的秩。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n对应列中数据类型的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值为 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT DENSE_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------------+\n| DENSE_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------------+\n|                                      12 |\n+-----------------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename, sal,\n              DENSE_RANK ( ) OVER (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n     FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    2 |\n|     20 | ADAMS  | 1400 |    3 |\n|     20 | SMITH  | 1100 |    4 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    6 |\n+--------+--------+------+------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822863"], "Title": ["APPROX_COUNT_DISTINCT"], "Feature": ["APPROX_COUNT_DISTINCT(expr)\n"], "Description": ["该函数对参数列去重后的行数进行计算，返回行数值，且该值是近似值，该函数可以用于进一步计算被引用的列的选择性。", "与函数 COUNT(DISTINCT x) 相比，APPROX_COUNT_DISTINCT 返回的是近似值，所以计算速度极快。在处理大量级的数据时 COUNT(DISTINCT x) 经常要花费很长的时间，使用 APPROX_COUNT_DISTINCT 牺牲了少量的精确度，却换来了计算效率的极大提升。", "expr 表示去重的数值列。", "返回 NUMBER 类型数据。"], "Examples": ["obclient> CREATE TABLE tbl1 (col1 INT,col2 INT,col3 varchar(10));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,10,'a'),(2,20,'b'),(3,30,'c'),\n    (4,40,'a'),(5,50,'c'),(1,10,'a'),(2,20,'b'),(3,30,'c'),(4,30,'a'),(5,40,'b');\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n", "obclient> SELECT APPROX_COUNT_DISTINCT(col2) FROM tbl1;\n+-----------------------------+\n| APPROX_COUNT_DISTINCT(COL2) |\n+-----------------------------+\n|                           5 |\n+-----------------------------+\n1 row in set\n", "obclient> SELECT col1,APPROX_COUNT_DISTINCT(col2) FROM tbl1 GROUP BY col1;\n+------+-----------------------------+\n| COL1 | APPROX_COUNT_DISTINCT(COL2) |\n+------+-----------------------------+\n|    1 |                           1 |\n|    2 |                           1 |\n|    3 |                           1 |\n|    4 |                           2 |\n|    5 |                           2 |\n+------+-----------------------------+\n5 rows in set\n", "obclient> SELECT col1,col3,APPROX_COUNT_DISTINCT(col2) FROM tbl1 GROUP BY col1,col3;\n+------+------+-----------------------------+\n| COL1 | COL3 | APPROX_COUNT_DISTINCT(COL2) |\n+------+------+-----------------------------+\n|    1 | a    |                           1 |\n|    2 | b    |                           1 |\n|    3 | c    |                           1 |\n|    4 | a    |                           2 |\n|    5 | b    |                           1 |\n|    5 | c    |                           1 |\n+------+------+-----------------------------+\n6 rows in set\n"], "Category": ["Aggregate Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822866"], "Title": ["GROUPING"], "Feature": ["GROUPING(expr)\n"], "Description": ["该函数将 GROUP BY 子句扩展（如 ROLLUP）生成的超聚集行中的 NULL 和常规行中的 NULL 区分开来。该函数把超聚集行中的 NULL 返回 1，常规行中的值返回 0。", "参数 expr 是 GROUP BY 子句中的一个表达式。", "返回 NUMBER 数据类型。"], "Examples": ["obclient> CREATE TABLE tbl1(col1 INT,col2 INT,col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,NULL,NULL),(2,NULL,5),(3,1,6),(4,1,9),\n            (5,1,NULL),(6,2,3),(7,2,NULL),(8,2,18),(9,2,9),\n            (10,3,10),(11,3,12),(12,3,NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | NULL | NULL |\n|    2 | NULL |    5 |\n|    3 |    1 |    6 |\n|    4 |    1 |    9 |\n|    5 |    1 | NULL |\n|    6 |    2 |    3 |\n|    7 |    2 | NULL |\n|    8 |    2 |   18 |\n|    9 |    2 |    9 |\n|   10 |    3 |   10 |\n|   11 |    3 |   12 |\n|   12 |    3 | NULL |\n+------+------+------+\n12 rows in set\n\nobclient> SELECT col2,col3,DECODE(GROUPING(col3),1,'汇总','正常记录'),COUNT(*)\n          FROM tbl1\n          GROUP BY ROLLUP(col2,col3);\n+------+------+--------------------------------------------------+----------+\n| COL2 | COL3 | DECODE(GROUPING(COL3),1,'汇总','正常记录')       | COUNT(*) |\n+------+------+--------------------------------------------------+----------+\n|    1 |    6 | 正常记录                                         |        1 |\n|    1 |    9 | 正常记录                                         |        1 |\n|    1 | NULL | 正常记录                                         |        1 |\n|    1 | NULL | 汇总                                             |        3 |\n|    2 |    3 | 正常记录                                         |        1 |\n|    2 |    9 | 正常记录                                         |        1 |\n|    2 |   18 | 正常记录                                         |        1 |\n|    2 | NULL | 正常记录                                         |        1 |\n|    2 | NULL | 汇总                                             |        4 |\n|    3 |   10 | 正常记录                                         |        1 |\n|    3 |   12 | 正常记录                                         |        1 |\n|    3 | NULL | 正常记录                                         |        1 |\n|    3 | NULL | 汇总                                             |        3 |\n| NULL |    5 | 正常记录                                         |        1 |\n| NULL | NULL | 正常记录                                         |        1 |\n| NULL | NULL | 汇总                                             |        2 |\n| NULL | NULL | 汇总                                             |       12 |\n+------+------+--------------------------------------------------+----------+\n17 rows in set\n"], "Category": ["Aggregate Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822880"], "Title": ["GROUPING_ID"], "Feature": ["GROUPING_ID(attributeList)\n"], "Description": ["GROUPING_ID 函数用于计算一组表达式的组合值，该函数返回一个数字，它代表了行所处的 GROUP BY 层级。", "GROUPING_ID 函数会创建一个位矢量，将 GROUPING 函数应用于每个属性时产生的 1 和 0 序列连接起来。这个位矢量作为一个二进制数处理，GROUPING_ID 函数随后返回其对应的十进制值。", "例如，使用 CUBE(a, b) 作为分组表达式时，可能的 GROUPING_ID 值如下所示：", "\n\n\n聚合层级\n位矢量\nGROUPING_ID\n\n\n\n\na, b\n00\n0\n\n\na\n01\n1\n\n\nb\n10\n2\n\n\n总计\n11\n3\n\n\n", "\n\n\n参数\n描述\n\n\n\n\nattributeList\n要计算其组合值的表达式列表。\n\n\n"], "Examples": [], "Category": ["Aggregate Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822889"], "Title": ["GROUP_ID"], "Feature": ["GROUP_ID()\n"], "Description": ["GROUP_ID 函数用于返回与 GROUP BY 子句中的重复组相关联的唯一标识符。它通常用在含有 ROLLUP 或 CUBE 操作的查询中，用于区分产生相同分组集的不同行。"], "Examples": ["-- 创建表 t1\nCREATE TABLE t1 (c1 INT, c2 INT, c3 INT, c4 INT);\n\n-- 向表 t1 插入数据\nINSERT INTO t1 VALUES (1, 1, 1, 1);\nINSERT INTO t1 VALUES (1, 1, 1, 2);\nINSERT INTO t1 VALUES (1, 1, 2, 2);\nINSERT INTO t1 VALUES (1, 2, 2, 2);\nINSERT INTO t1 VALUES (2, 2, 2, 2);\n\n-- 查询并汇总数据，使用 GROUP BY 与 ROLLUP\nSELECT c1, c2, c3, c4, GROUP_ID()\nFROM t1 GROUP BY c1, ROLLUP(c1, c2, c3, c4) ORDER BY c1, c2, c3, c4;\n", "+------+------+------+------+------------+\n| C1   | C2   | C3   | C4   | GROUP_ID() |\n+------+------+------+------+------------+\n|    1 |    1 |    1 |    1 |          0 |\n|    1 |    1 |    1 |    2 |          0 |\n|    1 |    1 |    1 | NULL |          0 |\n|    1 |    1 |    2 |    2 |          0 |\n|    1 |    1 |    2 | NULL |          0 |\n|    1 |    1 | NULL | NULL |          0 |\n|    1 |    2 |    2 |    2 |          0 |\n|    1 |    2 |    2 | NULL |          0 |\n|    1 |    2 | NULL | NULL |          0 |\n|    1 | NULL | NULL | NULL |          0 |\n|    1 | NULL | NULL | NULL |          1 |\n|    2 |    2 |    2 |    2 |          0 |\n|    2 |    2 |    2 | NULL |          0 |\n|    2 |    2 | NULL | NULL |          0 |\n|    2 | NULL | NULL | NULL |          0 |\n|    2 | NULL | NULL | NULL |          1 |\n+------+------+------+------+------------+\n16 rows in set\n"], "Category": ["Aggregate Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822883"], "Title": ["KEEP"], "Feature": ["aggregate_function KEEP ( DENSE_RANK { FIRST | LAST }\n                ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ]\n                      [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ]]...\n                        )\n[ OVER ( [query_partition_clause] ) ]\n\naggregate_function:\n  MIN\n |MAX\n |SUM\n |AVG\n |COUNT\n |VARIANCE\n |STDDEV\n"], "Description": ["该函数用于对一组行中的值进行操作，将这组行按照指定的排序规则排序后返回排在第一或最后的值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\naggregate_function\n指定聚合函数的种类。\n\n\nexpr\n可以是任何表达式。\n\n\nFIRST | LAST\n指定返回 expr 排序后那个位置的值。 \n      \nFIRST 表示返回排在首位的值。\nLAST 表示返回排在最后的值。\n\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与 aggregate_function 中指定的列相同的数据类型。"], "Examples": ["obclient> CREATE TABLE employees (department_id INT,manager_id INT,last_name varchar(50),hiredate varchar(50),SALARY INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO employees VALUES\n    (30, 100, 'Raphaely', '2017-07-01', 1700),\n    (30, 100, 'De Haan', '2018-05-01',11000),\n    (40, 100, 'Errazuriz', '2017-07-21', 1400),\n    (50, 100, 'Hartstein', '2019-10-05',14000),\n    (50, 100, 'Raphaely', '2017-07-22', 1700),\n    (50, 100, 'Weiss',  '2019-10-05',13500),\n    (90, 100, 'Russell', '2019-07-11', 13000),\n    (90,100, 'Partners',  '2018-12-01',14000);\nQuery OK, 8 rows affected\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE) \"Best\"\n    FROM employees;\n+-------+-------+\n| Worst | Best  |\n+-------+-------+\n|  1400 | 27500 |\n+-------+-------+\n1 row in set\n", "obclient> SELECT last_name,department_id,salary,\n    SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary)\n        OVER (PARTITION BY department_id) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE)\n        OVER (PARTITION BY department_id) \"Best\"\n    FROM employees\n    ORDER BY department_id, salary, last_name;\n+-----------+---------------+--------+-------+-------+\n| LAST_NAME | DEPARTMENT_ID | SALARY | Worst | Best  |\n+-----------+---------------+--------+-------+-------+\n| Raphaely  |            30 |   1700 |  1700 | 11000 |\n| De Haan   |            30 |  11000 |  1700 | 11000 |\n| Errazuriz |            40 |   1400 |  1400 |  1400 |\n| Raphaely  |            50 |   1700 |  1700 | 27500 |\n| Weiss     |            50 |  13500 |  1700 | 27500 |\n| Hartstein |            50 |  14000 |  1700 | 27500 |\n| Russell   |            90 |  13000 | 13000 | 13000 |\n| Partners  |            90 |  14000 | 13000 | 13000 |\n+-----------+---------------+--------+-------+-------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822868"], "Title": ["LISTAGG"], "Feature": ["LISTAGG (measure_expr [,'delimiter']) [ WITHIN GROUP ] (order_by_clause)\n[ OVER query_partition_clause ]\n"], "Description": ["该函数用于列转行，LISTAGG 对 ORDER BY 子句中指定的每个组内的数据进行排序，然后合并度量列的值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，不需要加 OVER 关键字。 \n     \n作为单个集合的聚合函数，LISTAGG 对所有行进行操作并返回单个输出行。\n作为组集聚合，LISTAGG 将对 GROUP BY 子句定义的每个组进行操作并返回输出行。\n\n\n", "\n\n\n参数\n说明\n\n\n\n\nmeasure_expr\n可以是任何表达式。度量列中的空值将被忽略。\n\n\ndelimiter\n指定用于分隔度量值的字符串。此子句是可选的，默认为 NULL。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "如果度量列是 RAW 的，则返回数据类型为 RAW，否则返回值为 VARCHAR2。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) as \"Emp_list\",\n              MIN(hiredate) as \"Earliest\"\n       FROM employees\n       WHERE department_id = 30;\n+-------------------+------------+\n| Emp_list          | Earliest   |\n+-------------------+------------+\n| Raphaely; De Haan | 2017-07-01 |\n+-------------------+------------+\n1 row in set\n", "obclient> SELECT department_id \"Dept\",hiredate \"Date\",last_name \"Name\",\n              LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n      FROM employees\n      WHERE hiredate < '2019-10-10'\n      ORDER BY \"Dept\", \"Date\", \"Name\";\n+------+------------+-----------+----------------------------+\n| Dept | Date       | Name      | Emp_list                   |\n+------+------------+-----------+----------------------------+\n|   30 | 2017-07-01 | Raphaely  | Raphaely; De Haan          |\n|   30 | 2018-05-01 | De Haan   | Raphaely; De Haan          |\n|   40 | 2017-07-21 | Errazuriz | Errazuriz                  |\n|   50 | 2017-07-22 | Raphaely  | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Hartstein | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Weiss     | Raphaely; Hartstein; Weiss |\n|   90 | 2018-12-01 | Partners  | Partners; Russell          |\n|   90 | 2019-07-11 | Russell   | Partners; Russell          |\n+------+------------+-----------+----------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822873"], "Title": ["MAX"], "Feature": ["MAX ([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回参数中指定的列中的最大值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：返回的行中去除重复行，且忽略值为 NULL 的行。\nUNIQUE：返回的行中去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n可为数值、字符、日期型或其它类型的数据列或表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与 expr 相同的数据类型值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT MAX(salary) FROM employees;\n+-------------+\n| MAX(SALARY) |\n+-------------+\n|       14000 |\n+-------------+\n1 row in set\n", "obclient> SELECT department_id,last_name,salary,\n                 MAX(salary) OVER (PARTITION BY department_id) AS rmax_sal\n          FROM employees;\n+---------------+-----------+--------+----------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | RMAX_SAL |\n+---------------+-----------+--------+----------+\n|            30 | Raphaely  |   1700 |    11000 |\n|            30 | De Haan   |  11000 |    11000 |\n|            40 | Errazuriz |   1400 |     1400 |\n|            50 | Hartstein |  14000 |    14000 |\n|            50 | Raphaely  |   1700 |    14000 |\n|            50 | Weiss     |  13500 |    14000 |\n|            90 | Russell   |  13000 |    14000 |\n|            90 | Partners  |  14000 |    14000 |\n+---------------+-----------+--------+----------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822881"], "Title": ["MEDIAN"], "Feature": ["MEDIAN(expr) [ OVER (query_partition_clause) ]\n"], "Description": ["该函数用于返回一组数值的中值，即将一组数值排序后返回居于中间的数值。如果参数集合中包含偶数个数值，该函数将返回位于中间的两个数的平均值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要求中值的数组名称，参数类型属于数值数据类型或可以隐式转换为数字数据类型。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "如果仅指定 expr，则该函数返回与参数的数值数据类型相同的数据类型。", "如果指定 OVER 子句，则数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。"], "Examples": ["obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT MEDIAN(col4) FROM tbl1;\n+--------------+\n| MEDIAN(COL4) |\n+--------------+\n|           15 |\n+--------------+\n1 row in set\n", "obclient> SELECT col1,col4,MEDIAN(col4) OVER(PARTITION BY col1) \"MEDIAN\"\n FROM tbl1;\n+------+------+--------+\n| COL1 | COL4 | MEDIAN |\n+------+------+--------+\n|    1 |   12 |     15 |\n|    1 |   15 |     15 |\n|    1 |   16 |     15 |\n|    2 |   14 |   14.5 |\n|    2 |   15 |   14.5 |\n|    2 |   13 |   14.5 |\n|    2 |   16 |   14.5 |\n|    3 |   18 |     15 |\n|    3 |   16 |     15 |\n|    3 |   15 |     15 |\n|    3 |   12 |     15 |\n|    3 |   10 |     15 |\n+------+------+--------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822874"], "Title": ["MIN"], "Feature": ["MIN([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回参数中指定列的最小值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重，为可选项。默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：返回的行中去除重复行，且忽略值为 NULL 的行。\nUNIQUE：返回的行中去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n可为数值、字符、日期型或其它数据类型的列或表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与 expr 相同数据类型的值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT MIN(salary)  FROM employees;\n+-------------+\n| MIN(SALARY) |\n+-------------+\n|        1400 |\n+-------------+\n1 row in set\n", "obclient> SELECT department_id,last_name,hiredate,salary,\n                 MIN(salary) OVER(PARTITION BY department_id) AS p_cmin\n          FROM employees;\n+---------------+-----------+------------+--------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | P_CMIN |\n+---------------+-----------+------------+--------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |   1700 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |   1700 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |   1700 |\n|            90 | Russell   | 2019-07-11 |  13000 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |  13000 |\n+---------------+-----------+------------+--------+--------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822888"], "Title": ["PERCENTILE_CONT"], "Feature": ["PERCENTILE_CONT(percentile) WITHIN GROUP (ORDER BY expr [ DESC | ASC ])\n[ OVER (query_partition_clause) ]\n"], "Description": ["该函数是一个假定连续分布模型的逆分布函数。根据指定百分比值和排序规范，返回一个在该排序规范的给定百分比值的内插值。在计算中忽略空值。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\npercentile\n指定百分位的值，是一个数值数据类型的常量，取值范围为 [0,1]。 说明 MEDIAN 函数相当于是 percentile 为 0.5 的特殊情况。\n\n\nexpr\n指定排序规范的表达式，数据类型属于数值类型或日期时间类型。 注意 expr 必须为涉及列引用的单个表达式，不允许使用多个表达式。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n该函数在根据排序规范对行进行排序后，通过指定百分比值 (P) 和非空行数 (N) 计算行号，行号计算公式为 RN = (1+ (P*(N-1))。该函数的最终结果通过行号 CRN = CEILING(RN) 和 FRN = FLOOR(RN) 的行中的值之间的线性内插计算。最终结果将如下：\n", "如果 (CRN = FRN = RN)，则结果为 (value of expression from row at RN)；否则，结果为：", "(CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN)。", "返回与参数 expr 相同的数据类型。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT PERCENTILE_CONT(0.1) WITHIN GROUP (ORDER BY col4) FROM tbl1;\n+----------------------------------------------+\n| PERCENTILE_CONT(0.1)WITHINGROUP(ORDERBYCOL4) |\n+----------------------------------------------+\n|                                           12 |\n+----------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col4,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY col4) OVER (PARTITION BY col1)\n          FROM tbl1;\n+------+------+-------------------------------------------------------------------+\n| COL1 | COL4 | PERCENTILE_CONT(0.5)WITHINGROUP(ORDERBYCOL4)OVER(PARTITIONBYCOL1) |\n+------+------+-------------------------------------------------------------------+\n|    1 |   12 |                                                                15 |\n|    1 |   15 |                                                                15 |\n|    1 |   16 |                                                                15 |\n|    2 |   14 |                                                              14.5 |\n|    2 |   15 |                                                              14.5 |\n|    2 |   13 |                                                              14.5 |\n|    2 |   16 |                                                              14.5 |\n|    3 |   18 |                                                                15 |\n|    3 |   16 |                                                                15 |\n|    3 |   15 |                                                                15 |\n|    3 |   12 |                                                                15 |\n|    3 |   10 |                                                                15 |\n+------+------+-------------------------------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822890"], "Title": ["PERCENTILE_DISC"], "Feature": ["PERCENTILE_DISC(expr1) WITHIN GROUP (ORDER BY expr2 [ DESC | ASC ])\n[ OVER (query_partition_clause) ]\n"], "Description": ["该函数根据一个百分位值和指定排序规范，返回大于或等于百分位值的最小累积分布值（相对于同一排序规范）的值。在计算中忽略空值。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定百分位的值，是一个数值数据类型的常量，取值范围为 [0,1]。\n\n\nexpr2\n指定用于排序和计算百分比的表达式，数据类型属于数值类型或日期时间类型。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与参数 expr2 相同的数据类型。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) \"PERCENTILE_DISC\" FROM tbl1;\n+-----------------+\n| PERCENTILE_DISC |\n+-----------------+\n|              15 |\n+-----------------+\n1 row in set\n", "obclient> SELECT col1,col4,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) OVER(PARTITION BY col1) \"PERCENTILE_DISC\"\n          FROM tbl1;\n+------+------+-----------------+\n| COL1 | COL4 | PERCENTILE_DISC |\n+------+------+-----------------+\n|    1 |   12 |              15 |\n|    1 |   15 |              15 |\n|    1 |   16 |              15 |\n|    2 |   14 |              14 |\n|    2 |   15 |              14 |\n|    2 |   13 |              14 |\n|    2 |   16 |              14 |\n|    3 |   18 |              15 |\n|    3 |   16 |              15 |\n|    3 |   15 |              15 |\n|    3 |   12 |              15 |\n|    3 |   10 |              15 |\n+------+------+-----------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822882"], "Title": ["PERCENT_RANK"], "Feature": ["/*聚合语法*/\nPERCENT_RANK(expr [, expr ...]) WITHIN GROUP\n               ( ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                          [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n               )\n\n/*分析语法*/\nPERCENT_RANK( ) OVER ([query_partition_clause] order_by_clause)\n"], "Description": ["该函数用来计算一组值中的某个值的累积分布。类似于 CUME_DIST 函数。可以将此函数用作聚合或分析函数。", "\n说明\n\n作为聚合函数，PERCENT_RANK 计算某一个数在一个集合中的对应位置百分比，它的返回值范围为 (0, 1]。如果有 N 行数据，expr 的值，大于第二行的值而小于第三行的值，那么位置百分比等于 2/N。常量参数表达式和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的类型必须兼容。如果指定值与分组序列中某值重复，则将两个相同的值视为一个值处理。\n作为分析函数，PERCENT_RANK 计算某列或某列组合后每行的百分比排序，它的返回值范围为 [0, 1]。当有相同排序值时，将会有相同的排名，并且值相同的行数会被记录到下个排名中。任何集合中的第一行的 PERCENT_RANK 函数为 0，位置百分比的计算公式为：位置百分比=序号/最大序号，具体示例请参见如下表格：\n\n", "\n\n\nN\n序号\n位置百分比\n\n\n\n\nA\n0\n0\n\n\nB\n1\n0.25\n\n\nC\n2\n0.5\n\n\nD\n3\n0.75\n\n\nE\n4\n1\n\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT PERCENT_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-------------------------------------------+\n| PERCENT_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-------------------------------------------+\n|                                        .8 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename,sal,\n              PERCENT_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) AS pr1\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | PR1                                       |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 |                                         0 |\n|     10 | CLARK  | 2750 |                                        .5 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                         0 |\n|     20 | SCOTT  | 3300 |                                         0 |\n|     20 | JONES  | 3275 |                                        .5 |\n|     20 | ADAMS  | 1400 |                                       .75 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 |                                         0 |\n|     30 | ALLEN  | 1900 | .1666666666666666666666666666666666666667 |\n|     30 | TURNER | 1800 | .3333333333333333333333333333333333333333 |\n|     30 | SCLARK | 1750 |                                        .5 |\n|     30 | MARTIN | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | WARD   | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822875"], "Title": ["AVG"], "Feature": ["AVG([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数将数值类型或者可以转换成数值类型的表达式作为参数求平均值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：查询时不去除数据中的重复值，且忽略数据中的 NULL 值。\nDISTINCT：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\nUNIQUE：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\n\n\n\nexpr\n指定要计算的列名。列的数据类型是数值类型或者可以转换成数值类型的表达式。数值类型可以为 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n", "返回值与参数 expr 的数据类型相同。"], "Examples": ["obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,'a',5),(1,'b',10),(1,'c',15),\n    (2,'d',20),(2,'e',18),(2,'f',12),(3,'a',10),\n    (3,'b',15),(4,'c',15),(4,'a',8);\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | a    |    5 |\n|    1 | b    |   10 |\n|    1 | c    |   15 |\n|    2 | d    |   20 |\n|    2 | e    |   18 |\n|    2 | f    |   12 |\n|    3 | a    |   10 |\n|    3 | b    |   15 |\n|    4 | c    |   15 |\n|    4 | a    |    8 |\n+------+------+------+\n10 rows in set\n", "obclient> SELECT AVG(col3) FROM tbl1;\n+-----------+\n| AVG(COL3) |\n+-----------+\n|      12.8 |\n+-----------+\n1 row in set\n", "obclient> SELECT col1,col2,col3, AVG(col3)\n              OVER (PARTITION BY col1 ORDER BY col2 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS over_col2\n          FROM tbl1\n          ORDER BY col1,col2,col3;\n+------+------+------+-------------------------------------------+\n| COL1 | COL2 | COL3 | OVER_COL2                                 |\n+------+------+------+-------------------------------------------+\n|    1 | a    |    5 |                                       7.5 |\n|    1 | b    |   10 |                                        10 |\n|    1 | c    |   15 |                                      12.5 |\n|    2 | d    |   20 |                                        19 |\n|    2 | e    |   18 | 16.66666666666666666666666666666666666667 |\n|    2 | f    |   12 |                                        15 |\n|    3 | a    |   10 |                                      12.5 |\n|    3 | b    |   15 |                                      12.5 |\n|    4 | a    |    8 |                                      11.5 |\n|    4 | c    |   15 |                                      11.5 |\n+------+------+------+-------------------------------------------+\n10 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
