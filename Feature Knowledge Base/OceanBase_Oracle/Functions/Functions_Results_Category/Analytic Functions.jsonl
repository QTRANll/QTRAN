{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822872"], "Title": ["RANK"], "Feature": ["/*聚合语法*/\nRANK(expr [, expr ]...) WITHIN GROUP\n  ( ORDER BY\n            expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n            [, expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n  )\n\n/*分析语法*/\nRANK() OVER ([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数用于计算一个值在一组值的排名。当有相同排序值时，将会有相同的排名，并且值相同的行数会被记录到下个排名中。可以将此函数用作聚合或分析函数。", "\n说明\n\n作为聚合函数，RANK 计算由参数 expr 标识的假设行相对于指定排序规范的排名。参数表达式 expr 和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的数据类型必须兼容。\n作为一个解析函数，RANK 计算从查询相对于由查询返回的其他行返回的每一行的秩，基于所述值 value_exprs 中 order_by_clause。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------+\n| RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------+\n|                                13 |\n+-----------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename,sal,\n                   RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    3 |\n|     20 | ADAMS  | 1400 |    4 |\n|     20 | SMITH  | 1100 |    5 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    7 |\n+--------+--------+------+------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822845"], "Title": ["RATIO_TO_REPORT"], "Feature": ["RATIO_TO_REPORT(expr) OVER ([query_partition_clause])\n"], "Description": ["该函数是一个分析函数，功能是计算一个值与一组值之和的比率。", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定需要查询的字段。 注意 不能使用 RATIO_TO_REPORT 函数或其他分析函数来嵌套 expr。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "如果 expr 为 NULL，则返回结果为 NULL。否则返回结果为数值类型数据。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,mgr,RATIO_TO_REPORT(mgr) OVER (PARTITION BY deptno)\n      FROM emp_msg;\n+--------+--------+------+---------------------------------------------+\n| DEPTNO | ENAME  | MGR  | RATIO_TO_REPORT(MGR)OVER(PARTITIONBYDEPTNO) |\n+--------+--------+------+---------------------------------------------+\n|     10 | CLARK  | 7839 |   .5018244670635682734780103706548876512387 |\n|     10 | KING   | NULL |                                        NULL |\n|     10 | MILLER | 7782 |   .4981755329364317265219896293451123487613 |\n|     20 | ADAMS  | 7788 |   .2014433149685729805230076821603165981221 |\n|     20 | FORD   | 7566 |   .1957010941258632730658803445332505625824 |\n|     20 | JONES  | 7839 |   .2027624738108171025064018002638317684488 |\n|     20 | SCOTT  | 7566 |   .1957010941258632730658803445332505625824 |\n|     20 | SMITH  | 7902 |   .2043920229688833708388298285093505082641 |\n|     30 | ALLEN  | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | BLAKE  | 7839 |   .1447164377492246344705361098803721754541 |\n|     30 | JAMES  | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | MARTIN | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | TURNER | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | WARD   | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | SCLARK | 7839 |   .1447164377492246344705361098803721754541 |\n+--------+--------+------+---------------------------------------------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822871"], "Title": ["REGR_ (Linear Regression)"], "Feature": ["{ REGR_SLOPE\n | REGR_INTERCEPT\n | REGR_COUNT\n | REGR_R2\n | REGR_AVGX\n | REGR_AVGY\n | REGR_SXX\n | REGR_SYY\n | REGR_SXY\n}(expr1 , expr2)\n  [ OVER (analytic_clause) ]\n"], "Description": ["该函数是线性回归函数，将普通最小二乘法回归线拟合到一组数字对上。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nREGR_SLOPE\n返回直线的坡度（斜率）。返回值是数值数据类型，可以为 NULL。 忽略空数值对（expr1,expr2）后，它进行以下计算： sql COVAR_POP(expr1, expr2) / VAR_POP(expr2)\n\n\nREGR_INTERCEPT\n返回回归线的 y 截距。返回值是数值数据类型，可以为 NULL。忽略空数值对（expr1,expr2）后，它进行以下计算： sql AVG(expr1) - REGR_SLOPE(expr1, expr2) * AVG(expr2)\n\n\nREGR_COUNT\n返回用于填充回归线的非空数值对的数目，是一个整数。\n\n\nREGR_R2\n返回回归的确定系数（也称为 R 平方或拟合优度）。返回值是数值数据类型，可以为 NULL。忽略 VAR_POP(expr1) 和 VAR_POP(expr2) 的空值后进行评估。返回值为： sql NULL if VAR_POP(expr2) = 0 1 if VAR_POP(expr1) = 0 and VAR_POP(expr2) != 0 POWER(CORR(expr1,expr),2) if VAR_POP(expr1) > 0 and VAR_POP(expr2 != 0\n\n\nREGR_AVGX\n返回回归线的自变量（expr2）的平均值。忽略空数值对（expr1,expr2）后，进行以下计算： sql AVG(expr2)\n\n\nREGR_AVGY\n返回回归线的因变量（expr1）的平均值。忽略空数值对（expr1,expr2）后，进行以下计算： sql AVG(expr1)\n\n\nREGR_SXX\n返回值等于在忽略空数值对（expr1,expr2）后数值对的个数乘以自变量的值的总体方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * VAR_POP(expr2)\n\n\nREGR_SYY\n返回值等于在忽略空数值对（expr1,expr2）后数值对的个数乘以因变量的值的总体方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * VAR_POP(expr1)\n\n\nREGR_SXY\n返回值等于在忽略空数值对（expr1,expr2）后的数值对的个数乘以总体协方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2)\n\n\nexpr1\n指定因变量的值（y 值）。\n\n\nexpr2\n指定自变量的值（x 值）。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\nREGR_SXX 、REGR_SYY 和 REGR_SXY 是用于计算各种诊断统计数据的辅助函数。\n", "返回值是数值数据类型或 NULL。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n", "obclient> SELECT col1,REGR_SXX(col3,col4) \"REGR_SXX\",\n            REGR_SYY(col3,col4) \"REGR_SYY\",\n            REGR_SXY(col3,col4) \"REGR_SXY\"\n          FROM tbl1\n          GROUP BY col1;\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n| COL1 | REGR_SXX                               | REGR_SYY                                 | REGR_SXY                               |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n|    1 | 8.666666666666666666666666666666666667 | 4.66666666666666666666666666666666666701 | 6.333333333333333333333333333333333333 |\n|    2 |                                      5 |                                        5 |                                      5 |\n|    3 |                                   40.8 |                                       10 |                                    -20 |\n|    4 |                                      0 |                                        0 |                                      0 |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n4 rows in set\n", "obclient> SELECT col1,col2,col3,col4,\n            REGR_SLOPE(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"REGR_SLOPE\"\n          FROM tbl1;\n+------+------+------+------+--------------------------------------------+\n| COL1 | COL2 | COL3 | COL4 | REGR_SLOPE                                 |\n+------+------+------+------+--------------------------------------------+\n|    1 | A1   |    8 |   12 |                                       NULL |\n|    1 | A2   |   10 |   15 |  .6666666666666666666666666666666666666667 |\n|    1 | A3   |   11 |   16 |  .7307692307692307692307692307692307691642 |\n|    2 | B1   |    9 |   14 |                                       NULL |\n|    2 | B2   |   10 |   15 |                                          1 |\n|    2 | B3   |    8 |   13 |                                          1 |\n|    2 | B4   |   11 |   16 |                                          1 |\n|    3 | C1   |    8 |   18 |                                       NULL |\n|    3 | C2   |    9 |   16 |                                        -.5 |\n|    3 | C3   |   10 |   15 | -.6428571428571428571428571428571428570956 |\n|    3 | C4   |   11 |   12 | -.5066666666666666666666666666666666666667 |\n|    3 | C5   |   12 |   10 | -.4901960784313725490196078431372549019608 |\n|    4 | d1   |    8 | NULL |                                       NULL |\n|    4 | d1   |    9 |   10 |                                       NULL |\n|    4 | d1   |   10 | NULL |                                       NULL |\n+------+------+------+------+--------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822842"], "Title": ["ROW_NUMBER"], "Feature": ["ROW_NUMBER( ) OVER ([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数是一个分析函数，作用是为每一条行（分组）记录返回一个唯一的序号，该序号按照 order_by_clause 中指定列进行的排序，从 1 开始。当遇到相同的数据时，排名按照记录集中记录的顺序依次递增，对于不同数据进行依次排名。", "使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。", "返回数值类型数据。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,\n                 ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC)\n          FROM emp_msg;\n+--------+--------+------+---------------------------------------------------+\n| DEPTNO | ENAME  | SAL  | ROW_NUMBER()OVER(PARTITIONBYDEPTNOORDERBYSALDESC) |\n+--------+--------+------+---------------------------------------------------+\n|     10 | KING   | 5300 |                                                 1 |\n|     10 | CLARK  | 2750 |                                                 2 |\n|     10 | MILLER | 1600 |                                                 3 |\n|     20 | FORD   | 3300 |                                                 1 |\n|     20 | SCOTT  | 3300 |                                                 2 |\n|     20 | JONES  | 3275 |                                                 3 |\n|     20 | ADAMS  | 1400 |                                                 4 |\n|     20 | SMITH  | 1100 |                                                 5 |\n|     30 | BLAKE  | 3150 |                                                 1 |\n|     30 | ALLEN  | 1900 |                                                 2 |\n|     30 | TURNER | 1800 |                                                 3 |\n|     30 | SCLARK | 1750 |                                                 4 |\n|     30 | MARTIN | 1550 |                                                 5 |\n|     30 | WARD   | 1550 |                                                 6 |\n|     30 | JAMES  | 1250 |                                                 7 |\n+--------+--------+------+---------------------------------------------------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822891"], "Title": ["STDDEV"], "Feature": ["STDDEV([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值型数据标准差。它与函数 STDDEV_SAMP 的不同之处在于，STDDEV 只有一行输入数据时返回 0，而 STDDEV_SAMP 返回 NULL。OceanBase 数据库中标准差的值是函数 VARIANCE 计算出的方差的算术平方根。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：全部数值列。\nDISTINCT：去重关键字，表示计算唯一值的总体标准差。\nUNIQUE：去重关键字，表示计算唯一值的总体标准差。\n\n\n\nexpr\n数值类型或者可以转换成数值类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n", "返回 NUMBER 类型的数据。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT STDDEV(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV(SALARY)                            |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT last_name,hiredate,salary,STDDEV(salary) OVER (ORDER BY hiredate) \"StdDev\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | StdDev                                    |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |  212.132034355964257320253308631454711785 |\n| Raphaely  | 2017-07-22 |   1700 |  173.205080756887729352744634150587236694 |\n| De Haan   | 2018-05-01 |  11000 | 4702.127178203498995615489088200868644482 |\n| Partners  | 2018-12-01 |  14000 | 6064.899009876421676804205219406952308814 |\n| Russell   | 2019-07-11 |  13000 |  6138.94670661561181357873224397795992899 |\n| Hartstein | 2019-10-05 |  14000 | 6026.474330580265330900400184969999384459 |\n| Weiss     | 2019-10-05 |  13500 | 6026.474330580265330900400184969999384459 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822862"], "Title": ["STDDEV_POP"], "Feature": ["STDDEV_POP( [ALL] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数将数值型数据作为参数计算总体标准差。总体标准差是总体方差的算术平方根。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nALL\n指定全部数值列，为可选项。默认值为 ALL。\n\n\nexpr\n数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或者可以转换成数值类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回类型与参数 expr 的数据类型相同。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT STDDEV_POP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_POP(SALARY)                        |\n+-------------------------------------------+\n| 5637.250548804798333699350384281939588505 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT department_id,last_name,salary,STDDEV_POP(salary) OVER (PARTITION BY department_id) AS pop_std\n          FROM employees\n          ORDER BY department_id,last_name,salary;\n+---------------+-----------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | POP_STD                                   |\n+---------------+-----------+--------+-------------------------------------------+\n|            30 | De Haan   |  11000 |                                      4650 |\n|            30 | Raphaely  |   1700 |                                      4650 |\n|            40 | Errazuriz |   1400 |                                         0 |\n|            50 | Hartstein |  14000 | 5684.090858606052304285807872404592677763 |\n|            50 | Raphaely  |   1700 | 5684.090858606052304285807872404592677763 |\n|            50 | Weiss     |  13500 | 5684.090858606052304285807872404592677763 |\n|            90 | Partners  |  14000 |                                       500 |\n|            90 | Russell   |  13000 |                                       500 |\n+---------------+-----------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822869"], "Title": ["STDDEV_SAMP"], "Feature": ["STDDEV_SAMP([ALL] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数将数值型数据作为参数计算样本标准差，样本标准差是样本方差的算术平方根。STDDEV_SAMP 与函数 STDDEV 的不同之处在于，STDDEV 只有一行输入数据时返回 0，而 STDDEV_SAMP 返回 NULL。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nALL\n全部数值列。为可选项，默认值 ALL。\n\n\nexpr\n数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或者可以转换成数值类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回类型与参数 expr 的数据类型相同。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT STDDEV_SAMP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_SAMP(SALARY)                       |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT department_id, last_name, hiredate, salary,\n                 STDDEV_SAMP(salary) OVER (PARTITION BY department_id\n                  ORDER BY hiredate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s_samp\n          FROM employees;\n+---------------+-----------+------------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | S_SAMP                                    |\n+---------------+-----------+------------+--------+-------------------------------------------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |                                      NULL |\n|            30 | De Haan   | 2018-05-01 |  11000 | 6576.093065034891976927852567575096065349 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |                                      NULL |\n|            50 | Raphaely  | 2017-07-22 |   1700 |                                      NULL |\n|            50 | Hartstein | 2019-10-05 |  14000 | 8697.413408594534550130385653889643183203 |\n|            50 | Weiss     | 2019-10-05 |  13500 | 6961.561127601576503543602300090640831831 |\n|            90 | Partners  | 2018-12-01 |  14000 |                                      NULL |\n|            90 | Russell   | 2019-07-11 |  13000 |  707.106781186547524400844362104849039285 |\n+---------------+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822877"], "Title": ["SUM"], "Feature": ["SUM([ DISTINCT | UNQIUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回指定参数的总和。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNQIUE | ALL\n计算时是否去重。为可选项，默认值 ALL。 \n      \nALL：计算所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：去除重复行，且忽略值为 NULL 的行。\nUNIQUE：去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n数值数据类型或任何可以隐式转换为数值数据类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause 参数。\n", "返回与 expr 相同数据类型的值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n", "obclient> SELECT department_id, last_name, salary,\n              SUM(salary) OVER\n                  (PARTITION BY department_id ORDER BY salary RANGE UNBOUNDED PRECEDING) s_sum\n    FROM employees\n    ORDER BY department_id,s_sum;\n+---------------+-----------+--------+-------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | S_SUM |\n+---------------+-----------+--------+-------+\n|            30 | Raphaely  |   1700 |  1700 |\n|            30 | De Haan   |  11000 | 12700 |\n|            40 | Errazuriz |   1400 |  1400 |\n|            50 | Raphaely  |   1700 |  1700 |\n|            50 | Weiss     |  13500 | 15200 |\n|            50 | Hartstein |  14000 | 29200 |\n|            90 | Russell   |  13000 | 13000 |\n|            90 | Partners  |  14000 | 27000 |\n+---------------+-----------+--------+-------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822879"], "Title": ["VARIANCE"], "Feature": ["VARIANCE([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数功能是返回指定列的方差。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：查询时不去除数据中的重复值，且忽略数据中的 NULL 值。\nDISTINCT：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\nUNIQUE：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\n\n\n\nexpr\n数值数据类型或任何可以隐式转换为数值数据类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n", "返回与参数 expr 相同的数据类型。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n", "obclient> SELECT last_name,hiredate,salary,VARIANCE(salary) OVER (ORDER BY hiredate) \"Variance\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | Variance                                  |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |                                     45000 |\n| Raphaely  | 2017-07-22 |   1700 |                                     30000 |\n| De Haan   | 2018-05-01 |  11000 |                                  22110000 |\n| Partners  | 2018-12-01 |  14000 |                                  36783000 |\n| Russell   | 2019-07-11 |  13000 |  37686666.6666666666666666666666666666666 |\n| Hartstein | 2019-10-05 |  14000 | 36318392.85714285714285714285714285714286 |\n| Weiss     | 2019-10-05 |  13500 | 36318392.85714285714285714285714285714286 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822885"], "Title": ["VAR_POP"], "Feature": ["VAR_POP(expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回一组数值集合的总体方差（忽略 NULL）。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定参与计算的数值表达式。属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n如果该函数应用于空集，则返回 NULL。返回结果计算公式为：SUM((expr - (SUM(expr) / COUNT(expr)))²)/ COUNT(expr)。\n", "返回与参数 expr 相同的数据类型或 NULL。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n", "obclient> SELECT VAR_POP(col4) FROM tbl1;\n+------------------------------------------+\n| VAR_POP(COL4)                            |\n+------------------------------------------+\n| 5.53846153846153846153846153846153846154 |\n+------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col2,col4,VAR_POP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                        0 |\n|    1 | A2   |   15 |                                     2.25 |\n|    1 | A3   |   16 |   2.888888888888888888888888888888888889 |\n|    2 | B1   |   14 |                                   2.1875 |\n|    2 | B2   |   15 |                                     1.84 |\n|    2 | B3   |   13 |  1.8055555555555555555555555555555555555 |\n|    2 | B4   |   16 | 1.95918367346938775510204081632653061229 |\n|    3 | C1   |   18 |                                 3.109375 |\n|    3 | C2   |   16 | 2.88888888888888888888888888888888888889 |\n|    3 | C3   |   15 |                                      2.6 |\n|    3 | C4   |   12 | 3.10743801652892561983471074380165289255 |\n|    3 | C5   |   10 | 4.55555555555555555555555555555555555558 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n|    4 | d1   |   10 | 5.53846153846153846153846153846153846154 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822867"], "Title": ["VAR_SAMP"], "Feature": ["VAR_SAMP(expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回一组数值集合的样本方差（忽略 NULL）。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定参与计算的数值表达式。属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n如果该函数应用于空集，则返回 NULL。返回结果计算公式为：(SUM(expr - (SUM(expr) / COUNT(expr)))²) /(COUNT(expr) - 1)。\n", "返回与参数 expr 相同的数据类型或 NULL。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n", "obclient> SELECT VAR_SAMP(col4) FROM tbl1;\n+----------------+\n| VAR_SAMP(COL4) |\n+----------------+\n|              6 |\n+----------------+\n1 row in set\n", "obclient> SELECT col1,col2,col4,VAR_SAMP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                     NULL |\n|    1 | A2   |   15 |                                      4.5 |\n|    1 | A3   |   16 |  4.3333333333333333333333333333333333335 |\n|    2 | B1   |   14 | 2.91666666666666666666666666666666666667 |\n|    2 | B2   |   15 |                                      2.3 |\n|    2 | B3   |   13 |  2.1666666666666666666666666666666666666 |\n|    2 | B4   |   16 | 2.28571428571428571428571428571428571433 |\n|    3 | C1   |   18 | 3.55357142857142857142857142857142857143 |\n|    3 | C2   |   16 |                                     3.25 |\n|    3 | C3   |   15 | 2.88888888888888888888888888888888888889 |\n|    3 | C4   |   12 |  3.4181818181818181818181818181818181818 |\n|    3 | C5   |   10 |   4.969696969696969696969696969696969697 |\n|    4 | d1   | NULL |                                        6 |\n|    4 | d1   |   10 |                                        6 |\n|    4 | d1   | NULL |                                        6 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822884"], "Title": ["WMSYS.WM_CONCAT/WM_CONCAT"], "Feature": ["WM_CONCAT ([DISTINCT] measure_expr) [OVER query_partition_clause]\n"], "Description": ["该函数用于列转行，将度量列的值进行合并。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，不需要加 OVER 关键字。 \n     \n作为单个集合的聚合函数，WM_CONCAT 对所有行进行操作并返回单个输出行。\n作为组集聚合，WM_CONCAT 将对 GROUP BY 子句定义的每个组进行操作并返回输出行。\n\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT\n如果指定 DISTINCT，会在返回结果中删除重复值。为可选项。\n\n\nmeasure_expr\n可以是任何表达式。度量列中的空值将被忽略。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 CLOB 类型的数据值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT WM_CONCAT(last_name) \"Emp_list\" FROM employees;\n+----------------------------------------------------------------------+\n| Emp_list                                                             |\n+----------------------------------------------------------------------+\n| Raphaely,De Haan,Errazuriz,Hartstein,Raphaely,Weiss,Russell,Partners |\n+----------------------------------------------------------------------+\n1 row in set\n", "obclient> SELECT department_id,hiredate,last_name,\n              WM_CONCAT(last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n    FROM employees\n    ORDER BY 1,2;\n+---------------+------------+-----------+--------------------------+\n| DEPARTMENT_ID | HIREDATE   | LAST_NAME | Emp_list                 |\n+---------------+------------+-----------+--------------------------+\n|            30 | 2017-07-01 | Raphaely  | Raphaely,De Haan         |\n|            30 | 2018-05-01 | De Haan   | Raphaely,De Haan         |\n|            40 | 2017-07-21 | Errazuriz | Errazuriz                |\n|            50 | 2017-07-22 | Raphaely  | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Hartstein | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Weiss     | Hartstein,Raphaely,Weiss |\n|            90 | 2018-12-01 | Partners  | Russell,Partners         |\n|            90 | 2019-07-11 | Russell   | Russell,Partners         |\n+---------------+------------+-----------+--------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822865"], "Title": ["CORR"], "Feature": ["CORR(expr1, expr2) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值对的相关系数。相关系数代表数值对的关联强度，范围为 [-1,1]，其中 0 表示不相关，小于 0 代表负相关，大于 0 代表正相关。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个参数，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个参数，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果。\n返回结果计算公式为：COVAR_POP(expr1, expr2) / (STDDEV_POP(expr1) * STDDEV_POP(expr2))。\n\n", "如果有任意一个参数为空或只有一行数据，则返回 NULL。否则返回一个 NUMBER 类型的值。"], "Examples": ["obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT CORR(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col3,col4,CORR(col3,col4) OVER(PARTITION BY col1) \"corr\" FROM tbl1;\n+------+------+------+--------------------------------------------+\n| COL1 | COL3 | COL4 | corr                                       |\n+------+------+------+--------------------------------------------+\n|    1 |    8 |   12 |  .9958705948858223809835060513429288056548 |\n|    1 |   10 |   15 |  .9958705948858223809835060513429288056548 |\n|    1 |   11 |   16 |  .9958705948858223809835060513429288056548 |\n|    2 |    9 |   14 |                                          1 |\n|    2 |   10 |   15 |                                          1 |\n|    2 |    8 |   13 |                                          1 |\n|    2 |   11 |   16 |                                          1 |\n|    3 |    8 |   18 | -.9901475429766743091532731291244706579003 |\n|    3 |    9 |   16 | -.9901475429766743091532731291244706579003 |\n|    3 |   10 |   15 | -.9901475429766743091532731291244706579003 |\n|    3 |   11 |   12 | -.9901475429766743091532731291244706579003 |\n|    3 |   12 |   10 | -.9901475429766743091532731291244706579003 |\n+------+------+------+--------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822887"], "Title": ["COUNT"], "Feature": ["COUNT({ * | [ DISTINCT | UNIQUE | ALL ] expr }) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于返回查询 expr 的行数。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\n*\n表示返回满足条件的所有行，且包含重复行和空行。\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略空行。\nDISTINCT：返回的行中去除重复行，且忽略空行。\nUNIQUE：返回的行中去除重复行，且忽略空行。\n\n\n\nexpr\n指定参与计算的列名。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n\n对于 COUNT 函数，从不返回 NULL，如果指定了 expr，即返回 expr 不为 NULL 的统计个数，如果指定 COUNT(*) 返回所有行的统计数目。使用参数 DISTINCT 、UNIQUE 或 ALL 时需要与 expr 用空格隔开。\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n\n", "返回一个自然数。"], "Examples": ["obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES\n    (1,'aa',10),(2,'bb',12),(3,'cc',15),(4,'dd',18),(5,'ee',20),\n    (6,'ff',23),(7,'gg',25),(8,'hh',30),(9,'ii',40),(10,'jj',15),\n    (11,'kk',NULL),(12,'oo',NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | aa   |   10 |\n|    2 | bb   |   12 |\n|    3 | cc   |   15 |\n|    4 | dd   |   18 |\n|    5 | ee   |   20 |\n|    6 | ff   |   23 |\n|    7 | gg   |   25 |\n|    8 | hh   |   30 |\n|    9 | ii   |   40 |\n|   10 | jj   |   15 |\n|   11 | kk   | NULL |\n|   12 | oo   | NULL |\n+------+------+------+\n12 rows in set\n", "obclient> SELECT COUNT(col3),COUNT(*) FROM tbl1;\n+-------------+----------+\n| COUNT(COL3) | COUNT(*) |\n+-------------+----------+\n|          10 |       12 |\n+-------------+----------+\n1 row in set\n", "obclient> SELECT col1,col2,\n                 COUNT(*) OVER (ORDER BY col3 RANGE BETWEEN 1 PRECEDING AND 3 FOLLOWING) AS mov_count\n          FROM tbl1;\n+------+------+-----------+\n| COL1 | COL2 | MOV_COUNT |\n+------+------+-----------+\n|    1 | aa   |         2 |\n|    2 | bb   |         3 |\n|    3 | cc   |         3 |\n|   10 | jj   |         3 |\n|    4 | dd   |         2 |\n|    5 | ee   |         2 |\n|    6 | ff   |         2 |\n|    7 | gg   |         1 |\n|    8 | hh   |         1 |\n|    9 | ii   |         1 |\n|   11 | kk   |         2 |\n|   12 | oo   |         2 |\n+------+------+-----------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822864"], "Title": ["COVAR_POP"], "Feature": ["COVAR_POP(expr1, expr2)[ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值对的总体协方差。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果，即 COVAR_POP(expr1, expr2) 等于 COVAR_POP(expr2, expr1)。\n返回结果计算公式为：(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n，其中 n 是（expr1,expr2）表达式对的数量，expr1 和 expr2 均不为空。\n\n", "如果有任意一个参数为空，则返回 NULL；否则返回一个 NUMBER 类型的值。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT COVAR_POP(col3,col4) FROM tbl1;\n+----------------------+\n| COVAR_POP(COL3,COL4) |\n+----------------------+\n|                 -.75 |\n+----------------------+\n1 row in set\n", "obclient> SELECT col1,col3,col4,\n            COVAR_POP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_POP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_POP                                 |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                         0 |\n|    1 |   10 |   15 |                                       1.5 |\n|    1 |   11 |   16 |    2.111111111111111111111111111111111111 |\n|    2 |    9 |   14 |                                         0 |\n|    2 |   10 |   15 |                                       .25 |\n|    2 |    8 |   13 | .6666666666666666666666666666666666666667 |\n|    2 |   11 |   16 |                                      1.25 |\n|    3 |    8 |   18 |                                         0 |\n|    3 |    9 |   16 |                                       -.5 |\n|    3 |   10 |   15 |                                        -1 |\n|    3 |   11 |   12 |                                    -2.375 |\n|    3 |   12 |   10 |                                        -4 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822876"], "Title": ["COVAR_SAMP"], "Feature": ["COVAR_SAMP(expr1, expr2) [ OVER (analytic_clause) ]\n"], "Description": ["该函数用于计算一组数值对的样本协方差。可以将该函数用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果，即 COVAR_POP(expr1, expr2) 等于 COVAR_POP(expr2, expr1)。\n返回结果计算公式为：(SUM(expr1 * expr2) - SUM(expr1) * SUM(expr2) / n) / (n-1)，其中 n 是（expr1,expr2）表达式对的数量，expr1 和 expr2 均不为空。\n\n", "如果有任意一个参数为空或只有一行数据，则返回 NULL；否则返回一个 NUMBER 类型的值。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT COVAR_SAMP(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col3,col4,\n            COVAR_SAMP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_SAMP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_SAMP                                |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                      NULL |\n|    1 |   10 |   15 |                                         3 |\n|    1 |   11 |   16 |   3.1666666666666666666666666666666666665 |\n|    2 |    9 |   14 |                                      NULL |\n|    2 |   10 |   15 |                                        .5 |\n|    2 |    8 |   13 |                                         1 |\n|    2 |   11 |   16 |  1.66666666666666666666666666666666666667 |\n|    3 |    8 |   18 |                                      NULL |\n|    3 |    9 |   16 |                                        -1 |\n|    3 |   10 |   15 |                                      -1.5 |\n|    3 |   11 |   12 | -3.16666666666666666666666666666666666667 |\n|    3 |   12 |   10 |                                        -5 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822886"], "Title": ["CUME_DIST"], "Feature": ["/*聚合语法*/\nCUME_DIST( expr[,expr]...)\n  WITHIN GROUP (ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                       [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n          )\n\n/*分析语法*/\nCUME_DIST() OVER ([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数用于计算一组值中的某个值的累积分布，返回值的范围为 (0,1]。可以将此函数用作聚合或分析函数。", "\n说明\n\n作为分析函数，该函数计算指定值在一组值中的相对位置。对于行 row，假设按升序排列，row 的 cume_dist 是值低于或等于 row 值的行数除以被计算的行数（整个查询结果集或分区）。\n作为聚合函数，该函数的参数标识每个聚合组中的单个假设行。因此，它们必须全部计算为每个聚合组内的常量表达式。常量参数表达式和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的类型必须兼容。如果指定值与分组序列中某值重复，则将两个重复的值视为一个值处理。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 ASC 为升序排序，为默认值。 DESC 为降序排序。\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 NULLS FIRST 表示 NULL 值排在非空值的前面。 NULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值为 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT CUME_DIST(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+----------------------------------------+\n| CUME_DIST(3300)WITHINGROUP(ORDERBYSAL) |\n+----------------------------------------+\n|                                  .9375 |\n+----------------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename,sal,\n              CUME_DIST ( ) over (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | RANK                                      |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 | .3333333333333333333333333333333333333333 |\n|     10 | CLARK  | 2750 | .6666666666666666666666666666666666666667 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                        .4 |\n|     20 | SCOTT  | 3300 |                                        .4 |\n|     20 | JONES  | 3275 |                                        .6 |\n|     20 | ADAMS  | 1400 |                                        .8 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 | .1428571428571428571428571428571428571429 |\n|     30 | ALLEN  | 1900 | .2857142857142857142857142857142857142857 |\n|     30 | TURNER | 1800 | .4285714285714285714285714285714285714286 |\n|     30 | SCLARK | 1750 | .5714285714285714285714285714285714285714 |\n|     30 | MARTIN | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | WARD   | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822870"], "Title": ["DENSE_RANK"], "Feature": ["/*聚合语法*/\nDENSE_RANK(expr [, expr ...])\n  WITHIN GROUP ( ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                        [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n                )\n\n/*分析语法*/\nDENSE_RANK( ) OVER([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数功能是计算有序行组中行的秩。秩的值是从 1 开始的连续整数，最大的秩值是符合查询结果的数值。具有相同值的排序标准的行接收相同的秩，相同的行数不会被记录到下个排名中。可以将其用作聚合或分析函数。", "\n说明\n\n作为聚合函数，DENSE_RANK 根据指定的排序规范计算由函数的参数标识的假设行的密集等级。常量参数表达式 expr 和 order_by_clause 聚合中的表达式按位置匹配。因此，参数的数量必须相同并且类型必须兼容。\n作为一个分析函数，DENSE_RANK 根据 order_by_clause 中 value_exprs 的值，计算从查询返回的每一行相对于其他行的秩。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n对应列中数据类型的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值为 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT DENSE_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------------+\n| DENSE_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------------+\n|                                      12 |\n+-----------------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename, sal,\n              DENSE_RANK ( ) OVER (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n     FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    2 |\n|     20 | ADAMS  | 1400 |    3 |\n|     20 | SMITH  | 1100 |    4 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    6 |\n+--------+--------+------+------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822833"], "Title": ["FIRST_VALUE"], "Feature": ["FIRST_VALUE { (expr) [{RESPECT | IGNORE} NULLS ]\n            | (expr [{RESPECT | IGNORE} NULLS ])\n            }\nOVER (analytic_clause)\n"], "Description": ["该函数是一个分析函数，功能是返回有序值中的第一个值。如果集合中的第一个值为 NULL，则函数返回NULL，除非您指定 IGNORE NULLS，该设置对于数据致密化很有用。expr 列中 NULL 值行对应的返回值是 NULL。", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要返回值的列名。 注意 不能将 FIRST_VALUE 或其他分析函数用于 expr 来嵌套分析函数。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值与参数 expr 的数据类型相同或返回 NULL。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,mgr,\n              FIRST_VALUE (MGR) IGNORE NULLS OVER (ORDER BY sal DESC) AS first_mgr\n      FROM emp_msg\n      ORDER BY sal DESC;\n+--------+--------+------+------+-----------+\n| DEPTNO | ENAME  | SAL  | MGR  | FIRST_MGR |\n+--------+--------+------+------+-----------+\n|     10 | KING   | 5300 | NULL | NULL      |\n|     20 | FORD   | 3300 | 7566 | 7566      |\n|     20 | SCOTT  | 3300 | 7566 | 7566      |\n|     20 | JONES  | 3275 | 7839 | 7566      |\n|     30 | BLAKE  | 3150 | 7839 | 7566      |\n|     10 | CLARK  | 2750 | 7839 | 7566      |\n|     30 | ALLEN  | 1900 | 7698 | 7566      |\n|     30 | TURNER | 1800 | 7698 | 7566      |\n|     30 | SCLARK | 1750 | 7839 | 7566      |\n|     10 | MILLER | 1600 | 7782 | 7566      |\n|     30 | MARTIN | 1550 | 7698 | 7566      |\n|     30 | WARD   | 1550 | 7698 | 7566      |\n|     20 | ADAMS  | 1400 | 7788 | 7566      |\n|     30 | JAMES  | 1250 | 7698 | 7566      |\n|     20 | SMITH  | 1100 | 7902 | 7566      |\n+--------+--------+------+------+-----------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822883"], "Title": ["KEEP"], "Feature": ["aggregate_function KEEP ( DENSE_RANK { FIRST | LAST }\n                ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ]\n                      [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ]]...\n                        )\n[ OVER ( [query_partition_clause] ) ]\n\naggregate_function:\n  MIN\n |MAX\n |SUM\n |AVG\n |COUNT\n |VARIANCE\n |STDDEV\n"], "Description": ["该函数用于对一组行中的值进行操作，将这组行按照指定的排序规则排序后返回排在第一或最后的值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\naggregate_function\n指定聚合函数的种类。\n\n\nexpr\n可以是任何表达式。\n\n\nFIRST | LAST\n指定返回 expr 排序后那个位置的值。 \n      \nFIRST 表示返回排在首位的值。\nLAST 表示返回排在最后的值。\n\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与 aggregate_function 中指定的列相同的数据类型。"], "Examples": ["obclient> CREATE TABLE employees (department_id INT,manager_id INT,last_name varchar(50),hiredate varchar(50),SALARY INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO employees VALUES\n    (30, 100, 'Raphaely', '2017-07-01', 1700),\n    (30, 100, 'De Haan', '2018-05-01',11000),\n    (40, 100, 'Errazuriz', '2017-07-21', 1400),\n    (50, 100, 'Hartstein', '2019-10-05',14000),\n    (50, 100, 'Raphaely', '2017-07-22', 1700),\n    (50, 100, 'Weiss',  '2019-10-05',13500),\n    (90, 100, 'Russell', '2019-07-11', 13000),\n    (90,100, 'Partners',  '2018-12-01',14000);\nQuery OK, 8 rows affected\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE) \"Best\"\n    FROM employees;\n+-------+-------+\n| Worst | Best  |\n+-------+-------+\n|  1400 | 27500 |\n+-------+-------+\n1 row in set\n", "obclient> SELECT last_name,department_id,salary,\n    SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary)\n        OVER (PARTITION BY department_id) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE)\n        OVER (PARTITION BY department_id) \"Best\"\n    FROM employees\n    ORDER BY department_id, salary, last_name;\n+-----------+---------------+--------+-------+-------+\n| LAST_NAME | DEPARTMENT_ID | SALARY | Worst | Best  |\n+-----------+---------------+--------+-------+-------+\n| Raphaely  |            30 |   1700 |  1700 | 11000 |\n| De Haan   |            30 |  11000 |  1700 | 11000 |\n| Errazuriz |            40 |   1400 |  1400 |  1400 |\n| Raphaely  |            50 |   1700 |  1700 | 27500 |\n| Weiss     |            50 |  13500 |  1700 | 27500 |\n| Hartstein |            50 |  14000 |  1700 | 27500 |\n| Russell   |            90 |  13000 | 13000 | 13000 |\n| Partners  |            90 |  14000 | 13000 | 13000 |\n+-----------+---------------+--------+-------+-------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822829"], "Title": ["LAG"], "Feature": ["LAG { (value_expr [,offset [,default]]) [{ RESPECT|IGNORE } NULLS ]\n    | (value_expr [{ RESPECT|IGNORE } NULLS ] [,offset [,default] ])\n    }\nOVER([query_partition_clause] order_by_clause)\n"], "Description": ["该函数是一个分析函数，功能是在查询中取出同一字段的前 offset 行的数据作为独立的列存在表中。这种操作可以代替表的自联接。", "\n\n\n参数\n说明\n\n\n\n\nvalue_expr\n指定需要查询的字段。 注意 不能使用 LAG 函数或其他分析函数来嵌套 value_expr。\n\n\noffset\n指定查询 value_expr 的偏移量，一个大于零的整数，为可选项。默认值为 1。\n\n\ndefault\n指定没有符合条件的默认值。如果偏移量超出窗口的范围，则返回 default 的值，为可选项。默认值为 NULL。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值的数据类型不限。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename, sal,LAG(ename,3,'XXX') OVER (ORDER BY ename) AS new_ename\n          FROM emp_msg;\n+--------+--------+------+-----------+\n| DEPTNO | ENAME  | SAL  | NEW_ENAME |\n+--------+--------+------+-----------+\n|     20 | ADAMS  | 1400 | XXX       |\n|     30 | ALLEN  | 1900 | XXX       |\n|     30 | BLAKE  | 3150 | XXX       |\n|     10 | CLARK  | 2750 | ADAMS     |\n|     20 | FORD   | 3300 | ALLEN     |\n|     30 | JAMES  | 1250 | BLAKE     |\n|     20 | JONES  | 3275 | CLARK     |\n|     10 | KING   | 5300 | FORD      |\n|     30 | MARTIN | 1550 | JAMES     |\n|     10 | MILLER | 1600 | JONES     |\n|     30 | SCLARK | 1750 | KING      |\n|     20 | SCOTT  | 3300 | MARTIN    |\n|     20 | SMITH  | 1100 | MILLER    |\n|     30 | TURNER | 1800 | SCLARK    |\n|     30 | WARD   | 1550 | SCOTT     |\n+--------+--------+------+-----------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822849"], "Title": ["LAST_VALUE"], "Feature": ["LAST_VALUE { (expr) [{RESPECT | IGNORE} NULLS ]\n            | (expr [{RESPECT | IGNORE} NULLS ])\n            }\nOVER (analytic_clause)\n"], "Description": ["该函数是一个分析函数，用于返回一组有序值中的最后一个值。如果集合中的最后一个值为 NULL，则该函数将返回 NULL，除非您指定 IGNORE NULLS，此设置对数据致密化很有用。", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定序列。 注意 不能将 LAST_VALUE 或其他分析函数用于 expr 来嵌套分析函数。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值与 expr 的数据类型相同或返回 NULL。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,MGR,\n            LAST_VALUE ( MGR ) IGNORE NULLS OVER (ORDER BY sal ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS last_MGR\n    FROM emp_msg;\n+--------+--------+------+------+----------+\n| DEPTNO | ENAME  | SAL  | MGR  | LAST_MGR |\n+--------+--------+------+------+----------+\n|     20 | SMITH  | 1100 | 7902 | 7566     |\n|     30 | JAMES  | 1250 | 7698 | 7566     |\n|     20 | ADAMS  | 1400 | 7788 | 7566     |\n|     30 | MARTIN | 1550 | 7698 | 7566     |\n|     30 | WARD   | 1550 | 7698 | 7566     |\n|     10 | MILLER | 1600 | 7782 | 7566     |\n|     30 | SCLARK | 1750 | 7839 | 7566     |\n|     30 | TURNER | 1800 | 7698 | 7566     |\n|     30 | ALLEN  | 1900 | 7698 | 7566     |\n|     10 | CLARK  | 2750 | 7839 | 7566     |\n|     30 | BLAKE  | 3150 | 7839 | 7566     |\n|     20 | JONES  | 3275 | 7839 | 7566     |\n|     20 | FORD   | 3300 | 7566 | 7566     |\n|     20 | SCOTT  | 3300 | 7566 | 7566     |\n|     10 | KING   | 5300 | NULL | 7566     |\n+--------+--------+------+------+----------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822831"], "Title": ["LEAD"], "Feature": ["LEAD { (value_expr [,offset [,default]]) [{ RESPECT|IGNORE } NULLS ]\n    | (value_expr [{ RESPECT|IGNORE } NULLS ] [,offset [,default] ])\n    }\nOVER([query_partition_clause] order_by_clause)\n"], "Description": ["该函数是一个分析函数，功能是在查询中取出同一字段的后 offset 行的数据作为独立的列存在表中。这种操作可以代替表的自联接。", "\n\n\n参数\n说明\n\n\n\n\nvalue_expr\n指定需要查询的字段。 注意 不能使用 LEAD 函数或其他分析函数来嵌套 value_expr。\n\n\noffset\n指定查询 value_expr 的偏移量，一个大于零的整数。为可选项，默认值为 1。\n\n\ndefault\n指定没有符合条件的默认值。如果偏移量超出窗口的范围，则返回 default 的值。为可选项，默认值为 NULL。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回的数据类型不限。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT  deptno, ename, sal, LEAD(ename,5,'XXX') OVER (ORDER BY ename desc) AS new_ename\n     FROM emp_msg;\n+--------+--------+------+-----------+\n| DEPTNO | ENAME  | SAL  | NEW_ENAME |\n+--------+--------+------+-----------+\n|     20 | ADAMS  | 1400 | JAMES     |\n|     30 | ALLEN  | 1900 | JONES     |\n|     30 | BLAKE  | 3150 | KING      |\n|     10 | CLARK  | 2750 | MARTIN    |\n|     20 | FORD   | 3300 | MILLER    |\n|     30 | JAMES  | 1250 | SCLARK    |\n|     20 | JONES  | 3275 | SCOTT     |\n|     10 | KING   | 5300 | SMITH     |\n|     30 | MARTIN | 1550 | TURNER    |\n|     10 | MILLER | 1600 | WARD      |\n|     30 | SCLARK | 1750 | XXX       |\n|     20 | SCOTT  | 3300 | XXX       |\n|     20 | SMITH  | 1100 | XXX       |\n|     30 | TURNER | 1800 | XXX       |\n|     30 | WARD   | 1550 | XXX       |\n+--------+--------+------+-----------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822868"], "Title": ["LISTAGG"], "Feature": ["LISTAGG (measure_expr [,'delimiter']) [ WITHIN GROUP ] (order_by_clause)\n[ OVER query_partition_clause ]\n"], "Description": ["该函数用于列转行，LISTAGG 对 ORDER BY 子句中指定的每个组内的数据进行排序，然后合并度量列的值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，不需要加 OVER 关键字。 \n     \n作为单个集合的聚合函数，LISTAGG 对所有行进行操作并返回单个输出行。\n作为组集聚合，LISTAGG 将对 GROUP BY 子句定义的每个组进行操作并返回输出行。\n\n\n", "\n\n\n参数\n说明\n\n\n\n\nmeasure_expr\n可以是任何表达式。度量列中的空值将被忽略。\n\n\ndelimiter\n指定用于分隔度量值的字符串。此子句是可选的，默认为 NULL。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "如果度量列是 RAW 的，则返回数据类型为 RAW，否则返回值为 VARCHAR2。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) as \"Emp_list\",\n              MIN(hiredate) as \"Earliest\"\n       FROM employees\n       WHERE department_id = 30;\n+-------------------+------------+\n| Emp_list          | Earliest   |\n+-------------------+------------+\n| Raphaely; De Haan | 2017-07-01 |\n+-------------------+------------+\n1 row in set\n", "obclient> SELECT department_id \"Dept\",hiredate \"Date\",last_name \"Name\",\n              LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n      FROM employees\n      WHERE hiredate < '2019-10-10'\n      ORDER BY \"Dept\", \"Date\", \"Name\";\n+------+------------+-----------+----------------------------+\n| Dept | Date       | Name      | Emp_list                   |\n+------+------------+-----------+----------------------------+\n|   30 | 2017-07-01 | Raphaely  | Raphaely; De Haan          |\n|   30 | 2018-05-01 | De Haan   | Raphaely; De Haan          |\n|   40 | 2017-07-21 | Errazuriz | Errazuriz                  |\n|   50 | 2017-07-22 | Raphaely  | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Hartstein | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Weiss     | Raphaely; Hartstein; Weiss |\n|   90 | 2018-12-01 | Partners  | Partners; Russell          |\n|   90 | 2019-07-11 | Russell   | Partners; Russell          |\n+------+------------+-----------+----------------------------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822873"], "Title": ["MAX"], "Feature": ["MAX ([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回参数中指定的列中的最大值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：返回的行中去除重复行，且忽略值为 NULL 的行。\nUNIQUE：返回的行中去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n可为数值、字符、日期型或其它类型的数据列或表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与 expr 相同的数据类型值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT MAX(salary) FROM employees;\n+-------------+\n| MAX(SALARY) |\n+-------------+\n|       14000 |\n+-------------+\n1 row in set\n", "obclient> SELECT department_id,last_name,salary,\n                 MAX(salary) OVER (PARTITION BY department_id) AS rmax_sal\n          FROM employees;\n+---------------+-----------+--------+----------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | RMAX_SAL |\n+---------------+-----------+--------+----------+\n|            30 | Raphaely  |   1700 |    11000 |\n|            30 | De Haan   |  11000 |    11000 |\n|            40 | Errazuriz |   1400 |     1400 |\n|            50 | Hartstein |  14000 |    14000 |\n|            50 | Raphaely  |   1700 |    14000 |\n|            50 | Weiss     |  13500 |    14000 |\n|            90 | Russell   |  13000 |    14000 |\n|            90 | Partners  |  14000 |    14000 |\n+---------------+-----------+--------+----------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822881"], "Title": ["MEDIAN"], "Feature": ["MEDIAN(expr) [ OVER (query_partition_clause) ]\n"], "Description": ["该函数用于返回一组数值的中值，即将一组数值排序后返回居于中间的数值。如果参数集合中包含偶数个数值，该函数将返回位于中间的两个数的平均值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要求中值的数组名称，参数类型属于数值数据类型或可以隐式转换为数字数据类型。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "如果仅指定 expr，则该函数返回与参数的数值数据类型相同的数据类型。", "如果指定 OVER 子句，则数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。"], "Examples": ["obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT MEDIAN(col4) FROM tbl1;\n+--------------+\n| MEDIAN(COL4) |\n+--------------+\n|           15 |\n+--------------+\n1 row in set\n", "obclient> SELECT col1,col4,MEDIAN(col4) OVER(PARTITION BY col1) \"MEDIAN\"\n FROM tbl1;\n+------+------+--------+\n| COL1 | COL4 | MEDIAN |\n+------+------+--------+\n|    1 |   12 |     15 |\n|    1 |   15 |     15 |\n|    1 |   16 |     15 |\n|    2 |   14 |   14.5 |\n|    2 |   15 |   14.5 |\n|    2 |   13 |   14.5 |\n|    2 |   16 |   14.5 |\n|    3 |   18 |     15 |\n|    3 |   16 |     15 |\n|    3 |   15 |     15 |\n|    3 |   12 |     15 |\n|    3 |   10 |     15 |\n+------+------+--------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822874"], "Title": ["MIN"], "Feature": ["MIN([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数返回参数中指定列的最小值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重，为可选项。默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：返回的行中去除重复行，且忽略值为 NULL 的行。\nUNIQUE：返回的行中去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n可为数值、字符、日期型或其它数据类型的列或表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与 expr 相同数据类型的值。"], "Examples": ["obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n", "obclient> SELECT MIN(salary)  FROM employees;\n+-------------+\n| MIN(SALARY) |\n+-------------+\n|        1400 |\n+-------------+\n1 row in set\n", "obclient> SELECT department_id,last_name,hiredate,salary,\n                 MIN(salary) OVER(PARTITION BY department_id) AS p_cmin\n          FROM employees;\n+---------------+-----------+------------+--------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | P_CMIN |\n+---------------+-----------+------------+--------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |   1700 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |   1700 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |   1700 |\n|            90 | Russell   | 2019-07-11 |  13000 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |  13000 |\n+---------------+-----------+------------+--------+--------+\n8 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822844"], "Title": ["NTH_VALUE"], "Feature": ["NTH_VALUE (measure_expr, n)\n  [ FROM { FIRST | LAST } ][ { RESPECT | IGNORE } NULLS ]\nOVER (analytic_clause)\n"], "Description": ["该函数功能是返回 analytic_clause 定义的窗口中第 n 行的 measure_expr 值。", "\n\n\n参数\n说明\n\n\n\n\nmeasure_expr\n指定返回数据的字段。\n\n\nn\n指定返回测量值的第 n 行。n 取值为正整数。 注意\n\n如果 n 是 NULL，函数将返回错误。\n如果 n 大于窗口内所有的行数，函数返回 NULL。\n\n\n\nFROM { FIRST | LAST }\n指定计算方向。为可选项，默认值为 FROM FIRST。 \n      \nFROM FIRST 表示从窗口的第一行开始计算。\nFROM LAST 表示最后一行开始计算。\n\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回值与参数 measure_expr 的数据类型相同。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,\n               NTH_VALUE(sal,4) OVER (PARTITION BY deptno ORDER BY sal DESC\n               ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS third_most_sal\n      FROM emp_msg\n      ORDER BY deptno,sal DESC;\n+--------+--------+------+----------------+\n| DEPTNO | ENAME  | SAL  | THIRD_MOST_SAL |\n+--------+--------+------+----------------+\n|     10 | KING   | 5300 |           NULL |\n|     10 | CLARK  | 2750 |           NULL |\n|     10 | MILLER | 1600 |           NULL |\n|     20 | FORD   | 3300 |           1400 |\n|     20 | SCOTT  | 3300 |           1400 |\n|     20 | JONES  | 3275 |           1400 |\n|     20 | ADAMS  | 1400 |           1400 |\n|     20 | SMITH  | 1100 |           1400 |\n|     30 | BLAKE  | 3150 |           1750 |\n|     30 | ALLEN  | 1900 |           1750 |\n|     30 | TURNER | 1800 |           1750 |\n|     30 | SCLARK | 1750 |           1750 |\n|     30 | MARTIN | 1550 |           1750 |\n|     30 | WARD   | 1550 |           1750 |\n|     30 | JAMES  | 1250 |           1750 |\n+--------+--------+------+----------------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822852"], "Title": ["NTILE"], "Feature": ["NTILE (expr) OVER ([ query_partition_clause ] order_by_clause)\n"], "Description": ["该函数是一个分析函数，功能是将有序数据集划分为若干个组，并为每一行分配适当的组号。组编号为 1 到 expr。", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定划分的组数。 \n      \nexpr 值必须解析为大于等于 1 的正数，如果 expr 是一个非整数常量，则数据库将会该值截断为整数。\n如果 expr 大于行数，则将填充与行数相等的多个组，其余组为空。\n 注意 不能通过使用 NTILE 或任何其他分析函数来嵌套分析函数。但是您可以在 expr 中使用其他内置函数表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 NUMERIC 类型数据。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT ename,sal,NTILE(5) OVER (ORDER BY sal DESC) sal_ntile FROM emp_msg ORDER BY sal DESC;\n+--------+------+-----------+\n| ENAME  | SAL  | SAL_NTILE |\n+--------+------+-----------+\n| KING   | 5300 |         1 |\n| FORD   | 3300 |         1 |\n| SCOTT  | 3300 |         1 |\n| JONES  | 3275 |         2 |\n| BLAKE  | 3150 |         2 |\n| CLARK  | 2750 |         2 |\n| ALLEN  | 1900 |         3 |\n| TURNER | 1800 |         3 |\n| SCLARK | 1750 |         3 |\n| MILLER | 1600 |         4 |\n| MARTIN | 1550 |         4 |\n| WARD   | 1550 |         4 |\n| ADAMS  | 1400 |         5 |\n| JAMES  | 1250 |         5 |\n| SMITH  | 1100 |         5 |\n+--------+------+-----------+\n15 rows in set\n"], "Category": ["Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822888"], "Title": ["PERCENTILE_CONT"], "Feature": ["PERCENTILE_CONT(percentile) WITHIN GROUP (ORDER BY expr [ DESC | ASC ])\n[ OVER (query_partition_clause) ]\n"], "Description": ["该函数是一个假定连续分布模型的逆分布函数。根据指定百分比值和排序规范，返回一个在该排序规范的给定百分比值的内插值。在计算中忽略空值。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\npercentile\n指定百分位的值，是一个数值数据类型的常量，取值范围为 [0,1]。 说明 MEDIAN 函数相当于是 percentile 为 0.5 的特殊情况。\n\n\nexpr\n指定排序规范的表达式，数据类型属于数值类型或日期时间类型。 注意 expr 必须为涉及列引用的单个表达式，不允许使用多个表达式。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n说明\n该函数在根据排序规范对行进行排序后，通过指定百分比值 (P) 和非空行数 (N) 计算行号，行号计算公式为 RN = (1+ (P*(N-1))。该函数的最终结果通过行号 CRN = CEILING(RN) 和 FRN = FLOOR(RN) 的行中的值之间的线性内插计算。最终结果将如下：\n", "如果 (CRN = FRN = RN)，则结果为 (value of expression from row at RN)；否则，结果为：", "(CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN)。", "返回与参数 expr 相同的数据类型。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT PERCENTILE_CONT(0.1) WITHIN GROUP (ORDER BY col4) FROM tbl1;\n+----------------------------------------------+\n| PERCENTILE_CONT(0.1)WITHINGROUP(ORDERBYCOL4) |\n+----------------------------------------------+\n|                                           12 |\n+----------------------------------------------+\n1 row in set\n", "obclient> SELECT col1,col4,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY col4) OVER (PARTITION BY col1)\n          FROM tbl1;\n+------+------+-------------------------------------------------------------------+\n| COL1 | COL4 | PERCENTILE_CONT(0.5)WITHINGROUP(ORDERBYCOL4)OVER(PARTITIONBYCOL1) |\n+------+------+-------------------------------------------------------------------+\n|    1 |   12 |                                                                15 |\n|    1 |   15 |                                                                15 |\n|    1 |   16 |                                                                15 |\n|    2 |   14 |                                                              14.5 |\n|    2 |   15 |                                                              14.5 |\n|    2 |   13 |                                                              14.5 |\n|    2 |   16 |                                                              14.5 |\n|    3 |   18 |                                                                15 |\n|    3 |   16 |                                                                15 |\n|    3 |   15 |                                                                15 |\n|    3 |   12 |                                                                15 |\n|    3 |   10 |                                                                15 |\n+------+------+-------------------------------------------------------------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822890"], "Title": ["PERCENTILE_DISC"], "Feature": ["PERCENTILE_DISC(expr1) WITHIN GROUP (ORDER BY expr2 [ DESC | ASC ])\n[ OVER (query_partition_clause) ]\n"], "Description": ["该函数根据一个百分位值和指定排序规范，返回大于或等于百分位值的最小累积分布值（相对于同一排序规范）的值。在计算中忽略空值。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定百分位的值，是一个数值数据类型的常量，取值范围为 [0,1]。\n\n\nexpr2\n指定用于排序和计算百分比的表达式，数据类型属于数值类型或日期时间类型。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回与参数 expr2 相同的数据类型。"], "Examples": ["obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n", "obclient> SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) \"PERCENTILE_DISC\" FROM tbl1;\n+-----------------+\n| PERCENTILE_DISC |\n+-----------------+\n|              15 |\n+-----------------+\n1 row in set\n", "obclient> SELECT col1,col4,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) OVER(PARTITION BY col1) \"PERCENTILE_DISC\"\n          FROM tbl1;\n+------+------+-----------------+\n| COL1 | COL4 | PERCENTILE_DISC |\n+------+------+-----------------+\n|    1 |   12 |              15 |\n|    1 |   15 |              15 |\n|    1 |   16 |              15 |\n|    2 |   14 |              14 |\n|    2 |   15 |              14 |\n|    2 |   13 |              14 |\n|    2 |   16 |              14 |\n|    3 |   18 |              15 |\n|    3 |   16 |              15 |\n|    3 |   15 |              15 |\n|    3 |   12 |              15 |\n|    3 |   10 |              15 |\n+------+------+-----------------+\n12 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822882"], "Title": ["PERCENT_RANK"], "Feature": ["/*聚合语法*/\nPERCENT_RANK(expr [, expr ...]) WITHIN GROUP\n               ( ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                          [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n               )\n\n/*分析语法*/\nPERCENT_RANK( ) OVER ([query_partition_clause] order_by_clause)\n"], "Description": ["该函数用来计算一组值中的某个值的累积分布。类似于 CUME_DIST 函数。可以将此函数用作聚合或分析函数。", "\n说明\n\n作为聚合函数，PERCENT_RANK 计算某一个数在一个集合中的对应位置百分比，它的返回值范围为 (0, 1]。如果有 N 行数据，expr 的值，大于第二行的值而小于第三行的值，那么位置百分比等于 2/N。常量参数表达式和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的类型必须兼容。如果指定值与分组序列中某值重复，则将两个相同的值视为一个值处理。\n作为分析函数，PERCENT_RANK 计算某列或某列组合后每行的百分比排序，它的返回值范围为 [0, 1]。当有相同排序值时，将会有相同的排名，并且值相同的行数会被记录到下个排名中。任何集合中的第一行的 PERCENT_RANK 函数为 0，位置百分比的计算公式为：位置百分比=序号/最大序号，具体示例请参见如下表格：\n\n", "\n\n\nN\n序号\n位置百分比\n\n\n\n\nA\n0\n0\n\n\nB\n1\n0.25\n\n\nC\n2\n0.5\n\n\nD\n3\n0.75\n\n\nE\n4\n1\n\n\n", "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "返回 NUMBER 数据类型。"], "Examples": ["obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n", "obclient> SELECT PERCENT_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-------------------------------------------+\n| PERCENT_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-------------------------------------------+\n|                                        .8 |\n+-------------------------------------------+\n1 row in set\n", "obclient> SELECT deptno,ename,sal,\n              PERCENT_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) AS pr1\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | PR1                                       |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 |                                         0 |\n|     10 | CLARK  | 2750 |                                        .5 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                         0 |\n|     20 | SCOTT  | 3300 |                                         0 |\n|     20 | JONES  | 3275 |                                        .5 |\n|     20 | ADAMS  | 1400 |                                       .75 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 |                                         0 |\n|     30 | ALLEN  | 1900 | .1666666666666666666666666666666666666667 |\n|     30 | TURNER | 1800 | .3333333333333333333333333333333333333333 |\n|     30 | SCLARK | 1750 |                                        .5 |\n|     30 | MARTIN | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | WARD   | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
{"HTML": ["https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822875"], "Title": ["AVG"], "Feature": ["AVG([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n"], "Description": ["该函数将数值类型或者可以转换成数值类型的表达式作为参数求平均值。可以将其用作聚合或分析函数。", "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n", "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：查询时不去除数据中的重复值，且忽略数据中的 NULL 值。\nDISTINCT：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\nUNIQUE：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\n\n\n\nexpr\n指定要计算的列名。列的数据类型是数值类型或者可以转换成数值类型的表达式。数值类型可以为 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n", "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n", "返回值与参数 expr 的数据类型相同。"], "Examples": ["obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,'a',5),(1,'b',10),(1,'c',15),\n    (2,'d',20),(2,'e',18),(2,'f',12),(3,'a',10),\n    (3,'b',15),(4,'c',15),(4,'a',8);\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | a    |    5 |\n|    1 | b    |   10 |\n|    1 | c    |   15 |\n|    2 | d    |   20 |\n|    2 | e    |   18 |\n|    2 | f    |   12 |\n|    3 | a    |   10 |\n|    3 | b    |   15 |\n|    4 | c    |   15 |\n|    4 | a    |    8 |\n+------+------+------+\n10 rows in set\n", "obclient> SELECT AVG(col3) FROM tbl1;\n+-----------+\n| AVG(COL3) |\n+-----------+\n|      12.8 |\n+-----------+\n1 row in set\n", "obclient> SELECT col1,col2,col3, AVG(col3)\n              OVER (PARTITION BY col1 ORDER BY col2 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS over_col2\n          FROM tbl1\n          ORDER BY col1,col2,col3;\n+------+------+------+-------------------------------------------+\n| COL1 | COL2 | COL3 | OVER_COL2                                 |\n+------+------+------+-------------------------------------------+\n|    1 | a    |    5 |                                       7.5 |\n|    1 | b    |   10 |                                        10 |\n|    1 | c    |   15 |                                      12.5 |\n|    2 | d    |   20 |                                        19 |\n|    2 | e    |   18 | 16.66666666666666666666666666666666666667 |\n|    2 | f    |   12 |                                        15 |\n|    3 | a    |   10 |                                      12.5 |\n|    3 | b    |   15 |                                      12.5 |\n|    4 | a    |    8 |                                      11.5 |\n|    4 | c    |   15 |                                      11.5 |\n+------+------+------+-------------------------------------------+\n10 rows in set\n"], "Category": ["Aggregate Functions", "Analytic Functions"]}
