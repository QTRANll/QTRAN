{
    "ABS": {
        "Title": [
            "ABS"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823164"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ABS(numeric_expression)\n",
        "Description": [
            "该函数返回 numeric_expression 的绝对值。ABS 将负值更改为正值，对零或正值没有影响。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nnumeric_expression\n精确数值或近似数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）的表达式。\n\n\n",
            "返回与 numeric_expression 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ABS(-1.0), ABS(0), ABS(6.66), ABS(3-6) FROM DUAL;\n+-----------+--------+-----------+----------+\n| ABS(-1.0) | ABS(0) | ABS(6.66) | ABS(3-6) |\n+-----------+--------+-----------+----------+\n|         1 |      0 |      6.66 |        3 |\n+-----------+--------+-----------+----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 -1.0、0.0、6.66 和 (3-6) 的绝对值。",
            "obclient> SELECT ABS(-1.0), ABS(0), ABS(6.66), ABS(3-6) FROM DUAL;\n+-----------+--------+-----------+----------+\n| ABS(-1.0) | ABS(0) | ABS(6.66) | ABS(3-6) |\n+-----------+--------+-----------+----------+\n|         1 |      0 |      6.66 |        3 |\n+-----------+--------+-----------+----------+\n1 row in set\n"
        ]
    },
    "ACOS": {
        "Title": [
            "ACOS"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823171"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ACOS(num_expression)\n",
        "Description": [
            "该函数是反余弦函数，返回一个在 [0,π] 范围内的值，以弧度表示。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nnum_expression\nNUMBER 类型或可隐式转换为 NUMBER 类型的表达式。取值在 [-1,1] 之间。\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ACOS(0.3) \"acos_test\" FROM DUAL;\n+------------------------------------------+\n| acos_test                                |\n+------------------------------------------+\n| 1.26610367277949911125931873041222227514 |\n+------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0.3 的 ACOS 的值。",
            "obclient> SELECT ACOS(0.3) \"acos_test\" FROM DUAL;\n+------------------------------------------+\n| acos_test                                |\n+------------------------------------------+\n| 1.26610367277949911125931873041222227514 |\n+------------------------------------------+\n1 row in set\n"
        ]
    },
    "ADD_MONTHS": {
        "Title": [
            "ADD_MONTHS"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823121"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "ADD_MONTHS(date, n)\n",
        "Description": [
            "该函数功能是返回日期 date 加上 n 个月后的日期值。",
            "\n说明\n由于每个月的天数不同，当 date 是一个月中的最后一天时，函数返回计算后所得月份的最后一天。例如，用 ADD_MONTHS 计算 2020 年 3 月 31 日一个月前的日期，返回 2020 年 2 月 29 日。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndate\n指定日期。该参数为 DATE 数据类型。\n\n\nn\n整数或可以转换为一个整数的任意值。NUMBER 数据类型。 \n      \n如果 n 的值为负数，则返回日期 date 基础上 n 个月前的日期值。\n如果 n 的值为正数，则返回日期 date 基础上 n 个月后的日期值。\n\n\n\n",
            "返回 DATE 数据类型。"
        ],
        "Examples": [],
        "Detailed Examples": []
    },
    "APPROX_COUNT_DISTINCT": {
        "Title": [
            "APPROX_COUNT_DISTINCT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822863"
        ],
        "Category": [
            "Aggregate Functions"
        ],
        "Feature": "APPROX_COUNT_DISTINCT(expr)\n",
        "Description": [
            "该函数对参数列去重后的行数进行计算，返回行数值，且该值是近似值，该函数可以用于进一步计算被引用的列的选择性。",
            "与函数 COUNT(DISTINCT x) 相比，APPROX_COUNT_DISTINCT 返回的是近似值，所以计算速度极快。在处理大量级的数据时 COUNT(DISTINCT x) 经常要花费很长的时间，使用 APPROX_COUNT_DISTINCT 牺牲了少量的精确度，却换来了计算效率的极大提升。"
        ],
        "Illustration": [
            "expr 表示去重的数值列。",
            "返回 NUMBER 类型数据。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT,col3 varchar(10));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,10,'a'),(2,20,'b'),(3,30,'c'),\n    (4,40,'a'),(5,50,'c'),(1,10,'a'),(2,20,'b'),(3,30,'c'),(4,30,'a'),(5,40,'b');\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n",
            "obclient> SELECT APPROX_COUNT_DISTINCT(col2) FROM tbl1;\n+-----------------------------+\n| APPROX_COUNT_DISTINCT(COL2) |\n+-----------------------------+\n|                           5 |\n+-----------------------------+\n1 row in set\n",
            "obclient> SELECT col1,APPROX_COUNT_DISTINCT(col2) FROM tbl1 GROUP BY col1;\n+------+-----------------------------+\n| COL1 | APPROX_COUNT_DISTINCT(COL2) |\n+------+-----------------------------+\n|    1 |                           1 |\n|    2 |                           1 |\n|    3 |                           1 |\n|    4 |                           2 |\n|    5 |                           2 |\n+------+-----------------------------+\n5 rows in set\n",
            "obclient> SELECT col1,col3,APPROX_COUNT_DISTINCT(col2) FROM tbl1 GROUP BY col1,col3;\n+------+------+-----------------------------+\n| COL1 | COL3 | APPROX_COUNT_DISTINCT(COL2) |\n+------+------+-----------------------------+\n|    1 | a    |                           1 |\n|    2 | b    |                           1 |\n|    3 | c    |                           1 |\n|    4 | a    |                           2 |\n|    5 | b    |                           1 |\n|    5 | c    |                           1 |\n+------+------+-----------------------------+\n6 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入十条数据。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT,col3 varchar(10));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,10,'a'),(2,20,'b'),(3,30,'c'),\n    (4,40,'a'),(5,50,'c'),(1,10,'a'),(2,20,'b'),(3,30,'c'),(4,30,'a'),(5,40,'b');\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n",
            "返回列 col2 不重复值的个数。",
            "obclient> SELECT APPROX_COUNT_DISTINCT(col2) FROM tbl1;\n+-----------------------------+\n| APPROX_COUNT_DISTINCT(COL2) |\n+-----------------------------+\n|                           5 |\n+-----------------------------+\n1 row in set\n",
            "以列 col1 和列 col2 分组去重后，统计列 col1 中各数值的个数。",
            "obclient> SELECT col1,APPROX_COUNT_DISTINCT(col2) FROM tbl1 GROUP BY col1;\n+------+-----------------------------+\n| COL1 | APPROX_COUNT_DISTINCT(COL2) |\n+------+-----------------------------+\n|    1 |                           1 |\n|    2 |                           1 |\n|    3 |                           1 |\n|    4 |                           2 |\n|    5 |                           2 |\n+------+-----------------------------+\n5 rows in set\n",
            "以列 col1、列 col2 和 col3 分组去重后，统计列 col1 和列 col3 组合值的个数。",
            "obclient> SELECT col1,col3,APPROX_COUNT_DISTINCT(col2) FROM tbl1 GROUP BY col1,col3;\n+------+------+-----------------------------+\n| COL1 | COL3 | APPROX_COUNT_DISTINCT(COL2) |\n+------+------+-----------------------------+\n|    1 | a    |                           1 |\n|    2 | b    |                           1 |\n|    3 | c    |                           1 |\n|    4 | a    |                           2 |\n|    5 | b    |                           1 |\n|    5 | c    |                           1 |\n+------+------+-----------------------------+\n6 rows in set\n"
        ]
    },
    "ASCII": {
        "Title": [
            "ASCII"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823207"
        ],
        "Category": [
            "Character Functions Returning NumberValues"
        ],
        "Feature": "ASCII(char)\n",
        "Description": [
            "该函数返回字符表达式最左端字符的 ASCII 码值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\nCHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的表达式。\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ASCII('A') A, ASCII('a') a, ASCII(' ') space FROM DUAL;\n+------+------+-------+\n| A    | A    | SPACE |\n+------+------+-------+\n|   65 |   97 |    32 |\n+------+------+-------+\n1 row in set\n",
            "obclient> SELECT ASCII('A') A, ASCII('a') a, ASCII(' ') space,ASCII('中') hz FROM DUAL;\n+------+------+-------+----------+\n| A    | A    | SPACE | HZ       |\n+------+------+-------+----------+\n|   65 |   97 |    32 | 14989485 |\n+------+------+-------+----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 ASCII 函数返回 A 、 a 和空格的 ASCII 码值。",
            "obclient> SELECT ASCII('A') A, ASCII('a') a, ASCII(' ') space FROM DUAL;\n+------+------+-------+\n| A    | A    | SPACE |\n+------+------+-------+\n|   65 |   97 |    32 |\n+------+------+-------+\n1 row in set\n",
            "使用 ASCII 函数返回 A 、 a 、 中 和空格的 ASCII 码值。",
            "obclient> SELECT ASCII('A') A, ASCII('a') a, ASCII(' ') space,ASCII('中') hz FROM DUAL;\n+------+------+-------+----------+\n| A    | A    | SPACE | HZ       |\n+------+------+-------+----------+\n|   65 |   97 |    32 | 14989485 |\n+------+------+-------+----------+\n1 row in set\n"
        ]
    },
    "ASCIISTR": {
        "Title": [
            "ASCIISTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823226"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "ASCIISTR(char)\n",
        "Description": [
            "该函数作用是使用数据库字符集将任何字符集中的字符串转换为 ASCII 字符串。",
            "非 ASCII 字符转换为 \\xxxx 格式，其中 xxxx 表示 UTF-16 代码单元。"
        ],
        "Illustration": [
            "参数 char 是任何字符集中的字符串。",
            "返回一个字符串值。"
        ],
        "Examples": [
            "obclient> SELECT ASCIISTR('A B C ＠ Ä Ê Í Õ Ø') FROM DUAL;\n+-------------------------------------------+\n| ASCIISTR('ABC＠ÄÊÍÕØ')                    |\n+-------------------------------------------+\n| A B C \\FF20 \\00C4 \\00CA \\00CD \\00D5 \\00D8 |\n+-------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 A B C ＠ Ä Ê Í Õ Ø 转化为 ASCII 字符串。",
            "obclient> SELECT ASCIISTR('A B C ＠ Ä Ê Í Õ Ø') FROM DUAL;\n+-------------------------------------------+\n| ASCIISTR('ABC＠ÄÊÍÕØ')                    |\n+-------------------------------------------+\n| A B C \\FF20 \\00C4 \\00CA \\00CD \\00D5 \\00D8 |\n+-------------------------------------------+\n1 row in set\n"
        ]
    },
    "ASIN": {
        "Title": [
            "ASIN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823150"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ASIN(number)\n",
        "Description": [
            "该函数的功能是求反正弦值。反正弦值是指正弦值为number 的角度，返回的角度以弧度表示，弧度值范围为 [-π/2，π/2]。"
        ],
        "Illustration": [
            "number 是一个取值范围在 [-1,1] 的数值数据类型或可以隐式转换为数值数据类型的参数。",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ASIN(0.5) FROM DUAL;\n+-------------------------------------------+\n| ASIN(0.5)                                 |\n+-------------------------------------------+\n| .5235987755982988730771072305465838140329 |\n+-------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0.5 的反正弦值。",
            "obclient> SELECT ASIN(0.5) FROM DUAL;\n+-------------------------------------------+\n| ASIN(0.5)                                 |\n+-------------------------------------------+\n| .5235987755982988730771072305465838140329 |\n+-------------------------------------------+\n1 row in set\n"
        ]
    },
    "ATAN": {
        "Title": [
            "ATAN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823163"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ATAN(number)\n",
        "Description": [
            "该函数用于求反正切值。反正切值是指正切值为number 的角度，返回的角度以弧度表示，弧度值范围为 (-π/2，π/2)。"
        ],
        "Illustration": [
            "number 是一个数值数据类型或可以隐式转换为数值数据类型的参数。",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ATAN(0.5) FROM DUAL;\n+-------------------------------------------+\n| ATAN(0.5)                                 |\n+-------------------------------------------+\n| .4636476090008061162142562314612144020285 |\n+-------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0.5 的反正切值。",
            "obclient> SELECT ATAN(0.5) FROM DUAL;\n+-------------------------------------------+\n| ATAN(0.5)                                 |\n+-------------------------------------------+\n| .4636476090008061162142562314612144020285 |\n+-------------------------------------------+\n1 row in set\n"
        ]
    },
    "ATAN2": {
        "Title": [
            "ATAN2"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823148"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ATAN2(y,x)\n",
        "Description": [
            "该函数返回 y 和 x 的反正切值，即返回的是原点至点 (x,y) 与 x 轴的夹角。返回值的单位是弧度，取值范围为 (-π，π]。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nx\n代表 x 轴坐标的值。\n\n\ny\n代表 y 轴坐标的值。\n\n\n",
            "\n说明\ny 和 x 取值是不同时为 0 的数值数据类型或可以隐式转换为数值数据类型的参数。\n",
            "如果任一参数的类型是 BINARY_FLOAT 或 BINARY_DOUBLE，则该函数返回 BINARY_DOUBLE。否则该函数返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ATAN2(0,-1),ATAN2(0,1),ATAN2(1,0),ATAN2(-1,0) FROM DUAL;\n+-----------------------------------------+------------+-----------------------------------------+------------------------------------------+\n| ATAN2(0,-1)                             | ATAN2(0,1) | ATAN2(1,0)                              | ATAN2(-1,0)                              |\n+-----------------------------------------+------------+-----------------------------------------+------------------------------------------+\n| 3.1415926535897932384626433832795028842 |          0 | 1.5707963267948966192313216916397514421 | -1.5707963267948966192313216916397514421 |\n+-----------------------------------------+------------+-----------------------------------------+------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 (0,-1)、(0,1)、(1,0) 和 (-1,0) 的反正切值。",
            "obclient> SELECT ATAN2(0,-1),ATAN2(0,1),ATAN2(1,0),ATAN2(-1,0) FROM DUAL;\n+-----------------------------------------+------------+-----------------------------------------+------------------------------------------+\n| ATAN2(0,-1)                             | ATAN2(0,1) | ATAN2(1,0)                              | ATAN2(-1,0)                              |\n+-----------------------------------------+------------+-----------------------------------------+------------------------------------------+\n| 3.1415926535897932384626433832795028842 |          0 | 1.5707963267948966192313216916397514421 | -1.5707963267948966192313216916397514421 |\n+-----------------------------------------+------------+-----------------------------------------+------------------------------------------+\n1 row in set\n"
        ]
    },
    "AVG": {
        "Title": [
            "AVG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822875"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "AVG([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数将数值类型或者可以转换成数值类型的表达式作为参数求平均值。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：查询时不去除数据中的重复值，且忽略数据中的 NULL 值。\nDISTINCT：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\nUNIQUE：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\n\n\n\nexpr\n指定要计算的列名。列的数据类型是数值类型或者可以转换成数值类型的表达式。数值类型可以为 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n",
            "返回值与参数 expr 的数据类型相同。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,'a',5),(1,'b',10),(1,'c',15),\n    (2,'d',20),(2,'e',18),(2,'f',12),(3,'a',10),\n    (3,'b',15),(4,'c',15),(4,'a',8);\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | a    |    5 |\n|    1 | b    |   10 |\n|    1 | c    |   15 |\n|    2 | d    |   20 |\n|    2 | e    |   18 |\n|    2 | f    |   12 |\n|    3 | a    |   10 |\n|    3 | b    |   15 |\n|    4 | c    |   15 |\n|    4 | a    |    8 |\n+------+------+------+\n10 rows in set\n",
            "obclient> SELECT AVG(col3) FROM tbl1;\n+-----------+\n| AVG(COL3) |\n+-----------+\n|      12.8 |\n+-----------+\n1 row in set\n",
            "obclient> SELECT col1,col2,col3, AVG(col3)\n              OVER (PARTITION BY col1 ORDER BY col2 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS over_col2\n          FROM tbl1\n          ORDER BY col1,col2,col3;\n+------+------+------+-------------------------------------------+\n| COL1 | COL2 | COL3 | OVER_COL2                                 |\n+------+------+------+-------------------------------------------+\n|    1 | a    |    5 |                                       7.5 |\n|    1 | b    |   10 |                                        10 |\n|    1 | c    |   15 |                                      12.5 |\n|    2 | d    |   20 |                                        19 |\n|    2 | e    |   18 | 16.66666666666666666666666666666666666667 |\n|    2 | f    |   12 |                                        15 |\n|    3 | a    |   10 |                                      12.5 |\n|    3 | b    |   15 |                                      12.5 |\n|    4 | a    |    8 |                                      11.5 |\n|    4 | c    |   15 |                                      11.5 |\n+------+------+------+-------------------------------------------+\n10 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入测试数据。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,'a',5),(1,'b',10),(1,'c',15),\n    (2,'d',20),(2,'e',18),(2,'f',12),(3,'a',10),\n    (3,'b',15),(4,'c',15),(4,'a',8);\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | a    |    5 |\n|    1 | b    |   10 |\n|    1 | c    |   15 |\n|    2 | d    |   20 |\n|    2 | e    |   18 |\n|    2 | f    |   12 |\n|    3 | a    |   10 |\n|    3 | b    |   15 |\n|    4 | c    |   15 |\n|    4 | a    |    8 |\n+------+------+------+\n10 rows in set\n",
            "聚合函数示例",
            "计算 col3 的平均值。",
            "obclient> SELECT AVG(col3) FROM tbl1;\n+-----------+\n| AVG(COL3) |\n+-----------+\n|      12.8 |\n+-----------+\n1 row in set\n",
            "分析函数示例",
            "以 col1 分组及列 col2 升序排序，计算列 col3 中值的之前和之后范围的平均值。",
            "obclient> SELECT col1,col2,col3, AVG(col3)\n              OVER (PARTITION BY col1 ORDER BY col2 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS over_col2\n          FROM tbl1\n          ORDER BY col1,col2,col3;\n+------+------+------+-------------------------------------------+\n| COL1 | COL2 | COL3 | OVER_COL2                                 |\n+------+------+------+-------------------------------------------+\n|    1 | a    |    5 |                                       7.5 |\n|    1 | b    |   10 |                                        10 |\n|    1 | c    |   15 |                                      12.5 |\n|    2 | d    |   20 |                                        19 |\n|    2 | e    |   18 | 16.66666666666666666666666666666666666667 |\n|    2 | f    |   12 |                                        15 |\n|    3 | a    |   10 |                                      12.5 |\n|    3 | b    |   15 |                                      12.5 |\n|    4 | a    |    8 |                                      11.5 |\n|    4 | c    |   15 |                                      11.5 |\n+------+------+------+-------------------------------------------+\n10 rows in set\n"
        ]
    },
    "BITAND": {
        "Title": [
            "BITAND"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823158"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "BITAND (expr1,expr2)\n",
        "Description": [
            "该函数将其输入参数进行二进制按位与操作。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定进行按位与运算的第一个值，是一个 NUMBER 类型表达式。\n\n\nexpr2\n指定进行按位与运算的第二个值，是一个 NUMBER 类型表达式。\n\n\n",
            "\n说明\n\n如果 expr1 和 expr2 有任意一个为 NULL，则返回结果是 NULL。\n如果参数为非整数，那么在进行运算之前转换为整数。\n\n",
            "返回 NUMBER 数据类型或 NULL。"
        ],
        "Examples": [
            "obclient> SELECT BITAND(2,3) FROM DUAL;\n+-------------+\n| BITAND(2,3) |\n+-------------+\n|           2 |\n+-------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "假如 a=2，b=3。a 的二进制为 0100，b 的二进制为 0110。按位比较该二进制，如果相对应的位置都为 1，则该位的值为 1，否则值为 0。",
            "obclient> SELECT BITAND(2,3) FROM DUAL;\n+-------------+\n| BITAND(2,3) |\n+-------------+\n|           2 |\n+-------------+\n1 row in set\n"
        ]
    },
    "CAST": {
        "Title": [
            "CAST"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823229"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "CAST ({ expr | MULTISET (subquery) }  AS type_name )\n",
        "Description": [
            "该函数用于将一种内置数据类型转换为另一种内置数据类型。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n列名或者表达式。\n\n\nMULTISET\n如果 subquery 的结果集可以为多行，则必须指定 MULTISET 关键字。CAST(MULTISET (subquery) ) AS 的结果是集合类型，子查询产生的行被转换为对应的集合元素。如果没有 MULTISET 关键字，子查询将被视为标量子查询。\n\n\nAS\n用于分隔两个参数，在 AS 之前的是要处理的数据，在 AS 之后是要转换的数据类型。\n\n\ntype_name\nOceanBase 数据库的内建数据类型名称。\n\n\n",
            "返回与 type_name 相同的类型。",
            "下表显示了哪些数据类型可以转换为其他内置数据类型：",
            "\n\n\n\nfrom BINARY_FLOAT, BINARY_DOUBLE\nfrom CHAR, VARCHAR2\nfrom NUMBER\nfrom DATETIME/INTERVAL\nfrom RAW\nfrom NCHAR, NVARCHAR2\n\n\n\n\nto BINARY_FLOAT, BINARY_DOUBLE\nyes\nyes\nyes\nno\nno\nyes\n\n\nto CHAR, VARCHAR2\nyes\nyes\nyes\nyes\nyes\nno\n\n\nto NUMBER\nyes\nyes\nyes\nno\nno\nyes\n\n\nto DATETIME, INTERVAL\nno\nyes\nno\nyes\nno\nno\n\n\nto RAW\nyes\nyes\nyes\nno\nyes\nno\n\n\nto NCHAR, NVARCHAR2\nyes\nno\nyes\nyes\nyes\nyes\n\n\n",
            "\n说明\nto DATETIME/INTERVAL 数据类型包括 DATE、TIMESTAMP、TIMESTAMP WITH TIMEZONE、INTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH。\n"
        ],
        "Examples": [
            "obclient> SELECT CAST('123' AS INT),CAST(1 AS VARCHAR2(10)),CAST('22-OCT-2021' AS TIMESTAMP WITH LOCAL TIME ZONE)\n    AS RESULT FROM DUAL;\n+------------------+-----------------------+------------------------------+\n| CAST('123'ASINT) | CAST(1ASVARCHAR2(10)) | RESULT                       |\n+------------------+-----------------------+------------------------------+\n|              123 | 1                     | 22-OCT-21 12.00.00.000000 AM |\n+------------------+-----------------------+------------------------------+\n1 row in set\n",
            "obclient> CREATE OR REPLACE TYPE tbl_int AS TABLE OF INT;\nQuery OK, 0 rows affected\nobclient> CREATE TABLE t1(c1 INT, c2 INT);\nQuery OK, 0 rows affected\nobclient> CREATE TABLE t2(c1 INT, c2 INT);\nQuery OK, 0 rows affected\nobclient> INSERT INTO t1 VALUES (1,1);\nQuery OK, 1 row affected\nobclient> INSERT INTO t2 VALUES (1,2);\nQuery OK, 1 row affected\nobclient> INSERT INTO t2 VALUES (1,3);\nQuery OK, 1 row affected\nobclient> SELECT * FROM t1,TABLE(CAST(MULTISET(SELECT t2.c2 FROM t2 WHERE t1.c1=t2.c1) AS tbl_int));\n+------+------+--------------+\n| C1   | C2   | COLUMN_VALUE |\n+------+------+--------------+\n|    1 |    1 |            2 |\n|    1 |    1 |            3 |\n+------+------+--------------+\n"
        ],
        "Detailed Examples": [
            "如下示例分别将字符型 123 转化为整型、整数 1 转化为 VARCHAR2(10) 类型、将 22-OCT-2021 转化为 TIMESTAMP WITH LOCAL TIME ZONE 类型。",
            "obclient> SELECT CAST('123' AS INT),CAST(1 AS VARCHAR2(10)),CAST('22-OCT-2021' AS TIMESTAMP WITH LOCAL TIME ZONE)\n    AS RESULT FROM DUAL;\n+------------------+-----------------------+------------------------------+\n| CAST('123'ASINT) | CAST(1ASVARCHAR2(10)) | RESULT                       |\n+------------------+-----------------------+------------------------------+\n|              123 | 1                     | 22-OCT-21 12.00.00.000000 AM |\n+------------------+-----------------------+------------------------------+\n1 row in set\n",
            "\n说明\n在转换日期类型的数据时此函数会受 NLS_DATE_FORMAT 参数的影响，建议先执行如下语句更改 NLS_DATE_FORMAT 格式：ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';\n",
            "如下示例为在 Table Function 里使用 MULTISET 获取集合类型的结果。",
            "obclient> CREATE OR REPLACE TYPE tbl_int AS TABLE OF INT;\nQuery OK, 0 rows affected\nobclient> CREATE TABLE t1(c1 INT, c2 INT);\nQuery OK, 0 rows affected\nobclient> CREATE TABLE t2(c1 INT, c2 INT);\nQuery OK, 0 rows affected\nobclient> INSERT INTO t1 VALUES (1,1);\nQuery OK, 1 row affected\nobclient> INSERT INTO t2 VALUES (1,2);\nQuery OK, 1 row affected\nobclient> INSERT INTO t2 VALUES (1,3);\nQuery OK, 1 row affected\nobclient> SELECT * FROM t1,TABLE(CAST(MULTISET(SELECT t2.c2 FROM t2 WHERE t1.c1=t2.c1) AS tbl_int));\n+------+------+--------------+\n| C1   | C2   | COLUMN_VALUE |\n+------+------+--------------+\n|    1 |    1 |            2 |\n|    1 |    1 |            3 |\n+------+------+--------------+\n"
        ]
    },
    "CEIL": {
        "Title": [
            "CEIL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823149"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "CEIL (numeric_expression)\n",
        "Description": [
            "该函数返回大于等于 numeric_expression 的最小整数。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nnumeric_expression\n精确数值或近似数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）的表达式。\n\n\n",
            "返回类型与参数 numeric_expression 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT CEIL(-1.5),CEIL(1.5),CEIL(2),CEIL(6-9.5) FROM DUAL;\n+------------+-----------+---------+-------------+\n| CEIL(-1.5) | CEIL(1.5) | CEIL(2) | CEIL(6-9.5) |\n+------------+-----------+---------+-------------+\n|         -1 |         2 |       2 |          -3 |\n+------------+-----------+---------+-------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回大于或等于 -1.5、1.5、2 和 6-9.5 的最小整数。",
            "obclient> SELECT CEIL(-1.5),CEIL(1.5),CEIL(2),CEIL(6-9.5) FROM DUAL;\n+------------+-----------+---------+-------------+\n| CEIL(-1.5) | CEIL(1.5) | CEIL(2) | CEIL(6-9.5) |\n+------------+-----------+---------+-------------+\n|         -1 |         2 |       2 |          -3 |\n+------------+-----------+---------+-------------+\n1 row in set\n"
        ]
    },
    "CHARTOROWID": {
        "Title": [
            "CHARTOROWID"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823232"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "CHARTOROWID(char)\n",
        "Description": [
            "该函数作用是将 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 类型的字符串转换为 ROWID 数据类型。"
        ],
        "Illustration": [
            "参数 char 是符合 ROWID 格式的字符串，例如 \"*AAIKAQAAAAAAAAA=\"。",
            "返回 ROWID 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT CHARTOROWID('*AAIKAQAAAAAAAA/=') FROM DUAL;\n+----------------------------------+\n| CHARTOROWID('*AAIKAQAAAAAAAA/=') |\n+----------------------------------+\n| *AAIKAQAAAAAAAA8=                |\n+----------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 *AAIKAQAAAAAAAA/= 转换为 ROWID 数据类型的值。",
            "obclient> SELECT CHARTOROWID('*AAIKAQAAAAAAAA/=') FROM DUAL;\n+----------------------------------+\n| CHARTOROWID('*AAIKAQAAAAAAAA/=') |\n+----------------------------------+\n| *AAIKAQAAAAAAAA8=                |\n+----------------------------------+\n1 row in set\n"
        ]
    },
    "CHR": {
        "Title": [
            "CHR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823189"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "CHR(n)\n",
        "Description": [
            "该函数根据数字参数返回字符，且返回值与当前系统的字符集相关。"
        ],
        "Illustration": [
            "参数 n 用于检索对应字符的 NUMBER 代码。是一个整数值，范围为 [0，4294967295]。",
            "返回值与当前系统的字符集相关。而 OceanBase 数据库支持的字符集是 binary、utf8mb4、gbk、utf16、gb18030。"
        ],
        "Examples": [
            "obclient> SELECT CHR(25700) AS str FROM DUAL;\n+------+\n| STR  |\n+------+\n| dd   |\n+------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将十进制数 25700 转换为对应字符，字符集为 UTF-8。",
            "obclient> SELECT CHR(25700) AS str FROM DUAL;\n+------+\n| STR  |\n+------+\n| dd   |\n+------+\n1 row in set\n"
        ]
    },
    "COALESCE": {
        "Title": [
            "COALESCE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823252"
        ],
        "Category": [
            "NULL-Related Functions"
        ],
        "Feature": "COALESCE (expr [, expr]...)\n",
        "Description": [
            "该函数返回参数列表中第一个非空表达式，必须指定最少两个参数。"
        ],
        "Illustration": [
            "expr 可以是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE）或字符数据类型（ CHAR、VARCHAR2、NCHAR 或 NVARCHAR2）的值或表达式。",
            "\n说明\n参数列表中的值除了非空表达式外，数据类型必须一致。\n",
            "返回类型与参数列表中第一个非空表达式 expr 的数据类型相同。",
            "如果所有的参数都是 NULL，则返回 NULL。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(supplier_id INT, product_id INT,list_price NUMERIC,min_price NUMERIC);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES ('102050', '1659', '45', NULL),('102050', '1770', NULL, '70'),\n    ('102050', '2370', '305', '247'),('102050', '2380', '750', '731'),('102050', '3255', NULL, NULL);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT product_id, list_price,min_price,COALESCE(0.8*list_price, min_price, 10) \"Sale\" FROM tbl1;\n+------------+------------+-----------+------+\n| PRODUCT_ID | LIST_PRICE | MIN_PRICE | Sale |\n+------------+------------+-----------+------+\n|       1659 |         45 |      NULL |   36 |\n|       1770 |       NULL |        70 |   70 |\n|       2370 |        305 |       247 |  244 |\n|       2380 |        750 |       731 |  600 |\n|       3255 |       NULL |      NULL |   10 |\n+------------+------------+-----------+------+\n5 rows in set\n"
        ],
        "Detailed Examples": [
            "创建一张表 tbl1，product_id 为商品 ID，list_price 为该商品原价，min_price 为商品最低价，Sale 为商品实际售价。设置商品折扣为 8 折，计算各商品的实际售价。此时可使用 COALESCE 函数，如果 list_price 为空，就按最低价 min_price 计算；如果 min_price 也为空，则按 10 计算。",
            "obclient> CREATE TABLE tbl1(supplier_id INT, product_id INT,list_price NUMERIC,min_price NUMERIC);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES ('102050', '1659', '45', NULL),('102050', '1770', NULL, '70'),\n    ('102050', '2370', '305', '247'),('102050', '2380', '750', '731'),('102050', '3255', NULL, NULL);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT product_id, list_price,min_price,COALESCE(0.8*list_price, min_price, 10) \"Sale\" FROM tbl1;\n+------------+------------+-----------+------+\n| PRODUCT_ID | LIST_PRICE | MIN_PRICE | Sale |\n+------------+------------+-----------+------+\n|       1659 |         45 |      NULL |   36 |\n|       1770 |       NULL |        70 |   70 |\n|       2370 |        305 |       247 |  244 |\n|       2380 |        750 |       731 |  600 |\n|       3255 |       NULL |      NULL |   10 |\n+------------+------------+-----------+------+\n5 rows in set\n"
        ]
    },
    "CONCAT": {
        "Title": [
            "CONCAT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823181"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "CONCAT(char1,char2)\n",
        "Description": [
            "该函数可以连接两个字符串。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n字符串，字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nchar2\n字符串，字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\n",
            "返回与 char1 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT CONCAT('Hello',', world!') FROM DUAL;\n+---------------------------+\n| CONCAT('HELLO',',WORLD!') |\n+---------------------------+\n| Hello, world!             |\n+---------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "连接字符串 Hello 和字符串 , world!。",
            "obclient> SELECT CONCAT('Hello',', world!') FROM DUAL;\n+---------------------------+\n| CONCAT('HELLO',',WORLD!') |\n+---------------------------+\n| Hello, world!             |\n+---------------------------+\n1 row in set\n"
        ]
    },
    "CONVERT": {
        "Title": [
            "CONVERT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823239"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "CONVERT(char, dest_char_set[, source_char_set])\n",
        "Description": [
            "该函数用于将字符串从一种字符集转换为另一种字符集。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\n要转换的字符串。可以是任何数据类型，例如 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\ndest_char_set\n字符串要转换到的字符集名称。\n\n\nsource_char_set\n字符串存储在数据库中的字符集名称。如果不指定，默认值为数据库字符集。\n\n\n",
            "如果 char 的数据类型为 CHAR 或 VARCHAR2，则返回 VARCHAR2 类型。",
            "如果 char 的数据类型为 NCHAR 或 NVARCHAR2，则返回 NVARCHAR2 类型。",
            "如果 char 的数据类型为 CLOB，则返回 CLOB 类型。"
        ],
        "Examples": [
            "obclient> SELECT CONVERT('Ä Ê Í a b c d', 'ZHS16GBK') FROM DUAL;\n+----------------------------------+\n| CONVERT('ÄÊÍABCD','ZHS16GBK')    |\n+----------------------------------+\n| ? ? ? a b c d                    |\n+----------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 Ä Ê Í a b c d 转换为 ZHS16GBK 字符集。",
            "obclient> SELECT CONVERT('Ä Ê Í a b c d', 'ZHS16GBK') FROM DUAL;\n+----------------------------------+\n| CONVERT('ÄÊÍABCD','ZHS16GBK')    |\n+----------------------------------+\n| ? ? ? a b c d                    |\n+----------------------------------+\n1 row in set\n"
        ]
    },
    "CORR": {
        "Title": [
            "CORR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822865"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "CORR(expr1, expr2) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数用于计算一组数值对的相关系数。相关系数代表数值对的关联强度，范围为 [-1,1]，其中 0 表示不相关，小于 0 代表负相关，大于 0 代表正相关。可以将该函数用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个参数，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个参数，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果。\n返回结果计算公式为：COVAR_POP(expr1, expr2) / (STDDEV_POP(expr1) * STDDEV_POP(expr2))。\n\n",
            "如果有任意一个参数为空或只有一行数据，则返回 NULL。否则返回一个 NUMBER 类型的值。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "obclient> SELECT CORR(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n",
            "obclient> SELECT col1,col3,col4,CORR(col3,col4) OVER(PARTITION BY col1) \"corr\" FROM tbl1;\n+------+------+------+--------------------------------------------+\n| COL1 | COL3 | COL4 | corr                                       |\n+------+------+------+--------------------------------------------+\n|    1 |    8 |   12 |  .9958705948858223809835060513429288056548 |\n|    1 |   10 |   15 |  .9958705948858223809835060513429288056548 |\n|    1 |   11 |   16 |  .9958705948858223809835060513429288056548 |\n|    2 |    9 |   14 |                                          1 |\n|    2 |   10 |   15 |                                          1 |\n|    2 |    8 |   13 |                                          1 |\n|    2 |   11 |   16 |                                          1 |\n|    3 |    8 |   18 | -.9901475429766743091532731291244706579003 |\n|    3 |    9 |   16 | -.9901475429766743091532731291244706579003 |\n|    3 |   10 |   15 | -.9901475429766743091532731291244706579003 |\n|    3 |   11 |   12 | -.9901475429766743091532731291244706579003 |\n|    3 |   12 |   10 | -.9901475429766743091532731291244706579003 |\n+------+------+------+--------------------------------------------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入数据。",
            "obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "计算列 col3 的数据与列 col4 的数据相关系数。",
            "obclient> SELECT CORR(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col1 分组，计算列 col3 的数据与列 col4 的数据相关系数。",
            "obclient> SELECT col1,col3,col4,CORR(col3,col4) OVER(PARTITION BY col1) \"corr\" FROM tbl1;\n+------+------+------+--------------------------------------------+\n| COL1 | COL3 | COL4 | corr                                       |\n+------+------+------+--------------------------------------------+\n|    1 |    8 |   12 |  .9958705948858223809835060513429288056548 |\n|    1 |   10 |   15 |  .9958705948858223809835060513429288056548 |\n|    1 |   11 |   16 |  .9958705948858223809835060513429288056548 |\n|    2 |    9 |   14 |                                          1 |\n|    2 |   10 |   15 |                                          1 |\n|    2 |    8 |   13 |                                          1 |\n|    2 |   11 |   16 |                                          1 |\n|    3 |    8 |   18 | -.9901475429766743091532731291244706579003 |\n|    3 |    9 |   16 | -.9901475429766743091532731291244706579003 |\n|    3 |   10 |   15 | -.9901475429766743091532731291244706579003 |\n|    3 |   11 |   12 | -.9901475429766743091532731291244706579003 |\n|    3 |   12 |   10 | -.9901475429766743091532731291244706579003 |\n+------+------+------+--------------------------------------------+\n12 rows in set\n"
        ]
    },
    "COS": {
        "Title": [
            "COS"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823147"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "COS(x)\n",
        "Description": [
            "该函数是余弦函数，用于计算参数角度的余弦值。返回值范围为 [-1,1]。"
        ],
        "Illustration": [
            "x 是取值为任意实数（以弧度表示的角度）的数值数据类型或可以隐式转换为数值数据类型的参数。",
            "如果参数 x 数据类型是 BINARY_FLOAT，则该函数返回 BINARY_DOUBLE 数据类型。否则，该函数返回与参数 x 相同的数值数据类型。"
        ],
        "Examples": [
            "obclient> SELECT COS(0) FROM DUAL;\n+--------+\n| COS(0) |\n+--------+\n|      1 |\n+--------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0 度角的余弦值。",
            "obclient> SELECT COS(0) FROM DUAL;\n+--------+\n| COS(0) |\n+--------+\n|      1 |\n+--------+\n1 row in set\n"
        ]
    },
    "COSH": {
        "Title": [
            "COSH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823156"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "COSH(number)\n",
        "Description": [
            "该函数是双曲余弦函数，返回数字参数的双曲余弦值。返回值范围是 [1,+∞)。"
        ],
        "Illustration": [
            "number 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "如果参数 number 是 BINARY_FLOAT 类型，则返回类型是 BINARY_DOUBLE。否则，返回与参数 number 相同的数值数据类型。"
        ],
        "Examples": [
            "obclient> SELECT COSH(0) FROM DUAL;\n+---------+\n| COSH(0) |\n+---------+\n|       1 |\n+---------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0 的双曲余弦值。",
            "obclient> SELECT COSH(0) FROM DUAL;\n+---------+\n| COSH(0) |\n+---------+\n|       1 |\n+---------+\n1 row in set\n"
        ]
    },
    "COUNT": {
        "Title": [
            "COUNT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822887"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "COUNT({ * | [ DISTINCT | UNIQUE | ALL ] expr }) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数用于返回查询 expr 的行数。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\n*\n表示返回满足条件的所有行，且包含重复行和空行。\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略空行。\nDISTINCT：返回的行中去除重复行，且忽略空行。\nUNIQUE：返回的行中去除重复行，且忽略空行。\n\n\n\nexpr\n指定参与计算的列名。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n注意\n\n对于 COUNT 函数，从不返回 NULL，如果指定了 expr，即返回 expr 不为 NULL 的统计个数，如果指定 COUNT(*) 返回所有行的统计数目。使用参数 DISTINCT 、UNIQUE 或 ALL 时需要与 expr 用空格隔开。\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n\n",
            "返回一个自然数。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES\n    (1,'aa',10),(2,'bb',12),(3,'cc',15),(4,'dd',18),(5,'ee',20),\n    (6,'ff',23),(7,'gg',25),(8,'hh',30),(9,'ii',40),(10,'jj',15),\n    (11,'kk',NULL),(12,'oo',NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | aa   |   10 |\n|    2 | bb   |   12 |\n|    3 | cc   |   15 |\n|    4 | dd   |   18 |\n|    5 | ee   |   20 |\n|    6 | ff   |   23 |\n|    7 | gg   |   25 |\n|    8 | hh   |   30 |\n|    9 | ii   |   40 |\n|   10 | jj   |   15 |\n|   11 | kk   | NULL |\n|   12 | oo   | NULL |\n+------+------+------+\n12 rows in set\n",
            "obclient> SELECT COUNT(col3),COUNT(*) FROM tbl1;\n+-------------+----------+\n| COUNT(COL3) | COUNT(*) |\n+-------------+----------+\n|          10 |       12 |\n+-------------+----------+\n1 row in set\n",
            "obclient> SELECT col1,col2,\n                 COUNT(*) OVER (ORDER BY col3 RANGE BETWEEN 1 PRECEDING AND 3 FOLLOWING) AS mov_count\n          FROM tbl1;\n+------+------+-----------+\n| COL1 | COL2 | MOV_COUNT |\n+------+------+-----------+\n|    1 | aa   |         2 |\n|    2 | bb   |         3 |\n|    3 | cc   |         3 |\n|   10 | jj   |         3 |\n|    4 | dd   |         2 |\n|    5 | ee   |         2 |\n|    6 | ff   |         2 |\n|    7 | gg   |         1 |\n|    8 | hh   |         1 |\n|    9 | ii   |         1 |\n|   11 | kk   |         2 |\n|   12 | oo   |         2 |\n+------+------+-----------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入测试数据。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 varchar(10),col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES\n    (1,'aa',10),(2,'bb',12),(3,'cc',15),(4,'dd',18),(5,'ee',20),\n    (6,'ff',23),(7,'gg',25),(8,'hh',30),(9,'ii',40),(10,'jj',15),\n    (11,'kk',NULL),(12,'oo',NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | aa   |   10 |\n|    2 | bb   |   12 |\n|    3 | cc   |   15 |\n|    4 | dd   |   18 |\n|    5 | ee   |   20 |\n|    6 | ff   |   23 |\n|    7 | gg   |   25 |\n|    8 | hh   |   30 |\n|    9 | ii   |   40 |\n|   10 | jj   |   15 |\n|   11 | kk   | NULL |\n|   12 | oo   | NULL |\n+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "求表 tbl1 列 col3 的非空行数和表 tbl1 的总行数。",
            "obclient> SELECT COUNT(col3),COUNT(*) FROM tbl1;\n+-------------+----------+\n| COUNT(COL3) | COUNT(*) |\n+-------------+----------+\n|          10 |       12 |\n+-------------+----------+\n1 row in set\n",
            "分析函数示例",
            "求表 tbl1 中所有以 col3 中值排序并且的偏移量在 1 至 3 范围内的个数。",
            "obclient> SELECT col1,col2,\n                 COUNT(*) OVER (ORDER BY col3 RANGE BETWEEN 1 PRECEDING AND 3 FOLLOWING) AS mov_count\n          FROM tbl1;\n+------+------+-----------+\n| COL1 | COL2 | MOV_COUNT |\n+------+------+-----------+\n|    1 | aa   |         2 |\n|    2 | bb   |         3 |\n|    3 | cc   |         3 |\n|   10 | jj   |         3 |\n|    4 | dd   |         2 |\n|    5 | ee   |         2 |\n|    6 | ff   |         2 |\n|    7 | gg   |         1 |\n|    8 | hh   |         1 |\n|    9 | ii   |         1 |\n|   11 | kk   |         2 |\n|   12 | oo   |         2 |\n+------+------+-----------+\n12 rows in set\n"
        ]
    },
    "COVAR_POP": {
        "Title": [
            "COVAR_POP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822864"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "COVAR_POP(expr1, expr2)[ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数用于计算一组数值对的总体协方差。可以将该函数用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果，即 COVAR_POP(expr1, expr2) 等于 COVAR_POP(expr2, expr1)。\n返回结果计算公式为：(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n，其中 n 是（expr1,expr2）表达式对的数量，expr1 和 expr2 均不为空。\n\n",
            "如果有任意一个参数为空，则返回 NULL；否则返回一个 NUMBER 类型的值。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "obclient> SELECT COVAR_POP(col3,col4) FROM tbl1;\n+----------------------+\n| COVAR_POP(COL3,COL4) |\n+----------------------+\n|                 -.75 |\n+----------------------+\n1 row in set\n",
            "obclient> SELECT col1,col3,col4,\n            COVAR_POP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_POP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_POP                                 |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                         0 |\n|    1 |   10 |   15 |                                       1.5 |\n|    1 |   11 |   16 |    2.111111111111111111111111111111111111 |\n|    2 |    9 |   14 |                                         0 |\n|    2 |   10 |   15 |                                       .25 |\n|    2 |    8 |   13 | .6666666666666666666666666666666666666667 |\n|    2 |   11 |   16 |                                      1.25 |\n|    3 |    8 |   18 |                                         0 |\n|    3 |    9 |   16 |                                       -.5 |\n|    3 |   10 |   15 |                                        -1 |\n|    3 |   11 |   12 |                                    -2.375 |\n|    3 |   12 |   10 |                                        -4 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "计算数值对列 col3 与列 col4 的总体协方差。",
            "obclient> SELECT COVAR_POP(col3,col4) FROM tbl1;\n+----------------------+\n| COVAR_POP(COL3,COL4) |\n+----------------------+\n|                 -.75 |\n+----------------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col1 分组和列 col2 排序，计算数值对列 col3 的数据与列 col4 的累计总体协方差。",
            "obclient> SELECT col1,col3,col4,\n            COVAR_POP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_POP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_POP                                 |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                         0 |\n|    1 |   10 |   15 |                                       1.5 |\n|    1 |   11 |   16 |    2.111111111111111111111111111111111111 |\n|    2 |    9 |   14 |                                         0 |\n|    2 |   10 |   15 |                                       .25 |\n|    2 |    8 |   13 | .6666666666666666666666666666666666666667 |\n|    2 |   11 |   16 |                                      1.25 |\n|    3 |    8 |   18 |                                         0 |\n|    3 |    9 |   16 |                                       -.5 |\n|    3 |   10 |   15 |                                        -1 |\n|    3 |   11 |   12 |                                    -2.375 |\n|    3 |   12 |   10 |                                        -4 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"
        ]
    },
    "COVAR_SAMP": {
        "Title": [
            "COVAR_SAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822876"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "COVAR_SAMP(expr1, expr2) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数用于计算一组数值对的样本协方差。可以将该函数用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nexpr2\n指定第二个数值表达式，属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\n\n数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。\n参数 expr1 和 expr2 的位置不影响返回结果，即 COVAR_POP(expr1, expr2) 等于 COVAR_POP(expr2, expr1)。\n返回结果计算公式为：(SUM(expr1 * expr2) - SUM(expr1) * SUM(expr2) / n) / (n-1)，其中 n 是（expr1,expr2）表达式对的数量，expr1 和 expr2 均不为空。\n\n",
            "如果有任意一个参数为空或只有一行数据，则返回 NULL；否则返回一个 NUMBER 类型的值。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "obclient> SELECT COVAR_SAMP(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n",
            "obclient> SELECT col1,col3,col4,\n            COVAR_SAMP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_SAMP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_SAMP                                |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                      NULL |\n|    1 |   10 |   15 |                                         3 |\n|    1 |   11 |   16 |   3.1666666666666666666666666666666666665 |\n|    2 |    9 |   14 |                                      NULL |\n|    2 |   10 |   15 |                                        .5 |\n|    2 |    8 |   13 |                                         1 |\n|    2 |   11 |   16 |  1.66666666666666666666666666666666666667 |\n|    3 |    8 |   18 |                                      NULL |\n|    3 |    9 |   16 |                                        -1 |\n|    3 |   10 |   15 |                                      -1.5 |\n|    3 |   11 |   12 | -3.16666666666666666666666666666666666667 |\n|    3 |   12 |   10 |                                        -5 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "计算数值对列 col3 与列 col4 的样本协方差。",
            "obclient> SELECT COVAR_SAMP(col3,col4) FROM tbl1;\n+--------------------------------------------+\n| CORR(COL3,COL4)                            |\n+--------------------------------------------+\n| -.2705008904002296868793073195758520224002 |\n+--------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col1 分组和列 col2 排序，计算数值对列 col3 的数据与列 col4 的累计样本协方差。",
            "obclient> SELECT col1,col3,col4,\n            COVAR_SAMP(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"COVAR_SAMP\"\n          FROM tbl1;\n+------+------+------+-------------------------------------------+\n| COL1 | COL3 | COL4 | COVAR_SAMP                                |\n+------+------+------+-------------------------------------------+\n|    1 |    8 |   12 |                                      NULL |\n|    1 |   10 |   15 |                                         3 |\n|    1 |   11 |   16 |   3.1666666666666666666666666666666666665 |\n|    2 |    9 |   14 |                                      NULL |\n|    2 |   10 |   15 |                                        .5 |\n|    2 |    8 |   13 |                                         1 |\n|    2 |   11 |   16 |  1.66666666666666666666666666666666666667 |\n|    3 |    8 |   18 |                                      NULL |\n|    3 |    9 |   16 |                                        -1 |\n|    3 |   10 |   15 |                                      -1.5 |\n|    3 |   11 |   12 | -3.16666666666666666666666666666666666667 |\n|    3 |   12 |   10 |                                        -5 |\n+------+------+------+-------------------------------------------+\n12 rows in set\n"
        ]
    },
    "CUME_DIST": {
        "Title": [
            "CUME_DIST"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822886"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "/*聚合语法*/\nCUME_DIST( expr[,expr]...)\n  WITHIN GROUP (ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                       [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n          )\n\n/*分析语法*/\nCUME_DIST() OVER ([ query_partition_clause ] order_by_clause)\n",
        "Description": [
            "该函数用于计算一组值中的某个值的累积分布，返回值的范围为 (0,1]。可以将此函数用作聚合或分析函数。",
            "\n说明\n\n作为分析函数，该函数计算指定值在一组值中的相对位置。对于行 row，假设按升序排列，row 的 cume_dist 是值低于或等于 row 值的行数除以被计算的行数（整个查询结果集或分区）。\n作为聚合函数，该函数的参数标识每个聚合组中的单个假设行。因此，它们必须全部计算为每个聚合组内的常量表达式。常量参数表达式和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的类型必须兼容。如果指定值与分组序列中某值重复，则将两个重复的值视为一个值处理。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 ASC 为升序排序，为默认值。 DESC 为降序排序。\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 NULLS FIRST 表示 NULL 值排在非空值的前面。 NULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回值为 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "obclient> SELECT CUME_DIST(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+----------------------------------------+\n| CUME_DIST(3300)WITHINGROUP(ORDERBYSAL) |\n+----------------------------------------+\n|                                  .9375 |\n+----------------------------------------+\n1 row in set\n",
            "obclient> SELECT deptno,ename,sal,\n              CUME_DIST ( ) over (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | RANK                                      |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 | .3333333333333333333333333333333333333333 |\n|     10 | CLARK  | 2750 | .6666666666666666666666666666666666666667 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                        .4 |\n|     20 | SCOTT  | 3300 |                                        .4 |\n|     20 | JONES  | 3275 |                                        .6 |\n|     20 | ADAMS  | 1400 |                                        .8 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 | .1428571428571428571428571428571428571429 |\n|     30 | ALLEN  | 1900 | .2857142857142857142857142857142857142857 |\n|     30 | TURNER | 1800 | .4285714285714285714285714285714285714286 |\n|     30 | SCLARK | 1750 | .5714285714285714285714285714285714285714 |\n|     30 | MARTIN | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | WARD   | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "返回 3300 在列 sal 中的位置。",
            "obclient> SELECT CUME_DIST(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+----------------------------------------+\n| CUME_DIST(3300)WITHINGROUP(ORDERBYSAL) |\n+----------------------------------------+\n|                                  .9375 |\n+----------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 deptno 分组及列 sal 降序排序，返回列 sal 中各值的位置。",
            "obclient> SELECT deptno,ename,sal,\n              CUME_DIST ( ) over (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | RANK                                      |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 | .3333333333333333333333333333333333333333 |\n|     10 | CLARK  | 2750 | .6666666666666666666666666666666666666667 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                        .4 |\n|     20 | SCOTT  | 3300 |                                        .4 |\n|     20 | JONES  | 3275 |                                        .6 |\n|     20 | ADAMS  | 1400 |                                        .8 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 | .1428571428571428571428571428571428571429 |\n|     30 | ALLEN  | 1900 | .2857142857142857142857142857142857142857 |\n|     30 | TURNER | 1800 | .4285714285714285714285714285714285714286 |\n|     30 | SCLARK | 1750 | .5714285714285714285714285714285714285714 |\n|     30 | MARTIN | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | WARD   | 1550 | .8571428571428571428571428571428571428571 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"
        ]
    },
    "CURRENT_DATE": {
        "Title": [
            "CURRENT_DATE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823128"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "CURRENT_DATE\n",
        "Description": [
            "该函数返回当前会话时区的当前日期。"
        ],
        "Illustration": [
            "返回 DATE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT CURRENT_DATE FROM DUAL;\n+--------------+\n| CURRENT_DATE |\n+--------------+\n| 17-NOV-21    |\n+--------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 CURRENT_DATE 函数返回当前时区日期。",
            "obclient> SELECT CURRENT_DATE FROM DUAL;\n+--------------+\n| CURRENT_DATE |\n+--------------+\n| 17-NOV-21    |\n+--------------+\n1 row in set\n"
        ]
    },
    "CURRENT_TIMESTAMP": {
        "Title": [
            "CURRENT_TIMESTAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823132"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "CURRENT_TIMESTAMP[ (precision）]\n",
        "Description": [
            "该函数返回当前会话时区中的当前日期，返回值中包含当前的时区信息。"
        ],
        "Illustration": [
            "precision 表示秒小数位的精度，取整数值，范围为 [0,9]，为可选项。默认值为 6。",
            "返回包含当前的时区信息的 TIMESTAMP WITH TIME ZONE 数据类型。"
        ],
        "Examples": [
            "obclient> ALTER SESSION SET TIME_ZONE = '-05:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT CURRENT_TIMESTAMP(2) FROM DUAL;\n+---------------------------------+\n| CURRENT_TIMESTAMP(2)            |\n+---------------------------------+\n| 17-NOV-21 04.22.51.13 AM -05:00 |\n+---------------------------------+\n1 row in set\n",
            "obclient> ALTER SESSION SET TIME_ZONE = '+08:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT CURRENT_TIMESTAMP(2) FROM DUAL;\n+---------------------------------+\n| CURRENT_TIMESTAMP(2)            |\n+---------------------------------+\n| 17-NOV-21 05.23.01.92 PM +08:00 |\n+---------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "设置当前会话时区至 GMT-5 时区，返回当前会话的时间及会话时区信息，且调整秒的小数位精度为 2。",
            "obclient> ALTER SESSION SET TIME_ZONE = '-05:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT CURRENT_TIMESTAMP(2) FROM DUAL;\n+---------------------------------+\n| CURRENT_TIMESTAMP(2)            |\n+---------------------------------+\n| 17-NOV-21 04.22.51.13 AM -05:00 |\n+---------------------------------+\n1 row in set\n",
            "设置当前会话时区至 GMT+8 时区，返回当前会话的时间及会话时区信息，且调整秒的小数位精度为 2。",
            "obclient> ALTER SESSION SET TIME_ZONE = '+08:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT CURRENT_TIMESTAMP(2) FROM DUAL;\n+---------------------------------+\n| CURRENT_TIMESTAMP(2)            |\n+---------------------------------+\n| 17-NOV-21 05.23.01.92 PM +08:00 |\n+---------------------------------+\n1 row in set\n"
        ]
    },
    "DBTIMEZONE": {
        "Title": [
            "DBTIMEZONE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823124"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "DBTIMEZONE\n",
        "Description": [
            "该函数返回当前数据库实例的时区，OceanBase 数据库的时区恒为+00:00，且不支持修改。"
        ],
        "Illustration": [
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT DBTIMEZONE FROM DUAL;\n+------------+\n| DBTIMEZONE |\n+------------+\n| +00:00     |\n+------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回当前数据库实例的时区。",
            "obclient> SELECT DBTIMEZONE FROM DUAL;\n+------------+\n| DBTIMEZONE |\n+------------+\n| +00:00     |\n+------------+\n1 row in set\n"
        ]
    },
    "DECODE": {
        "Title": [
            "DECODE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823114"
        ],
        "Category": [
            "Encoding and Decoding Functions"
        ],
        "Feature": "DECODE (condition, search, result [, search, result ...][, default])\n",
        "Description": [
            "该函数功能是将 condition 与每个 search 依次做比较，并返回对比结果。",
            "如果有一个或多个 search 与 condition 的值相等，则返回首个与 condition 的值相等的 search 后跟随的 result 的值。",
            "如果没有 search 与 condition 相等，则返回参数 default 的值。如果省略参数 default 的值，则返回 null。"
        ],
        "Illustration": [
            "condition、search、result 和 default 可以是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE）或字符数据类型（ CHAR、VARCHAR2、NCHAR 或 NVARCHAR2）的值或表达式。",
            "\n注意\n如果第一个 result 是数值数据类型，则返回 result 或 default 也必须是数值数据类型，否则报错。\n",
            "如果首个与 condition 的值相等的 search 后跟随的 result 的数据类型是 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2，则返回 VARCHAR2 数据类型。",
            "如果首个与 condition 的值相等的 search 后跟随的 result 的数据类型是数值数据类型，则返回该参数 result 数据类型。",
            "如果所有 search 与 condition 都不相等时：",
            "\n如果省略参数 default 的值，则返回 null。\n如果参数 default 的数据类型是 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2，则返回 VARCHAR2 数据类型。\n",
            "如果省略参数 default 的值，则返回 null。",
            "如果参数 default 的数据类型是 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2，则返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT DECODE(SIGN((5*3-2)-(3*4-1)),0,'相等',1,'(5*3-2)大','(3*4-1)大') FROM DUAL;\n+----------------------------------------------------------------------+\n| DECODE(SIGN((5*3-2)-(3*4-1)),0,'相等',1,'(5*3-2)大','(3*4-1)大')     |\n+----------------------------------------------------------------------+\n| (5*3-2)大                                                            |\n+----------------------------------------------------------------------+\n1 row in set\n",
            "obclient> SELECT\n    DECODE(INSTR('CLARK','S'), 0, '不含有 S', '含有 S') \"CLARK\",\n    DECODE(INSTR('KING','S'), 0, '不含有 S', '含有 S') \"KING\",\n    DECODE(INSTR('MILLER','S'), 0, '不含有 S', '含有 S') \"MILLER\",\n    DECODE(INSTR('ADAMS','S'), 0, '不含有 S', '含有 S') \"ADAMS\",\n    DECODE(INSTR('FORD','S'), 0, '不含有 S', '含有 S') \"FORD\",\n    DECODE(INSTR('JONES','S'), 0, '不含有 S', '含有 S') \"JONES\"\n    FROM DUAL;\n+-------------+-------------+-------------+----------+-------------+----------+\n| CLARK       | KING        | MILLER      | ADAMS    | FORD        | JONES    |\n+-------------+-------------+-------------+----------+-------------+----------+\n| 不含有 S    | 不含有 S    | 不含有 S    | 含有 S   | 不含有 S    | 含有 S   |\n+-------------+-------------+-------------+----------+-------------+----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 DECODE 比较 5*3-2 与 3*4-1 数值的大小。",
            "obclient> SELECT DECODE(SIGN((5*3-2)-(3*4-1)),0,'相等',1,'(5*3-2)大','(3*4-1)大') FROM DUAL;\n+----------------------------------------------------------------------+\n| DECODE(SIGN((5*3-2)-(3*4-1)),0,'相等',1,'(5*3-2)大','(3*4-1)大')     |\n+----------------------------------------------------------------------+\n| (5*3-2)大                                                            |\n+----------------------------------------------------------------------+\n1 row in set\n",
            "使用 DECODE 函数查看数据中是否包含字符 S。",
            "obclient> SELECT\n    DECODE(INSTR('CLARK','S'), 0, '不含有 S', '含有 S') \"CLARK\",\n    DECODE(INSTR('KING','S'), 0, '不含有 S', '含有 S') \"KING\",\n    DECODE(INSTR('MILLER','S'), 0, '不含有 S', '含有 S') \"MILLER\",\n    DECODE(INSTR('ADAMS','S'), 0, '不含有 S', '含有 S') \"ADAMS\",\n    DECODE(INSTR('FORD','S'), 0, '不含有 S', '含有 S') \"FORD\",\n    DECODE(INSTR('JONES','S'), 0, '不含有 S', '含有 S') \"JONES\"\n    FROM DUAL;\n+-------------+-------------+-------------+----------+-------------+----------+\n| CLARK       | KING        | MILLER      | ADAMS    | FORD        | JONES    |\n+-------------+-------------+-------------+----------+-------------+----------+\n| 不含有 S    | 不含有 S    | 不含有 S    | 含有 S   | 不含有 S    | 含有 S   |\n+-------------+-------------+-------------+----------+-------------+----------+\n1 row in set\n"
        ]
    },
    "DELETEXML": {
        "Title": [
            "DELETEXML"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823514"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "DELETEXML( XMLType_instance, XPath_string [, namespace_string ])\n",
        "Description": [
            "该函数用于删除 XPath 表达式在 XML 中匹配的一个或多个节点。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n指定一个 XMLType 实例，表示目标 XML 文档。\n\n\nXPath_string\n指定一个 XPath 表达式，指示要删除的一个或多个节点。可以使用绝对路径（以斜杠开头）或相对路径（省略初始斜杠）。如果省略初始斜杠，则相对路径的上下文默认为根节点。XPath_string 指定的节点的所有子节点也将被删除。\n\n\nnamespace_string\n可选项，用于为 XPath_string 提供命名空间信息。\n\n\n",
            "返回 XMLType 数据类型。"
        ],
        "Examples": [
            "SELECT DELETEXML(\n        XMLtype('<bookstore>\n                  <book att=\"old\"></book>\n                  <author>carrot</author>\n                </bookstore>'),\n        '/bookstore/author'\n      ) AS result\nFROM dual;\n",
            "+-----------------------------------------------+\n| RESULT                                        |\n+-----------------------------------------------+\n| <bookstore>\n  <book att=\"old\"/>\n</bookstore>\n|\n+-----------------------------------------------+\n1 row in set\n",
            "SELECT\n  DELETEXML(\n    xmltype(\n      '<a xmlns=\"ns1\" xmlns:f=\"ns2\">\n        <f:b b1=\"b1\" b2=\"b2\">bbb1</f:b>\n        <b b1=\"b1\" b2=\"b2\">bbb2</b>\n      </a>'\n    ),\n    '/a/*',\n    'xmlns=\"ns1\"'\n  )\nFROM dual;\n",
            "+----------------------------------------------------------------------------------------------------------------------------------+\n| DELETEXML(XMLTYPE('<AXMLNS=\"NS1\"XMLNS:F=\"NS2\"><F:BB1=\"B1\"B2=\"B2\">BBB1</F:B><BB1=\"B1\"B2=\"B2\">BBB2</B></A>'),'/A/*','XMLNS=\"NS1\"') |\n+----------------------------------------------------------------------------------------------------------------------------------+\n| <a xmlns=\"ns1\" xmlns:f=\"ns2\"/>\n                                                                                                  |\n+----------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 DELETEXML 函数从目标 XML 中删除匹配的节点。其中，目标 XML 是 <bookstore> 节点及其子节点；指定 XPath 表达式是 /bookstore/author，它指示要删除 <bookstore> 节点下的 <author> 节点；查询的结果使用 AS 关键字重命名为 result；最后，从 dual 表中检索结果。",
            "SELECT DELETEXML(\n        XMLtype('<bookstore>\n                  <book att=\"old\"></book>\n                  <author>carrot</author>\n                </bookstore>'),\n        '/bookstore/author'\n      ) AS result\nFROM dual;\n",
            "返回结果如下：",
            "+-----------------------------------------------+\n| RESULT                                        |\n+-----------------------------------------------+\n| <bookstore>\n  <book att=\"old\"/>\n</bookstore>\n|\n+-----------------------------------------------+\n1 row in set\n",
            "删除父节点下所有子节点后，父节点 namespace 仍然保留。",
            "SELECT\n  DELETEXML(\n    xmltype(\n      '<a xmlns=\"ns1\" xmlns:f=\"ns2\">\n        <f:b b1=\"b1\" b2=\"b2\">bbb1</f:b>\n        <b b1=\"b1\" b2=\"b2\">bbb2</b>\n      </a>'\n    ),\n    '/a/*',\n    'xmlns=\"ns1\"'\n  )\nFROM dual;\n",
            "返回结果如下：",
            "+----------------------------------------------------------------------------------------------------------------------------------+\n| DELETEXML(XMLTYPE('<AXMLNS=\"NS1\"XMLNS:F=\"NS2\"><F:BB1=\"B1\"B2=\"B2\">BBB1</F:B><BB1=\"B1\"B2=\"B2\">BBB2</B></A>'),'/A/*','XMLNS=\"NS1\"') |\n+----------------------------------------------------------------------------------------------------------------------------------+\n| <a xmlns=\"ns1\" xmlns:f=\"ns2\"/>\n                                                                                                  |\n+----------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "DENSE_RANK": {
        "Title": [
            "DENSE_RANK"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822870"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "/*聚合语法*/\nDENSE_RANK(expr [, expr ...])\n  WITHIN GROUP ( ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                        [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n                )\n\n/*分析语法*/\nDENSE_RANK( ) OVER([ query_partition_clause ] order_by_clause)\n",
        "Description": [
            "该函数功能是计算有序行组中行的秩。秩的值是从 1 开始的连续整数，最大的秩值是符合查询结果的数值。具有相同值的排序标准的行接收相同的秩，相同的行数不会被记录到下个排名中。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为聚合函数，DENSE_RANK 根据指定的排序规范计算由函数的参数标识的假设行的密集等级。常量参数表达式 expr 和 order_by_clause 聚合中的表达式按位置匹配。因此，参数的数量必须相同并且类型必须兼容。\n作为一个分析函数，DENSE_RANK 根据 order_by_clause 中 value_exprs 的值，计算从查询返回的每一行相对于其他行的秩。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n对应列中数据类型的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回值为 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "obclient> SELECT DENSE_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------------+\n| DENSE_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------------+\n|                                      12 |\n+-----------------------------------------+\n1 row in set\n",
            "obclient> SELECT deptno,ename, sal,\n              DENSE_RANK ( ) OVER (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n     FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    2 |\n|     20 | ADAMS  | 1400 |    3 |\n|     20 | SMITH  | 1100 |    4 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    6 |\n+--------+--------+------+------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "返回 3300 在列 sal 中的秩。",
            "obclient> SELECT DENSE_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------------+\n| DENSE_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------------+\n|                                      12 |\n+-----------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 deptno 分组并按列 sal 降序排序，返回列 sal 中各值的秩。",
            "obclient> SELECT deptno,ename, sal,\n              DENSE_RANK ( ) OVER (PARTITION BY deptno ORDER BY sal DESC ) \"RANK\"\n     FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    2 |\n|     20 | ADAMS  | 1400 |    3 |\n|     20 | SMITH  | 1100 |    4 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    6 |\n+--------+--------+------+------+\n15 rows in set\n"
        ]
    },
    "DUMP": {
        "Title": [
            "DUMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823116"
        ],
        "Category": [
            "Encoding and Decoding Functions"
        ],
        "Feature": "DUMP(expr[, return_fmt [, start_position [, length ] ] ])\n",
        "Description": [
            "该函数返回指定表达式的数据类型代码、字节长度和表达式的内部表示形式。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定进行分析的表达式，可以是各个类型的值。\n\n\nreturn_fmt\n指定返回值的格式，为可选项。有以下几种用法： \n      \n8 表示以八进制返回结果的值。\n10 表示以十进制返回结果的值，为默认值。\n16 表示以十六进制返回结果的值。\n17 表示以单字符的形式返回结果的值，能被解释为编译器字符集中的可打印字符，通常是 ASCII 字符集或 EBCDIC 字符编码。否则，字符以十六进制表示法打印。所有 NLS 参数都将被忽略。\n\n\n\nstart_position\n指定开始进行返回的字符位置，为可选项。默认值是 1。\n\n\nlength\n指定需要返回的字符长度，为可选项。默认返回全部字符。\n\n\n",
            "如果 expr 为 NULL，则返回 NULL。否则，返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT DUMP('OceanBase',8) FROM DUAL;\n+---------------------------------------------------+\n| DUMP('OCEANBASE',8)                               |\n+---------------------------------------------------+\n| Typ=23 Len=9: 117,143,145,141,156,102,141,163,145 |\n+---------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回字符串 OceanBase 的数据类型代码、字节长度和相关字符对应八进制的值。",
            "obclient> SELECT DUMP('OceanBase',8) FROM DUAL;\n+---------------------------------------------------+\n| DUMP('OCEANBASE',8)                               |\n+---------------------------------------------------+\n| Typ=23 Len=9: 117,143,145,141,156,102,141,163,145 |\n+---------------------------------------------------+\n1 row in set\n"
        ]
    },
    "EXP": {
        "Title": [
            "EXP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823173"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "EXP (numeric_expression)\n",
        "Description": [
            "该函数是以自然常数 e 为底的指数函数，用于返回 e 的 numeric_expression 次方，其中 e = 2.71828183...。"
        ],
        "Illustration": [
            "numeric_expression 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "当参数为 BINARY_FLOAT 数据类型时，返回类型为 BINARY_DOUBLE，其他情况下返回类型与参数 numeric_expression 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT EXP(4),EXP(3+2.5) FROM DUAL;\n+-------------------------------------------+------------------------------------------+\n| EXP(4)                                    | EXP(3+2.5)                               |\n+-------------------------------------------+------------------------------------------+\n| 54.59815003314423907811026120286087840279 | 244.691932264220387915188949511839350184 |\n+-------------------------------------------+------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 e 的 4 次幂和 e 的 3+2.5 次幂。",
            "obclient> SELECT EXP(4),EXP(3+2.5) FROM DUAL;\n+-------------------------------------------+------------------------------------------+\n| EXP(4)                                    | EXP(3+2.5)                               |\n+-------------------------------------------+------------------------------------------+\n| 54.59815003314423907811026120286087840279 | 244.691932264220387915188949511839350184 |\n+-------------------------------------------+------------------------------------------+\n1 row in set\n"
        ]
    },
    "EXTRACT": {
        "Title": [
            "EXTRACT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823508"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "EXTRACT(XMLType_instance, XPath_string [, namespace_string ])\n",
        "Description": [
            "该函数依据 Xpath 抽取一个 XML 片段，其结果是 Xpath 匹配到的所有节点的拼接。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n指定 XMLType 类型的数据，可以是 XMLType 列或者返回类型为 XMLType 的表达式。\n\n\nXPath_string\n指定需要搜索节点的 Xpath。\n\n\nnamespace_string\n指定 XML 命名空间。\n\n\n",
            "返回 XMLType 数据类型。"
        ],
        "Examples": [
            "DROP TABLE xml_test;\nCREATE TABLE xml_test (id NUMBER, c1 XMLType);\nINSERT INTO xml_test VALUES (1, '<a>aaa</a>');\nINSERT INTO xml_test VALUES (2, '<a><b>aaa</b><b>bbb</b></a>');\nINSERT INTO xml_test VALUES (3, '<a a1=\"a1\">aaa</a>');\nINSERT INTO xml_test VALUES (4, '<a><b b1=\"b1\" b2=\"b2\">bbb</b></a>');\nINSERT INTO xml_test VALUES (5, '<a><b b1=\"b1\" b2=\"b2\">bbb1</b><b b1=\"b1\" b2=\"b2\">bbb2</b></a>');\nINSERT INTO xml_test VALUES (6, '<a xmlns=\"ns1\" xmlns:f=\"ns2\"><f:b b1=\"b1\" b2=\"b2\">bbb1</f:b><b b1=\"b1\" b2=\"b2\">bbb2</b></a>');\n\nobclient> SELECT EXTRACT(c1, '/a/f:b', 'xmlns=\"ns1\" xmlns:f=\"ns2\"') as RES\n FROM xml_test WHERE id = 6;\n+----------------------------------+\n| RES                              |\n+----------------------------------+\n| <f:b b1=\"b1\" b2=\"b2\">bbb1</f:b>\n |\n+----------------------------------+\n1 row in set\n\nobclient> SELECT EXTRACT(c1, '/a/h:b/text()', 'xmlns=\"ns1\" xmlns:h=\"ns2\"') as RES FROM xml_test WHERE id = 6;\n+------+\n| RES  |\n+------+\n| bbb1 |\n+------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "DROP TABLE xml_test;\nCREATE TABLE xml_test (id NUMBER, c1 XMLType);\nINSERT INTO xml_test VALUES (1, '<a>aaa</a>');\nINSERT INTO xml_test VALUES (2, '<a><b>aaa</b><b>bbb</b></a>');\nINSERT INTO xml_test VALUES (3, '<a a1=\"a1\">aaa</a>');\nINSERT INTO xml_test VALUES (4, '<a><b b1=\"b1\" b2=\"b2\">bbb</b></a>');\nINSERT INTO xml_test VALUES (5, '<a><b b1=\"b1\" b2=\"b2\">bbb1</b><b b1=\"b1\" b2=\"b2\">bbb2</b></a>');\nINSERT INTO xml_test VALUES (6, '<a xmlns=\"ns1\" xmlns:f=\"ns2\"><f:b b1=\"b1\" b2=\"b2\">bbb1</f:b><b b1=\"b1\" b2=\"b2\">bbb2</b></a>');\n\nobclient> SELECT EXTRACT(c1, '/a/f:b', 'xmlns=\"ns1\" xmlns:f=\"ns2\"') as RES\n FROM xml_test WHERE id = 6;\n+----------------------------------+\n| RES                              |\n+----------------------------------+\n| <f:b b1=\"b1\" b2=\"b2\">bbb1</f:b>\n |\n+----------------------------------+\n1 row in set\n\nobclient> SELECT EXTRACT(c1, '/a/h:b/text()', 'xmlns=\"ns1\" xmlns:h=\"ns2\"') as RES FROM xml_test WHERE id = 6;\n+------+\n| RES  |\n+------+\n| bbb1 |\n+------+\n1 row in set\n"
        ]
    },
    "EXTRACTVALUE": {
        "Title": [
            "EXTRACTVALUE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823509"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "EXTRACTVALUE(XMLType_instance, XPath_string [, namespace_string ])\n",
        "Description": [
            "该函数依据 Xpath 抽取一个 XML 片段并返回标量值。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n指定 XMLType 类型的数据，可以是 XMLType 列或者返回类型为 XMLType 的表达式。\n\n\nXPath_string\n指定需要搜索节点的 XPath。XPath 必须指向单一节点（TEXT、ATTRIBUTE或 ELEMENT），且节点必须有单一值，否则会报错。\n\n\nnamespace_string\n指定 XML 命名空间。\n\n\n",
            "返回类型为 VARCHAR2(4000)。"
        ],
        "Examples": [
            "obclient> SELECT EXTRACTVALUE(c1, '/a/f:b', 'xmlns=\"ns1\" xmlns:f=\"ns2\"') as RES from xml_test where id = 6;\n+------+\n| RES  |\n+------+\n| bbb1 |\n+------+\n1 row in set\n\nobclient> SELECT EXTRACTVALUE(c1, '/a/h:b/text()', 'xmlns=\"ns1\" xmlns:h=\"ns2\"') as RES from xml_test where id = 6;\n+------+\n| RES  |\n+------+\n| bbb1 |\n+------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "obclient> SELECT EXTRACTVALUE(c1, '/a/f:b', 'xmlns=\"ns1\" xmlns:f=\"ns2\"') as RES from xml_test where id = 6;\n+------+\n| RES  |\n+------+\n| bbb1 |\n+------+\n1 row in set\n\nobclient> SELECT EXTRACTVALUE(c1, '/a/h:b/text()', 'xmlns=\"ns1\" xmlns:h=\"ns2\"') as RES from xml_test where id = 6;\n+------+\n| RES  |\n+------+\n| bbb1 |\n+------+\n1 row in set\n"
        ]
    },
    "EXTRACT（datetime）": {
        "Title": [
            "EXTRACT（datetime）"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823126"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "EXTRACT ({ YEAR\n         | MONTH\n         | DAY\n         | HOUR\n         | MINUTE\n         | SECOND\n         | TIMEZONE_HOUR\n         | TIMEZONE_MINUTE\n         | TIMEZONE_REGION\n         | TIMEZONE_ABBR\n         }\n   FROM datetime)\n",
        "Description": [
            "该函数是从指定的时间字段或表达式中抽取年、月、日、时、分、秒和时区等元素。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nYEAR\n指定提取年份。\n\n\nMONTH\n指定提取月份。\n\n\nDAY\n指定提取日期。\n\n\nHOUR\n指定提取小时。\n\n\nMINUTE\n指定提取分钟。\n\n\nSECOND\n指定提取秒数。\n\n\nTIMEZONE_HOUR\n指定提取时区的时。\n\n\nTIMEZONE_MINUTE\n指定提取时区的分。\n\n\nTIMEZONE_REGION\n指定返回时区区域名称。 说明 当时间表达式中提供了时区数字偏移并且该数字偏移可能映射到多个时区区域名称时，返回 UNKNOWN。\n\n\nTIMEZONE_ABBR\n指定返回时区区域名称缩写。 说明 当时间表达式中提供了时区数字偏移并且该数字偏移可能映射到多个时区区域名称时，返回 UNK。\n\n\ndatetime\nDATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE、INTERVAL YEAR TO MONTH、INTERVAL DAY TO SECOND 等数据类型的值。\n\n\n",
            "\n说明\n\n如果指定提取 YEAR 或 MONTH，则 datetime 数据类型为 DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE 或 INTERVAL YEAR TO MONTH。\n如果指定提取 DAY，则 datetime 数据类型为 DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE 或 INTERVAL DAY TO SECOND。\n如果指定提取 HOUR、MINUTE、或 SECOND，则 datetime 数据类型为 TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE、INTERVAL DAY TO SECOND。\n如果指定提取 TIMEZONE_HOUR、TIMEZONE_MINUTE、TIMEZONE_ABBR 或 TIMEZONE_REGION，则 datetime 数据类型为 TIMESTAMP WITH TIME ZONE 或 TIMESTAMP WITH LOCAL TIME ZONE。\n\n",
            "抽取元素 TIMEZONE_REGION、TIMEZONE_ABBR 时，返回值的数据类型为 VARCHAR2。",
            "抽取其他元素时，返回值的数据类型为 NUMBER。"
        ],
        "Examples": [
            "obclient> SELECT  EXTRACT(HOUR FROM TIMESTAMP '2021-11-17 12:38:40') \"HOUR\",\n            EXTRACT(MINUTE FROM TIMESTAMP '2021-11-17 12:38:40') \"MINUTE\",\n            EXTRACT(SECOND FROM TIMESTAMP '2021-11-17 12:38:40') \"SECOND\",\n            EXTRACT(DAY FROM TIMESTAMP '2021-11-17 12:38:40') \"DAY\",\n            EXTRACT(MONTH FROM TIMESTAMP '2021-11-17 12:38:40') \"MONTH\",\n            EXTRACT(YEAR FROM TIMESTAMP '2021-11-17 12:38:40') \"YEAR\",\n            EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP '2021-11-17 12:38:40 +08:00') \"TIMEZONE_HOUR\",\n            EXTRACT(TIMEZONE_REGION FROM TIMESTAMP '2021-11-17 12:38:40 +08:00') \"TIMEZONE_REGION\",\n            EXTRACT(TIMEZONE_ABBR FROM TIMESTAMP '2021-11-17 12:38:40 +08:00') \"TIMEZONE_ABBR\"\n          FROM DUAL;\n+------+--------+--------+------+-------+------+---------------+-----------------+---------------+\n| HOUR | MINUTE | SECOND | DAY  | MONTH | YEAR | TIMEZONE_HOUR | TIMEZONE_REGION | TIMEZONE_ABBR |\n+------+--------+--------+------+-------+------+---------------+-----------------+---------------+\n|   12 |     38 |     40 |   17 |    11 | 2021 |             8 | UNKNOWN         | UNK           |\n+------+--------+--------+------+-------+------+---------------+-----------------+---------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "执行以下语句：",
            "obclient> SELECT  EXTRACT(HOUR FROM TIMESTAMP '2021-11-17 12:38:40') \"HOUR\",\n            EXTRACT(MINUTE FROM TIMESTAMP '2021-11-17 12:38:40') \"MINUTE\",\n            EXTRACT(SECOND FROM TIMESTAMP '2021-11-17 12:38:40') \"SECOND\",\n            EXTRACT(DAY FROM TIMESTAMP '2021-11-17 12:38:40') \"DAY\",\n            EXTRACT(MONTH FROM TIMESTAMP '2021-11-17 12:38:40') \"MONTH\",\n            EXTRACT(YEAR FROM TIMESTAMP '2021-11-17 12:38:40') \"YEAR\",\n            EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP '2021-11-17 12:38:40 +08:00') \"TIMEZONE_HOUR\",\n            EXTRACT(TIMEZONE_REGION FROM TIMESTAMP '2021-11-17 12:38:40 +08:00') \"TIMEZONE_REGION\",\n            EXTRACT(TIMEZONE_ABBR FROM TIMESTAMP '2021-11-17 12:38:40 +08:00') \"TIMEZONE_ABBR\"\n          FROM DUAL;\n+------+--------+--------+------+-------+------+---------------+-----------------+---------------+\n| HOUR | MINUTE | SECOND | DAY  | MONTH | YEAR | TIMEZONE_HOUR | TIMEZONE_REGION | TIMEZONE_ABBR |\n+------+--------+--------+------+-------+------+---------------+-----------------+---------------+\n|   12 |     38 |     40 |   17 |    11 | 2021 |             8 | UNKNOWN         | UNK           |\n+------+--------+--------+------+-------+------+---------------+-----------------+---------------+\n1 row in set\n"
        ]
    },
    "FIRST_VALUE": {
        "Title": [
            "FIRST_VALUE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822833"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "FIRST_VALUE { (expr) [{RESPECT | IGNORE} NULLS ]\n            | (expr [{RESPECT | IGNORE} NULLS ])\n            }\nOVER (analytic_clause)\n",
        "Description": [
            "该函数是一个分析函数，功能是返回有序值中的第一个值。如果集合中的第一个值为 NULL，则函数返回NULL，除非您指定 IGNORE NULLS，该设置对于数据致密化很有用。expr 列中 NULL 值行对应的返回值是 NULL。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要返回值的列名。 注意 不能将 FIRST_VALUE 或其他分析函数用于 expr 来嵌套分析函数。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回值与参数 expr 的数据类型相同或返回 NULL。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,mgr,\n              FIRST_VALUE (MGR) IGNORE NULLS OVER (ORDER BY sal DESC) AS first_mgr\n      FROM emp_msg\n      ORDER BY sal DESC;\n+--------+--------+------+------+-----------+\n| DEPTNO | ENAME  | SAL  | MGR  | FIRST_MGR |\n+--------+--------+------+------+-----------+\n|     10 | KING   | 5300 | NULL | NULL      |\n|     20 | FORD   | 3300 | 7566 | 7566      |\n|     20 | SCOTT  | 3300 | 7566 | 7566      |\n|     20 | JONES  | 3275 | 7839 | 7566      |\n|     30 | BLAKE  | 3150 | 7839 | 7566      |\n|     10 | CLARK  | 2750 | 7839 | 7566      |\n|     30 | ALLEN  | 1900 | 7698 | 7566      |\n|     30 | TURNER | 1800 | 7698 | 7566      |\n|     30 | SCLARK | 1750 | 7839 | 7566      |\n|     10 | MILLER | 1600 | 7782 | 7566      |\n|     30 | MARTIN | 1550 | 7698 | 7566      |\n|     30 | WARD   | 1550 | 7698 | 7566      |\n|     20 | ADAMS  | 1400 | 7788 | 7566      |\n|     30 | JAMES  | 1250 | 7698 | 7566      |\n|     20 | SMITH  | 1100 | 7902 | 7566      |\n+--------+--------+------+------+-----------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表emp_msg。将 emp_msg 表中的数据按列 sal 降序排序，将 mgr 列中第一个非空值填入first_mgr 列。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,mgr,\n              FIRST_VALUE (MGR) IGNORE NULLS OVER (ORDER BY sal DESC) AS first_mgr\n      FROM emp_msg\n      ORDER BY sal DESC;\n+--------+--------+------+------+-----------+\n| DEPTNO | ENAME  | SAL  | MGR  | FIRST_MGR |\n+--------+--------+------+------+-----------+\n|     10 | KING   | 5300 | NULL | NULL      |\n|     20 | FORD   | 3300 | 7566 | 7566      |\n|     20 | SCOTT  | 3300 | 7566 | 7566      |\n|     20 | JONES  | 3275 | 7839 | 7566      |\n|     30 | BLAKE  | 3150 | 7839 | 7566      |\n|     10 | CLARK  | 2750 | 7839 | 7566      |\n|     30 | ALLEN  | 1900 | 7698 | 7566      |\n|     30 | TURNER | 1800 | 7698 | 7566      |\n|     30 | SCLARK | 1750 | 7839 | 7566      |\n|     10 | MILLER | 1600 | 7782 | 7566      |\n|     30 | MARTIN | 1550 | 7698 | 7566      |\n|     30 | WARD   | 1550 | 7698 | 7566      |\n|     20 | ADAMS  | 1400 | 7788 | 7566      |\n|     30 | JAMES  | 1250 | 7698 | 7566      |\n|     20 | SMITH  | 1100 | 7902 | 7566      |\n+--------+--------+------+------+-----------+\n15 rows in set\n"
        ]
    },
    "FLOOR": {
        "Title": [
            "FLOOR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823166"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "FLOOR (numeric_expression)\n",
        "Description": [
            "该函数返回小于等于数值 numeric_expression 的最大整数。"
        ],
        "Illustration": [
            "numeric_expression 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "返回类型与参数 numeric_expression 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT FLOOR(-1.5),FLOOR(1.5),FLOOR(2),FLOOR(6-9.5) FROM DUAL;\n+-------------+------------+----------+--------------+\n| FLOOR(-1.5) | FLOOR(1.5) | FLOOR(2) | FLOOR(6-9.5) |\n+-------------+------------+----------+--------------+\n|          -2 |          1 |        2 |           -4 |\n+-------------+------------+----------+--------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回分别小于或等于 -1.5、1.5、2 和 6-9.5 的最大整数。",
            "obclient> SELECT FLOOR(-1.5),FLOOR(1.5),FLOOR(2),FLOOR(6-9.5) FROM DUAL;\n+-------------+------------+----------+--------------+\n| FLOOR(-1.5) | FLOOR(1.5) | FLOOR(2) | FLOOR(6-9.5) |\n+-------------+------------+----------+--------------+\n|          -2 |          1 |        2 |           -4 |\n+-------------+------------+----------+--------------+\n1 row in set\n"
        ]
    },
    "FROM_TZ": {
        "Title": [
            "FROM_TZ"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823136"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "FROM_TZ (timestamp_value,time_zone_value)\n",
        "Description": [
            "该函数将一个 TIMSTAMP 数据类型的值和时区信息拼成一个 TIMESTAMP WITH TIME ZONE 数据类型的时间值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ntimestamp_value\nTIMSTAMP 数据类型的时间值。\n\n\ntime_zone_value\n时区信息。\n\n\n",
            "返回 TIMESTAMP WITH TIME ZONE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT FROM_TZ(TIMESTAMP '2021-03-28 08:00:00', '+08:00') FROM DUAL;\n+-------------------------------------------------+\n| FROM_TZ(TIMESTAMP'2021-03-2808:00:00','+08:00') |\n+-------------------------------------------------+\n| 28-MAR-21 08.00.00.000000000 AM +08:00          |\n+-------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将时间戳值 2021-03-28 08:00:00 和时区 +08:00 合为 TIMESTAMP WITH TIME ZONE 类型的数据并返回。",
            "obclient> SELECT FROM_TZ(TIMESTAMP '2021-03-28 08:00:00', '+08:00') FROM DUAL;\n+-------------------------------------------------+\n| FROM_TZ(TIMESTAMP'2021-03-2808:00:00','+08:00') |\n+-------------------------------------------------+\n| 28-MAR-21 08.00.00.000000000 AM +08:00          |\n+-------------------------------------------------+\n1 row in set\n"
        ]
    },
    "GENERATOR": {
        "Title": [
            "GENERATOR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823172"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "TABLE(GENERATOR(N))\n",
        "Description": [
            "GENERATOR 函数是一种特殊的内置函数，设计用于在 Table Function 框架中使用。它的主要作用是生成一个指定数量行的虚拟表。这个表不包含任何实际数据，而是提供了一个结构，可以在其中插入数据。GENERATOR 函数通常用于生成一组连续的行，以便进行批量操作或模拟数据集。",
            "Table Function 是 SQL 中的一个高级功能，它允许函数返回一整张表，而不仅仅是单个值。这意味着 Table Function 可以产出多行和多列，类似于常规的数据表一样。",
            "TABLE(GENERATOR(N)) 可以生成一个有 N 行的虚拟表，其中 N 是一个大于或等于 0 的 64 位整数。如果你想要这个虚拟表包括具体的数据，那么你需要在 SELECT 语句后面添加数据生成的逻辑，比如常量、计算表达式、函数调用或用户自定义函数（UDF）等。",
            "TABLE(GENERATOR(N)) 支持并行执行。你可以在并行 SELECT 查询或并行数据操纵语言（DML）操作中使用它。然而，生成这些虚拟行的过程本身不是并行的；只有一个线程负责读取 TABLE(GENERATOR(N)) 生成的行。因此，在包含 TABLE(GENERATOR(N)) 的数据流操作(Data Flow Operation, DFO)中，Degree of Parallelism (DOP) 设置应为 1。"
        ],
        "Illustration": [
            "N",
            "：一个大于或等于 0 的 64 位的正整数，用于指定生成的行数。"
        ],
        "Examples": [
            "obclient [SYS]> SELECT * FROM TABLE(GENERATOR(10));\n",
            "+--------------+\n| COLUMN_VALUE |\n+--------------+\n|            1 |\n|            2 |\n|            3 |\n|            4 |\n|            5 |\n|            6 |\n|            7 |\n|            8 |\n|            9 |\n|           10 |\n+--------------+\n10 rows in set\n",
            "obclient [SYS]> SELECT 'Hello, World!' AS greeting FROM TABLE(GENERATOR(10));\n",
            "+---------------+\n| GREETING      |\n+---------------+\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n+---------------+\n10 rows in set\n",
            "obclient> SELECT COUNT(*) FROM TABLE(GENERATOR(100000));\n+----------+\n| COUNT(*) |\n+----------+\n|   100000 |\n+----------+\n1 row in set\n\nobclient> SELECT NORMAL(0, 1, RANDOM()) FROM TABLE(GENERATOR(5));\n+------------------------+\n| NORMAL(0, 1, RANDOM()) |\n|------------------------|\n|           0.227384164  |\n|           0.9945290748 |\n|          -0.2045078571 |\n|          -1.594607893  |\n|          -0.8213296842 |\n+------------------------+\n5 rows in set\n\nobclient> SELECT RANDSTR(1, ZIPF(1, 5, RANDOM())) str FROM TABLE(GENERATOR(5));\n+------------------------+\n|                    str |\n|------------------------|\n|                     A  |\n|                     D  |\n|                     A  |\n|                     A  |\n|                     C  |\n+------------------------+\n5 rows in set\n",
            "obclient> CREATE TABLE t1 (c1 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO t1 VALUES (1), (2);\nQuery OK, 2 rows affected\nRecords: 2  Duplicates: 0  Warnings: 0\n\nobclient> SELECT c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+------+----------------------+\n| c1   | RANDOM(1)            |\n+------+----------------------+\n|    1 | -6753783847308464280 |\n|    2 | -6707106347154343346 |\n|    1 |  -899926183391115878 |\n|    2 | -8835543475904200562 |\n|    1 | -2750444335953844424 |\n|    2 |  7588216632478230601 |\n+------+----------------------+\n6 rows in set\n\nobclient> EXPLAIN SELECT c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+----------------------------------------------------------------------------------+\n| Query Plan                                                                       |\n+----------------------------------------------------------------------------------+\n| ==================================================================               |\n| |ID|OPERATOR                   |NAME       |EST.ROWS|EST.TIME(us)|               |\n| ------------------------------------------------------------------               |\n| |0 |NESTED-LOOP JOIN CARTESIAN |           |398     |14          |               |\n| |1 |├─FUNCTION_TABLE           |FUNC_TABLE1|199     |1           |               |\n| |2 |└─MATERIAL                 |           |2       |2           |               |\n| |3 |  └─TABLE FULL SCAN        |T1         |2       |2           |               |\n| ==================================================================               |\n| Outputs & filters:                                                               |\n| -------------------------------------                                            |\n|   0 - output([T1.C1], [RANDOM(cast(1, BIGINT(-1, 0)))]), filter(nil), rowset=256 |\n|       conds(nil), nl_params_(nil), use_batch=false                               |\n|   1 - output(nil), filter(nil)                                                   |\n|       value(GENERATOR(cast(3, BIGINT(-1, 0))))                                   |\n|   2 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   3 - output([T1.C1]), filter(nil), rowset=256                                   |\n|       access([T1.C1]), partitions(p0)                                            |\n|       is_index_back=false, is_global_index=false,                                |\n|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true                |\n+----------------------------------------------------------------------------------+\n19 rows in set\n\nobclient> SELECT /*+ PARALLEL(2) */ c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+------+----------------------+\n| c1   | random(1)            |\n+------+----------------------+\n|    1 | -6753783847308464280 |\n|    2 | -6707106347154343346 |\n|    1 |  -899926183391115878 |\n|    2 | -8835543475904200562 |\n|    1 | -2750444335953844424 |\n|    2 |  7588216632478230601 |\n+------+----------------------+\n6 rows in set\n\nobclient> EXPLAIN SELECT /*+ PARALLEL(2) */ c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+----------------------------------------------------------------------------------+\n| Query Plan                                                                       |\n+----------------------------------------------------------------------------------+\n| ==================================================================               |\n| |ID|OPERATOR                   |NAME       |EST.ROWS|EST.TIME(us)|               |\n| ------------------------------------------------------------------               |\n| |0 |NESTED-LOOP JOIN CARTESIAN |           |398     |13          |               |\n| |1 |├─FUNCTION_TABLE           |FUNC_TABLE1|199     |1           |               |\n| |2 |└─MATERIAL                 |           |2       |3           |               |\n| |3 |  └─PX COORDINATOR         |           |2       |3           |               |\n| |4 |    └─EXCHANGE OUT DISTR   |:EX10000   |2       |2           |               |\n| |5 |      └─PX BLOCK ITERATOR  |           |2       |1           |               |\n| |6 |        └─TABLE FULL SCAN  |T1         |2       |1           |               |\n| ==================================================================               |\n| Outputs & filters:                                                               |\n| -------------------------------------                                            |\n|   0 - output([T1.C1], [RANDOM(cast(1, BIGINT(-1, 0)))]), filter(nil), rowset=256 |\n|       conds(nil), nl_params_(nil), use_batch=false                               |\n|   1 - output(nil), filter(nil)                                                   |\n|       value(GENERATOR(cast(3, BIGINT(-1, 0))))                                   |\n|   2 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   3 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   4 - output([T1.C1]), filter(nil), rowset=256                                   |\n|       dop=2                                                                      |\n|   5 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   6 - output([T1.C1]), filter(nil), rowset=256                                   |\n|       access([T1.C1]), partitions(p0)                                            |\n|       is_index_back=false, is_global_index=false,                                |\n|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true                |\n+----------------------------------------------------------------------------------+\n26 rows in set\n"
        ],
        "Detailed Examples": [
            "示例 1：",
            "obclient [SYS]> SELECT * FROM TABLE(GENERATOR(10));\n",
            "上述 SQL 语句将生成一个含有 10 行的虚拟表，每一行都是空的，因为没有指定要显示的数据。",
            "返回结果如下所示：",
            "+--------------+\n| COLUMN_VALUE |\n+--------------+\n|            1 |\n|            2 |\n|            3 |\n|            4 |\n|            5 |\n|            6 |\n|            7 |\n|            8 |\n|            9 |\n|           10 |\n+--------------+\n10 rows in set\n",
            "如果想要生成具体的数据，可以这样写：",
            "obclient [SYS]> SELECT 'Hello, World!' AS greeting FROM TABLE(GENERATOR(10));\n",
            "此查询将生成一个含有 10 行的虚拟表，每一行的 greeting 列都包含字符串 Hello, World!。",
            "返回结果如下所示：",
            "+---------------+\n| GREETING      |\n+---------------+\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n| Hello, World! |\n+---------------+\n10 rows in set\n",
            "示例 2：使用 ",
            "GENERATOR()",
            " 函数生成符合条件的随机数。",
            "obclient> SELECT COUNT(*) FROM TABLE(GENERATOR(100000));\n+----------+\n| COUNT(*) |\n+----------+\n|   100000 |\n+----------+\n1 row in set\n\nobclient> SELECT NORMAL(0, 1, RANDOM()) FROM TABLE(GENERATOR(5));\n+------------------------+\n| NORMAL(0, 1, RANDOM()) |\n|------------------------|\n|           0.227384164  |\n|           0.9945290748 |\n|          -0.2045078571 |\n|          -1.594607893  |\n|          -0.8213296842 |\n+------------------------+\n5 rows in set\n\nobclient> SELECT RANDSTR(1, ZIPF(1, 5, RANDOM())) str FROM TABLE(GENERATOR(5));\n+------------------------+\n|                    str |\n|------------------------|\n|                     A  |\n|                     D  |\n|                     A  |\n|                     A  |\n|                     C  |\n+------------------------+\n5 rows in set\n",
            "示例 3：",
            "GENERATOR()",
            " 函数也可以和其它表做 Join，示例如下：",
            "obclient> CREATE TABLE t1 (c1 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO t1 VALUES (1), (2);\nQuery OK, 2 rows affected\nRecords: 2  Duplicates: 0  Warnings: 0\n\nobclient> SELECT c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+------+----------------------+\n| c1   | RANDOM(1)            |\n+------+----------------------+\n|    1 | -6753783847308464280 |\n|    2 | -6707106347154343346 |\n|    1 |  -899926183391115878 |\n|    2 | -8835543475904200562 |\n|    1 | -2750444335953844424 |\n|    2 |  7588216632478230601 |\n+------+----------------------+\n6 rows in set\n\nobclient> EXPLAIN SELECT c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+----------------------------------------------------------------------------------+\n| Query Plan                                                                       |\n+----------------------------------------------------------------------------------+\n| ==================================================================               |\n| |ID|OPERATOR                   |NAME       |EST.ROWS|EST.TIME(us)|               |\n| ------------------------------------------------------------------               |\n| |0 |NESTED-LOOP JOIN CARTESIAN |           |398     |14          |               |\n| |1 |├─FUNCTION_TABLE           |FUNC_TABLE1|199     |1           |               |\n| |2 |└─MATERIAL                 |           |2       |2           |               |\n| |3 |  └─TABLE FULL SCAN        |T1         |2       |2           |               |\n| ==================================================================               |\n| Outputs & filters:                                                               |\n| -------------------------------------                                            |\n|   0 - output([T1.C1], [RANDOM(cast(1, BIGINT(-1, 0)))]), filter(nil), rowset=256 |\n|       conds(nil), nl_params_(nil), use_batch=false                               |\n|   1 - output(nil), filter(nil)                                                   |\n|       value(GENERATOR(cast(3, BIGINT(-1, 0))))                                   |\n|   2 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   3 - output([T1.C1]), filter(nil), rowset=256                                   |\n|       access([T1.C1]), partitions(p0)                                            |\n|       is_index_back=false, is_global_index=false,                                |\n|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true                |\n+----------------------------------------------------------------------------------+\n19 rows in set\n\nobclient> SELECT /*+ PARALLEL(2) */ c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+------+----------------------+\n| c1   | random(1)            |\n+------+----------------------+\n|    1 | -6753783847308464280 |\n|    2 | -6707106347154343346 |\n|    1 |  -899926183391115878 |\n|    2 | -8835543475904200562 |\n|    1 | -2750444335953844424 |\n|    2 |  7588216632478230601 |\n+------+----------------------+\n6 rows in set\n\nobclient> EXPLAIN SELECT /*+ PARALLEL(2) */ c1, RANDOM(1) FROM t1, TABLE(GENERATOR(3));\n+----------------------------------------------------------------------------------+\n| Query Plan                                                                       |\n+----------------------------------------------------------------------------------+\n| ==================================================================               |\n| |ID|OPERATOR                   |NAME       |EST.ROWS|EST.TIME(us)|               |\n| ------------------------------------------------------------------               |\n| |0 |NESTED-LOOP JOIN CARTESIAN |           |398     |13          |               |\n| |1 |├─FUNCTION_TABLE           |FUNC_TABLE1|199     |1           |               |\n| |2 |└─MATERIAL                 |           |2       |3           |               |\n| |3 |  └─PX COORDINATOR         |           |2       |3           |               |\n| |4 |    └─EXCHANGE OUT DISTR   |:EX10000   |2       |2           |               |\n| |5 |      └─PX BLOCK ITERATOR  |           |2       |1           |               |\n| |6 |        └─TABLE FULL SCAN  |T1         |2       |1           |               |\n| ==================================================================               |\n| Outputs & filters:                                                               |\n| -------------------------------------                                            |\n|   0 - output([T1.C1], [RANDOM(cast(1, BIGINT(-1, 0)))]), filter(nil), rowset=256 |\n|       conds(nil), nl_params_(nil), use_batch=false                               |\n|   1 - output(nil), filter(nil)                                                   |\n|       value(GENERATOR(cast(3, BIGINT(-1, 0))))                                   |\n|   2 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   3 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   4 - output([T1.C1]), filter(nil), rowset=256                                   |\n|       dop=2                                                                      |\n|   5 - output([T1.C1]), filter(nil), rowset=256                                   |\n|   6 - output([T1.C1]), filter(nil), rowset=256                                   |\n|       access([T1.C1]), partitions(p0)                                            |\n|       is_index_back=false, is_global_index=false,                                |\n|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true                |\n+----------------------------------------------------------------------------------+\n26 rows in set\n"
        ]
    },
    "GREATEST": {
        "Title": [
            "GREATEST"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823211"
        ],
        "Category": [
            "General Comparison Functions"
        ],
        "Feature": "GREATEST(expr [, expr ]...)\n",
        "Description": [
            "该函数返回一个或多个表达式的列表中的最大值。"
        ],
        "Illustration": [
            "参数 expr 是一个表达式或多个表达式的列表。数据类型可以是 NUMBER、FLOAT、BINARY_FLOAT、BINARY_DOUBLE、CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。",
            "数据库使用第一个参数 expr 来确定返回类型。如果其余参数的数据类型和第一个参数 expr 的数据类型不同，则数据库将第一个参数 expr 之后的每个参数隐式转换为第一个 expr 的数据类型。",
            "如果第一个参数 expr 的数据类型为 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE，则返回与第一个参数 expr 相同的数据类型。",
            "如果第一个参数 expr 的数据类型为 CHAR、VARCHAR2 或 CLOB，则返回 VARCHAR2 类型。",
            "如果第一个参数 expr 的数据类型为 NCHAR 或 NVARCHAR2，则返回 NVARCHAR2 类型。"
        ],
        "Examples": [
            "obclient> SELECT GREATEST('AC','BB','C') \"MAX\" FROM DUAL;\n+-----+\n| MAX |\n+-----+\n| C   |\n+-----+\n1 row in set\n",
            "obclient> SELECT GREATEST (1,'6','5.555') \"MAX\" FROM DUAL;\n+-----+\n| MAX |\n+-----+\n|   6 |\n+-----+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "比较字符串 AC、BB 和 C 的大小，并返回其中最大的字符串。",
            "obclient> SELECT GREATEST('AC','BB','C') \"MAX\" FROM DUAL;\n+-----+\n| MAX |\n+-----+\n| C   |\n+-----+\n1 row in set\n",
            "比较整数 1、字符串 6 和 5.555 三者间的大小，并返回其中最大的值。",
            "obclient> SELECT GREATEST (1,'6','5.555') \"MAX\" FROM DUAL;\n+-----+\n| MAX |\n+-----+\n|   6 |\n+-----+\n1 row in set\n"
        ]
    },
    "GROUPING": {
        "Title": [
            "GROUPING"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822866"
        ],
        "Category": [
            "Aggregate Functions"
        ],
        "Feature": "GROUPING(expr)\n",
        "Description": [
            "该函数将 GROUP BY 子句扩展（如 ROLLUP）生成的超聚集行中的 NULL 和常规行中的 NULL 区分开来。该函数把超聚集行中的 NULL 返回 1，常规行中的值返回 0。"
        ],
        "Illustration": [
            "参数 expr 是 GROUP BY 子句中的一个表达式。",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 INT,col2 INT,col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,NULL,NULL),(2,NULL,5),(3,1,6),(4,1,9),\n            (5,1,NULL),(6,2,3),(7,2,NULL),(8,2,18),(9,2,9),\n            (10,3,10),(11,3,12),(12,3,NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | NULL | NULL |\n|    2 | NULL |    5 |\n|    3 |    1 |    6 |\n|    4 |    1 |    9 |\n|    5 |    1 | NULL |\n|    6 |    2 |    3 |\n|    7 |    2 | NULL |\n|    8 |    2 |   18 |\n|    9 |    2 |    9 |\n|   10 |    3 |   10 |\n|   11 |    3 |   12 |\n|   12 |    3 | NULL |\n+------+------+------+\n12 rows in set\n\nobclient> SELECT col2,col3,DECODE(GROUPING(col3),1,'汇总','正常记录'),COUNT(*)\n          FROM tbl1\n          GROUP BY ROLLUP(col2,col3);\n+------+------+--------------------------------------------------+----------+\n| COL2 | COL3 | DECODE(GROUPING(COL3),1,'汇总','正常记录')       | COUNT(*) |\n+------+------+--------------------------------------------------+----------+\n|    1 |    6 | 正常记录                                         |        1 |\n|    1 |    9 | 正常记录                                         |        1 |\n|    1 | NULL | 正常记录                                         |        1 |\n|    1 | NULL | 汇总                                             |        3 |\n|    2 |    3 | 正常记录                                         |        1 |\n|    2 |    9 | 正常记录                                         |        1 |\n|    2 |   18 | 正常记录                                         |        1 |\n|    2 | NULL | 正常记录                                         |        1 |\n|    2 | NULL | 汇总                                             |        4 |\n|    3 |   10 | 正常记录                                         |        1 |\n|    3 |   12 | 正常记录                                         |        1 |\n|    3 | NULL | 正常记录                                         |        1 |\n|    3 | NULL | 汇总                                             |        3 |\n| NULL |    5 | 正常记录                                         |        1 |\n| NULL | NULL | 正常记录                                         |        1 |\n| NULL | NULL | 汇总                                             |        2 |\n| NULL | NULL | 汇总                                             |       12 |\n+------+------+--------------------------------------------------+----------+\n17 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入数据。查询以列 col2 和列 col3 分组及 ROLLUP 子句生成的汇总行和正常记录。",
            "obclient> CREATE TABLE tbl1(col1 INT,col2 INT,col3 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,NULL,NULL),(2,NULL,5),(3,1,6),(4,1,9),\n            (5,1,NULL),(6,2,3),(7,2,NULL),(8,2,18),(9,2,9),\n            (10,3,10),(11,3,12),(12,3,NULL);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| COL1 | COL2 | COL3 |\n+------+------+------+\n|    1 | NULL | NULL |\n|    2 | NULL |    5 |\n|    3 |    1 |    6 |\n|    4 |    1 |    9 |\n|    5 |    1 | NULL |\n|    6 |    2 |    3 |\n|    7 |    2 | NULL |\n|    8 |    2 |   18 |\n|    9 |    2 |    9 |\n|   10 |    3 |   10 |\n|   11 |    3 |   12 |\n|   12 |    3 | NULL |\n+------+------+------+\n12 rows in set\n\nobclient> SELECT col2,col3,DECODE(GROUPING(col3),1,'汇总','正常记录'),COUNT(*)\n          FROM tbl1\n          GROUP BY ROLLUP(col2,col3);\n+------+------+--------------------------------------------------+----------+\n| COL2 | COL3 | DECODE(GROUPING(COL3),1,'汇总','正常记录')       | COUNT(*) |\n+------+------+--------------------------------------------------+----------+\n|    1 |    6 | 正常记录                                         |        1 |\n|    1 |    9 | 正常记录                                         |        1 |\n|    1 | NULL | 正常记录                                         |        1 |\n|    1 | NULL | 汇总                                             |        3 |\n|    2 |    3 | 正常记录                                         |        1 |\n|    2 |    9 | 正常记录                                         |        1 |\n|    2 |   18 | 正常记录                                         |        1 |\n|    2 | NULL | 正常记录                                         |        1 |\n|    2 | NULL | 汇总                                             |        4 |\n|    3 |   10 | 正常记录                                         |        1 |\n|    3 |   12 | 正常记录                                         |        1 |\n|    3 | NULL | 正常记录                                         |        1 |\n|    3 | NULL | 汇总                                             |        3 |\n| NULL |    5 | 正常记录                                         |        1 |\n| NULL | NULL | 正常记录                                         |        1 |\n| NULL | NULL | 汇总                                             |        2 |\n| NULL | NULL | 汇总                                             |       12 |\n+------+------+--------------------------------------------------+----------+\n17 rows in set\n"
        ]
    },
    "GROUPING_ID": {
        "Title": [
            "GROUPING_ID"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822880"
        ],
        "Category": [
            "Aggregate Functions"
        ],
        "Feature": "GROUPING_ID(attributeList)\n",
        "Description": [
            "GROUPING_ID 函数用于计算一组表达式的组合值，该函数返回一个数字，它代表了行所处的 GROUP BY 层级。",
            "GROUPING_ID 函数会创建一个位矢量，将 GROUPING 函数应用于每个属性时产生的 1 和 0 序列连接起来。这个位矢量作为一个二进制数处理，GROUPING_ID 函数随后返回其对应的十进制值。",
            "例如，使用 CUBE(a, b) 作为分组表达式时，可能的 GROUPING_ID 值如下所示：",
            "\n\n\n聚合层级\n位矢量\nGROUPING_ID\n\n\n\n\na, b\n00\n0\n\n\na\n01\n1\n\n\nb\n10\n2\n\n\n总计\n11\n3\n\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n描述\n\n\n\n\nattributeList\n要计算其组合值的表达式列表。\n\n\n"
        ],
        "Examples": [],
        "Detailed Examples": []
    },
    "GROUP_ID": {
        "Title": [
            "GROUP_ID"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822889"
        ],
        "Category": [
            "Aggregate Functions"
        ],
        "Feature": "GROUP_ID()\n",
        "Description": [
            "GROUP_ID 函数用于返回与 GROUP BY 子句中的重复组相关联的唯一标识符。它通常用在含有 ROLLUP 或 CUBE 操作的查询中，用于区分产生相同分组集的不同行。"
        ],
        "Illustration": [],
        "Examples": [
            "-- 创建表 t1\nCREATE TABLE t1 (c1 INT, c2 INT, c3 INT, c4 INT);\n\n-- 向表 t1 插入数据\nINSERT INTO t1 VALUES (1, 1, 1, 1);\nINSERT INTO t1 VALUES (1, 1, 1, 2);\nINSERT INTO t1 VALUES (1, 1, 2, 2);\nINSERT INTO t1 VALUES (1, 2, 2, 2);\nINSERT INTO t1 VALUES (2, 2, 2, 2);\n\n-- 查询并汇总数据，使用 GROUP BY 与 ROLLUP\nSELECT c1, c2, c3, c4, GROUP_ID()\nFROM t1 GROUP BY c1, ROLLUP(c1, c2, c3, c4) ORDER BY c1, c2, c3, c4;\n",
            "+------+------+------+------+------------+\n| C1   | C2   | C3   | C4   | GROUP_ID() |\n+------+------+------+------+------------+\n|    1 |    1 |    1 |    1 |          0 |\n|    1 |    1 |    1 |    2 |          0 |\n|    1 |    1 |    1 | NULL |          0 |\n|    1 |    1 |    2 |    2 |          0 |\n|    1 |    1 |    2 | NULL |          0 |\n|    1 |    1 | NULL | NULL |          0 |\n|    1 |    2 |    2 |    2 |          0 |\n|    1 |    2 |    2 | NULL |          0 |\n|    1 |    2 | NULL | NULL |          0 |\n|    1 | NULL | NULL | NULL |          0 |\n|    1 | NULL | NULL | NULL |          1 |\n|    2 |    2 |    2 |    2 |          0 |\n|    2 |    2 |    2 | NULL |          0 |\n|    2 |    2 | NULL | NULL |          0 |\n|    2 | NULL | NULL | NULL |          0 |\n|    2 | NULL | NULL | NULL |          1 |\n+------+------+------+------+------------+\n16 rows in set\n"
        ],
        "Detailed Examples": [
            "创建了一个名为 t1 的表，向表 t1 中插入多行数据。",
            "-- 创建表 t1\nCREATE TABLE t1 (c1 INT, c2 INT, c3 INT, c4 INT);\n\n-- 向表 t1 插入数据\nINSERT INTO t1 VALUES (1, 1, 1, 1);\nINSERT INTO t1 VALUES (1, 1, 1, 2);\nINSERT INTO t1 VALUES (1, 1, 2, 2);\nINSERT INTO t1 VALUES (1, 2, 2, 2);\nINSERT INTO t1 VALUES (2, 2, 2, 2);\n\n-- 查询并汇总数据，使用 GROUP BY 与 ROLLUP\nSELECT c1, c2, c3, c4, GROUP_ID()\nFROM t1 GROUP BY c1, ROLLUP(c1, c2, c3, c4) ORDER BY c1, c2, c3, c4;\n",
            "GROUP_ID() 函数用于识别 GROUP BY 子句返回的重复记录。例如，对于 c1=1 的两行相同汇总记录，GROUP_ID() 分别为 0 和 1。",
            "返回结果如下：",
            "+------+------+------+------+------------+\n| C1   | C2   | C3   | C4   | GROUP_ID() |\n+------+------+------+------+------------+\n|    1 |    1 |    1 |    1 |          0 |\n|    1 |    1 |    1 |    2 |          0 |\n|    1 |    1 |    1 | NULL |          0 |\n|    1 |    1 |    2 |    2 |          0 |\n|    1 |    1 |    2 | NULL |          0 |\n|    1 |    1 | NULL | NULL |          0 |\n|    1 |    2 |    2 |    2 |          0 |\n|    1 |    2 |    2 | NULL |          0 |\n|    1 |    2 | NULL | NULL |          0 |\n|    1 | NULL | NULL | NULL |          0 |\n|    1 | NULL | NULL | NULL |          1 |\n|    2 |    2 |    2 |    2 |          0 |\n|    2 |    2 |    2 | NULL |          0 |\n|    2 |    2 | NULL | NULL |          0 |\n|    2 | NULL | NULL | NULL |          0 |\n|    2 | NULL | NULL | NULL |          1 |\n+------+------+------+------+------------+\n16 rows in set\n"
        ]
    },
    "HEXTORAW": {
        "Title": [
            "HEXTORAW"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823221"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "HEXTORAW (char)\n",
        "Description": [
            "该函数将十六进制字符串转换为 RAW。"
        ],
        "Illustration": [
            "参数 char 是十六进制的字符串。字符串类型可以为 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。",
            "\n注意\n当 char 中出现比 F 大的字母时（以 A 为最小，Z 为最大）就会报错。\n",
            "返回 RAW 类型的数据。"
        ],
        "Examples": [
            "obclient> SELECT HEXTORAW('AAA') FROM DUAL;\n+-----------------+\n| HEXTORAW('AAA') |\n+-----------------+\n| 0AAA            |\n+-----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将十六进制字符串 AAA 转化为 RAW。",
            "obclient> SELECT HEXTORAW('AAA') FROM DUAL;\n+-----------------+\n| HEXTORAW('AAA') |\n+-----------------+\n| 0AAA            |\n+-----------------+\n1 row in set\n"
        ]
    },
    "INITCAP": {
        "Title": [
            "INITCAP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823186"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "INITCAP(char)\n",
        "Description": [
            "该函数返回字符串并将字符串中每个单词的首字母大写，其他字母小写。单词由空格或非字母数字字符分隔。"
        ],
        "Illustration": [
            "char 表示字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。",
            "返回 CHAR 类型数据。"
        ],
        "Examples": [
            "obclient> SELECT INITCAP('ABC def,gHI') STR FROM DUAL;\n+-------------+\n| STR         |\n+-------------+\n| Abc Def,Ghi |\n+-------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 ABC def,gHI 的每个单词首字母都大写。",
            "obclient> SELECT INITCAP('ABC def,gHI') STR FROM DUAL;\n+-------------+\n| STR         |\n+-------------+\n| Abc Def,Ghi |\n+-------------+\n1 row in set\n"
        ]
    },
    "INSERTCHILDXML": {
        "Title": [
            "INSERTCHILDXML"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823515"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "INSERTCHILDXML( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ])\n",
        "Description": [
            "该函数用于将指定的 XML 片段插入到目标 XML 中，插入位置由 XPath 表达式指示的节点决定。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n指定一个 XMLType 实例，表示目标 XML 文档。\n\n\nXPath_string\nXPath 表达式，指示要插入一个或多个子节点的一个或多个目标节点。可以使用绝对路径（以斜杠开头）或相对路径（省略初始斜杠）。如果省略初始斜杠，则相对路径的上下文默认为根节点。\n\n\nchild_expr\n指定一个或多个要插入的元素或属性节点。\n\n\nvalue_expr\n指定一个 XMLType 片段，指定要插入的一个或多个节点。它必须解析为一个字符串或者 XMLType。\n\n\nnamespace_string\n可选项，用于为 XPath_string 提供命名空间信息。\n\n\n",
            "\n说明\n插入的父节点如果还有命名空间，但是待插入的值没有，就要遍历增加空的命名空间。\n",
            "返回 XMLType 数据类型。"
        ],
        "Examples": [
            "SELECT INSERTCHILDXML(\n        XMLtype('<bookstore>\n                    <book att=\"old\"></book>\n                    <author>carrot</author>\n                  </bookstore>'), \n        '/bookstore', \n        'price', \n        XMLtype('<price>99.9</price>')\n      ) AS result\nFROM dual;\n",
            "+-----------------------------------------------------------------------------------------------+\n| RESULT                                                                                        |\n+-----------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\"/>\n  <author>carrot</author>\n  <price>99.9</price>\n</bookstore>\n|\n+-----------------------------------------------------------------------------------------------+\n1 row in set\n",
            "SELECT \n  INSERTCHILDXML(\n    xmltype(\n      '<bookstore>\n        <book att=\"old\"></book>\n        <author>carrot</author>\n      </bookstore>'\n    ), \n    '/bookstore/book', \n    'a', \n    xmltype('<a><b/></a>')\n  )\nFROM dual;\n",
            "+----------------------------------------------------------------------------------------------------------------------------------------------+\n| INSERTCHILDXML(XMLTYPE('<BOOKSTORE><BOOKATT=\"OLD\"></BOOK><AUTHOR>CARROT</AUTHOR></BOOKSTORE>'),'/BOOKSTORE/BOOK','A',XMLTYPE('<A><B/></A>')) |\n+----------------------------------------------------------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\">\n    <a>\n      <b/>\n    </a>\n  </book>\n  <author>carrot</author>\n</bookstore>\n                                |\n+----------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n",
            "SELECT \n  INSERTCHILDXML(\n    xmltype(\n      '<bookstore>\n        <book att=\"old\"></book>\n        <book></book>\n        <author>carrot</author>\n      </bookstore>'\n    ), \n    '/bookstore/book', \n    'price', \n    xmltype('<price>99.9</price>')\n  ) \nFROM dual;\n",
            "+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| INSERTCHILDXML(XMLTYPE('<BOOKSTORE><BOOKATT=\"OLD\"></BOOK><BOOK></BOOK><AUTHOR>CARROT</AUTHOR></BOOKSTORE>'),'/BOOKSTORE/BOOK','PRICE',XMLTYPE('<PRICE>99.9</PRICE>')) |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\">\n    <price>99.9</price>\n  </book>\n  <book>\n    <price>99.9</price>\n  </book>\n  <author>carrot</author>\n</bookstore>\n                  |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n",
            "SELECT \n  INSERTCHILDXML(\n    xmltype(\n      '<bookstore>\n        <book att=\"old\"></book>\n        <author>carrot</author>\n      </bookstore>'\n    ), \n    '/bookstore/book', \n    '@att2', \n    'abc'\n  ) \nFROM dual;\n",
            "+---------------------------------------------------------------------------------------------------------------------------------+\n| INSERTCHILDXML(XMLTYPE('<BOOKSTORE><BOOKATT=\"OLD\"></BOOK><AUTHOR>CARROT</AUTHOR></BOOKSTORE>'),'/BOOKSTORE/BOOK','@ATT2','ABC') |\n+---------------------------------------------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\" att2=\"abc\"/>\n  <author>carrot</author>\n</bookstore>\n                                              |\n+---------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 INSERTCHILDXML 函数向目标 XML 中插入一个子节点。其中，目标 XML 是 <bookstore> 节点及其子节点；XPath 表达式是 /bookstore，它指示要将子节点插入到 <bookstore> 节点中；要插入的子节点名是 price；要插入的子节点的内容是一个 XMLType 实例，表示 <price>99.9</price>；查询的结果使用 AS 关键字重命名为 result；最后，从 dual 表中检索结果。",
            "SELECT INSERTCHILDXML(\n        XMLtype('<bookstore>\n                    <book att=\"old\"></book>\n                    <author>carrot</author>\n                  </bookstore>'), \n        '/bookstore', \n        'price', \n        XMLtype('<price>99.9</price>')\n      ) AS result\nFROM dual;\n",
            "返回结果如下：",
            "+-----------------------------------------------------------------------------------------------+\n| RESULT                                                                                        |\n+-----------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\"/>\n  <author>carrot</author>\n  <price>99.9</price>\n</bookstore>\n|\n+-----------------------------------------------------------------------------------------------+\n1 row in set\n",
            "插入一个节点。",
            "SELECT \n  INSERTCHILDXML(\n    xmltype(\n      '<bookstore>\n        <book att=\"old\"></book>\n        <author>carrot</author>\n      </bookstore>'\n    ), \n    '/bookstore/book', \n    'a', \n    xmltype('<a><b/></a>')\n  )\nFROM dual;\n",
            "返回结果如下：",
            "+----------------------------------------------------------------------------------------------------------------------------------------------+\n| INSERTCHILDXML(XMLTYPE('<BOOKSTORE><BOOKATT=\"OLD\"></BOOK><AUTHOR>CARROT</AUTHOR></BOOKSTORE>'),'/BOOKSTORE/BOOK','A',XMLTYPE('<A><B/></A>')) |\n+----------------------------------------------------------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\">\n    <a>\n      <b/>\n    </a>\n  </book>\n  <author>carrot</author>\n</bookstore>\n                                |\n+----------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n",
            "如果xpath查出多个，都会插入进去",
            "SELECT \n  INSERTCHILDXML(\n    xmltype(\n      '<bookstore>\n        <book att=\"old\"></book>\n        <book></book>\n        <author>carrot</author>\n      </bookstore>'\n    ), \n    '/bookstore/book', \n    'price', \n    xmltype('<price>99.9</price>')\n  ) \nFROM dual;\n",
            "返回结果如下：",
            "+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| INSERTCHILDXML(XMLTYPE('<BOOKSTORE><BOOKATT=\"OLD\"></BOOK><BOOK></BOOK><AUTHOR>CARROT</AUTHOR></BOOKSTORE>'),'/BOOKSTORE/BOOK','PRICE',XMLTYPE('<PRICE>99.9</PRICE>')) |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\">\n    <price>99.9</price>\n  </book>\n  <book>\n    <price>99.9</price>\n  </book>\n  <author>carrot</author>\n</bookstore>\n                  |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n",
            "插入属性。",
            "SELECT \n  INSERTCHILDXML(\n    xmltype(\n      '<bookstore>\n        <book att=\"old\"></book>\n        <author>carrot</author>\n      </bookstore>'\n    ), \n    '/bookstore/book', \n    '@att2', \n    'abc'\n  ) \nFROM dual;\n",
            "返回结果如下：",
            "+---------------------------------------------------------------------------------------------------------------------------------+\n| INSERTCHILDXML(XMLTYPE('<BOOKSTORE><BOOKATT=\"OLD\"></BOOK><AUTHOR>CARROT</AUTHOR></BOOKSTORE>'),'/BOOKSTORE/BOOK','@ATT2','ABC') |\n+---------------------------------------------------------------------------------------------------------------------------------+\n| <bookstore>\n  <book att=\"old\" att2=\"abc\"/>\n  <author>carrot</author>\n</bookstore>\n                                              |\n+---------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "INSTR": {
        "Title": [
            "INSTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823209"
        ],
        "Category": [
            "Character Functions Returning NumberValues"
        ],
        "Feature": "INSTR(char1,char2[,i[,j]])\n",
        "Description": [
            "该函数在一个字符串中搜索指定的字符，返回发现指定的字符的位置。多字节字符（汉字、全角符等）按 1 个字符计算。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n被搜索的字符串。字符串类型可以为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nchar2\n指定要搜索的字符串。字符串类型可以为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\ni\n搜索的开始位置，默认值为 1。当值小于 0 时，搜索从反方向开始，但是仍返回被搜索到的字符的正序位置。\n\n\nj\nchar2 第 j 次出现的位置，为可选项。默认值为 1。\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT INSTR('OceanBase','a',1,2) \"INSTR\" FROM DUAL;\n+-------+\n| INSTR |\n+-------+\n|     7 |\n+-------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回在字符串 OceanBase 中正向搜索 a 第二次出现的位置。",
            "obclient> SELECT INSTR('OceanBase','a',1,2) \"INSTR\" FROM DUAL;\n+-------+\n| INSTR |\n+-------+\n|     7 |\n+-------+\n1 row in set\n"
        ]
    },
    "JSON_ARRAY": {
        "Title": [
            "JSON_ARRAY"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823495"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_ARRAY (\n              [val [FORMAT JSON], val [FORMAT JSON] ...]\n                    [ABSENT|NULL ON NULL]\n              [RETURNING JSON | CLOB| BLOB| VARCAHR2| VARCHAR2[size]]\n              [STRICT] )\n",
        "Description": [
            "JSON_ARRAY() 函数计算一系列 SQL 标量表达式，将每个表达式转换为 JSON 值，并且构造一个包含这些 JSON 值的 JSON 数组。",
            "JSON_ARRAY() 可以指定参数表达式的计算结果为 JSON 对象、JSON 数组、数字文字、文本文字、日期、时间戳或 NULL。此函数将数字文字转换为 JSON 数字值，并将文本文字转换为 JSON 字符串值。日期和时间戳数据类型在生成的 JSON 对象或数组中打印为遵循 ISO 8601 日期格式的 JSON 字符串。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用嵌套表达式以及 NULL ON NULL 子句\nobclient> SELECT JSON_ARRAY (JSON_ARRAY(1,2,3),100,'California',null NULL ON NULL) \"JSON Array Example\"\n        FROM DUAL;\n+-----------------------------------+\n| JSON Array Example                |\n+-----------------------------------+\n| [\"[1,2,3]\",100,\"California\",null] |\n+-----------------------------------+\n1 row in set\n\n# ABSENT ON NULL 子句生效，结果里面没有 Null\nobclient> SELECT JSON_ARRAY( JSON_ARRAY(1,2,3),100,'California', null ABSENT ON NULL) \"JSON Array Example\"\n      FROM DUAL;\n+----------------------------------+\n| JSON Array Example               |\n+----------------------------------+\n| [\"[1, 2, 3]\", 100, \"California\"] |\n+----------------------------------+\n1 row in set\n\n# FORMAT JSON 子句生效，把当前表达式输入字符串当做 JSON 类型，输出结果没有被加'\\\"'\n\nobclient> SELECT JSON_ARRAY('{\"a\":\"a-value\", \"b\" : \"b-value\"}' format json RETURNING CLOB)\n    FROM DUAL;\n+--------------------------------------------------------------------+\n| JSON_ARRAY('{\"A\":\"A-VALUE\",\"B\":\"B-VALUE\"}'FORMATJSONRETURNINGCLOB) |\n+--------------------------------------------------------------------+\n| [{\"a\": \"a-value\", \"b\": \"b-value\"}]                                 |\n+--------------------------------------------------------------------+\n1 row in set\n\n# 输入中没有 FORMAT JSON, 输出字符串被加了'\\\"'\nobclient> SELECT JSON_ARRAY('{\"a\":\"a-value\", \"b\" : \"b-value\"}' RETURNING CLOB) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_ARRAY('{\"A\":\"A-VALUE\",\"B\":\"B-VALUE\"}'RETURNINGCLOB) |\n+----------------------------------------------------------+\n| [\"{\\\"a\\\":\\\"a-value\\\", \\\"b\\\" : \\\"b-value\\\"}\"]             |\n+----------------------------------------------------------+\n1 row in set\n\n# 指定返回值类型为 VARCHAR2 类型\nobclient> SELECT JSON_ARRAY('{\"a\":\"a-value\", \"b\" : \"b-value\"}' format json RETURNING VARCHAR2)\n    FROM DUAL;\n+------------------------------------------------------------------------+\n| JSON_ARRAY('{\"A\":\"A-VALUE\",\"B\":\"B-VALUE\"}'FORMATJSONRETURNINGVARCHAR2) |\n+------------------------------------------------------------------------+\n| [{\"a\": \"a-value\", \"b\": \"b-value\"}]                                     |\n+------------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 使用嵌套表达式以及 NULL ON NULL 子句\nobclient> SELECT JSON_ARRAY (JSON_ARRAY(1,2,3),100,'California',null NULL ON NULL) \"JSON Array Example\"\n        FROM DUAL;\n+-----------------------------------+\n| JSON Array Example                |\n+-----------------------------------+\n| [\"[1,2,3]\",100,\"California\",null] |\n+-----------------------------------+\n1 row in set\n\n# ABSENT ON NULL 子句生效，结果里面没有 Null\nobclient> SELECT JSON_ARRAY( JSON_ARRAY(1,2,3),100,'California', null ABSENT ON NULL) \"JSON Array Example\"\n      FROM DUAL;\n+----------------------------------+\n| JSON Array Example               |\n+----------------------------------+\n| [\"[1, 2, 3]\", 100, \"California\"] |\n+----------------------------------+\n1 row in set\n\n# FORMAT JSON 子句生效，把当前表达式输入字符串当做 JSON 类型，输出结果没有被加'\\\"'\n\nobclient> SELECT JSON_ARRAY('{\"a\":\"a-value\", \"b\" : \"b-value\"}' format json RETURNING CLOB)\n    FROM DUAL;\n+--------------------------------------------------------------------+\n| JSON_ARRAY('{\"A\":\"A-VALUE\",\"B\":\"B-VALUE\"}'FORMATJSONRETURNINGCLOB) |\n+--------------------------------------------------------------------+\n| [{\"a\": \"a-value\", \"b\": \"b-value\"}]                                 |\n+--------------------------------------------------------------------+\n1 row in set\n\n# 输入中没有 FORMAT JSON, 输出字符串被加了'\\\"'\nobclient> SELECT JSON_ARRAY('{\"a\":\"a-value\", \"b\" : \"b-value\"}' RETURNING CLOB) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_ARRAY('{\"A\":\"A-VALUE\",\"B\":\"B-VALUE\"}'RETURNINGCLOB) |\n+----------------------------------------------------------+\n| [\"{\\\"a\\\":\\\"a-value\\\", \\\"b\\\" : \\\"b-value\\\"}\"]             |\n+----------------------------------------------------------+\n1 row in set\n\n# 指定返回值类型为 VARCHAR2 类型\nobclient> SELECT JSON_ARRAY('{\"a\":\"a-value\", \"b\" : \"b-value\"}' format json RETURNING VARCHAR2)\n    FROM DUAL;\n+------------------------------------------------------------------------+\n| JSON_ARRAY('{\"A\":\"A-VALUE\",\"B\":\"B-VALUE\"}'FORMATJSONRETURNINGVARCHAR2) |\n+------------------------------------------------------------------------+\n| [{\"a\": \"a-value\", \"b\": \"b-value\"}]                                     |\n+------------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "JSON_ARRAYAGG": {
        "Title": [
            "JSON_ARRAYAGG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823494"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_ARRAYAGG(expr [FORMAT JSON]\n                   [ORDER SIBLINGS BY order_condition]\n                   [ABSENT|NULL ON NULL,]\n                   [RETURNING  CLOB|BLOB|JSON|VARCHAR2|VARCHAR2[size],]\n                   [STRICT]);\n",
        "Description": [
            "JSON_ARRAYAGG() 是一个聚合函数，它将所有列的数据转换成 JSON 数据，并且将所有的 JSON 数据组成一个单独的 JSON 数组结构。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用默认参数\nobclient> CREATE TABLE id_table (id NUMBER);\nobclient> INSERT INTO id_table VALUES(624);\nobclient> INSERT INTO id_table VALUES(null);\nobclient> INSERT INTO id_table VALUES(925);\nobclient> INSERT INTO id_table VALUES(585);\nobclient> SELECT JSON_ARRAYAGG(id) ID_NUMBERS FROM id_table;\n+---------------+\n| ID_NUMBERS    |\n+---------------+\n| [624,925,585] |\n+---------------+\n1 row in set\n\n# 使用FORMAT JSON 子句\nobclient> CREATE TABLE json_table (json_doc VARCHAR2(100))\nobclient> INSERT INTO json_table VALUES('[1]');\nobclient> INSERT INTO json_table VALUES('[1,2]');\nobclient> INSERT INTO json_table VALUES('[1,2,3]')\nobclient> INSERT INTO json_table VALUES('{key:\"value\"}');\nobclient> SELECT JSON_ARRAYAGG(json_doc FORMAT JSON) FROM json_table;\n+-----------------------------------+\n| JSON_ARRAYAGG(JSON_DOCFORMATJSON) |\n+-----------------------------------+\n| [[1],[1,2],[1,2,3],{key:\"value\"}] |\n+-----------------------------------+\n1 row in set\n\n# 使用 ABSENT ON NULL 子句\nobclient> SELECT JSON_ARRAYAGG(id ORDER BY id ABSENT ON NULL) FROM id_table;\n+----------------------------------------+\n| JSON_ARRAYAGG(IDORDERBYIDABSENTONNULL) |\n+----------------------------------------+\n| [585,624,925]                          |\n+----------------------------------------+\n1 row in set\n\n# 使用 ORDER BY 子句\nCREATE TABLE json_table (id NUMBER, text_data VARCHAR2(10), json_data JSON);\nINSERT INTO json_table VALUES(624, 'test1', '[1]');\nINSERT INTO json_table VALUES(null, 'test4', '[2]');\nINSERT INTO json_table VALUES(925, 'test2', '[3]');\nINSERT INTO json_table VALUES(585, 'test5', '[4]');\nINSERT INTO json_table VALUES(585, 'test3', '[5]');\nobclient> SELECT JSON_ARRAYAGG(text_data ORDER BY text_data) FROM json_table;\n+-------------------------------------------+\n| JSON_ARRAYAGG(TEXT_DATAORDERBYTEXT_DATA)  |\n+-------------------------------------------+\n| [\"test1\",\"test2\",\"test3\",\"test4\",\"test5\"] |\n+-------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_ARRAYAGG(text_data ORDER BY id) FROM json_table;\n+-------------------------------------------+\n| JSON_ARRAYAGG(TEXT_DATAORDERBYID)         |\n+-------------------------------------------+\n| [\"test5\",\"test3\",\"test1\",\"test2\",\"test4\"] |\n+-------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_ARRAYAGG(text_data ORDER BY id,text_data) FROM json_table;\n+---------------------------------------------+\n| JSON_ARRAYAGG(TEXT_DATAORDERBYID,TEXT_DATA) |\n+---------------------------------------------+\n| [\"test3\",\"test5\",\"test1\",\"test2\",\"test4\"]   |\n+---------------------------------------------+\n1 row in set\n\n# 使用 STRICT 子句\nCREATE TABLE json_table (json_doc VARCHAR2(100));\nINSERT INTO json_table VALUES('[1]');\nINSERT INTO json_table VALUES('[1,2]');\nINSERT INTO json_table VALUES('[1,2,3]');\nINSERT INTO json_table VALUES('{key:\"value\"}');\n\nobclient> SELECT JSON_ARRAYAGG(json_doc FORMAT JSON STRICT) ID_NUMBERS FROM json_table;\nORA-00600: Invalid JSON text.\nobclient> SELECT JSON_ARRAYAGG(json_doc FORMAT JSON) ID_NUMBERS FROM json_table;\n+-----------------------------------+\n| ID_NUMBERS                        |\n+-----------------------------------+\n| [[1],[1,2],[1,2,3],{key:\"value\"}] |\n+-----------------------------------+\n1 row in set\n\n"
        ],
        "Detailed Examples": [
            "# 使用默认参数\nobclient> CREATE TABLE id_table (id NUMBER);\nobclient> INSERT INTO id_table VALUES(624);\nobclient> INSERT INTO id_table VALUES(null);\nobclient> INSERT INTO id_table VALUES(925);\nobclient> INSERT INTO id_table VALUES(585);\nobclient> SELECT JSON_ARRAYAGG(id) ID_NUMBERS FROM id_table;\n+---------------+\n| ID_NUMBERS    |\n+---------------+\n| [624,925,585] |\n+---------------+\n1 row in set\n\n# 使用FORMAT JSON 子句\nobclient> CREATE TABLE json_table (json_doc VARCHAR2(100))\nobclient> INSERT INTO json_table VALUES('[1]');\nobclient> INSERT INTO json_table VALUES('[1,2]');\nobclient> INSERT INTO json_table VALUES('[1,2,3]')\nobclient> INSERT INTO json_table VALUES('{key:\"value\"}');\nobclient> SELECT JSON_ARRAYAGG(json_doc FORMAT JSON) FROM json_table;\n+-----------------------------------+\n| JSON_ARRAYAGG(JSON_DOCFORMATJSON) |\n+-----------------------------------+\n| [[1],[1,2],[1,2,3],{key:\"value\"}] |\n+-----------------------------------+\n1 row in set\n\n# 使用 ABSENT ON NULL 子句\nobclient> SELECT JSON_ARRAYAGG(id ORDER BY id ABSENT ON NULL) FROM id_table;\n+----------------------------------------+\n| JSON_ARRAYAGG(IDORDERBYIDABSENTONNULL) |\n+----------------------------------------+\n| [585,624,925]                          |\n+----------------------------------------+\n1 row in set\n\n# 使用 ORDER BY 子句\nCREATE TABLE json_table (id NUMBER, text_data VARCHAR2(10), json_data JSON);\nINSERT INTO json_table VALUES(624, 'test1', '[1]');\nINSERT INTO json_table VALUES(null, 'test4', '[2]');\nINSERT INTO json_table VALUES(925, 'test2', '[3]');\nINSERT INTO json_table VALUES(585, 'test5', '[4]');\nINSERT INTO json_table VALUES(585, 'test3', '[5]');\nobclient> SELECT JSON_ARRAYAGG(text_data ORDER BY text_data) FROM json_table;\n+-------------------------------------------+\n| JSON_ARRAYAGG(TEXT_DATAORDERBYTEXT_DATA)  |\n+-------------------------------------------+\n| [\"test1\",\"test2\",\"test3\",\"test4\",\"test5\"] |\n+-------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_ARRAYAGG(text_data ORDER BY id) FROM json_table;\n+-------------------------------------------+\n| JSON_ARRAYAGG(TEXT_DATAORDERBYID)         |\n+-------------------------------------------+\n| [\"test5\",\"test3\",\"test1\",\"test2\",\"test4\"] |\n+-------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_ARRAYAGG(text_data ORDER BY id,text_data) FROM json_table;\n+---------------------------------------------+\n| JSON_ARRAYAGG(TEXT_DATAORDERBYID,TEXT_DATA) |\n+---------------------------------------------+\n| [\"test3\",\"test5\",\"test1\",\"test2\",\"test4\"]   |\n+---------------------------------------------+\n1 row in set\n\n# 使用 STRICT 子句\nCREATE TABLE json_table (json_doc VARCHAR2(100));\nINSERT INTO json_table VALUES('[1]');\nINSERT INTO json_table VALUES('[1,2]');\nINSERT INTO json_table VALUES('[1,2,3]');\nINSERT INTO json_table VALUES('{key:\"value\"}');\n\nobclient> SELECT JSON_ARRAYAGG(json_doc FORMAT JSON STRICT) ID_NUMBERS FROM json_table;\nORA-00600: Invalid JSON text.\nobclient> SELECT JSON_ARRAYAGG(json_doc FORMAT JSON) ID_NUMBERS FROM json_table;\n+-----------------------------------+\n| ID_NUMBERS                        |\n+-----------------------------------+\n| [[1],[1,2],[1,2,3],{key:\"value\"}] |\n+-----------------------------------+\n1 row in set\n\n"
        ]
    },
    "JSON_EQUAL": {
        "Title": [
            "JSON_EQUAL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823503"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "json_equal(expr,\n           expr\n          [TRUE|FALSE|ERROR ON ERROR]);\n",
        "Description": [
            "JSON_EQUAL() 函数用于比较两个 JSON 值，如果相等则返回 Ture。如果两个值不相等，则返回 False。输入值必须是有效的 JSON 数据。比较忽略空格和对象成员顺序。例如，如果 JSON 对象具有相同的成员，则无论它们的顺序如何，都是相等的。",
            "此外，IS JSON和 IS NOT JSON在 SQL 语句中作为 SQL 条件也用以校验表达式结果是否是合法的 JSON 数据格式。详细信息请参见 JSON 数据类型列的创建。"
        ],
        "Illustration": [],
        "Examples": [
            "# WHEN CASE 中作为 SQL 条件使用 JSON_EQUAL() 函数\nobclient> SELECT CASE\n               WHEN JSON_EQUAL (\n       '{\"comparesAttributes\":\"and values\"}', '{\"inTwoJSONDocuments\": \"for equality\"}'\n               ) THEN 'THE SAME' ELSE 'DIFFERENT'\n             END JSON_COMPARE\n      FROM   DUAL;\n+--------------+\n| JSON_COMPARE |\n+--------------+\n|  DIFFERENT   |\n+--------------+\n1 row in set\n\n# 相同的输入\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1]' FALSE ON ERROR);\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n1 row in set\n\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1' TRUE ON ERROR);\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n1 row in set\n\n# 使用 ERROR 子句 FALSE ON ERROR\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1' FALSE ON ERROR);\nEmpty set\n\n# 使用 ERROR 子句 ERROR ON ERROR\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1' error on error);\nORA-40441: JSON syntax error\n"
        ],
        "Detailed Examples": [
            "# WHEN CASE 中作为 SQL 条件使用 JSON_EQUAL() 函数\nobclient> SELECT CASE\n               WHEN JSON_EQUAL (\n       '{\"comparesAttributes\":\"and values\"}', '{\"inTwoJSONDocuments\": \"for equality\"}'\n               ) THEN 'THE SAME' ELSE 'DIFFERENT'\n             END JSON_COMPARE\n      FROM   DUAL;\n+--------------+\n| JSON_COMPARE |\n+--------------+\n|  DIFFERENT   |\n+--------------+\n1 row in set\n\n# 相同的输入\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1]' FALSE ON ERROR);\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n1 row in set\n\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1' TRUE ON ERROR);\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n1 row in set\n\n# 使用 ERROR 子句 FALSE ON ERROR\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1' FALSE ON ERROR);\nEmpty set\n\n# 使用 ERROR 子句 ERROR ON ERROR\nobclient> SELECT 1 FROM DUAL WHERE JSON_EQUAL('[1,]', '[1' error on error);\nORA-40441: JSON syntax error\n"
        ]
    },
    "JSON_EXISTS": {
        "Title": [
            "JSON_EXISTS"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823500"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_EXISTS(\n              expr [FORMAT JSON],\n              json_path_literal\n                 [PASSING expr AS identifier]\n                 [ERROR|TRUE|FALSE ON ERROR]\n              [ERROR|TRUE|FALSE ON EMPTY]);\n\n",
        "Description": [
            "JSON_EXISTS() 函数在 SQL 语句中作为 SQL 条件，来检验指定路径下的 JSON 数据是否存在，或者满足某些条件，可以理解为针对 JSON 数据起到过滤条件作用。如果 JSON 值存在，此条件返回 TRUE，如果 JSON 值不存在，则返回 FALSE。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用默认参数，用于选取符合条件的 JSON 值\nCREATE TABLE t (name VARCHAR2(100));\nINSERT INTO t VALUES ('[{first:\"John\"}, {middle:\"Mark\"}, {last:\"Smith\"}]');\nINSERT INTO t VALUES ('[{first:\"Mary\"}, {last:\"Jones\"}]');\nINSERT INTO t VALUES ('[{first:\"Jeff\"}, {last:\"Williams\"}]');\nINSERT INTO t VALUES ('[{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}]');\nINSERT INTO t VALUES (NULL);\nINSERT INTO t VALUES ('This is not well-formed JSON data');\n\nobclient> SELECT name FROM t  WHERE JSON_EXISTS(name, '$[0].first');\n+---------------------------------------------------+\n| NAME                                              |\n+---------------------------------------------------+\n| [{first:\"John\"}, {middle:\"Mark\"}, {last:\"Smith\"}] |\n| [{first:\"Mary\"}, {last:\"Jones\"}]                  |\n| [{first:\"Jeff\"}, {last:\"Williams\"}]               |\n| [{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}] |\n+---------------------------------------------------+\n4 rows in set\n\n# 当出现不匹配时，或者 expr 不是合法的JSON数据时，JSON_EXIST 返回 false\nobclient> SELECT name FROM t WHERE JSON_EXISTS(name, '$[1].middle');\n+---------------------------------------------------+\n| NAME                                              |\n+---------------------------------------------------+\n| [{first:\"John\"}, {middle:\"Mark\"}, {last:\"Smith\"}] |\n| [{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}] |\n+---------------------------------------------------+\n2 rows in set\n\n# 将 PASSING 子句传递给 json-path 参数\nobclient> SELECT name FROM t WHERE JSON_EXISTS(name, '$[1]?(@.middle == $var1)' PASSING 'Anne' as \"var1\");\n+---------------------------------------------------+\n| NAME                                              |\n+---------------------------------------------------+\n| [{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}] |\n+---------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 使用默认参数，用于选取符合条件的 JSON 值\nCREATE TABLE t (name VARCHAR2(100));\nINSERT INTO t VALUES ('[{first:\"John\"}, {middle:\"Mark\"}, {last:\"Smith\"}]');\nINSERT INTO t VALUES ('[{first:\"Mary\"}, {last:\"Jones\"}]');\nINSERT INTO t VALUES ('[{first:\"Jeff\"}, {last:\"Williams\"}]');\nINSERT INTO t VALUES ('[{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}]');\nINSERT INTO t VALUES (NULL);\nINSERT INTO t VALUES ('This is not well-formed JSON data');\n\nobclient> SELECT name FROM t  WHERE JSON_EXISTS(name, '$[0].first');\n+---------------------------------------------------+\n| NAME                                              |\n+---------------------------------------------------+\n| [{first:\"John\"}, {middle:\"Mark\"}, {last:\"Smith\"}] |\n| [{first:\"Mary\"}, {last:\"Jones\"}]                  |\n| [{first:\"Jeff\"}, {last:\"Williams\"}]               |\n| [{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}] |\n+---------------------------------------------------+\n4 rows in set\n\n# 当出现不匹配时，或者 expr 不是合法的JSON数据时，JSON_EXIST 返回 false\nobclient> SELECT name FROM t WHERE JSON_EXISTS(name, '$[1].middle');\n+---------------------------------------------------+\n| NAME                                              |\n+---------------------------------------------------+\n| [{first:\"John\"}, {middle:\"Mark\"}, {last:\"Smith\"}] |\n| [{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}] |\n+---------------------------------------------------+\n2 rows in set\n\n# 将 PASSING 子句传递给 json-path 参数\nobclient> SELECT name FROM t WHERE JSON_EXISTS(name, '$[1]?(@.middle == $var1)' PASSING 'Anne' as \"var1\");\n+---------------------------------------------------+\n| NAME                                              |\n+---------------------------------------------------+\n| [{first:\"Jean\"}, {middle:\"Anne\"}, {last:\"Brown\"}] |\n+---------------------------------------------------+\n1 row in set\n"
        ]
    },
    "JSON_MERGEPATCH": {
        "Title": [
            "JSON_MERGEPATCH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823502"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_MERGEPATCH (\n                 target_expr,\n                 patch_expr\n                 [RETURNING  CLOB|BLOB|JSON|VARCHAR2|VARCHAR2[size],]\n                 [PRETTY]\n                 [ASCII]\n                 [TRUNCATE]\n                 [ERROR|NULL ON ERROR]);\n",
        "Description": [
            "JSON_MERGEPATCH() 函数用于更新 target_json 数据的特定部分，根据 RFC 7396 的标准对两个或多个 JSON 文档执行合并返回合并结果，而不保留具有重复键的成员。 如果至少一个文档作为参数传递给此函数是无效的，则会引发错误。",
            "JSON_MERGEPATCH() 执行合并的原理如下：",
            "如果第一个参数不是对象，则合并的结果与空对象和第二个参数合并的结果相同。",
            "如果第二个参数不是对象，则合并的结果是第二个参数。",
            "如果两个参数都是对象，则合并的结果是具有以下成员的对象： \n    ",
            "\n第一个对象的所有成员在第二个对象中没有具有相同键的对应成员。\n第二个对象的所有成员在第一个对象中没有对应的键，并且其值不是 JSON Null 文字。\n",
            "第一个对象的所有成员在第二个对象中没有具有相同键的对应成员。",
            "第二个对象的所有成员在第一个对象中没有对应的键，并且其值不是 JSON Null 文字。",
            "所有成员的键都存在于第一个和第二个对象中，并且其在第二个对象中的值不是 JSON Null 文字。",
            "这些成员的值是递归合并第一个对象中的值与第二个对象中的值的结果。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用默认参数\nobclient> SELECT json_mergepatch('{\"a\":\"b\"}', '{\"b\":\"c\"}') FROM DUAL;\n+------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\"}','{\"B\":\"C\"}') |\n+------------------------------------------+\n| {\"a\": \"b\", \"b\": \"c\"}                     |\n+------------------------------------------+\n1 row in set\n\n# 当 Patch 是 null, 相当于删除\nobclient> SELECT json_mergepatch('{\"a\":\"b\"}', '{\"a\":null}') FROM DUAL;\n+-------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\"}','{\"A\":NULL}') |\n+-------------------------------------------+\n| {}                                        |\n+-------------------------------------------+\n1 row in set\n\n# 相同的 Key 时会更新\nobclient> SELECT json_mergepatch('{\"a\":[\"b\"]}', '{\"a\":\"c\"}') FROM DUAL;\n+--------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":[\"B\"]}','{\"A\":\"C\"}') |\n+--------------------------------------------+\n| {\"a\": \"c\"}                                 |\n+--------------------------------------------+\n1 row in set\n\n# 使用 RETURNING 子句和 PRETTY 子句\nobclient> SELECT json_mergepatch('{\"a\":\"b\", \"b\":\"c\"}', '{\"a\":null}' RETURNING CLOB PRETTY ) FROM DUAL;\n+----------------------------------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\",\"B\":\"C\"}','{\"A\":NULL}'RETURNINGCLOBPRETTY) |\n+----------------------------------------------------------------------+\n| {\n  \"b\": \"c\"\n}                                                       |\n+----------------------------------------------------------------------+\n1 row in set\n\n# 使用 TRUNCATE 子句生效\nobclient> SELECT json_mergepatch(\n      '{\"a\":\"b\"}',\n      '{\"a\":\"cccccccccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccccccccccccccccccc\"}'\n          RETURNING varchar2(32) PRETTY TRUNCATE) FROM DUAL;\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\"}','{\"A\":\"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\"}'RETURNINGVARCHAR2(32)PRETTYTRUNCATE) |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| {\n  \"a\": \"cccccccccccccccccccccc                                                                                                                                                                                                        |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\n# 使用 ERROR 子句\nobclient> SELECT json_mergepatch('{', '[1,2,3]' ERROR ON ERROR) FROM DUAL;\nORA-40441: JSON syntax error\n\n# 默认对错误处理返回 NULL\nobclient> SELECT json_mergepatch('{', '[1,2,3]') FROM DUAL;\n+--------------------------------+\n| JSON_MERGEPATCH('{','[1,2,3]') |\n+--------------------------------+\n| NULL                           |\n+--------------------------------+\n1 row in set\n\n# 指定 ERROR 子句的处理\nobclient> SELECT json_mergepatch('{', '[1,2,3]' NULL ON ERROR) FROM DUAL;\n+-------------------------------------------+\n| JSON_MERGEPATCH('{','[1,2,3]'NULLONERROR) |\n+-------------------------------------------+\n| NULL                                      |\n+-------------------------------------------+\n1 row in set \n\n"
        ],
        "Detailed Examples": [
            "# 使用默认参数\nobclient> SELECT json_mergepatch('{\"a\":\"b\"}', '{\"b\":\"c\"}') FROM DUAL;\n+------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\"}','{\"B\":\"C\"}') |\n+------------------------------------------+\n| {\"a\": \"b\", \"b\": \"c\"}                     |\n+------------------------------------------+\n1 row in set\n\n# 当 Patch 是 null, 相当于删除\nobclient> SELECT json_mergepatch('{\"a\":\"b\"}', '{\"a\":null}') FROM DUAL;\n+-------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\"}','{\"A\":NULL}') |\n+-------------------------------------------+\n| {}                                        |\n+-------------------------------------------+\n1 row in set\n\n# 相同的 Key 时会更新\nobclient> SELECT json_mergepatch('{\"a\":[\"b\"]}', '{\"a\":\"c\"}') FROM DUAL;\n+--------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":[\"B\"]}','{\"A\":\"C\"}') |\n+--------------------------------------------+\n| {\"a\": \"c\"}                                 |\n+--------------------------------------------+\n1 row in set\n\n# 使用 RETURNING 子句和 PRETTY 子句\nobclient> SELECT json_mergepatch('{\"a\":\"b\", \"b\":\"c\"}', '{\"a\":null}' RETURNING CLOB PRETTY ) FROM DUAL;\n+----------------------------------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\",\"B\":\"C\"}','{\"A\":NULL}'RETURNINGCLOBPRETTY) |\n+----------------------------------------------------------------------+\n| {\n  \"b\": \"c\"\n}                                                       |\n+----------------------------------------------------------------------+\n1 row in set\n\n# 使用 TRUNCATE 子句生效\nobclient> SELECT json_mergepatch(\n      '{\"a\":\"b\"}',\n      '{\"a\":\"cccccccccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccccccccccccccccccc\"}'\n          RETURNING varchar2(32) PRETTY TRUNCATE) FROM DUAL;\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| JSON_MERGEPATCH('{\"A\":\"B\"}','{\"A\":\"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\"}'RETURNINGVARCHAR2(32)PRETTYTRUNCATE) |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| {\n  \"a\": \"cccccccccccccccccccccc                                                                                                                                                                                                        |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\n# 使用 ERROR 子句\nobclient> SELECT json_mergepatch('{', '[1,2,3]' ERROR ON ERROR) FROM DUAL;\nORA-40441: JSON syntax error\n\n# 默认对错误处理返回 NULL\nobclient> SELECT json_mergepatch('{', '[1,2,3]') FROM DUAL;\n+--------------------------------+\n| JSON_MERGEPATCH('{','[1,2,3]') |\n+--------------------------------+\n| NULL                           |\n+--------------------------------+\n1 row in set\n\n# 指定 ERROR 子句的处理\nobclient> SELECT json_mergepatch('{', '[1,2,3]' NULL ON ERROR) FROM DUAL;\n+-------------------------------------------+\n| JSON_MERGEPATCH('{','[1,2,3]'NULLONERROR) |\n+-------------------------------------------+\n| NULL                                      |\n+-------------------------------------------+\n1 row in set \n\n"
        ]
    },
    "JSON_OBJECT": {
        "Title": [
            "JSON_OBJECT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823497"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_OBJECT([KEY]'key_name': value_expr FORMAT JSON,\n                         'key_name' VALUE value_expr\n                         [ABSENT|NULL ON NULL,]\n                         [RETURNING  CLOB|BLOB|JSON|VARCHAR2|VARCHAR2[size],]\n                         [STRICT,]\n                         [WITH UNIQUE KEYS]);\n",
        "Description": [
            "对于 SQL 输入的一系列 key-value 对，JSON_OBJECT() 函数将其转换成一个 JSON 格式的对象，包含了前面输入的所有 key-value 对。"
        ],
        "Illustration": [],
        "Examples": [
            "# 入参是(a), (b)的场景\nSELECT JSON_OBJECT(\n'name' : first_name || ' ' || last_name,\n'email' : email,\n'phone' : phone_number,\n'hire_date' : hire_date\n)\n    FROM employees\n    WHERE employee_id = 140;\n\n# 入参是(f)的场景，使用通配符\nSELECT JSON_OBJECT(*) FROM employees WHERE employee_id = 140;\n---------------------------------------------------------------------\n{\n\"EMPLOYEE_ID\":140,\n\"FIRST_NAME\":\"Joshua\",\n\"LAST_NAME\":\"Patel\",\n\"EMAIL\":\"JPATEL\",\n\"PHONE_NUMBER\":\"650.121.1834\",\n\"HIRE_DATE\":\"2006-04-06T00:00:00\",\n\"JOB_ID\":\"ST_CLERK\",\n\"SALARY\":2500,\n\"COMMISSION_PCT\":null,\n\"MANAGER_ID\":123,\"DEPARTMENT_ID\":50\n}\n\n# 入参是(c), (d)的场景\nSELECT JSON_OBJECT('NAME' VALUE first_name, d.*)\n   FROM employees e, departments d\n      WHERE e.department_id = d.department_id AND e.employee_id =140\n\n# 使用 FORMAT JSON 子句\nSELECT JSON_OBJECT ('name' value 'Foo') FROM DUAL;\n+-------------------------------+\n| JSON_OBJECT('NAME'VALUE'FOO') |\n+-------------------------------+\n| {\"name\":\"Foo\"}                |\n+-------------------------------+\n\n\n# 场景(a), (b) 使用关键字 KEY VALUE\nSELECT JSON_OBJECT (\n    KEY 'deptno' VALUE d.department_id,\n    KEY 'deptname' VALUE d.department_name\n    ) \"Department Objects\"\n  FROM departments d\n  ORDER BY d.department_id;\n\nDepartment Objects\n----------------------------------------\n{\"deptno\":10,\"deptname\":\"Administration\"}\n{\"deptno\":20,\"deptname\":\"Marketing\"}\n{\"deptno\":30,\"deptname\":\"Purchasing\"}\n{\"deptno\":40,\"deptname\":\"Human Resources\"}\n{\"deptno\":50,\"deptname\":\"Shipping\"}\n\n# 入参(1),(2)\nSELECT JSON_OBJECT(\n'first_name' VALUE first_name,\n'last_name' VALUE last_name,\n'email' VALUE email,\n'hire_date' VALUE hire_date\n)\nFROM employees\nWHERE employee_id = 140;\n---------------------------------------------------------------------------\n{\n\"first_name\":\"Joshua\",\n\"last_name\":\"Patel\",\n\"email\":\"JPATEL\",\n\"hire_date\":\"2006-04-06T00:00:00\"\n}\n"
        ],
        "Detailed Examples": [
            "# 入参是(a), (b)的场景\nSELECT JSON_OBJECT(\n'name' : first_name || ' ' || last_name,\n'email' : email,\n'phone' : phone_number,\n'hire_date' : hire_date\n)\n    FROM employees\n    WHERE employee_id = 140;\n\n# 入参是(f)的场景，使用通配符\nSELECT JSON_OBJECT(*) FROM employees WHERE employee_id = 140;\n---------------------------------------------------------------------\n{\n\"EMPLOYEE_ID\":140,\n\"FIRST_NAME\":\"Joshua\",\n\"LAST_NAME\":\"Patel\",\n\"EMAIL\":\"JPATEL\",\n\"PHONE_NUMBER\":\"650.121.1834\",\n\"HIRE_DATE\":\"2006-04-06T00:00:00\",\n\"JOB_ID\":\"ST_CLERK\",\n\"SALARY\":2500,\n\"COMMISSION_PCT\":null,\n\"MANAGER_ID\":123,\"DEPARTMENT_ID\":50\n}\n\n# 入参是(c), (d)的场景\nSELECT JSON_OBJECT('NAME' VALUE first_name, d.*)\n   FROM employees e, departments d\n      WHERE e.department_id = d.department_id AND e.employee_id =140\n\n# 使用 FORMAT JSON 子句\nSELECT JSON_OBJECT ('name' value 'Foo') FROM DUAL;\n+-------------------------------+\n| JSON_OBJECT('NAME'VALUE'FOO') |\n+-------------------------------+\n| {\"name\":\"Foo\"}                |\n+-------------------------------+\n\n\n# 场景(a), (b) 使用关键字 KEY VALUE\nSELECT JSON_OBJECT (\n    KEY 'deptno' VALUE d.department_id,\n    KEY 'deptname' VALUE d.department_name\n    ) \"Department Objects\"\n  FROM departments d\n  ORDER BY d.department_id;\n\nDepartment Objects\n----------------------------------------\n{\"deptno\":10,\"deptname\":\"Administration\"}\n{\"deptno\":20,\"deptname\":\"Marketing\"}\n{\"deptno\":30,\"deptname\":\"Purchasing\"}\n{\"deptno\":40,\"deptname\":\"Human Resources\"}\n{\"deptno\":50,\"deptname\":\"Shipping\"}\n\n# 入参(1),(2)\nSELECT JSON_OBJECT(\n'first_name' VALUE first_name,\n'last_name' VALUE last_name,\n'email' VALUE email,\n'hire_date' VALUE hire_date\n)\nFROM employees\nWHERE employee_id = 140;\n---------------------------------------------------------------------------\n{\n\"first_name\":\"Joshua\",\n\"last_name\":\"Patel\",\n\"email\":\"JPATEL\",\n\"hire_date\":\"2006-04-06T00:00:00\"\n}\n"
        ]
    },
    "JSON_OBJECTAGG": {
        "Title": [
            "JSON_OBJECTAGG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823496"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_OBJECTAGG([KEY] key_expr [VALUE] value_expr\n                              [ABSENT|NULL ON NULL,]\n                              [RETURNING  CLOB|BLOB|JSON|VARCHAR2|VARCHAR2[size],]\n                              [STRICT,]\n                          [WITH UNIQUE KEYS]);\n\n",
        "Description": [
            "JSON_OBJECTAGG() 函数将输入参数作为 key-value 对, 其中的 key 和 value 都是列表达式，将所有的 key-value 对组合到一个JSON 对象中，并将该对象返回。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用默认参数\nCREATE TABLE t (a int, k VARCHAR(10), v VARCHAR(10));\nINSERT INTO t VALUES (1, 'key1', '\"alfa\"');\nINSERT INTO t VALUES (1, 'key3', 'null');\nINSERT INTO t VALUES (1, 'key4', 'false');\nINSERT INTO t VALUES (2, 'key6', '124');\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEV)                          |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\"}                                   |\n+------+--------------------------------------------------+\n\n# 使用 FORMAT JSON 子句\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v FORMAT JSON) FROM t GROUP BY a;\n+------+------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVFORMATJSON)        |\n+------+------------------------------------------+\n|    1 | {\"key1\":\"alfa\",\"key3\":null,\"key4\":false} |\n|    2 | {\"key6\":124}                             |\n+------+------------------------------------------+\n\n# 使用 NULL|ABSENT ON NULL 子句\nobclient> INSERT INTO t VALUES (2, 'key7', null);\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v NULL ON NULL) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVNULLONNULL)                |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\",\"key7\":\"null\"}                     |\n+------+--------------------------------------------------+\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v ABSENT ON NULL) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVABSENTONNULL)              |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\"}                                   |\n+------+--------------------------------------------------+\n\n# 使用 RETURNING 子句\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v returning varchar2) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVRETURNINGVARCHAR2)         |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\"}                                   |\n+------+--------------------------------------------------+\n2 rows in set\n"
        ],
        "Detailed Examples": [
            "# 使用默认参数\nCREATE TABLE t (a int, k VARCHAR(10), v VARCHAR(10));\nINSERT INTO t VALUES (1, 'key1', '\"alfa\"');\nINSERT INTO t VALUES (1, 'key3', 'null');\nINSERT INTO t VALUES (1, 'key4', 'false');\nINSERT INTO t VALUES (2, 'key6', '124');\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEV)                          |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\"}                                   |\n+------+--------------------------------------------------+\n\n# 使用 FORMAT JSON 子句\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v FORMAT JSON) FROM t GROUP BY a;\n+------+------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVFORMATJSON)        |\n+------+------------------------------------------+\n|    1 | {\"key1\":\"alfa\",\"key3\":null,\"key4\":false} |\n|    2 | {\"key6\":124}                             |\n+------+------------------------------------------+\n\n# 使用 NULL|ABSENT ON NULL 子句\nobclient> INSERT INTO t VALUES (2, 'key7', null);\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v NULL ON NULL) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVNULLONNULL)                |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\",\"key7\":\"null\"}                     |\n+------+--------------------------------------------------+\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v ABSENT ON NULL) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVABSENTONNULL)              |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\"}                                   |\n+------+--------------------------------------------------+\n\n# 使用 RETURNING 子句\nobclient> SELECT a, JSON_OBJECTAGG(k VALUE v returning varchar2) FROM t GROUP BY a;\n+------+--------------------------------------------------+\n| A    | JSON_OBJECTAGG(KVALUEVRETURNINGVARCHAR2)         |\n+------+--------------------------------------------------+\n|    1 | {\"key1\":\"\\\"alfa\\\"\",\"key3\":\"null\",\"key4\":\"false\"} |\n|    2 | {\"key6\":\"124\"}                                   |\n+------+--------------------------------------------------+\n2 rows in set\n"
        ]
    },
    "JSON_QUERY": {
        "Title": [
            "JSON_QUERY"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823499"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_QUERY(\n              expr [FORMAT JSON],\n              json_path_literal\n                  [RETURNING  CLOB|BLOB|JSON|VARCHAR2|VARCHAR2[size],]\n              [ALLOW|DISALLOW SCALARS]\n              [PRETTY]\n              [ASCII]\n              [WITHOUT [ARRAY] WRAPPER, WITH CONDITIONAL|UNCONDITIONAL [ARRAY] WRAPPER]\n              [ERROR|NULL|EMPTY|EMTPY ARRAY|EMPTY OBJECT ON ERROR]\n              [ERROR|NULL|EMPTY|EMTPY ARRAY|EMPTY OBJECT ON EMPTY]);\n",
        "Description": [
            "JSON_QUERY() 函数用于从 JSON 数据中查询一个或者多个值，并且返回这些值。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用 RETURNING 子句\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$') AS value FROM DUAL;\n+--------------------------------+\n| VALUE                          |\n+--------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300} |\n+--------------------------------+\n1 row in set\n\nobclient>SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING CLOB) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGCLOB) |\n+----------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                           |\n+----------------------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING VARCHAR2(200)) FROM DUAL;\n+-------------------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGVARCHAR2(200)) |\n+-------------------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                                    |\n+-------------------------------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING BLOB) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGBLOB) |\n+----------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                           |\n+----------------------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING JSON) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGJSON) |\n+----------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                           |\n+----------------------------------------------------------+\n1 row in set\n\n# 使用 WRAPPER 子句和 ERROR子句\nobclient> SET @col_json = '[1,2]';\nobclient> SELECT JSON_QUERY(@col_json, '$[0 to 10]' RETURNING JSON WITH WRAPPER EMPTY ON ERROR) FROM DUAL;\n+----------------------------------------------------------------------+\n| JSON_QUERY(@COL_JSON,'$[0TO10]'RETURNINGJSONWITHWRAPPEREMPTYONERROR) |\n+----------------------------------------------------------------------+\n| [1, 2]                                                               |\n+----------------------------------------------------------------------+\n1 row in set\n\n# 使用 ARRAY WRAPPER 子句\nobclient> SELECT JSON_QUERY(treat('{\"a\":100, \"b\":200, \"c\":300}' as json), '$' WITH ARRAY WRAPPER) AS value FROM DUAL;\n+----------------------------------+\n| VALUE                            |\n+----------------------------------+\n| [{\"a\": 100, \"b\": 200, \"c\": 300}] |\n+----------------------------------+\n1 row in set\n\n# 使用 DISALLOW SCALAR 子句\nobclient> SELECT JSON_QUERY('\"aaa\"', '$' DISALLOW SCALARS ) FROM DUAL;\n+----------------------------------------+\n| JSON_QUERY('\"AAA\"','$'DISALLOWSCALARS) |\n+----------------------------------------+\n| NULL                                   |\n+----------------------------------------+\n1 row in set\n\n# 使用 EMPTY OBJECT/EMPTY ARRAY ON EMTPY子句\nobclient>SELECT JSON_QUERY('{}', '$.a' EMPTY OBJECT ON EMPTY) AS value FROM DUAL;\n+-------+\n| VALUE |\n+-------+\n| {}    |\n+-------+\n1 row in set\n\nobclient>SELECT JSON_QUERY('{}', '$.a' EMPTY ARRAY ON EMPTY) AS value FROM DUAL;\n+-------+\n| VALUE |\n+-------+\n| []    |\n+-------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 使用 RETURNING 子句\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$') AS value FROM DUAL;\n+--------------------------------+\n| VALUE                          |\n+--------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300} |\n+--------------------------------+\n1 row in set\n\nobclient>SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING CLOB) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGCLOB) |\n+----------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                           |\n+----------------------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING VARCHAR2(200)) FROM DUAL;\n+-------------------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGVARCHAR2(200)) |\n+-------------------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                                    |\n+-------------------------------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING BLOB) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGBLOB) |\n+----------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                           |\n+----------------------------------------------------------+\n1 row in set\n\nobclient> SELECT JSON_QUERY('{\"a\":100, \"b\":200, \"c\":300}', '$' RETURNING JSON) FROM DUAL;\n+----------------------------------------------------------+\n| JSON_QUERY('{\"A\":100,\"B\":200,\"C\":300}','$'RETURNINGJSON) |\n+----------------------------------------------------------+\n| {\"a\": 100, \"b\": 200, \"c\": 300}                           |\n+----------------------------------------------------------+\n1 row in set\n\n# 使用 WRAPPER 子句和 ERROR子句\nobclient> SET @col_json = '[1,2]';\nobclient> SELECT JSON_QUERY(@col_json, '$[0 to 10]' RETURNING JSON WITH WRAPPER EMPTY ON ERROR) FROM DUAL;\n+----------------------------------------------------------------------+\n| JSON_QUERY(@COL_JSON,'$[0TO10]'RETURNINGJSONWITHWRAPPEREMPTYONERROR) |\n+----------------------------------------------------------------------+\n| [1, 2]                                                               |\n+----------------------------------------------------------------------+\n1 row in set\n\n# 使用 ARRAY WRAPPER 子句\nobclient> SELECT JSON_QUERY(treat('{\"a\":100, \"b\":200, \"c\":300}' as json), '$' WITH ARRAY WRAPPER) AS value FROM DUAL;\n+----------------------------------+\n| VALUE                            |\n+----------------------------------+\n| [{\"a\": 100, \"b\": 200, \"c\": 300}] |\n+----------------------------------+\n1 row in set\n\n# 使用 DISALLOW SCALAR 子句\nobclient> SELECT JSON_QUERY('\"aaa\"', '$' DISALLOW SCALARS ) FROM DUAL;\n+----------------------------------------+\n| JSON_QUERY('\"AAA\"','$'DISALLOWSCALARS) |\n+----------------------------------------+\n| NULL                                   |\n+----------------------------------------+\n1 row in set\n\n# 使用 EMPTY OBJECT/EMPTY ARRAY ON EMTPY子句\nobclient>SELECT JSON_QUERY('{}', '$.a' EMPTY OBJECT ON EMPTY) AS value FROM DUAL;\n+-------+\n| VALUE |\n+-------+\n| {}    |\n+-------+\n1 row in set\n\nobclient>SELECT JSON_QUERY('{}', '$.a' EMPTY ARRAY ON EMPTY) AS value FROM DUAL;\n+-------+\n| VALUE |\n+-------+\n| []    |\n+-------+\n1 row in set\n"
        ]
    },
    "JSON_TABLE": {
        "Title": [
            "JSON_TABLE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823501"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_TABLE(\n        expr [FORMAT JSON]\n        [, json_path_literal]\n        [ERROR | NULL ON ERROR]\n        COLUMNS (\n          [column_name [json_value_return_type] EXISTS [PATH path_literal] [json_exists_on_error_clause] [json_exists_on_emtpy_clause]]\n          [column_name [json_query_return_type] FORMAT JSON [ALLOW|DISALLOW SCALARS] [json_query_wrapper_clause] [PATH path_literal] [json_query_on_error_clause]]\n          [column_name [json_value_return_type] [TRUNCATE] [PATH path_literal] [json_exists_on_error_clause] [json_exists_on_emtpy_clause]]\n          [column_name FOR ORDINALITY]\n          [NESTED PATH path_literal COLUMNS (\n            # 嵌套结构，重复父一级语法\n            ...\n          )]\n        )\n       )\n",
        "Description": [
            "JSON_TABLE() 函数提供了一种联系关系表和 JSON 结构数据的途径。可以在 SQL 中像使用虚拟关系表一样来使用 JSON_TABLE() 的输出结果。JSON_TABLE() 为每一个 JSON 值提供了列输出，对于 JSON 内的数组，提供了多行（列）输出。 JSON_TABLE() 必须用在 SELECT 语句的 FROM 子句中。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用 NESTED COLUMN 嵌套语句\nDROP TABLE jsonb_table_test;\nCREATE TABLE jsonb_table_test (js VARCHAR2 (4000));\n\nDELETE FROM jsonb_table_test;\nINSERT INTO jsonb_table_test VALUES (\n  '[\n  \t{\"c\": [7], \"d\": [3], \"a\": 2,  \"b\": [3,4]}\n  ]'\n);\n\nobclient> SELECT jt.* FROM jsonb_table_test jtt,\n      json_table (jtt.js, '$[*]'\n          columns (\n            nested path '$.c[*]' COLUMNS (c int path '$'),\n            nested path '$.d[*]' COLUMNS (d int path '$'),\n            nested path '$.b[*]' COLUMNS (b int path '$'),\n            a int path '$.a'\n          )\n      ) jt;\n+------+------+------+------+\n| C    | D    | B    | A    |\n+------+------+------+------+\n| NULL | NULL |    3 |    2 |\n| NULL | NULL |    4 |    2 |\n| NULL |    3 | NULL |    2 |\n|    7 | NULL | NULL |    2 |\n+------+------+------+------+\n4 rows in set\n\n\n# 使用 NESTED COLUMN 嵌套和 ORDINALITY 列\nobclient> INSERT INTO jsonb_table_test VALUES (\n        '[\n        {\"a\":  1,  \"b\": [], \"c\": []},\n        {\"a\":  2,  \"b\": [1, 2, 3], \"c\": [10, null, 20]},\n        {\"a\":  3,  \"b\": [1, 2], \"c\": []},\n        {\"a\":  4, \"b\": [1, 2], \"c\": [123]}\n        ]'\n      );\nQuery OK, 1 row affected\n\nobclient> SELECT jt.* FROM jsonb_table_test jtt,\n        json_table (jtt.js, '$[*]'\n          columns (\n            nested path '$.c[*]' COLUMNS (c int path '$'),\n            nested path '$.b[*]' COLUMNS (b int path '$'),\n            n FOR ORDINALITY,\n            a int path '$.a'\n          )\n        ) jt;\n+------+------+------+------+\n| C    | B    | N    | A    |\n+------+------+------+------+\n| NULL | NULL |    1 |    1 |\n| NULL |    1 |    2 |    2 |\n| NULL |    2 |    2 |    2 |\n| NULL |    3 |    2 |    2 |\n|   10 | NULL |    2 |    2 |\n| NULL | NULL |    2 |    2 |\n|   20 | NULL |    2 |    2 |\n| NULL |    1 |    3 |    3 |\n| NULL |    2 |    3 |    3 |\n| NULL |    1 |    4 |    4 |\n| NULL |    2 |    4 |    4 |\n|  123 | NULL |    4 |    4 |\n+------+------+------+------+\n12 rows in set\n\n# 查询 json_table 的 json_value 列，以及使用 EMTPY 子句\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": 123.45}',\n        '$'\n         columns (a CLOB path '$.nokey' default 'abc' on EMPTY)\n        ) jt;\n+------+\n| A    |\n+------+\n| abc  |\n+------+\n1 row in set\n\n# 查询 json_table 的 json_value 列，以及使用 EMTPY 子句\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": 123.45}',\n        '$'\n         columns (a CLOB path '$.nokey' NULL on EMPTY)\n        ) jt;\n+------+\n| A    |\n+------+\n| NULL |\n+------+\n1 row in set\n\nobclient> SELECT jt.* FROM\n   json_table(\n   '{\"details\":\n     [ {\"branch_code\": \"3020300\", \"products\": [\n                                           \"23D0980000000000\",\n                                           \"23E2980000000000\",\n                                           \"23E3980000000004\"]},\n      {\"branch_code\": \"3090100\", \"products\": [\n                                           \"23D0980000000000\",\n                                           \"23E2980000000000\"]}],\n      \"extras\": [\"AWUX1201293111\", \"AWUX1201293112\"]\n     }',\n     '$.details[*]'\n     columns (\n       branch_code varchar2(100) path '$.branch_code',\n       nested path '$.products[*]' columns (product varchar2(100) path '$[*]')\n       )\n     ) jt;\n\n+-------------+------------------+\n| BRANCH_CODE | PRODUCT          |\n+-------------+------------------+\n| 3020300     | 23D0980000000000 |\n| 3020300     | 23E2980000000000 |\n| 3020300     | 23E3980000000004 |\n| 3090100     | 23D0980000000000 |\n| 3090100     | 23E2980000000000 |\n+-------------+------------------+\n5 rows in set\n\n# 查询 json_table 的 JSON_EXISTS 列\n obclient> SELECT jt.* FROM json_table (\n        '{\n          \"a\": \"1997-8-14 11:11:11\",\n          \"b\" : 123,\n          \"c\": \"varchar2\"\n         }',\n        '$' columns (\n            a date EXISTS path '$.a',\n            b int EXISTS path '$.b' ERROR ON EMPTY,\n            c varchar2(32) format json path '$.c' NULL ON EMPTY\n          )\n        ) jt;\n+---------------------+------+----------+\n| A                   | B    | C        |\n+---------------------+------+----------+\n| 1997-08-14 11:11:11 |  123 | varchar2 |\n+---------------------+------+----------+\n1 row in set\n\n# 查询 json_table 的 json_query 列\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": [1, 2, 3, 3]}',\n        '$'\n         columns (a varchar2(1024) FORMAT JSON path '$.data[*]')\n        ) jt;\n+--------------+\n| A            |\n+--------------+\n| [1, 2, 3, 3] |\n+--------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 使用 NESTED COLUMN 嵌套语句\nDROP TABLE jsonb_table_test;\nCREATE TABLE jsonb_table_test (js VARCHAR2 (4000));\n\nDELETE FROM jsonb_table_test;\nINSERT INTO jsonb_table_test VALUES (\n  '[\n  \t{\"c\": [7], \"d\": [3], \"a\": 2,  \"b\": [3,4]}\n  ]'\n);\n\nobclient> SELECT jt.* FROM jsonb_table_test jtt,\n      json_table (jtt.js, '$[*]'\n          columns (\n            nested path '$.c[*]' COLUMNS (c int path '$'),\n            nested path '$.d[*]' COLUMNS (d int path '$'),\n            nested path '$.b[*]' COLUMNS (b int path '$'),\n            a int path '$.a'\n          )\n      ) jt;\n+------+------+------+------+\n| C    | D    | B    | A    |\n+------+------+------+------+\n| NULL | NULL |    3 |    2 |\n| NULL | NULL |    4 |    2 |\n| NULL |    3 | NULL |    2 |\n|    7 | NULL | NULL |    2 |\n+------+------+------+------+\n4 rows in set\n\n\n# 使用 NESTED COLUMN 嵌套和 ORDINALITY 列\nobclient> INSERT INTO jsonb_table_test VALUES (\n        '[\n        {\"a\":  1,  \"b\": [], \"c\": []},\n        {\"a\":  2,  \"b\": [1, 2, 3], \"c\": [10, null, 20]},\n        {\"a\":  3,  \"b\": [1, 2], \"c\": []},\n        {\"a\":  4, \"b\": [1, 2], \"c\": [123]}\n        ]'\n      );\nQuery OK, 1 row affected\n\nobclient> SELECT jt.* FROM jsonb_table_test jtt,\n        json_table (jtt.js, '$[*]'\n          columns (\n            nested path '$.c[*]' COLUMNS (c int path '$'),\n            nested path '$.b[*]' COLUMNS (b int path '$'),\n            n FOR ORDINALITY,\n            a int path '$.a'\n          )\n        ) jt;\n+------+------+------+------+\n| C    | B    | N    | A    |\n+------+------+------+------+\n| NULL | NULL |    1 |    1 |\n| NULL |    1 |    2 |    2 |\n| NULL |    2 |    2 |    2 |\n| NULL |    3 |    2 |    2 |\n|   10 | NULL |    2 |    2 |\n| NULL | NULL |    2 |    2 |\n|   20 | NULL |    2 |    2 |\n| NULL |    1 |    3 |    3 |\n| NULL |    2 |    3 |    3 |\n| NULL |    1 |    4 |    4 |\n| NULL |    2 |    4 |    4 |\n|  123 | NULL |    4 |    4 |\n+------+------+------+------+\n12 rows in set\n\n# 查询 json_table 的 json_value 列，以及使用 EMTPY 子句\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": 123.45}',\n        '$'\n         columns (a CLOB path '$.nokey' default 'abc' on EMPTY)\n        ) jt;\n+------+\n| A    |\n+------+\n| abc  |\n+------+\n1 row in set\n\n# 查询 json_table 的 json_value 列，以及使用 EMTPY 子句\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": 123.45}',\n        '$'\n         columns (a CLOB path '$.nokey' NULL on EMPTY)\n        ) jt;\n+------+\n| A    |\n+------+\n| NULL |\n+------+\n1 row in set\n\nobclient> SELECT jt.* FROM\n   json_table(\n   '{\"details\":\n     [ {\"branch_code\": \"3020300\", \"products\": [\n                                           \"23D0980000000000\",\n                                           \"23E2980000000000\",\n                                           \"23E3980000000004\"]},\n      {\"branch_code\": \"3090100\", \"products\": [\n                                           \"23D0980000000000\",\n                                           \"23E2980000000000\"]}],\n      \"extras\": [\"AWUX1201293111\", \"AWUX1201293112\"]\n     }',\n     '$.details[*]'\n     columns (\n       branch_code varchar2(100) path '$.branch_code',\n       nested path '$.products[*]' columns (product varchar2(100) path '$[*]')\n       )\n     ) jt;\n\n+-------------+------------------+\n| BRANCH_CODE | PRODUCT          |\n+-------------+------------------+\n| 3020300     | 23D0980000000000 |\n| 3020300     | 23E2980000000000 |\n| 3020300     | 23E3980000000004 |\n| 3090100     | 23D0980000000000 |\n| 3090100     | 23E2980000000000 |\n+-------------+------------------+\n5 rows in set\n\n# 查询 json_table 的 JSON_EXISTS 列\n obclient> SELECT jt.* FROM json_table (\n        '{\n          \"a\": \"1997-8-14 11:11:11\",\n          \"b\" : 123,\n          \"c\": \"varchar2\"\n         }',\n        '$' columns (\n            a date EXISTS path '$.a',\n            b int EXISTS path '$.b' ERROR ON EMPTY,\n            c varchar2(32) format json path '$.c' NULL ON EMPTY\n          )\n        ) jt;\n+---------------------+------+----------+\n| A                   | B    | C        |\n+---------------------+------+----------+\n| 1997-08-14 11:11:11 |  123 | varchar2 |\n+---------------------+------+----------+\n1 row in set\n\n# 查询 json_table 的 json_query 列\nobclient> SELECT jt.* FROM json_table (\n        '{\"data\": [1, 2, 3, 3]}',\n        '$'\n         columns (a varchar2(1024) FORMAT JSON path '$.data[*]')\n        ) jt;\n+--------------+\n| A            |\n+--------------+\n| [1, 2, 3, 3] |\n+--------------+\n1 row in set\n"
        ]
    },
    "JSON_VALUE": {
        "Title": [
            "JSON_VALUE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823498"
        ],
        "Category": [
            "JSON Functions"
        ],
        "Feature": "JSON_VALUE(value_expr [FORMAT JSON],\n                  json_path_literal\n                      [RETURNING  NUMBER|DATE|TIMESTAMP|VARCHAR2|VARCHAR2[size],]\n                   [ERROR|NULL|DEFAULT-literal ON ERROR]\n                      [ERROR|NULL|DEFAULT-literal ON EMPTY]\n                  [ERROR|NULL ON MISMATCH]);\n",
        "Description": [
            "JSON_VALUE() 函数用于查询 JSON 数据中的特定部分，并且返回 SQL 值。"
        ],
        "Illustration": [],
        "Examples": [
            "# 使用默认参数\nobclient> SELECT JSON_VALUE('{\"a\":100}', '$.a') AS value FROM DUAL;\n+-------+\n| VALUE |\n+-------+\n| 100   |\n+-------+\n1 row in set\n\n# 使用 ERROR 子句\nobclient> SELECT JSON_VALUE( '{a:\"cat\"}','$.a.number()' NULL ON EMPTY  DEFAULT -1 ON ERROR ) FROM DUAL;\n+-------------------------------------------------------------------+\n| JSON_VALUE('{A:\"CAT\"}','$.A.NUMBER()'NULLONEMPTYDEFAULT-1ONERROR) |\n+-------------------------------------------------------------------+\n|                                                               -1  |\n+-------------------------------------------------------------------+\n1 row in set\n\n# 使用 DEFAULT 子句\nobclient> SELECT JSON_VALUE('{firstname:\"John\"}', '$.lastname' DEFAULT 'No last name found' ON ERROR) AS \"Last Name\" FROM DUAL;\n+--------------------+\n| Last Name          |\n+--------------------+\n| No last name found |\n+--------------------+\n1 row in set\n\n# 使用 RETURNING 子句\nobclient> SELECT JSON_VALUE('\"2019-08-30, 1\"', '$' RETURNING CLOB error on error) FROM DUAL;\n+-----------------------------------------------------------+\n| JSON_VALUE('\"2019-08-30,1\"','$'RETURNINGCLOBERRORONERROR) |\n+-----------------------------------------------------------+\n| 2019-08-30, 1                                             |\n+-----------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 使用默认参数\nobclient> SELECT JSON_VALUE('{\"a\":100}', '$.a') AS value FROM DUAL;\n+-------+\n| VALUE |\n+-------+\n| 100   |\n+-------+\n1 row in set\n\n# 使用 ERROR 子句\nobclient> SELECT JSON_VALUE( '{a:\"cat\"}','$.a.number()' NULL ON EMPTY  DEFAULT -1 ON ERROR ) FROM DUAL;\n+-------------------------------------------------------------------+\n| JSON_VALUE('{A:\"CAT\"}','$.A.NUMBER()'NULLONEMPTYDEFAULT-1ONERROR) |\n+-------------------------------------------------------------------+\n|                                                               -1  |\n+-------------------------------------------------------------------+\n1 row in set\n\n# 使用 DEFAULT 子句\nobclient> SELECT JSON_VALUE('{firstname:\"John\"}', '$.lastname' DEFAULT 'No last name found' ON ERROR) AS \"Last Name\" FROM DUAL;\n+--------------------+\n| Last Name          |\n+--------------------+\n| No last name found |\n+--------------------+\n1 row in set\n\n# 使用 RETURNING 子句\nobclient> SELECT JSON_VALUE('\"2019-08-30, 1\"', '$' RETURNING CLOB error on error) FROM DUAL;\n+-----------------------------------------------------------+\n| JSON_VALUE('\"2019-08-30,1\"','$'RETURNINGCLOBERRORONERROR) |\n+-----------------------------------------------------------+\n| 2019-08-30, 1                                             |\n+-----------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "KEEP": {
        "Title": [
            "KEEP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822883"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "aggregate_function KEEP ( DENSE_RANK { FIRST | LAST }\n                ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ]\n                      [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ]]...\n                        )\n[ OVER ( [query_partition_clause] ) ]\n\naggregate_function:\n  MIN\n |MAX\n |SUM\n |AVG\n |COUNT\n |VARIANCE\n |STDDEV\n",
        "Description": [
            "该函数用于对一组行中的值进行操作，将这组行按照指定的排序规则排序后返回排在第一或最后的值。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\naggregate_function\n指定聚合函数的种类。\n\n\nexpr\n可以是任何表达式。\n\n\nFIRST | LAST\n指定返回 expr 排序后那个位置的值。 \n      \nFIRST 表示返回排在首位的值。\nLAST 表示返回排在最后的值。\n\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回与 aggregate_function 中指定的列相同的数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE employees (department_id INT,manager_id INT,last_name varchar(50),hiredate varchar(50),SALARY INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO employees VALUES\n    (30, 100, 'Raphaely', '2017-07-01', 1700),\n    (30, 100, 'De Haan', '2018-05-01',11000),\n    (40, 100, 'Errazuriz', '2017-07-21', 1400),\n    (50, 100, 'Hartstein', '2019-10-05',14000),\n    (50, 100, 'Raphaely', '2017-07-22', 1700),\n    (50, 100, 'Weiss',  '2019-10-05',13500),\n    (90, 100, 'Russell', '2019-07-11', 13000),\n    (90,100, 'Partners',  '2018-12-01',14000);\nQuery OK, 8 rows affected\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE) \"Best\"\n    FROM employees;\n+-------+-------+\n| Worst | Best  |\n+-------+-------+\n|  1400 | 27500 |\n+-------+-------+\n1 row in set\n",
            "obclient> SELECT last_name,department_id,salary,\n    SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary)\n        OVER (PARTITION BY department_id) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE)\n        OVER (PARTITION BY department_id) \"Best\"\n    FROM employees\n    ORDER BY department_id, salary, last_name;\n+-----------+---------------+--------+-------+-------+\n| LAST_NAME | DEPARTMENT_ID | SALARY | Worst | Best  |\n+-----------+---------------+--------+-------+-------+\n| Raphaely  |            30 |   1700 |  1700 | 11000 |\n| De Haan   |            30 |  11000 |  1700 | 11000 |\n| Errazuriz |            40 |   1400 |  1400 |  1400 |\n| Raphaely  |            50 |   1700 |  1700 | 27500 |\n| Weiss     |            50 |  13500 |  1700 | 27500 |\n| Hartstein |            50 |  14000 |  1700 | 27500 |\n| Russell   |            90 |  13000 | 13000 | 13000 |\n| Partners  |            90 |  14000 | 13000 | 13000 |\n+-----------+---------------+--------+-------+-------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 employees，并向里面插入数据。",
            "obclient> CREATE TABLE employees (department_id INT,manager_id INT,last_name varchar(50),hiredate varchar(50),SALARY INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO employees VALUES\n    (30, 100, 'Raphaely', '2017-07-01', 1700),\n    (30, 100, 'De Haan', '2018-05-01',11000),\n    (40, 100, 'Errazuriz', '2017-07-21', 1400),\n    (50, 100, 'Hartstein', '2019-10-05',14000),\n    (50, 100, 'Raphaely', '2017-07-22', 1700),\n    (50, 100, 'Weiss',  '2019-10-05',13500),\n    (90, 100, 'Russell', '2019-07-11', 13000),\n    (90,100, 'Partners',  '2018-12-01',14000);\nQuery OK, 8 rows affected\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "按照薪水排序，对排在第一的员工的薪水求和；按照雇用日期排序，对排在最后的员工的薪水求和。",
            "obclient> SELECT SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE) \"Best\"\n    FROM employees;\n+-------+-------+\n| Worst | Best  |\n+-------+-------+\n|  1400 | 27500 |\n+-------+-------+\n1 row in set\n",
            "分析函数示例",
            "对于每个部门按照薪水排序，对排在第一的员工的薪水求和；按照雇用日期排序，对排在最后的员工的薪水求和。",
            "obclient> SELECT last_name,department_id,salary,\n    SUM(salary) KEEP (DENSE_RANK FIRST ORDER BY salary)\n        OVER (PARTITION BY department_id) \"Worst\",\n    SUM(salary) KEEP (DENSE_RANK LAST ORDER BY HIREDATE)\n        OVER (PARTITION BY department_id) \"Best\"\n    FROM employees\n    ORDER BY department_id, salary, last_name;\n+-----------+---------------+--------+-------+-------+\n| LAST_NAME | DEPARTMENT_ID | SALARY | Worst | Best  |\n+-----------+---------------+--------+-------+-------+\n| Raphaely  |            30 |   1700 |  1700 | 11000 |\n| De Haan   |            30 |  11000 |  1700 | 11000 |\n| Errazuriz |            40 |   1400 |  1400 |  1400 |\n| Raphaely  |            50 |   1700 |  1700 | 27500 |\n| Weiss     |            50 |  13500 |  1700 | 27500 |\n| Hartstein |            50 |  14000 |  1700 | 27500 |\n| Russell   |            90 |  13000 | 13000 | 13000 |\n| Partners  |            90 |  14000 | 13000 | 13000 |\n+-----------+---------------+--------+-------+-------+\n8 rows in set\n"
        ]
    },
    "LAG": {
        "Title": [
            "LAG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822829"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "LAG { (value_expr [,offset [,default]]) [{ RESPECT|IGNORE } NULLS ]\n    | (value_expr [{ RESPECT|IGNORE } NULLS ] [,offset [,default] ])\n    }\nOVER([query_partition_clause] order_by_clause)\n",
        "Description": [
            "该函数是一个分析函数，功能是在查询中取出同一字段的前 offset 行的数据作为独立的列存在表中。这种操作可以代替表的自联接。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nvalue_expr\n指定需要查询的字段。 注意 不能使用 LAG 函数或其他分析函数来嵌套 value_expr。\n\n\noffset\n指定查询 value_expr 的偏移量，一个大于零的整数，为可选项。默认值为 1。\n\n\ndefault\n指定没有符合条件的默认值。如果偏移量超出窗口的范围，则返回 default 的值，为可选项。默认值为 NULL。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回值的数据类型不限。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename, sal,LAG(ename,3,'XXX') OVER (ORDER BY ename) AS new_ename\n          FROM emp_msg;\n+--------+--------+------+-----------+\n| DEPTNO | ENAME  | SAL  | NEW_ENAME |\n+--------+--------+------+-----------+\n|     20 | ADAMS  | 1400 | XXX       |\n|     30 | ALLEN  | 1900 | XXX       |\n|     30 | BLAKE  | 3150 | XXX       |\n|     10 | CLARK  | 2750 | ADAMS     |\n|     20 | FORD   | 3300 | ALLEN     |\n|     30 | JAMES  | 1250 | BLAKE     |\n|     20 | JONES  | 3275 | CLARK     |\n|     10 | KING   | 5300 | FORD      |\n|     30 | MARTIN | 1550 | JAMES     |\n|     10 | MILLER | 1600 | JONES     |\n|     30 | SCLARK | 1750 | KING      |\n|     20 | SCOTT  | 3300 | MARTIN    |\n|     20 | SMITH  | 1100 | MILLER    |\n|     30 | TURNER | 1800 | SCLARK    |\n|     30 | WARD   | 1550 | SCOTT     |\n+--------+--------+------+-----------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。查询 emp_msg 表，将前 3 个值用 XXX 代替，从第 4 个值开始追加按 ename 字段升序排列的值。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename, sal,LAG(ename,3,'XXX') OVER (ORDER BY ename) AS new_ename\n          FROM emp_msg;\n+--------+--------+------+-----------+\n| DEPTNO | ENAME  | SAL  | NEW_ENAME |\n+--------+--------+------+-----------+\n|     20 | ADAMS  | 1400 | XXX       |\n|     30 | ALLEN  | 1900 | XXX       |\n|     30 | BLAKE  | 3150 | XXX       |\n|     10 | CLARK  | 2750 | ADAMS     |\n|     20 | FORD   | 3300 | ALLEN     |\n|     30 | JAMES  | 1250 | BLAKE     |\n|     20 | JONES  | 3275 | CLARK     |\n|     10 | KING   | 5300 | FORD      |\n|     30 | MARTIN | 1550 | JAMES     |\n|     10 | MILLER | 1600 | JONES     |\n|     30 | SCLARK | 1750 | KING      |\n|     20 | SCOTT  | 3300 | MARTIN    |\n|     20 | SMITH  | 1100 | MILLER    |\n|     30 | TURNER | 1800 | SCLARK    |\n|     30 | WARD   | 1550 | SCOTT     |\n+--------+--------+------+-----------+\n15 rows in set\n"
        ]
    },
    "LAST_DAY": {
        "Title": [
            "LAST_DAY"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823123"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "LAST_DAY (date)\n",
        "Description": [
            "该函数返回日期 date 所在月份的最后一天的日期。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndate\n所有包含日期信息的数据类型（DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE）的值。\n\n\n",
            "返回 DATE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE,LAST_DAY(SYSDATE) \"Last\",LAST_DAY(SYSDATE)-SYSDATE FROM DUAL;\n+-----------+-----------+---------------------------+\n| SYSDATE   | Last      | LAST_DAY(SYSDATE)-SYSDATE |\n+-----------+-----------+---------------------------+\n| 17-NOV-21 | 30-NOV-21 |                        13 |\n+-----------+-----------+---------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "显示当前日期与本月的最后一天的日期以及本月剩余的天数。",
            "obclient> SELECT SYSDATE,LAST_DAY(SYSDATE) \"Last\",LAST_DAY(SYSDATE)-SYSDATE FROM DUAL;\n+-----------+-----------+---------------------------+\n| SYSDATE   | Last      | LAST_DAY(SYSDATE)-SYSDATE |\n+-----------+-----------+---------------------------+\n| 17-NOV-21 | 30-NOV-21 |                        13 |\n+-----------+-----------+---------------------------+\n1 row in set\n"
        ]
    },
    "LAST_VALUE": {
        "Title": [
            "LAST_VALUE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822849"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "LAST_VALUE { (expr) [{RESPECT | IGNORE} NULLS ]\n            | (expr [{RESPECT | IGNORE} NULLS ])\n            }\nOVER (analytic_clause)\n",
        "Description": [
            "该函数是一个分析函数，用于返回一组有序值中的最后一个值。如果集合中的最后一个值为 NULL，则该函数将返回 NULL，除非您指定 IGNORE NULLS，此设置对数据致密化很有用。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定序列。 注意 不能将 LAST_VALUE 或其他分析函数用于 expr 来嵌套分析函数。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回值与 expr 的数据类型相同或返回 NULL。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,MGR,\n            LAST_VALUE ( MGR ) IGNORE NULLS OVER (ORDER BY sal ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS last_MGR\n    FROM emp_msg;\n+--------+--------+------+------+----------+\n| DEPTNO | ENAME  | SAL  | MGR  | LAST_MGR |\n+--------+--------+------+------+----------+\n|     20 | SMITH  | 1100 | 7902 | 7566     |\n|     30 | JAMES  | 1250 | 7698 | 7566     |\n|     20 | ADAMS  | 1400 | 7788 | 7566     |\n|     30 | MARTIN | 1550 | 7698 | 7566     |\n|     30 | WARD   | 1550 | 7698 | 7566     |\n|     10 | MILLER | 1600 | 7782 | 7566     |\n|     30 | SCLARK | 1750 | 7839 | 7566     |\n|     30 | TURNER | 1800 | 7698 | 7566     |\n|     30 | ALLEN  | 1900 | 7698 | 7566     |\n|     10 | CLARK  | 2750 | 7839 | 7566     |\n|     30 | BLAKE  | 3150 | 7839 | 7566     |\n|     20 | JONES  | 3275 | 7839 | 7566     |\n|     20 | FORD   | 3300 | 7566 | 7566     |\n|     20 | SCOTT  | 3300 | 7566 | 7566     |\n|     10 | KING   | 5300 | NULL | 7566     |\n+--------+--------+------+------+----------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。将 emp_msg 表中的数据按列 sal 升序排序，返回列 MGR 最后一个非空值作为 last_MGR 列。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,MGR,\n            LAST_VALUE ( MGR ) IGNORE NULLS OVER (ORDER BY sal ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS last_MGR\n    FROM emp_msg;\n+--------+--------+------+------+----------+\n| DEPTNO | ENAME  | SAL  | MGR  | LAST_MGR |\n+--------+--------+------+------+----------+\n|     20 | SMITH  | 1100 | 7902 | 7566     |\n|     30 | JAMES  | 1250 | 7698 | 7566     |\n|     20 | ADAMS  | 1400 | 7788 | 7566     |\n|     30 | MARTIN | 1550 | 7698 | 7566     |\n|     30 | WARD   | 1550 | 7698 | 7566     |\n|     10 | MILLER | 1600 | 7782 | 7566     |\n|     30 | SCLARK | 1750 | 7839 | 7566     |\n|     30 | TURNER | 1800 | 7698 | 7566     |\n|     30 | ALLEN  | 1900 | 7698 | 7566     |\n|     10 | CLARK  | 2750 | 7839 | 7566     |\n|     30 | BLAKE  | 3150 | 7839 | 7566     |\n|     20 | JONES  | 3275 | 7839 | 7566     |\n|     20 | FORD   | 3300 | 7566 | 7566     |\n|     20 | SCOTT  | 3300 | 7566 | 7566     |\n|     10 | KING   | 5300 | NULL | 7566     |\n+--------+--------+------+------+----------+\n15 rows in set\n"
        ]
    },
    "LEAD": {
        "Title": [
            "LEAD"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822831"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "LEAD { (value_expr [,offset [,default]]) [{ RESPECT|IGNORE } NULLS ]\n    | (value_expr [{ RESPECT|IGNORE } NULLS ] [,offset [,default] ])\n    }\nOVER([query_partition_clause] order_by_clause)\n",
        "Description": [
            "该函数是一个分析函数，功能是在查询中取出同一字段的后 offset 行的数据作为独立的列存在表中。这种操作可以代替表的自联接。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nvalue_expr\n指定需要查询的字段。 注意 不能使用 LEAD 函数或其他分析函数来嵌套 value_expr。\n\n\noffset\n指定查询 value_expr 的偏移量，一个大于零的整数。为可选项，默认值为 1。\n\n\ndefault\n指定没有符合条件的默认值。如果偏移量超出窗口的范围，则返回 default 的值。为可选项，默认值为 NULL。\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回的数据类型不限。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT  deptno, ename, sal, LEAD(ename,5,'XXX') OVER (ORDER BY ename desc) AS new_ename\n     FROM emp_msg;\n+--------+--------+------+-----------+\n| DEPTNO | ENAME  | SAL  | NEW_ENAME |\n+--------+--------+------+-----------+\n|     20 | ADAMS  | 1400 | JAMES     |\n|     30 | ALLEN  | 1900 | JONES     |\n|     30 | BLAKE  | 3150 | KING      |\n|     10 | CLARK  | 2750 | MARTIN    |\n|     20 | FORD   | 3300 | MILLER    |\n|     30 | JAMES  | 1250 | SCLARK    |\n|     20 | JONES  | 3275 | SCOTT     |\n|     10 | KING   | 5300 | SMITH     |\n|     30 | MARTIN | 1550 | TURNER    |\n|     10 | MILLER | 1600 | WARD      |\n|     30 | SCLARK | 1750 | XXX       |\n|     20 | SCOTT  | 3300 | XXX       |\n|     20 | SMITH  | 1100 | XXX       |\n|     30 | TURNER | 1800 | XXX       |\n|     30 | WARD   | 1550 | XXX       |\n+--------+--------+------+-----------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表emp_msg。查询 emp_msg 表，取字段 ename 的值，按 ename 字段升序排序，最后 5 行的值用 XXX 代替。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT  deptno, ename, sal, LEAD(ename,5,'XXX') OVER (ORDER BY ename desc) AS new_ename\n     FROM emp_msg;\n+--------+--------+------+-----------+\n| DEPTNO | ENAME  | SAL  | NEW_ENAME |\n+--------+--------+------+-----------+\n|     20 | ADAMS  | 1400 | JAMES     |\n|     30 | ALLEN  | 1900 | JONES     |\n|     30 | BLAKE  | 3150 | KING      |\n|     10 | CLARK  | 2750 | MARTIN    |\n|     20 | FORD   | 3300 | MILLER    |\n|     30 | JAMES  | 1250 | SCLARK    |\n|     20 | JONES  | 3275 | SCOTT     |\n|     10 | KING   | 5300 | SMITH     |\n|     30 | MARTIN | 1550 | TURNER    |\n|     10 | MILLER | 1600 | WARD      |\n|     30 | SCLARK | 1750 | XXX       |\n|     20 | SCOTT  | 3300 | XXX       |\n|     20 | SMITH  | 1100 | XXX       |\n|     30 | TURNER | 1800 | XXX       |\n|     30 | WARD   | 1550 | XXX       |\n+--------+--------+------+-----------+\n15 rows in set\n"
        ]
    },
    "LEAST": {
        "Title": [
            "LEAST"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823210"
        ],
        "Category": [
            "General Comparison Functions"
        ],
        "Feature": "LEAST(expr [, expr ]...)\n",
        "Description": [
            "该函数返回一个或多个表达式列表中的最小值。"
        ],
        "Illustration": [
            "参数 expr 是一个表达式或多个表达式的列表。数据类型可以是 NUMBER、FLOAT、BINARY_FLOAT、BINARY_DOUBLE、CHAR、VARCHAR2、NCHAR、NVARCHAR2或 CLOB。",
            "数据库使用第一个参数 expr 来确定返回类型。如果其余参数的数据类型和第一个参数 expr 的数据类型不同，则数据库将第一个参数 expr 之后的每个参数隐式转换为第一个 expr 的数据类型。",
            "如果第一个参数 expr 的数据类型为 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE，则返回与第一个参数 expr 相同的数据类型。",
            "如果第一个参数 expr 的数据类型为 CHAR、VARCHAR2 或 CLOB，则返回 VARCHAR2 类型。",
            "如果第一个参数 expr 的数据类型为 NCHAR 或 NVARCHAR2，则返回 NVARCHAR2 类型。"
        ],
        "Examples": [
            "obclient> SELECT LEAST('AC','BB','C') \"MIN\" FROM DUAL;\n+-----+\n| MIN |\n+-----+\n| AC  |\n+-----+\n1 row in set\n",
            "obclient> SELECT LEAST (1,'6','5.555') \"MIN\" FROM DUAL;\n+-----+\n| MIN |\n+-----+\n|   1 |\n+-----+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "比较字符串 AC、BB 和 C 的大小，并返回其中最小的字符串。",
            "obclient> SELECT LEAST('AC','BB','C') \"MIN\" FROM DUAL;\n+-----+\n| MIN |\n+-----+\n| AC  |\n+-----+\n1 row in set\n",
            "比较整数 1、字符串 6 和 5.555 三者间的大小，并返回其中最小的值。",
            "obclient> SELECT LEAST (1,'6','5.555') \"MIN\" FROM DUAL;\n+-----+\n| MIN |\n+-----+\n|   1 |\n+-----+\n1 row in set\n"
        ]
    },
    "LENGTH": {
        "Title": [
            "LENGTH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823205"
        ],
        "Category": [
            "Character Functions Returning NumberValues"
        ],
        "Feature": "LENGTH(char)\n",
        "Description": [
            "该函数返回字符串的长度。多字节字符（汉字、全角符等）按 1 个字符计算。"
        ],
        "Illustration": [
            "char 属于 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB 数据类型的字符串。",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT LENGTH('OceanBase') \"LENGTH\" FROM DUAL;\n+--------+\n| LENGTH |\n+--------+\n|      9 |\n+--------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回字符串 OceanBase 的长度。",
            "obclient> SELECT LENGTH('OceanBase') \"LENGTH\" FROM DUAL;\n+--------+\n| LENGTH |\n+--------+\n|      9 |\n+--------+\n1 row in set\n"
        ]
    },
    "LISTAGG": {
        "Title": [
            "LISTAGG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822868"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "LISTAGG (measure_expr [,'delimiter']) [ WITHIN GROUP ] (order_by_clause)\n[ OVER query_partition_clause ]\n",
        "Description": [
            "该函数用于列转行，LISTAGG 对 ORDER BY 子句中指定的每个组内的数据进行排序，然后合并度量列的值。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，不需要加 OVER 关键字。 \n     \n作为单个集合的聚合函数，LISTAGG 对所有行进行操作并返回单个输出行。\n作为组集聚合，LISTAGG 将对 GROUP BY 子句定义的每个组进行操作并返回输出行。\n\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nmeasure_expr\n可以是任何表达式。度量列中的空值将被忽略。\n\n\ndelimiter\n指定用于分隔度量值的字符串。此子句是可选的，默认为 NULL。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "如果度量列是 RAW 的，则返回数据类型为 RAW，否则返回值为 VARCHAR2。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) as \"Emp_list\",\n              MIN(hiredate) as \"Earliest\"\n       FROM employees\n       WHERE department_id = 30;\n+-------------------+------------+\n| Emp_list          | Earliest   |\n+-------------------+------------+\n| Raphaely; De Haan | 2017-07-01 |\n+-------------------+------------+\n1 row in set\n",
            "obclient> SELECT department_id \"Dept\",hiredate \"Date\",last_name \"Name\",\n              LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n      FROM employees\n      WHERE hiredate < '2019-10-10'\n      ORDER BY \"Dept\", \"Date\", \"Name\";\n+------+------------+-----------+----------------------------+\n| Dept | Date       | Name      | Emp_list                   |\n+------+------------+-----------+----------------------------+\n|   30 | 2017-07-01 | Raphaely  | Raphaely; De Haan          |\n|   30 | 2018-05-01 | De Haan   | Raphaely; De Haan          |\n|   40 | 2017-07-21 | Errazuriz | Errazuriz                  |\n|   50 | 2017-07-22 | Raphaely  | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Hartstein | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Weiss     | Raphaely; Hartstein; Weiss |\n|   90 | 2018-12-01 | Partners  | Partners; Russell          |\n|   90 | 2019-07-11 | Russell   | Partners; Russell          |\n+------+------------+-----------+----------------------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表employees。",
            "obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "查询第 30 部门的所有员工，并按雇用日期和姓氏排序。",
            "obclient> SELECT LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) as \"Emp_list\",\n              MIN(hiredate) as \"Earliest\"\n       FROM employees\n       WHERE department_id = 30;\n+-------------------+------------+\n| Emp_list          | Earliest   |\n+-------------------+------------+\n| Raphaely; De Haan | 2017-07-01 |\n+-------------------+------------+\n1 row in set\n",
            "分析函数示例",
            "查询 2019 年 10 月 10 日之前雇用的雇员信息，包括该雇员的部门、雇用日期以及该部门中的其他雇员。",
            "obclient> SELECT department_id \"Dept\",hiredate \"Date\",last_name \"Name\",\n              LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hiredate, last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n      FROM employees\n      WHERE hiredate < '2019-10-10'\n      ORDER BY \"Dept\", \"Date\", \"Name\";\n+------+------------+-----------+----------------------------+\n| Dept | Date       | Name      | Emp_list                   |\n+------+------------+-----------+----------------------------+\n|   30 | 2017-07-01 | Raphaely  | Raphaely; De Haan          |\n|   30 | 2018-05-01 | De Haan   | Raphaely; De Haan          |\n|   40 | 2017-07-21 | Errazuriz | Errazuriz                  |\n|   50 | 2017-07-22 | Raphaely  | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Hartstein | Raphaely; Hartstein; Weiss |\n|   50 | 2019-10-05 | Weiss     | Raphaely; Hartstein; Weiss |\n|   90 | 2018-12-01 | Partners  | Partners; Russell          |\n|   90 | 2019-07-11 | Russell   | Partners; Russell          |\n+------+------------+-----------+----------------------------+\n8 rows in set\n"
        ]
    },
    "LN": {
        "Title": [
            "LN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823151"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "LN (numeric_expression)\n",
        "Description": [
            "该函数返回以 e 为底 numeric_expression 的对数。",
            "\n说明\ne 为数学常量，等于 2.71828183...。\n"
        ],
        "Illustration": [
            "numeric_expression 是大于 0 的数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "当参数为 BINARY_FLOAT 数据类型时，返回类型为 BINARY_DOUBLE，其他情况下返回类型与参数 numeric_expression 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT LN(9) FROM DUAL;\n+------------------------------------------+\n| LN(9)                                    |\n+------------------------------------------+\n| 2.19722457733621938279049047384505140929 |\n+------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 9 的自然对数。",
            "obclient> SELECT LN(9) FROM DUAL;\n+------------------------------------------+\n| LN(9)                                    |\n+------------------------------------------+\n| 2.19722457733621938279049047384505140929 |\n+------------------------------------------+\n1 row in set\n"
        ]
    },
    "LNNVL": {
        "Title": [
            "LNNVL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823253"
        ],
        "Category": [
            "NULL-Related Functions"
        ],
        "Feature": "LNNVL (condition)\n",
        "Description": [
            "该函数功能是当条件中的一个或者两个操作数可能为空时，提供判断方法。将条件作为参数，如果条件为 FALSE 或 UNKNOWN，则返回 TRUE；如果条件为 TRUE，则返回 FALSE。",
            "该函数可以在 WHERE 子句中使用，也可以作为 CASE 表达式中的 WHEN 条件。"
        ],
        "Illustration": [
            "condition 是指判断条件。假设 a = 2，b 值为 NULL，下表显示了 LNNVL 函数的返回值。",
            "\n\n\n条件\n条件判断结果\nLNNVL 返回值\n\n\n\n\na = 1\nFALSE\nTRUE\n\n\na = 2\nTRUE\nFALSE\n\n\na IS NULL\nFALSE\nTRUE\n\n\nb = 1\nUNKNOWN\nTRUE\n\n\nb IS NULL\nTRUE\nFALSE\n\n\na = b\nUNKNOWN\nTRUE\n\n\n",
            "返回布尔型 TRUE 或 FALSE。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,30),(2,null),(3,50),(4,80),(5,10);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1 WHERE LNNVL(col2 >= 50);\n+------+------+\n| COL1 | COL2 |\n+------+------+\n|    1 |   30 |\n|    2 | NULL |\n|    5 |   10 |\n+------+------+\n3 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，插入五条数据。查询列 col2 中小于 50 并且包括为空的数据。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,30),(2,null),(3,50),(4,80),(5,10);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1 WHERE LNNVL(col2 >= 50);\n+------+------+\n| COL1 | COL2 |\n+------+------+\n|    1 |   30 |\n|    2 | NULL |\n|    5 |   10 |\n+------+------+\n3 rows in set\n"
        ]
    },
    "LOCALTIMESTAMP": {
        "Title": [
            "LOCALTIMESTAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823119"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "LOCALTIMESTAMP [(timestamp_precision)]\n",
        "Description": [
            "该函数返回当前会话时区中的当前日期，返回 TIMESTAMP 数据类型的值。",
            "与函数 CURRENT_TIMESTAMP 的区别是，CURRENT_TIMESTAMP 函数返回 TIMESTAMP WITH TIME ZONE 数据类型的值。"
        ],
        "Illustration": [
            "timestamp_precision 表示秒的小数位的精度，取整数值，范围为 [0,9]，为可选项。默认值为 6。",
            "返回 TIMESTAMP 数据类型。"
        ],
        "Examples": [
            "obclient> ALTER SESSION SET TIME_ZONE = '-05:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT LOCALTIMESTAMP FROM DUAL;\n+------------------------------+\n| LOCALTIMESTAMP               |\n+------------------------------+\n| 17-NOV-21 04.36.28.557316 AM |\n+------------------------------+\n1 row in set\n",
            "obclient> ALTER SESSION SET TIME_ZONE = '+08:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT LOCALTIMESTAMP(3) FROM DUAL;\n+---------------------------+\n| LOCALTIMESTAMP(3)         |\n+---------------------------+\n| 17-NOV-21 05.38.12.839 PM |\n+---------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "设置当前时区至 GMT-5 时区，使用 LOCALTIMESTAMP 函数返回当前日期。",
            "obclient> ALTER SESSION SET TIME_ZONE = '-05:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT LOCALTIMESTAMP FROM DUAL;\n+------------------------------+\n| LOCALTIMESTAMP               |\n+------------------------------+\n| 17-NOV-21 04.36.28.557316 AM |\n+------------------------------+\n1 row in set\n",
            "设置当前时区至 GMT+8 时区，且调整秒的小数位精度为 3。使用 LOCALTIMESTAMP 函数返回当前日期。",
            "obclient> ALTER SESSION SET TIME_ZONE = '+08:00';\nQuery OK, 0 rows affected\n\nobclient> SELECT LOCALTIMESTAMP(3) FROM DUAL;\n+---------------------------+\n| LOCALTIMESTAMP(3)         |\n+---------------------------+\n| 17-NOV-21 05.38.12.839 PM |\n+---------------------------+\n1 row in set\n"
        ]
    },
    "LOG": {
        "Title": [
            "LOG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823143"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "LOG (x,y)\n",
        "Description": [
            "该函数返回以 x 为底的 y 的对数。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nx\n表示对数的底，数值型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。 x 大于 0 且不等于 1。\n\n\ny\n表示真数，数值型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。 y 大于 0。\n\n\n",
            "当参数为 BINARY_FLOAT 和 BINARY_DOUBLE 数据类型时，返回类型为 BINARY_DOUBLE，其他情况下返回类型为 NUMBER。"
        ],
        "Examples": [
            "obclient> SELECT LOG(2,8) FROM DUAL;\n+----------+\n| LOG(2,8) |\n+----------+\n|        3 |\n+----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回以 2 为底的 8 的对数。",
            "obclient> SELECT LOG(2,8) FROM DUAL;\n+----------+\n| LOG(2,8) |\n+----------+\n|        3 |\n+----------+\n1 row in set\n"
        ]
    },
    "LOWER": {
        "Title": [
            "LOWER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823196"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "LOWER(char)\n",
        "Description": [
            "该函数将字符串中英文字母全部转为小写。"
        ],
        "Illustration": [
            "char 表示字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。",
            "返回与 char 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT  LOWER('AaBbCcDd') Lowercase FROM DUAL;\n+-----------+\n| LOWERCASE |\n+-----------+\n| aabbccdd  |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 AaBbCcDd 中的英文字母全部转化为小写。",
            "obclient> SELECT  LOWER('AaBbCcDd') Lowercase FROM DUAL;\n+-----------+\n| LOWERCASE |\n+-----------+\n| aabbccdd  |\n+-----------+\n1 row in set\n"
        ]
    },
    "LPAD": {
        "Title": [
            "LPAD"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823192"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "LPAD(char1,n[,char2])\n",
        "Description": [
            "该函数的功能是将字符串 char1 的左边用字符串 char2 填充，直到长度为 n 时为止。",
            "\n说明\n\n如果 char1 长度大于 n，则返回 char1 左边 n 个字符。\n如果 char1 长度小于 n，char2 和 char1 连接后大于 n，则返回连接后的右边 n 个字符。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n表示字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nn\n追加后字符总长度，必须是 NUMBER 类型或可以隐式转换为 NUMBER 类型的值。 说明 对于非整数值，会舍去小数部分转化为整数。\n\n\nchar2\n表示追加的字符串，默认为空格。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\n",
            "如果 char1 是字符型数据，则返回 VARCHAR2 类型。",
            "如果 char1 是国家字符数据类型，则返回 NVARCHAR2 类型。",
            "如果 char1 是 LOB 数据类型，则返回 LOB 类型。"
        ],
        "Examples": [
            "obclient> SELECT  LPAD('ABCDE',10,'*') FROM DUAL;\n+----------------------+\n| LPAD('ABCDE',10,'*') |\n+----------------------+\n| *****ABCDE           |\n+----------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用星号 * 左填充字符串 ABCDE。",
            "obclient> SELECT  LPAD('ABCDE',10,'*') FROM DUAL;\n+----------------------+\n| LPAD('ABCDE',10,'*') |\n+----------------------+\n| *****ABCDE           |\n+----------------------+\n1 row in set\n"
        ]
    },
    "LTRIM": {
        "Title": [
            "LTRIM"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823184"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "LTRIM(char1 [,char2])\n",
        "Description": [
            "该函数功能是从 char1 的左端开始删除 char2 中包含的所有字符，直到 char1 左端出现 char2 中不存在的字符为止，然后返回结果。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n表示字符串。 字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nchar2\n表示要删除的字符集合。如果未指定 char2，则默认为单个空格。 字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\n",
            "如果 char1 是 CHAR、VARCHAR2 数据类型，则函数返回 VARCHAR2 数据类型。",
            "如果 char1 是 NCHAR、NVARCHAR2 数据类型，则函数返回 NVARCHAR2 数据类型。",
            "如果 char1 是 LOB 数据类型，则返回的字符串为 LOB 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT LTRIM('#a￥!aa￥  Hello World!','#a￥! ') text FROM DUAL;\n+--------------+\n| TEXT         |\n+--------------+\n| Hello World! |\n+--------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "去掉字符串 #a￥！aa￥ Hello World! 中 Hello World! 前面的多余字符。",
            "obclient> SELECT LTRIM('#a￥!aa￥  Hello World!','#a￥! ') text FROM DUAL;\n+--------------+\n| TEXT         |\n+--------------+\n| Hello World! |\n+--------------+\n1 row in set\n"
        ]
    },
    "MAX": {
        "Title": [
            "MAX"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822873"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "MAX ([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数返回参数中指定的列中的最大值。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：返回的行中去除重复行，且忽略值为 NULL 的行。\nUNIQUE：返回的行中去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n可为数值、字符、日期型或其它类型的数据列或表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回与 expr 相同的数据类型值。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT MAX(salary) FROM employees;\n+-------------+\n| MAX(SALARY) |\n+-------------+\n|       14000 |\n+-------------+\n1 row in set\n",
            "obclient> SELECT department_id,last_name,salary,\n                 MAX(salary) OVER (PARTITION BY department_id) AS rmax_sal\n          FROM employees;\n+---------------+-----------+--------+----------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | RMAX_SAL |\n+---------------+-----------+--------+----------+\n|            30 | Raphaely  |   1700 |    11000 |\n|            30 | De Haan   |  11000 |    11000 |\n|            40 | Errazuriz |   1400 |     1400 |\n|            50 | Hartstein |  14000 |    14000 |\n|            50 | Raphaely  |   1700 |    14000 |\n|            50 | Weiss     |  13500 |    14000 |\n|            90 | Russell   |  13000 |    14000 |\n|            90 | Partners  |  14000 |    14000 |\n+---------------+-----------+--------+----------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 employees。",
            "obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "查询 salary 列的最大值。",
            "obclient> SELECT MAX(salary) FROM employees;\n+-------------+\n| MAX(SALARY) |\n+-------------+\n|       14000 |\n+-------------+\n1 row in set\n",
            "分析函数示例",
            "以 department_id 分组，查询 salary 列的最大值。",
            "obclient> SELECT department_id,last_name,salary,\n                 MAX(salary) OVER (PARTITION BY department_id) AS rmax_sal\n          FROM employees;\n+---------------+-----------+--------+----------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | RMAX_SAL |\n+---------------+-----------+--------+----------+\n|            30 | Raphaely  |   1700 |    11000 |\n|            30 | De Haan   |  11000 |    11000 |\n|            40 | Errazuriz |   1400 |     1400 |\n|            50 | Hartstein |  14000 |    14000 |\n|            50 | Raphaely  |   1700 |    14000 |\n|            50 | Weiss     |  13500 |    14000 |\n|            90 | Russell   |  13000 |    14000 |\n|            90 | Partners  |  14000 |    14000 |\n+---------------+-----------+--------+----------+\n8 rows in set\n"
        ]
    },
    "MEDIAN": {
        "Title": [
            "MEDIAN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822881"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "MEDIAN(expr) [ OVER (query_partition_clause) ]\n",
        "Description": [
            "该函数用于返回一组数值的中值，即将一组数值排序后返回居于中间的数值。如果参数集合中包含偶数个数值，该函数将返回位于中间的两个数的平均值。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要求中值的数组名称，参数类型属于数值数据类型或可以隐式转换为数字数据类型。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "如果仅指定 expr，则该函数返回与参数的数值数据类型相同的数据类型。",
            "如果指定 OVER 子句，则数据库确定具有最高数值优先级的参数，将其余参数隐式转换为该数据类型，并返回该数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "obclient> SELECT MEDIAN(col4) FROM tbl1;\n+--------------+\n| MEDIAN(COL4) |\n+--------------+\n|           15 |\n+--------------+\n1 row in set\n",
            "obclient> SELECT col1,col4,MEDIAN(col4) OVER(PARTITION BY col1) \"MEDIAN\"\n FROM tbl1;\n+------+------+--------+\n| COL1 | COL4 | MEDIAN |\n+------+------+--------+\n|    1 |   12 |     15 |\n|    1 |   15 |     15 |\n|    1 |   16 |     15 |\n|    2 |   14 |   14.5 |\n|    2 |   15 |   14.5 |\n|    2 |   13 |   14.5 |\n|    2 |   16 |   14.5 |\n|    3 |   18 |     15 |\n|    3 |   16 |     15 |\n|    3 |   15 |     15 |\n|    3 |   12 |     15 |\n|    3 |   10 |     15 |\n+------+------+--------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入数据。",
            "obclient> CREATE TABLE tbl1(col1 INT,col2 varchar(10),col3 INT,col4 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'A1',8,12),(1,'A2',10,15),(1,'A3',11,16),\n            (2,'B1',9,14),(2,'B2',10,15),(2,'B3',8,13),(2,'B4',11,16),(3,'C1',8,18),\n            (3,'C2',9,16),(3,'C3',10,15),(3,'C4',11,12),(3,'C5',12,10);\nQuery OK, 12 rows affected\nRecords: 12  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "计算列 col4 的中值。",
            "obclient> SELECT MEDIAN(col4) FROM tbl1;\n+--------------+\n| MEDIAN(COL4) |\n+--------------+\n|           15 |\n+--------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col1 分组，计算列 col4 的中值。",
            "obclient> SELECT col1,col4,MEDIAN(col4) OVER(PARTITION BY col1) \"MEDIAN\"\n FROM tbl1;\n+------+------+--------+\n| COL1 | COL4 | MEDIAN |\n+------+------+--------+\n|    1 |   12 |     15 |\n|    1 |   15 |     15 |\n|    1 |   16 |     15 |\n|    2 |   14 |   14.5 |\n|    2 |   15 |   14.5 |\n|    2 |   13 |   14.5 |\n|    2 |   16 |   14.5 |\n|    3 |   18 |     15 |\n|    3 |   16 |     15 |\n|    3 |   15 |     15 |\n|    3 |   12 |     15 |\n|    3 |   10 |     15 |\n+------+------+--------+\n12 rows in set\n"
        ]
    },
    "MIN": {
        "Title": [
            "MIN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822874"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "MIN([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数返回参数中指定列的最小值。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重，为可选项。默认值 ALL。 \n      \nALL：返回所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：返回的行中去除重复行，且忽略值为 NULL 的行。\nUNIQUE：返回的行中去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n可为数值、字符、日期型或其它数据类型的列或表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回与 expr 相同数据类型的值。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT MIN(salary)  FROM employees;\n+-------------+\n| MIN(SALARY) |\n+-------------+\n|        1400 |\n+-------------+\n1 row in set\n",
            "obclient> SELECT department_id,last_name,hiredate,salary,\n                 MIN(salary) OVER(PARTITION BY department_id) AS p_cmin\n          FROM employees;\n+---------------+-----------+------------+--------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | P_CMIN |\n+---------------+-----------+------------+--------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |   1700 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |   1700 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |   1700 |\n|            90 | Russell   | 2019-07-11 |  13000 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |  13000 |\n+---------------+-----------+------------+--------+--------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 employees。",
            "obclient> SELECT * FROM employees;\n+---------------+------------+-----------+------------+--------+\n| DEPARTMENT_ID | MANAGER_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+------------+-----------+------------+--------+\n|            30 |        100 | Raphaely  | 2017-07-01 |   1700 |\n|            30 |        100 | De Haan   | 2018-05-01 |  11000 |\n|            40 |        100 | Errazuriz | 2017-07-21 |   1400 |\n|            50 |        100 | Hartstein | 2019-10-05 |  14000 |\n|            50 |        100 | Raphaely  | 2017-07-22 |   1700 |\n|            50 |        100 | Weiss     | 2019-10-05 |  13500 |\n|            90 |        100 | Russell   | 2019-07-11 |  13000 |\n|            90 |        100 | Partners  | 2018-12-01 |  14000 |\n+---------------+------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "查询 salary 列的最小值。",
            "obclient> SELECT MIN(salary)  FROM employees;\n+-------------+\n| MIN(SALARY) |\n+-------------+\n|        1400 |\n+-------------+\n1 row in set\n",
            "分析函数示例",
            "以列 department_id 分组，查询 salary 列的最小值。",
            "obclient> SELECT department_id,last_name,hiredate,salary,\n                 MIN(salary) OVER(PARTITION BY department_id) AS p_cmin\n          FROM employees;\n+---------------+-----------+------------+--------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | P_CMIN |\n+---------------+-----------+------------+--------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |   1700 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |   1700 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |   1700 |\n|            90 | Russell   | 2019-07-11 |  13000 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |  13000 |\n+---------------+-----------+------------+--------+--------+\n8 rows in set\n"
        ]
    },
    "MOD": {
        "Title": [
            "MOD"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823160"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "MOD (x,y)\n",
        "Description": [
            "该函数是一个求余函数，即是两个数值表达式作除法运算后的余数。返回结果的符号与被除数的符号相同。",
            "\n注意\n在用 REMAINDER (x,y) 和 MOD (x,y) 函数进行运算时，都用了一个公式 result=x-y*(x/y)，区别在于计算 x/y 时的处理方式不同。在 REMAINDER (x,y) 函数中，采用 ROUND(x/y)，而在 MOD (x,y) 函数中采用 FLOOR(x/y)。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nx\n表示被除数，属于数值型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。\n\n\ny\n表示除数，属于数值型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。\n\n\n",
            "返回类型与数值优先级高的参数的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT MOD(11,4),MOD(12,4),MOD(-11,4) FROM DUAL;\n+-----------+-----------+------------+\n| MOD(11,4) | MOD(12,4) | MOD(-11,4) |\n+-----------+-----------+------------+\n|         3 |         0 |         -3 |\n+-----------+-----------+------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 11 除以 4 的余数、12 除以 4 的余数和 -11 除以 4 的余数。",
            "obclient> SELECT MOD(11,4),MOD(12,4),MOD(-11,4) FROM DUAL;\n+-----------+-----------+------------+\n| MOD(11,4) | MOD(12,4) | MOD(-11,4) |\n+-----------+-----------+------------+\n|         3 |         0 |         -3 |\n+-----------+-----------+------------+\n1 row in set\n"
        ]
    },
    "MONTHS_BETWEEN": {
        "Title": [
            "MONTHS_BETWEEN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823129"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "MONTHS_BETWEEN (date1，date2)\n",
        "Description": [
            "该函数是返回参数 date1 到 date2 之间的月数。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndate1\nDATE 数据类型的值。\n\n\ndate2\nDATE 数据类型的值。\n\n\n",
            "返回 NUMBER 数据类型。",
            "如果 date1 大于 date2，返回正数。",
            "如果 date1 小于 date2，则返回负数。"
        ],
        "Examples": [
            "obclient> SELECT MONTHS_BETWEEN(TO_DATE('2030-11-17','YYYY-MM-DD'),TO_DATE('2022-01-15','YYYY-MM-DD')) \"MONTHS\" FROM DUAL;\n+------------------------------------------+\n| MONTHS                                   |\n+------------------------------------------+\n| 106.064516129032258064516129032258064516 |\n+------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "计算 2030-11-17 与 2022-01-15 之间的月数。",
            "obclient> SELECT MONTHS_BETWEEN(TO_DATE('2030-11-17','YYYY-MM-DD'),TO_DATE('2022-01-15','YYYY-MM-DD')) \"MONTHS\" FROM DUAL;\n+------------------------------------------+\n| MONTHS                                   |\n+------------------------------------------+\n| 106.064516129032258064516129032258064516 |\n+------------------------------------------+\n1 row in set\n"
        ]
    },
    "NANVL": {
        "Title": [
            "NANVL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823174"
        ],
        "Category": [
            "Numeric Functions",
            "NULL-Related Functions"
        ],
        "Feature": "NANVL(n1,n2)\n",
        "Description": [
            "该函数用于判断输入值参数 n1 是不是 NaN（表示非数字），并返回结果。",
            "如果 n1 是 NaN，则返回参数 n2。",
            "如果 n1 不是 NaN，则返回参数 n1。",
            "\n注意\n该函数仅适用于 BINARY_FLOAT 或 BINARY_DOUBLE 数据类型。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nn1\n属于数值数据类型（BINARY_FLOAT、BINARY_DOUBLE）或可以隐式转换为数值数据类型的表达式。\n\n\nn2\n属于数值数据类型（BINARY_FLOAT、BINARY_DOUBLE）或可以隐式转换为数值数据类型的表达式。\n\n\n",
            "如果有任意一个参数类型是 BINARY_DOUBLE，则返回 BINARY_DOUBLE 数据类型。",
            "如果有参数类型都是 BINARY_FLOAT，则返回 BINARY_FLOAT 数据类型。",
            "如果有任意一个参数为空，则返回 NULL。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 NUMBER(10,2), col2 BINARY_DOUBLE, col3 BINARY_FLOAT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,1,1),(2,'NaN',2),(3,3,'NaN');\nQuery OK, 3 rows affected\nRecords: 3  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+----------+----------+\n| COL1 | COL2     | COL3     |\n+------+----------+----------+\n|    1 | 1.0E+000 | 1.0E+000 |\n|    2 |      Nan | 2.0E+000 |\n|    3 | 3.0E+000 |      Nan |\n+------+----------+----------+\n3 rows in set\n\nobclient> SELECT col2,NANVL(col2,0) FROM tbl1;\n+----------+---------------+\n| COL2     | NANVL(COL2,0) |\n+----------+---------------+\n| 1.0E+000 |      1.0E+000 |\n|      Nan |             0 |\n| 3.0E+000 |      3.0E+000 |\n+----------+---------------+\n3 rows in set\n",
            "obclient> SELECT NANVL('',1),NANVL(2,'') FROM DUAL;\n+-------------+-------------+\n| NANVL('',1) | NANVL(2,'') |\n+-------------+-------------+\n|        NULL |        NULL |\n+-------------+-------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入测试数据。如果列 col2 是数字，则返回原数值，否则返回 0。",
            "obclient> CREATE TABLE tbl1 (col1 NUMBER(10,2), col2 BINARY_DOUBLE, col3 BINARY_FLOAT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,1,1),(2,'NaN',2),(3,3,'NaN');\nQuery OK, 3 rows affected\nRecords: 3  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+----------+----------+\n| COL1 | COL2     | COL3     |\n+------+----------+----------+\n|    1 | 1.0E+000 | 1.0E+000 |\n|    2 |      Nan | 2.0E+000 |\n|    3 | 3.0E+000 |      Nan |\n+------+----------+----------+\n3 rows in set\n\nobclient> SELECT col2,NANVL(col2,0) FROM tbl1;\n+----------+---------------+\n| COL2     | NANVL(COL2,0) |\n+----------+---------------+\n| 1.0E+000 |      1.0E+000 |\n|      Nan |             0 |\n| 3.0E+000 |      3.0E+000 |\n+----------+---------------+\n3 rows in set\n",
            "当有一个参数为空时，返回 NULL。",
            "obclient> SELECT NANVL('',1),NANVL(2,'') FROM DUAL;\n+-------------+-------------+\n| NANVL('',1) | NANVL(2,'') |\n+-------------+-------------+\n|        NULL |        NULL |\n+-------------+-------------+\n1 row in set\n"
        ]
    },
    "NEXT_DAY": {
        "Title": [
            "NEXT_DAY"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823139"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "NEXT_DAY (date,week)\n",
        "Description": [
            "该函数是返回日期 date 的下一周中 week（星期值）所在的日期值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndate\nDATE 数据类型的值。\n\n\nweek\n星期值。包括 SUNDAY（星期天）、 MONDAY（星期一）、 TUESDAY（星期二）、 WEDNESDAY（星期三）、 THURSDAY（星期四）、 FRIDAY（星期五）和 SATURDAY（星期六）。\n\n\n",
            "返回 DATE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE \"当前日期\",\n    NEXT_DAY(SYSDATE,'MONDAY') \"下周一\",\n    NEXT_DAY(SYSDATE,'TUESDAY') \"下周二\",\n    NEXT_DAY(SYSDATE,'WEDNESDAY') \"下周三\",\n    NEXT_DAY(SYSDATE,'THURSDAY') \"下周四\",\n    NEXT_DAY(SYSDATE,'FRIDAY') \"下周五\",\n    NEXT_DAY(SYSDATE,'SATURDAY') \"下周六\",\n    NEXT_DAY(SYSDATE,'SUNDAY') \"下周日\"\n    FROM DUAL;\n+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n| 当前日期     | 下周一    | 下周二    | 下周三    | 下周四    | 下周五    | 下周六    | 下周日    |\n+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n| 17-NOV-21    | 22-NOV-21 | 23-NOV-21 | 24-NOV-21 | 18-NOV-21 | 19-NOV-21 | 20-NOV-21 | 21-NOV-21 |\n+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回下周每个星期值对应的日期值。",
            "obclient> SELECT SYSDATE \"当前日期\",\n    NEXT_DAY(SYSDATE,'MONDAY') \"下周一\",\n    NEXT_DAY(SYSDATE,'TUESDAY') \"下周二\",\n    NEXT_DAY(SYSDATE,'WEDNESDAY') \"下周三\",\n    NEXT_DAY(SYSDATE,'THURSDAY') \"下周四\",\n    NEXT_DAY(SYSDATE,'FRIDAY') \"下周五\",\n    NEXT_DAY(SYSDATE,'SATURDAY') \"下周六\",\n    NEXT_DAY(SYSDATE,'SUNDAY') \"下周日\"\n    FROM DUAL;\n+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n| 当前日期     | 下周一    | 下周二    | 下周三    | 下周四    | 下周五    | 下周六    | 下周日    |\n+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n| 17-NOV-21    | 22-NOV-21 | 23-NOV-21 | 24-NOV-21 | 18-NOV-21 | 19-NOV-21 | 20-NOV-21 | 21-NOV-21 |\n+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n1 row in set\n"
        ]
    },
    "NLSSORT": {
        "Title": [
            "NLSSORT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823197"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "NLSSORT(char [, 'nlsparam' ])\n",
        "Description": [
            "该函数根据显式或隐式参数指定的排序规则，返回字符排序键值（Sortkey）。",
            "NLSSORT() 函数使用指定的排序规则生成排序键值，排序键是一个字节字符串，用于根据指定的排序规则对字符进行排序。",
            "排序规则键的长度受参数 MAX_STRING_SIZE 的影响。如果 MAX_STRING_SIZE=EXTENDED，则返回值的最大长度为 32767 字节。如果排序规则键超出此限制，则函数将执行失败，并出现无法创建排序规则键的报错\"unable to create the collation key\"。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\n该参数支持字面量，也支持表达式（包括列名）。 数据类型可以为 CHAR、VARCHAR2、NCHAR 或者 NVARCHAR2。如果输入的数据类型为CLOB，会做隐式转换。\n\n\nnlsparam\n指定排序规则。 nlsparam 的固定格式为 NLS_SORT = collation。collation 是指语言排序规则名称。 OceanBase 数据库于 V4.2 版本及以后，简体中文排序新支持基于 GB18030_2022 字符集的排序方式。对于中文字符集，目前支持如下 3 种简体中文的排序方式： \n      \nSCHINESE_PINYIN2_M：按拼音排序。\nSCHINESE_STROKE2_M：按笔画排序。\nSCHINESE_RADICAL2_M：按部首排序。\n 对于 Unicode，目前支持如下 3 种简体中文的排序方式： \n      \nUCA0900_SCHINESE_PINYIN: 按拼音排序。\nUCA0900_SCHINESE_STROKE：按笔画排序\nUCA0900_SCHINESE_RADICAL：先按部首排序，再按笔画排序。\n 如果省略 nlsparam，则此函数使用字符集默认排序规则。\n\n\n"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(PK INT, name VARCHAR(25));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'福克斯'),(2,'警察'),(3,'的士'),(4,'林肯'),(5,'亚利桑那州'),(6,'华盛顿'),\n      (7,'戴尔'),(10,'朗讯');\nQuery OK, 8 rows affected\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+-----------------+\n| PK   | NAME            |\n+------+-----------------+\n|    1 | 福克斯          |\n|    2 | 警察            |\n|    3 | 的士            |\n|    4 | 林肯            |\n|    5 | 亚利桑那州      |\n|    6 | 华盛顿          |\n|    7 | 戴尔            |\n|   10 | 朗讯            |\n+------+-----------------+\n8 rows in set\n\nobclient> SELECT * FROM tbl1 ORDER BY NLSSORT(name,'NLS_SORT = SCHINESE_PINYIN_M');\n+------+-----------------+\n| PK   | NAME            |\n+------+-----------------+\n|    7 | 戴尔            |\n|    3 | 的士            |\n|    1 | 福克斯          |\n|    6 | 华盛顿          |\n|    2 | 警察            |\n|   10 | 朗讯            |\n|    4 | 林肯            |\n|    5 | 亚利桑那州      |\n+------+-----------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "obclient> CREATE TABLE tbl1(PK INT, name VARCHAR(25));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'福克斯'),(2,'警察'),(3,'的士'),(4,'林肯'),(5,'亚利桑那州'),(6,'华盛顿'),\n      (7,'戴尔'),(10,'朗讯');\nQuery OK, 8 rows affected\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+-----------------+\n| PK   | NAME            |\n+------+-----------------+\n|    1 | 福克斯          |\n|    2 | 警察            |\n|    3 | 的士            |\n|    4 | 林肯            |\n|    5 | 亚利桑那州      |\n|    6 | 华盛顿          |\n|    7 | 戴尔            |\n|   10 | 朗讯            |\n+------+-----------------+\n8 rows in set\n\nobclient> SELECT * FROM tbl1 ORDER BY NLSSORT(name,'NLS_SORT = SCHINESE_PINYIN_M');\n+------+-----------------+\n| PK   | NAME            |\n+------+-----------------+\n|    7 | 戴尔            |\n|    3 | 的士            |\n|    1 | 福克斯          |\n|    6 | 华盛顿          |\n|    2 | 警察            |\n|   10 | 朗讯            |\n|    4 | 林肯            |\n|    5 | 亚利桑那州      |\n+------+-----------------+\n8 rows in set\n"
        ]
    },
    "NLS_LOWER": {
        "Title": [
            "NLS_LOWER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823190"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "NLS_LOWER(char [, 'nlsparam' ])\n",
        "Description": [
            "该函数将字符串中英文字母全部转为小写。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\n指定要转换的字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nnlsparam\n指定返回字符串的排序方式，为可选项。 说明 OceanBase 数据库当前版本暂不支持此参数。\n\n\n",
            "返回与 char 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT  NLS_LOWER('AaBbCcDd') Lowercase FROM DUAL;\n+-----------+\n| LOWERCASE |\n+-----------+\n| aabbccdd  |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 AaBbCcDd 中的英文字母全部转化为小写。",
            "obclient> SELECT  NLS_LOWER('AaBbCcDd') Lowercase FROM DUAL;\n+-----------+\n| LOWERCASE |\n+-----------+\n| aabbccdd  |\n+-----------+\n1 row in set\n"
        ]
    },
    "NLS_UPPER": {
        "Title": [
            "NLS_UPPER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823194"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "NLS_UPPER(char [, 'nlsparam' ])\n",
        "Description": [
            "该函数将字符串中英文字母全部转为大写。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\n指定要转换的字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nnlsparam\n指定返回字符串的排序方式，为可选项。 说明 OceanBase 数据库当前版本暂不支持此参数。\n\n\n",
            "返回与 char 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT NLS_UPPER('OceanBase') \"UPPER\" FROM DUAL;\n+-----------+\n| UPPER     |\n+-----------+\n| OCEANBASE |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 OceanBase 全部转化为大写。",
            "obclient> SELECT NLS_UPPER('OceanBase') \"UPPER\" FROM DUAL;\n+-----------+\n| UPPER     |\n+-----------+\n| OCEANBASE |\n+-----------+\n1 row in set\n"
        ]
    },
    "NORMAL": {
        "Title": [
            "NORMAL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823170"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "NORMAL(<mean> , <stddev> , <gen>)\n",
        "Description": [],
        "Illustration": [
            "该函数返回一个符合正态分布（Normal Distribution，又称高斯分布）的浮点数。",
            "mean",
            " 表示均值，",
            "stddev",
            " 表示标准差。",
            "mean",
            " 和 ",
            "stddev",
            " 的取值必须是标量值，不随行迭代而变。例如，整形或浮点型常量、标量函数等。 \n    ",
            "\nmean 和 stddev 的取值可以是 1、2、ABS(-10)；PL 里还可以是 @v1、1+@v3 等。\nmean 和 stddev 的取值不可以是 RAND()、RANDOM()、RAND(2)、t1.c1、ABS(-t1.c1)、1+c2 等。\n",
            "mean",
            " 和 ",
            "stddev",
            " 的取值可以是 ",
            "1",
            "、",
            "2",
            "、",
            "ABS(-10)",
            "；PL 里还可以是 ",
            "@v1",
            "、",
            "1+@v3",
            " 等。",
            "mean",
            " 和 ",
            "stddev",
            " 的取值不可以是 ",
            "RAND()",
            "、",
            "RANDOM()",
            "、",
            "RAND(2)",
            "、",
            "t1.c1",
            "、",
            "ABS(-t1.c1)",
            "、",
            "1+c2",
            " 等。",
            "随机值生成算法基于 ",
            "std::normal_distribution",
            "，采用了 “Marsaglia Polar Method”算法，该算法会消耗较多 CPU。",
            "gen",
            " 是一个数值生成函数，通常使用 ",
            "RANDOM()",
            " 函数生成。如果传入值是一个常量，则 ",
            "NORMAL()",
            " 函数返回值也为一个定值。"
        ],
        "Examples": [
            "obclient> SELECT v, COUNT(*) FROM (SELECT ROUND(NORMAL(3, 0.1, RANDOM()), 1) v FROM TABLE(GENERATOR(1000000))) x GROUP BY v ORDER BY v;\n+------+----------+\n| V    | COUNT(*) |\n+------+----------+\n|  2.5 |        4 |\n|  2.6 |      237 |\n|  2.7 |     6053 |\n|  2.8 |    60273 |\n|  2.9 |   241467 |\n|    3 |   383862 |\n|  3.1 |   241592 |\n|  3.2 |    60447 |\n|  3.3 |     5837 |\n|  3.4 |      224 |\n|  3.5 |        4 |\n+------+----------+\n11 rows in set\n",
            "obclient> SELECT COUNT(NORMAL(0, 1, RANDOM())) v FROM TABLE(GENERATOR(1000000));\n+---------+\n| V       |\n+---------+\n| 1000000 |\n+---------+\n1 row in set (1.49 sec)\n"
        ],
        "Detailed Examples": [
            "如下示例为对 100 万个符合正态分布的随机数值进行取值（只保留小数点后一位），并统计数量。",
            "obclient> SELECT v, COUNT(*) FROM (SELECT ROUND(NORMAL(3, 0.1, RANDOM()), 1) v FROM TABLE(GENERATOR(1000000))) x GROUP BY v ORDER BY v;\n+------+----------+\n| V    | COUNT(*) |\n+------+----------+\n|  2.5 |        4 |\n|  2.6 |      237 |\n|  2.7 |     6053 |\n|  2.8 |    60273 |\n|  2.9 |   241467 |\n|    3 |   383862 |\n|  3.1 |   241592 |\n|  3.2 |    60447 |\n|  3.3 |     5837 |\n|  3.4 |      224 |\n|  3.5 |        4 |\n+------+----------+\n11 rows in set\n",
            "如下示例为生成 100 万个符合正态分布的随机数值，耗时 1.5 秒。",
            "obclient> SELECT COUNT(NORMAL(0, 1, RANDOM())) v FROM TABLE(GENERATOR(1000000));\n+---------+\n| V       |\n+---------+\n| 1000000 |\n+---------+\n1 row in set (1.49 sec)\n"
        ]
    },
    "NTH_VALUE": {
        "Title": [
            "NTH_VALUE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822844"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "NTH_VALUE (measure_expr, n)\n  [ FROM { FIRST | LAST } ][ { RESPECT | IGNORE } NULLS ]\nOVER (analytic_clause)\n",
        "Description": [
            "该函数功能是返回 analytic_clause 定义的窗口中第 n 行的 measure_expr 值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nmeasure_expr\n指定返回数据的字段。\n\n\nn\n指定返回测量值的第 n 行。n 取值为正整数。 注意\n\n如果 n 是 NULL，函数将返回错误。\n如果 n 大于窗口内所有的行数，函数返回 NULL。\n\n\n\nFROM { FIRST | LAST }\n指定计算方向。为可选项，默认值为 FROM FIRST。 \n      \nFROM FIRST 表示从窗口的第一行开始计算。\nFROM LAST 表示最后一行开始计算。\n\n\n\n{RESPECT | IGNORE} NULLS\n表示是否忽略 NULL 值，为可选项。默认值为 RESPECT NULLS。 \n      \nRESPECT NULLS 表示不忽略 NULL 值。\nIGNORE NULLS 表示忽略 NULL 值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回值与参数 measure_expr 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,\n               NTH_VALUE(sal,4) OVER (PARTITION BY deptno ORDER BY sal DESC\n               ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS third_most_sal\n      FROM emp_msg\n      ORDER BY deptno,sal DESC;\n+--------+--------+------+----------------+\n| DEPTNO | ENAME  | SAL  | THIRD_MOST_SAL |\n+--------+--------+------+----------------+\n|     10 | KING   | 5300 |           NULL |\n|     10 | CLARK  | 2750 |           NULL |\n|     10 | MILLER | 1600 |           NULL |\n|     20 | FORD   | 3300 |           1400 |\n|     20 | SCOTT  | 3300 |           1400 |\n|     20 | JONES  | 3275 |           1400 |\n|     20 | ADAMS  | 1400 |           1400 |\n|     20 | SMITH  | 1100 |           1400 |\n|     30 | BLAKE  | 3150 |           1750 |\n|     30 | ALLEN  | 1900 |           1750 |\n|     30 | TURNER | 1800 |           1750 |\n|     30 | SCLARK | 1750 |           1750 |\n|     30 | MARTIN | 1550 |           1750 |\n|     30 | WARD   | 1550 |           1750 |\n|     30 | JAMES  | 1250 |           1750 |\n+--------+--------+------+----------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。查询表 emp_msg 按列 deptno 分组和按列 sal 降序，返回列 sal 的第 4 个值。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,\n               NTH_VALUE(sal,4) OVER (PARTITION BY deptno ORDER BY sal DESC\n               ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS third_most_sal\n      FROM emp_msg\n      ORDER BY deptno,sal DESC;\n+--------+--------+------+----------------+\n| DEPTNO | ENAME  | SAL  | THIRD_MOST_SAL |\n+--------+--------+------+----------------+\n|     10 | KING   | 5300 |           NULL |\n|     10 | CLARK  | 2750 |           NULL |\n|     10 | MILLER | 1600 |           NULL |\n|     20 | FORD   | 3300 |           1400 |\n|     20 | SCOTT  | 3300 |           1400 |\n|     20 | JONES  | 3275 |           1400 |\n|     20 | ADAMS  | 1400 |           1400 |\n|     20 | SMITH  | 1100 |           1400 |\n|     30 | BLAKE  | 3150 |           1750 |\n|     30 | ALLEN  | 1900 |           1750 |\n|     30 | TURNER | 1800 |           1750 |\n|     30 | SCLARK | 1750 |           1750 |\n|     30 | MARTIN | 1550 |           1750 |\n|     30 | WARD   | 1550 |           1750 |\n|     30 | JAMES  | 1250 |           1750 |\n+--------+--------+------+----------------+\n15 rows in set\n"
        ]
    },
    "NTILE": {
        "Title": [
            "NTILE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822852"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "NTILE (expr) OVER ([ query_partition_clause ] order_by_clause)\n",
        "Description": [
            "该函数是一个分析函数，功能是将有序数据集划分为若干个组，并为每一行分配适当的组号。组编号为 1 到 expr。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定划分的组数。 \n      \nexpr 值必须解析为大于等于 1 的正数，如果 expr 是一个非整数常量，则数据库将会该值截断为整数。\n如果 expr 大于行数，则将填充与行数相等的多个组，其余组为空。\n 注意 不能通过使用 NTILE 或任何其他分析函数来嵌套分析函数。但是您可以在 expr 中使用其他内置函数表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回 NUMERIC 类型数据。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT ename,sal,NTILE(5) OVER (ORDER BY sal DESC) sal_ntile FROM emp_msg ORDER BY sal DESC;\n+--------+------+-----------+\n| ENAME  | SAL  | SAL_NTILE |\n+--------+------+-----------+\n| KING   | 5300 |         1 |\n| FORD   | 3300 |         1 |\n| SCOTT  | 3300 |         1 |\n| JONES  | 3275 |         2 |\n| BLAKE  | 3150 |         2 |\n| CLARK  | 2750 |         2 |\n| ALLEN  | 1900 |         3 |\n| TURNER | 1800 |         3 |\n| SCLARK | 1750 |         3 |\n| MILLER | 1600 |         4 |\n| MARTIN | 1550 |         4 |\n| WARD   | 1550 |         4 |\n| ADAMS  | 1400 |         5 |\n| JAMES  | 1250 |         5 |\n| SMITH  | 1100 |         5 |\n+--------+------+-----------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。查询 emp_msg 表中，根据列 sal 的值将人员分为 5 个级别。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT ename,sal,NTILE(5) OVER (ORDER BY sal DESC) sal_ntile FROM emp_msg ORDER BY sal DESC;\n+--------+------+-----------+\n| ENAME  | SAL  | SAL_NTILE |\n+--------+------+-----------+\n| KING   | 5300 |         1 |\n| FORD   | 3300 |         1 |\n| SCOTT  | 3300 |         1 |\n| JONES  | 3275 |         2 |\n| BLAKE  | 3150 |         2 |\n| CLARK  | 2750 |         2 |\n| ALLEN  | 1900 |         3 |\n| TURNER | 1800 |         3 |\n| SCLARK | 1750 |         3 |\n| MILLER | 1600 |         4 |\n| MARTIN | 1550 |         4 |\n| WARD   | 1550 |         4 |\n| ADAMS  | 1400 |         5 |\n| JAMES  | 1250 |         5 |\n| SMITH  | 1100 |         5 |\n+--------+------+-----------+\n15 rows in set\n"
        ]
    },
    "NULLIF": {
        "Title": [
            "NULLIF"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823255"
        ],
        "Category": [
            "NULL-Related Functions"
        ],
        "Feature": "NULLIF(expr1, expr2)\n",
        "Description": [
            "该函数用于比较两个参数表达式是否相等。如果 expr1 与 expr2 相等，则返回 NULL。如果 expr1 与 expr2 不相等，则返回 expr1。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个参数，可以是任意数据类型的表达式。\n\n\nexpr2\n指定第二个参数，如果 expr1 不是数值数据类型，则 expr2 的数据类型必须与 expr1 相同，否则数据库将返回错误。\n\n\n",
            "如果参数 expr1 和 expr2 都是数值数据类型，则数据库确定具有较高优先级的参数，将另一个参数隐式转换为该数据类型，并返回该数据类型。",
            "如果 expr1 与 expr2 的相等或者 expr1 是空值，则返回 NULL。",
            "如果 expr1 与 expr2 的不相等，则返回与 expr1 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT NULLIF(3+4,6+1) FROM DUAL;\n+-----------------+\n| NULLIF(3+4,6+1) |\n+-----------------+\n|            NULL |\n+-----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "比较 3+4 和 6+1 是否相等。",
            "obclient> SELECT NULLIF(3+4,6+1) FROM DUAL;\n+-----------------+\n| NULLIF(3+4,6+1) |\n+-----------------+\n|            NULL |\n+-----------------+\n1 row in set\n"
        ]
    },
    "NUMTODSINTERVAL": {
        "Title": [
            "NUMTODSINTERVAL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823125"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "NUMTODSINTERVAL (n,interval_unit)\n",
        "Description": [
            "该函数是把参数 n 转为以参数 interval_unit 为单位的 INTERVAL DAY TO SECOND 数据类型的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nn\nNUMBER 数据类型或可以转换为 NUMBER 数据类型的表达式。\n\n\ninterval_unit\n单位值。取值为 DAY（天）、HOUR（小时）、MINUTE（分钟）、SECOND（秒），不区分大小写。\n\n\n",
            "返回 INTERVAL DAY TO SECOND 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE,SYSDATE+NUMTODSINTERVAL(3,'DAY') AS \"DAY\" FROM DUAL;\n+-----------+-----------+\n| SYSDATE   | DAY       |\n+-----------+-----------+\n| 18-NOV-21 | 21-NOV-21 |\n+-----------+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回当前日期 3 天后的日期。",
            "obclient> SELECT SYSDATE,SYSDATE+NUMTODSINTERVAL(3,'DAY') AS \"DAY\" FROM DUAL;\n+-----------+-----------+\n| SYSDATE   | DAY       |\n+-----------+-----------+\n| 18-NOV-21 | 21-NOV-21 |\n+-----------+-----------+\n1 row in set\n"
        ]
    },
    "NUMTOYMINTERVAL": {
        "Title": [
            "NUMTOYMINTERVAL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823140"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "NUMTOYMINTERVAL (n,interval_unit)\n",
        "Description": [
            "该函数是把参数 n 转为以 interval_unit 为单位的 INTERVAL YEAR TO MONTH 数据类型的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nn\nNUMBER 数据类型或可以转换为 NUMBER 数据类型的表达式。\n\n\ninterval_unit\n单位值。取值为 YEAR（年）或 MONTH（月），不区分大小写。\n\n\n",
            "返回 INTERVAL YEAR TO MONTH 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE,SYSDATE+NUMTOYMINTERVAL(3,'YEAR') AS RES FROM DUAL;\n+-----------+-----------+\n| SYSDATE   | RES       |\n+-----------+-----------+\n| 18-NOV-21 | 18-NOV-24 |\n+-----------+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回当前日期 3 年后的日期时间值。",
            "obclient> SELECT SYSDATE,SYSDATE+NUMTOYMINTERVAL(3,'YEAR') AS RES FROM DUAL;\n+-----------+-----------+\n| SYSDATE   | RES       |\n+-----------+-----------+\n| 18-NOV-21 | 18-NOV-24 |\n+-----------+-----------+\n1 row in set\n"
        ]
    },
    "NVL": {
        "Title": [
            "NVL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823256"
        ],
        "Category": [
            "NULL-Related Functions"
        ],
        "Feature": "NVL(expr1, expr2)\n",
        "Description": [
            "该函数从两个表达式返回一个非空值。如果 expr1 与 expr2 的结果都为空值，则 NVL 函数返回 NULL。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个参数，数据类型可以是数据库内建数据类型中的任何数据类型。\n\n\nexpr2\n指定第二个参数，数据类型可以是数据库内建数据类型中的任何数据类型。\n\n\n",
            "\n说明\nexpr1 和 expr2 必须是相同类型，或者可以隐式转换为相同类型。如果它们不能隐式转换，则数据库返回错误。隐式转换规则如下：\n\n如果 expr1 是 CHAR、NCHAR、NVARCHAR、VARCHAR2 或 VARCHAR 字符型数据，则数据库在比较 expr1 之前将 expr2 转换为 expr1 的数据类型，并返回 expr1 字符集的 VARCHAR2。\n如果 expr1 是 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE 数值型数据，则数据库确定哪个参数具有最高的数字优先级，隐式地将另一个参数转换为该数据类型，并返回该数据类型。\n\n",
            "如果 expr1、expr2 是 NULL，则返回 NULL。",
            "如果 expr1 属于字符数据类型 CHAR、NCHAR、NVARCHAR、VARCHAR2 或 VARCHAR，则返回 expr1 字符集的 VARCHAR2。",
            "如果 expr1 属于数值数据类型 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE，则返回 expr1 中具有最高优先级的数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,30),(2,null),(3,50),(4,80),(5,10);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT col1,NVL(col2,100) FROM tbl1;\n+------+---------------+\n| COL1 | NVL(COL2,100) |\n+------+---------------+\n|    1 |            30 |\n|    2 |           100 |\n|    3 |            50 |\n|    4 |            80 |\n|    5 |            10 |\n+------+---------------+\n5 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，插入五条数据。并将列 col2 中为空的值用 100 代替。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,30),(2,null),(3,50),(4,80),(5,10);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT col1,NVL(col2,100) FROM tbl1;\n+------+---------------+\n| COL1 | NVL(COL2,100) |\n+------+---------------+\n|    1 |            30 |\n|    2 |           100 |\n|    3 |            50 |\n|    4 |            80 |\n|    5 |            10 |\n+------+---------------+\n5 rows in set\n"
        ]
    },
    "NVL2": {
        "Title": [
            "NVL2"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823254"
        ],
        "Category": [
            "NULL-Related Functions"
        ],
        "Feature": "NVL2(expr1, expr2, expr3)\n",
        "Description": [
            "该函数根据输入表达式 expr1 是否为空，返回不同的值。",
            "如果 expr1 不为空，则返回 expr2 的值。",
            "如果 expr1 为空，则返回 expr3 的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定第一个参数，数据类型可以是数据库内建数据类型中的任何数据类型。\n\n\nexpr2\n指定第二个参数，数据类型可以是数据库内建数据类型中的任何数据类型。\n\n\nexpr3\n指定第三个参数，数据类型可以是数据库内建数据类型中的任何数据类型。\n\n\n",
            "当 expr1 是空值时，如果 expr3 是空值，则返回 NULL。如果 expr3 不是空值，则返回类型请参见下面的 说明。",
            "当 expr1 不为空值时，如果 expr2 是空值，则返回 NULL。如果 expr2 不是空值，则返回类型请参见下面的 说明。",
            "\n说明\n如果 expr2 和 expr3 的数据类型不同，则数据库将其中一个隐式转换为另一个。如果它们不能隐式转换，则数据库返回错误。如果 expr2 是字符类型或数值类型，则隐式转换规则如下：\n\n如果 expr2 是 CHAR、NCHAR、NVARCHAR、VARCHAR2 或 VARCHAR 字符型数据，则 OceanBase 数据库先将 expr3 转换为 expr2 的数据类型再返回值；如果 expr3 是 NULL，则不需要数据类型转换，结果返回 VARCHAR2 类型。\n如果 expr2 是 NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBL 数值类型，则 OceanBase 数据库确定哪个参数具有最高的数值优先级，隐式地将另一个参数转换为该数据类型，并返回该数据类型。\n\n",
            "如果 ",
            "expr2",
            " 是 ",
            "CHAR",
            "、",
            "NCHAR",
            "、",
            "NVARCHAR",
            "、",
            "VARCHAR2",
            " 或 ",
            "VARCHAR",
            " 字符型数据，则 OceanBase 数据库先将 ",
            "expr3",
            " 转换为 ",
            "expr2",
            " 的数据类型再返回值；如果 ",
            "expr3",
            " 是 ",
            "NULL",
            "，则不需要数据类型转换，结果返回 ",
            "VARCHAR2",
            " 类型。",
            "如果 ",
            "expr2",
            " 是 ",
            "NUMBER",
            "、",
            "FLOAT",
            "、",
            "BINARY_FLOAT",
            " 或 ",
            "BINARY_DOUBL",
            " 数值类型，则 OceanBase 数据库确定哪个参数具有最高的数值优先级，隐式地将另一个参数转换为该数据类型，并返回该数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,30),(2,NULL),(3,50),(4,80),(5,10);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT col1,NVL2(col2,50,100) FROM tbl1;\n+------+-------------------+\n| COL1 | NVL2(COL2,50,100) |\n+------+-------------------+\n|    1 |                50 |\n|    2 |               100 |\n|    3 |                50 |\n|    4 |                50 |\n|    5 |                50 |\n+------+-------------------+\n5 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，插入五条数据。并将列 col2 中为空的值用 100 代替，非空值用 50 代替。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES (1,30),(2,NULL),(3,50),(4,80),(5,10);\nQuery OK, 5 rows affected\nRecords: 5  Duplicates: 0  Warnings: 0\n\nobclient> SELECT col1,NVL2(col2,50,100) FROM tbl1;\n+------+-------------------+\n| COL1 | NVL2(COL2,50,100) |\n+------+-------------------+\n|    1 |                50 |\n|    2 |               100 |\n|    3 |                50 |\n|    4 |                50 |\n|    5 |                50 |\n+------+-------------------+\n5 rows in set\n"
        ]
    },
    "OB_TRANSACTION_ID": {
        "Title": [
            "OB_TRANSACTION_ID"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822827"
        ],
        "Category": [
            "Information Functions"
        ],
        "Feature": "OB_TRANSACTION_ID()\n",
        "Description": [],
        "Illustration": [
            "当前会话处于活跃事务中，则返回所处的事务 ID 整数值，大于 0。",
            "当前会话如果未处于活跃事务中，返回 0。"
        ],
        "Examples": [
            "obclient [SYS]> START TRANSACTION;\n",
            "obclient [SYS]> SELECT OB_TRANSACTION_ID() FROM DUAL;\n",
            "+---------------------+\n| OB_TRANSACTION_ID() |\n+---------------------+\n|            11003721 |\n+---------------------+\n1 row in set\n",
            "obclient [SYS]> COMMIT;\n",
            "obclient [SYS]> SELECT OB_TRANSACTION_ID() FROM DUAL;\n",
            "+---------------------+\n| OB_TRANSACTION_ID() |\n+---------------------+\n|                   0 |\n+---------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "开启事务。",
            "obclient [SYS]> START TRANSACTION;\n",
            "查询当前处于活跃事务中的事务 ID。",
            "obclient [SYS]> SELECT OB_TRANSACTION_ID() FROM DUAL;\n",
            "返回结果如下：",
            "+---------------------+\n| OB_TRANSACTION_ID() |\n+---------------------+\n|            11003721 |\n+---------------------+\n1 row in set\n",
            "提交事务。",
            "obclient [SYS]> COMMIT;\n",
            "查询当前未处于活跃事务中的事务 ID。",
            "obclient [SYS]> SELECT OB_TRANSACTION_ID() FROM DUAL;\n",
            "返回结果如下：",
            "+---------------------+\n| OB_TRANSACTION_ID() |\n+---------------------+\n|                   0 |\n+---------------------+\n1 row in set\n"
        ]
    },
    "OB_VERSION": {
        "Title": [
            "OB_VERSION"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823179"
        ],
        "Category": [
            "Environment and Identifier Functions"
        ],
        "Feature": "OB_VERSION()\n",
        "Description": [],
        "Illustration": [
            "返回当前 OceanBase 数据库的版本信息，字符集为 utf8mb4。"
        ],
        "Examples": [
            "obclient> SELECT OB_VERSION() FROM DUAL;\n+--------------+\n| OB_VERSION() |\n+--------------+\n| 4.0.0.0      |\n+--------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "obclient> SELECT OB_VERSION() FROM DUAL;\n+--------------+\n| OB_VERSION() |\n+--------------+\n| 4.0.0.0      |\n+--------------+\n1 row in set\n"
        ]
    },
    "ORA_HASH": {
        "Title": [
            "ORA_HASH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823115"
        ],
        "Category": [
            "Encoding and Decoding Functions"
        ],
        "Feature": "ORA_HASH(expr [, max_bucket [, seed_value ]])\n",
        "Description": [
            "该函数的功能是计算对应表达式的哈希值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n通常为数据库表的列名，数据类型可以是数值类型、字符类型、日期时间类型或 RAW 类型。\n\n\nmax_bucket\n确定哈希函数返回的最大桶值，为可选项。取值范围为 [0, 4294967295]，默认值是 4294967295。\n\n\nseed_value\n使数据库能够为同一组数据生成不同的结果，为可选项。取值范围为 [0, 4294967295]，默认值为 0。\n\n\n",
            "返回一个 NUMBER 类型的数据值。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 CHAR(6),col2 NUMBER(10,2));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES('ABC', 1000),('DEF', 1100),('GHI', 1200),('JKL', 1300),\n    ('MNO', 1400),('PQR', 1500),('STU', 1600),('VWX', 1700),('YZ1', 1800),('234', 1900);\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n\nobclient> SELECT ORA_HASH(col1,10,5),col1,col2 FROM tbl1;\n+---------------------+--------+------+\n| ORA_HASH(COL1,10,5) | COL1   | COL2 |\n+---------------------+--------+------+\n|                   5 | ABC    | 1000 |\n|                   3 | DEF    | 1100 |\n|                   8 | GHI    | 1200 |\n|                   3 | JKL    | 1300 |\n|                   3 | MNO    | 1400 |\n|                   1 | PQR    | 1500 |\n|                   4 | STU    | 1600 |\n|                   2 | VWX    | 1700 |\n|                  10 | YZ1    | 1800 |\n|                   5 | 234    | 1900 |\n+---------------------+--------+------+\n10 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并向里面插入数据。使用 ORA_HASH 函数查询表 tbl1 的 col1 列的哈希值，将哈希值划分为最多 10 个桶，并将第三个参数设置为 5。",
            "obclient> CREATE TABLE tbl1(col1 CHAR(6),col2 NUMBER(10,2));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES('ABC', 1000),('DEF', 1100),('GHI', 1200),('JKL', 1300),\n    ('MNO', 1400),('PQR', 1500),('STU', 1600),('VWX', 1700),('YZ1', 1800),('234', 1900);\nQuery OK, 10 rows affected\nRecords: 10  Duplicates: 0  Warnings: 0\n\nobclient> SELECT ORA_HASH(col1,10,5),col1,col2 FROM tbl1;\n+---------------------+--------+------+\n| ORA_HASH(COL1,10,5) | COL1   | COL2 |\n+---------------------+--------+------+\n|                   5 | ABC    | 1000 |\n|                   3 | DEF    | 1100 |\n|                   8 | GHI    | 1200 |\n|                   3 | JKL    | 1300 |\n|                   3 | MNO    | 1400 |\n|                   1 | PQR    | 1500 |\n|                   4 | STU    | 1600 |\n|                   2 | VWX    | 1700 |\n|                  10 | YZ1    | 1800 |\n|                   5 | 234    | 1900 |\n+---------------------+--------+------+\n10 rows in set\n"
        ]
    },
    "PERCENTILE_CONT": {
        "Title": [
            "PERCENTILE_CONT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822888"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "PERCENTILE_CONT(percentile) WITHIN GROUP (ORDER BY expr [ DESC | ASC ])\n[ OVER (query_partition_clause) ]\n",
        "Description": [
            "该函数是一个假定连续分布模型的逆分布函数。根据指定百分比值和排序规范，返回一个在该排序规范的给定百分比值的内插值。在计算中忽略空值。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\npercentile\n指定百分位的值，是一个数值数据类型的常量，取值范围为 [0,1]。 说明 MEDIAN 函数相当于是 percentile 为 0.5 的特殊情况。\n\n\nexpr\n指定排序规范的表达式，数据类型属于数值类型或日期时间类型。 注意 expr 必须为涉及列引用的单个表达式，不允许使用多个表达式。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\n该函数在根据排序规范对行进行排序后，通过指定百分比值 (P) 和非空行数 (N) 计算行号，行号计算公式为 RN = (1+ (P*(N-1))。该函数的最终结果通过行号 CRN = CEILING(RN) 和 FRN = FLOOR(RN) 的行中的值之间的线性内插计算。最终结果将如下：\n",
            "如果 (CRN = FRN = RN)，则结果为 (value of expression from row at RN)；否则，结果为：",
            "(CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN)。",
            "返回与参数 expr 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "obclient> SELECT PERCENTILE_CONT(0.1) WITHIN GROUP (ORDER BY col4) FROM tbl1;\n+----------------------------------------------+\n| PERCENTILE_CONT(0.1)WITHINGROUP(ORDERBYCOL4) |\n+----------------------------------------------+\n|                                           12 |\n+----------------------------------------------+\n1 row in set\n",
            "obclient> SELECT col1,col4,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY col4) OVER (PARTITION BY col1)\n          FROM tbl1;\n+------+------+-------------------------------------------------------------------+\n| COL1 | COL4 | PERCENTILE_CONT(0.5)WITHINGROUP(ORDERBYCOL4)OVER(PARTITIONBYCOL1) |\n+------+------+-------------------------------------------------------------------+\n|    1 |   12 |                                                                15 |\n|    1 |   15 |                                                                15 |\n|    1 |   16 |                                                                15 |\n|    2 |   14 |                                                              14.5 |\n|    2 |   15 |                                                              14.5 |\n|    2 |   13 |                                                              14.5 |\n|    2 |   16 |                                                              14.5 |\n|    3 |   18 |                                                                15 |\n|    3 |   16 |                                                                15 |\n|    3 |   15 |                                                                15 |\n|    3 |   12 |                                                                15 |\n|    3 |   10 |                                                                15 |\n+------+------+-------------------------------------------------------------------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "计算列 col4 的第 10 个百分点的值。",
            "obclient> SELECT PERCENTILE_CONT(0.1) WITHIN GROUP (ORDER BY col4) FROM tbl1;\n+----------------------------------------------+\n| PERCENTILE_CONT(0.1)WITHINGROUP(ORDERBYCOL4) |\n+----------------------------------------------+\n|                                           12 |\n+----------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col1 分组，计算列 col4 的第 50 个百分点的值（即计算列 col4 的中位数）。",
            "obclient> SELECT col1,col4,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY col4) OVER (PARTITION BY col1)\n          FROM tbl1;\n+------+------+-------------------------------------------------------------------+\n| COL1 | COL4 | PERCENTILE_CONT(0.5)WITHINGROUP(ORDERBYCOL4)OVER(PARTITIONBYCOL1) |\n+------+------+-------------------------------------------------------------------+\n|    1 |   12 |                                                                15 |\n|    1 |   15 |                                                                15 |\n|    1 |   16 |                                                                15 |\n|    2 |   14 |                                                              14.5 |\n|    2 |   15 |                                                              14.5 |\n|    2 |   13 |                                                              14.5 |\n|    2 |   16 |                                                              14.5 |\n|    3 |   18 |                                                                15 |\n|    3 |   16 |                                                                15 |\n|    3 |   15 |                                                                15 |\n|    3 |   12 |                                                                15 |\n|    3 |   10 |                                                                15 |\n+------+------+-------------------------------------------------------------------+\n12 rows in set\n"
        ]
    },
    "PERCENTILE_DISC": {
        "Title": [
            "PERCENTILE_DISC"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822890"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "PERCENTILE_DISC(expr1) WITHIN GROUP (ORDER BY expr2 [ DESC | ASC ])\n[ OVER (query_partition_clause) ]\n",
        "Description": [
            "该函数根据一个百分位值和指定排序规范，返回大于或等于百分位值的最小累积分布值（相对于同一排序规范）的值。在计算中忽略空值。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr1\n指定百分位的值，是一个数值数据类型的常量，取值范围为 [0,1]。\n\n\nexpr2\n指定用于排序和计算百分比的表达式，数据类型属于数值类型或日期时间类型。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回与参数 expr2 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "obclient> SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) \"PERCENTILE_DISC\" FROM tbl1;\n+-----------------+\n| PERCENTILE_DISC |\n+-----------------+\n|              15 |\n+-----------------+\n1 row in set\n",
            "obclient> SELECT col1,col4,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) OVER(PARTITION BY col1) \"PERCENTILE_DISC\"\n          FROM tbl1;\n+------+------+-----------------+\n| COL1 | COL4 | PERCENTILE_DISC |\n+------+------+-----------------+\n|    1 |   12 |              15 |\n|    1 |   15 |              15 |\n|    1 |   16 |              15 |\n|    2 |   14 |              14 |\n|    2 |   15 |              14 |\n|    2 |   13 |              14 |\n|    2 |   16 |              14 |\n|    3 |   18 |              15 |\n|    3 |   16 |              15 |\n|    3 |   15 |              15 |\n|    3 |   12 |              15 |\n|    3 |   10 |              15 |\n+------+------+-----------------+\n12 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n+------+------+------+------+\n12 rows in set\n",
            "聚合函数示例",
            "计算列 col4 的离散百分比中位数。",
            "obclient> SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) \"PERCENTILE_DISC\" FROM tbl1;\n+-----------------+\n| PERCENTILE_DISC |\n+-----------------+\n|              15 |\n+-----------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col1 分组，计算列 col4 的离散百分比中位数。",
            "obclient> SELECT col1,col4,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY col4) OVER(PARTITION BY col1) \"PERCENTILE_DISC\"\n          FROM tbl1;\n+------+------+-----------------+\n| COL1 | COL4 | PERCENTILE_DISC |\n+------+------+-----------------+\n|    1 |   12 |              15 |\n|    1 |   15 |              15 |\n|    1 |   16 |              15 |\n|    2 |   14 |              14 |\n|    2 |   15 |              14 |\n|    2 |   13 |              14 |\n|    2 |   16 |              14 |\n|    3 |   18 |              15 |\n|    3 |   16 |              15 |\n|    3 |   15 |              15 |\n|    3 |   12 |              15 |\n|    3 |   10 |              15 |\n+------+------+-----------------+\n12 rows in set\n"
        ]
    },
    "PERCENT_RANK": {
        "Title": [
            "PERCENT_RANK"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822882"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "/*聚合语法*/\nPERCENT_RANK(expr [, expr ...]) WITHIN GROUP\n               ( ORDER BY expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n                          [,expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n               )\n\n/*分析语法*/\nPERCENT_RANK( ) OVER ([query_partition_clause] order_by_clause)\n",
        "Description": [
            "该函数用来计算一组值中的某个值的累积分布。类似于 CUME_DIST 函数。可以将此函数用作聚合或分析函数。",
            "\n说明\n\n作为聚合函数，PERCENT_RANK 计算某一个数在一个集合中的对应位置百分比，它的返回值范围为 (0, 1]。如果有 N 行数据，expr 的值，大于第二行的值而小于第三行的值，那么位置百分比等于 2/N。常量参数表达式和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的类型必须兼容。如果指定值与分组序列中某值重复，则将两个相同的值视为一个值处理。\n作为分析函数，PERCENT_RANK 计算某列或某列组合后每行的百分比排序，它的返回值范围为 [0, 1]。当有相同排序值时，将会有相同的排名，并且值相同的行数会被记录到下个排名中。任何集合中的第一行的 PERCENT_RANK 函数为 0，位置百分比的计算公式为：位置百分比=序号/最大序号，具体示例请参见如下表格：\n\n",
            "\n\n\nN\n序号\n位置百分比\n\n\n\n\nA\n0\n0\n\n\nB\n1\n0.25\n\n\nC\n2\n0.5\n\n\nD\n3\n0.75\n\n\nE\n4\n1\n\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "obclient> SELECT PERCENT_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-------------------------------------------+\n| PERCENT_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-------------------------------------------+\n|                                        .8 |\n+-------------------------------------------+\n1 row in set\n",
            "obclient> SELECT deptno,ename,sal,\n              PERCENT_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) AS pr1\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | PR1                                       |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 |                                         0 |\n|     10 | CLARK  | 2750 |                                        .5 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                         0 |\n|     20 | SCOTT  | 3300 |                                         0 |\n|     20 | JONES  | 3275 |                                        .5 |\n|     20 | ADAMS  | 1400 |                                       .75 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 |                                         0 |\n|     30 | ALLEN  | 1900 | .1666666666666666666666666666666666666667 |\n|     30 | TURNER | 1800 | .3333333333333333333333333333333333333333 |\n|     30 | SCLARK | 1750 |                                        .5 |\n|     30 | MARTIN | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | WARD   | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "返回 3300 在列 sal 中的位置百分比。",
            "obclient> SELECT PERCENT_RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-------------------------------------------+\n| PERCENT_RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-------------------------------------------+\n|                                        .8 |\n+-------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 deptno 分组和列 sal 降序排序并返回列 sal 中各值的位置百分比。",
            "obclient> SELECT deptno,ename,sal,\n              PERCENT_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) AS pr1\n          FROM emp_msg;\n+--------+--------+------+-------------------------------------------+\n| DEPTNO | ENAME  | SAL  | PR1                                       |\n+--------+--------+------+-------------------------------------------+\n|     10 | KING   | 5300 |                                         0 |\n|     10 | CLARK  | 2750 |                                        .5 |\n|     10 | MILLER | 1600 |                                         1 |\n|     20 | FORD   | 3300 |                                         0 |\n|     20 | SCOTT  | 3300 |                                         0 |\n|     20 | JONES  | 3275 |                                        .5 |\n|     20 | ADAMS  | 1400 |                                       .75 |\n|     20 | SMITH  | 1100 |                                         1 |\n|     30 | BLAKE  | 3150 |                                         0 |\n|     30 | ALLEN  | 1900 | .1666666666666666666666666666666666666667 |\n|     30 | TURNER | 1800 | .3333333333333333333333333333333333333333 |\n|     30 | SCLARK | 1750 |                                        .5 |\n|     30 | MARTIN | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | WARD   | 1550 | .6666666666666666666666666666666666666667 |\n|     30 | JAMES  | 1250 |                                         1 |\n+--------+--------+------+-------------------------------------------+\n15 rows in set\n"
        ]
    },
    "POWER": {
        "Title": [
            "POWER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823145"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "POWER (x, y)\n",
        "Description": [
            "该函数作用是返回指定数字的乘幂。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nx\n表示底数，属于数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。\n\n\ny\n表示指数，属于数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。如果 x 是负数，则 y 必须是整数。\n\n\n",
            "当参数为 BINARY_FLOAT 和 BINARY_DOUBLE 数据类型时，返回类型为 BINARY_DOUBLE，其他情况下返回类型为 NUMBER。"
        ],
        "Examples": [
            "obclient> SELECT POWER(3,2),POWER(-3,3),POWER(4,-2) FROM DUAL;\n+------------+-------------+-------------+\n| POWER(3,2) | POWER(-3,3) | POWER(4,-2) |\n+------------+-------------+-------------+\n|          9 |         -27 |       .0625 |\n+------------+-------------+-------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 3 的平方、-3 的立方和 4 的 -2 次幂。",
            "obclient> SELECT POWER(3,2),POWER(-3,3),POWER(4,-2) FROM DUAL;\n+------------+-------------+-------------+\n| POWER(3,2) | POWER(-3,3) | POWER(4,-2) |\n+------------+-------------+-------------+\n|          9 |         -27 |       .0625 |\n+------------+-------------+-------------+\n1 row in set\n"
        ]
    },
    "RANDOM": {
        "Title": [
            "RANDOM"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823169"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "RANDOM(seed)\n",
        "Description": [],
        "Illustration": [
            "该函数生成一个 64 位的整数伪随机值。",
            "seed",
            " 为整数类型，不同 ",
            "seed",
            " 可以生成不同的随机数值序列。",
            "RANDOM()",
            " 使用了 MT19937 伪随机数生成算法，其随机空间非常大，生成 2",
            "19937",
            " - 1 个随机元素后才会重复生成相同序列。"
        ],
        "Examples": [
            "obclient> SELECT RANDOM(4) FROM TABLE(GENERATOR(3));\n+---------------------+\n| RANDOM(4)           |\n+---------------------+\n| 5267436225003336391 |\n| -851690886662571060 |\n| 1738617244330437274 |\n+---------------------+\n3 rows in set\n",
            "obclient> SELECT UNIFORM(1, 100, RANDOM()) FROM TABLE(GENERATOR(4));\n+-------------------------+\n| UNIFORM(1,100,RANDOM()) |\n+-------------------------+\n|       73.61272325544115 |\n|       40.25665028115364 |\n|       66.83183914022183 |\n|       70.22767627040167 |\n+-------------------------+\n4 rows in set\n",
            "obclient> SELECT * FROM t1;\n+------+\n| c1   |\n+------+\n|    3 |\n|    4 |\n|    5 |\n|    1 |\n|    1 |\n+------+\n5 rows in set\n\nobclient> SELECT t1.c1, RANDOM(t1.c1) FROM TABLE(GENERATOR(1)), t1;\n+------+----------------------+\n| c1   | RANDOM(t1.c1)        |\n+------+----------------------+\n|    3 | 1084041170817055659  |\n|    4 | 5267436225003336391  |\n|    5 | 192483991702052534   |\n|    1 | -6753783847308464280 |\n|    1 | -6753783847308464280 |\n+------+----------------------+\n5 rows in set\n"
        ],
        "Detailed Examples": [
            "如下示例为使用 RANDOM() 生成随机数。",
            "obclient> SELECT RANDOM(4) FROM TABLE(GENERATOR(3));\n+---------------------+\n| RANDOM(4)           |\n+---------------------+\n| 5267436225003336391 |\n| -851690886662571060 |\n| 1738617244330437274 |\n+---------------------+\n3 rows in set\n",
            "如下示例为将 RANDOM() 的结果作为分布函数的随机输入。",
            "obclient> SELECT UNIFORM(1, 100, RANDOM()) FROM TABLE(GENERATOR(4));\n+-------------------------+\n| UNIFORM(1,100,RANDOM()) |\n+-------------------------+\n|       73.61272325544115 |\n|       40.25665028115364 |\n|       66.83183914022183 |\n|       70.22767627040167 |\n+-------------------------+\n4 rows in set\n",
            "如下示例为特殊场景，当 RANDOM() 参数输入为变量时，每次都会重新计算 seed。",
            "obclient> SELECT * FROM t1;\n+------+\n| c1   |\n+------+\n|    3 |\n|    4 |\n|    5 |\n|    1 |\n|    1 |\n+------+\n5 rows in set\n\nobclient> SELECT t1.c1, RANDOM(t1.c1) FROM TABLE(GENERATOR(1)), t1;\n+------+----------------------+\n| c1   | RANDOM(t1.c1)        |\n+------+----------------------+\n|    3 | 1084041170817055659  |\n|    4 | 5267436225003336391  |\n|    5 | 192483991702052534   |\n|    1 | -6753783847308464280 |\n|    1 | -6753783847308464280 |\n+------+----------------------+\n5 rows in set\n"
        ]
    },
    "RANDSTR": {
        "Title": [
            "RANDSTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823153"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "RANDSTR(N, gen)\n",
        "Description": [],
        "Illustration": [
            "该函数按照指定长度生成一个随机字符串，字符串中的字符包含 A-Z、a-z 和 0-9。",
            "N 为生成的随机字符串长度：",
            "\n当 N < 0 时，返回 NULL。\n当 N = 0 时，返回空字符串。\n当 N > 0 并且 N <= max_allowed_packet 时，返回长度为 N 的随机字符串。\n当 N > max_allowed_packet 时，返回 NULL。其中 max_allowed_packet 为系统变量，默认值为 16777216。\n",
            "当 ",
            "N < 0",
            " 时，返回 ",
            "NULL",
            "。",
            "当 ",
            "N = 0",
            " 时，返回空字符串。",
            "当 ",
            "N > 0",
            " 并且 ",
            "N <= max_allowed_packet",
            " 时，返回长度为 N 的随机字符串。",
            "当 ",
            "N > max_allowed_packet",
            " 时，返回 ",
            "NULL",
            "。其中 ",
            "max_allowed_packet",
            " 为系统变量，默认值为 16777216。",
            "gen 为分布函数，可取值如下：",
            "\n常量，则每次调用 RANDSTR() 都会生成相同的随机串。\n返回整数值的随机函数，例如 RANDOM()。\n分布函数，例如均匀分布、zipf 分布、高斯分布等。\n",
            "常量，则每次调用 ",
            "RANDSTR()",
            " 都会生成相同的随机串。",
            "返回整数值的随机函数，例如 ",
            "RANDOM()",
            "。",
            "分布函数，例如均匀分布、zipf 分布、高斯分布等。",
            "随机串的生成算法：采用 LCG 算法生成 N 个随机值，据此选出 N 个字符组成随机串。所以当 N 很大时会消耗较多 CPU。例如下面生成了一个长度为 300 M 的随机串，耗时 1.7 秒。",
            "obclient> SELECT LENGTH(RANDSTR(300000000, 1)) FROM DUAL;;\n+------------------------------+\n| LENGTH(RANDSTR(300000000,1)) |\n+------------------------------+\n|                    300000000 |\n+------------------------------+\n1 row in set (1.73 sec)\n"
        ],
        "Examples": [
            "obclient> SELECT RANDSTR(10, RANDOM()) FROM TABLE(GENERATOR(7));\n+-----------------------+\n| randstr(10, random()) |\n+-----------------------+\n| TGfdBAZ1BP            |\n| VvMbD2bChR            |\n| VNSB6MpgQw            |\n| 3QWYQYQVJ4            |\n| CpyE58jM0o            |\n| vBvsJBGGmX            |\n| rg3Pkde0UJ            |\n+-----------------------+\n7 rows in set\n",
            "obclient> SELECT RANDSTR(5, 40) FROM DUAL;\n+----------------+\n| RANDSTR(5, 40) |\n+----------------+\n| UU3g0          |\n+----------------+\n1 row in set\n\nobclient> SELECT RANDSTR(1, 40) FROM DUAL;\n+----------------+\n| RANDSTR(1, 40) |\n+----------------+\n| U              |\n+----------------+\n1 row in set\n\nobclient> SELECT RANDSTR(0, 40) FROM DUAL;\n+----------------+\n| RANDSTR(0, 40) |\n+----------------+\n|                |\n+----------------+\n1 row in set\n\nobclient> SELECT RANDSTR(-1, 40) FROM DUAL;\n+-----------------+\n| RANDSTR(-1, 40) |\n+-----------------+\n| NULL            |\n+-----------------+\n1 row in set\n",
            "obclient> SELECT RANDSTR(10, 1442) FROM TABLE(GENERATOR(7));\n+-------------------+\n| RANDSTR(10, 1442) |\n+-------------------+\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n+-------------------+\n7 rows in set\n\nobclient> SELECT RANDSTR(10, 1442) FROM TABLE(GENERATOR(7));\n+-------------------+\n| RANDSTR(10, 1442) |\n+-------------------+\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n+-------------------+\n7 rows in set\n"
        ],
        "Detailed Examples": [
            "如下示例为通过 RANDSTR() 函数生成长度为 10 的随机字符串。",
            "obclient> SELECT RANDSTR(10, RANDOM()) FROM TABLE(GENERATOR(7));\n+-----------------------+\n| randstr(10, random()) |\n+-----------------------+\n| TGfdBAZ1BP            |\n| VvMbD2bChR            |\n| VNSB6MpgQw            |\n| 3QWYQYQVJ4            |\n| CpyE58jM0o            |\n| vBvsJBGGmX            |\n| rg3Pkde0UJ            |\n+-----------------------+\n7 rows in set\n",
            "RANDSTR() 函数通过控制 N 参数的大小，可以生成长度不同的字符串，如下例所示。",
            "obclient> SELECT RANDSTR(5, 40) FROM DUAL;\n+----------------+\n| RANDSTR(5, 40) |\n+----------------+\n| UU3g0          |\n+----------------+\n1 row in set\n\nobclient> SELECT RANDSTR(1, 40) FROM DUAL;\n+----------------+\n| RANDSTR(1, 40) |\n+----------------+\n| U              |\n+----------------+\n1 row in set\n\nobclient> SELECT RANDSTR(0, 40) FROM DUAL;\n+----------------+\n| RANDSTR(0, 40) |\n+----------------+\n|                |\n+----------------+\n1 row in set\n\nobclient> SELECT RANDSTR(-1, 40) FROM DUAL;\n+-----------------+\n| RANDSTR(-1, 40) |\n+-----------------+\n| NULL            |\n+-----------------+\n1 row in set\n",
            "当 gen 为常量时，反复执行 RANDSTR() 函数，会生成相同的随机字符串，如下例所示。",
            "obclient> SELECT RANDSTR(10, 1442) FROM TABLE(GENERATOR(7));\n+-------------------+\n| RANDSTR(10, 1442) |\n+-------------------+\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n+-------------------+\n7 rows in set\n\nobclient> SELECT RANDSTR(10, 1442) FROM TABLE(GENERATOR(7));\n+-------------------+\n| RANDSTR(10, 1442) |\n+-------------------+\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n| 4dTm5bOtGc        |\n+-------------------+\n7 rows in set\n"
        ]
    },
    "RANK": {
        "Title": [
            "RANK"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822872"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "/*聚合语法*/\nRANK(expr [, expr ]...) WITHIN GROUP\n  ( ORDER BY\n            expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]\n            [, expr_col [ DESC | ASC ][ NULLS { FIRST | LAST } ]]...\n  )\n\n/*分析语法*/\nRANK() OVER ([ query_partition_clause ] order_by_clause)\n",
        "Description": [
            "该函数用于计算一个值在一组值的排名。当有相同排序值时，将会有相同的排名，并且值相同的行数会被记录到下个排名中。可以将此函数用作聚合或分析函数。",
            "\n说明\n\n作为聚合函数，RANK 计算由参数 expr 标识的假设行相对于指定排序规范的排名。参数表达式 expr 和 ORDER BY 聚合子句中的表达式按位置匹配。因此，参数的数量必须相同，并且它们的数据类型必须兼容。\n作为一个解析函数，RANK 计算从查询相对于由查询返回的其他行返回的每一行的秩，基于所述值 value_exprs 中 order_by_clause。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定要查询的值。\n\n\nexpr_col\n指定要查询的值对应的列名。\n\n\nDESC | ASC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，默认值。\nDESC 为降序排序。\n\n\n\nNULLS { FIRST | LAST }\n排序后 expr_col 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST 表示 NULL 值排在非空值的前面。\nNULLS LAST 表示 NULL 值排在非空值的后面，为默认值。\n\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "obclient> SELECT RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------+\n| RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------+\n|                                13 |\n+-----------------------------------+\n1 row in set\n",
            "obclient> SELECT deptno,ename,sal,\n                   RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    3 |\n|     20 | ADAMS  | 1400 |    4 |\n|     20 | SMITH  | 1100 |    5 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    7 |\n+--------+--------+------+------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "返回 3300 在列 sal 中的排名。",
            "obclient> SELECT RANK(3300) WITHIN GROUP (ORDER BY sal) FROM emp_msg;\n+-----------------------------------+\n| RANK(3300)WITHINGROUP(ORDERBYSAL) |\n+-----------------------------------+\n|                                13 |\n+-----------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 deptno 分组及列 sal 降序排序并返回列 sal 中各值的排名。",
            "obclient> SELECT deptno,ename,sal,\n                   RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) \"RANK\"\n          FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | RANK |\n+--------+--------+------+------+\n|     10 | KING   | 5300 |    1 |\n|     10 | CLARK  | 2750 |    2 |\n|     10 | MILLER | 1600 |    3 |\n|     20 | FORD   | 3300 |    1 |\n|     20 | SCOTT  | 3300 |    1 |\n|     20 | JONES  | 3275 |    3 |\n|     20 | ADAMS  | 1400 |    4 |\n|     20 | SMITH  | 1100 |    5 |\n|     30 | BLAKE  | 3150 |    1 |\n|     30 | ALLEN  | 1900 |    2 |\n|     30 | TURNER | 1800 |    3 |\n|     30 | SCLARK | 1750 |    4 |\n|     30 | MARTIN | 1550 |    5 |\n|     30 | WARD   | 1550 |    5 |\n|     30 | JAMES  | 1250 |    7 |\n+--------+--------+------+------+\n15 rows in set\n"
        ]
    },
    "RATIO_TO_REPORT": {
        "Title": [
            "RATIO_TO_REPORT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822845"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "RATIO_TO_REPORT(expr) OVER ([query_partition_clause])\n",
        "Description": [
            "该函数是一个分析函数，功能是计算一个值与一组值之和的比率。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定需要查询的字段。 注意 不能使用 RATIO_TO_REPORT 函数或其他分析函数来嵌套 expr。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "如果 expr 为 NULL，则返回结果为 NULL。否则返回结果为数值类型数据。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,mgr,RATIO_TO_REPORT(mgr) OVER (PARTITION BY deptno)\n      FROM emp_msg;\n+--------+--------+------+---------------------------------------------+\n| DEPTNO | ENAME  | MGR  | RATIO_TO_REPORT(MGR)OVER(PARTITIONBYDEPTNO) |\n+--------+--------+------+---------------------------------------------+\n|     10 | CLARK  | 7839 |   .5018244670635682734780103706548876512387 |\n|     10 | KING   | NULL |                                        NULL |\n|     10 | MILLER | 7782 |   .4981755329364317265219896293451123487613 |\n|     20 | ADAMS  | 7788 |   .2014433149685729805230076821603165981221 |\n|     20 | FORD   | 7566 |   .1957010941258632730658803445332505625824 |\n|     20 | JONES  | 7839 |   .2027624738108171025064018002638317684488 |\n|     20 | SCOTT  | 7566 |   .1957010941258632730658803445332505625824 |\n|     20 | SMITH  | 7902 |   .2043920229688833708388298285093505082641 |\n|     30 | ALLEN  | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | BLAKE  | 7839 |   .1447164377492246344705361098803721754541 |\n|     30 | JAMES  | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | MARTIN | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | TURNER | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | WARD   | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | SCLARK | 7839 |   .1447164377492246344705361098803721754541 |\n+--------+--------+------+---------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。查询 emp_msg 表中，按 deptno 字段分组，求列 mgr 中各值占 mgr 总计的比例。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,mgr,RATIO_TO_REPORT(mgr) OVER (PARTITION BY deptno)\n      FROM emp_msg;\n+--------+--------+------+---------------------------------------------+\n| DEPTNO | ENAME  | MGR  | RATIO_TO_REPORT(MGR)OVER(PARTITIONBYDEPTNO) |\n+--------+--------+------+---------------------------------------------+\n|     10 | CLARK  | 7839 |   .5018244670635682734780103706548876512387 |\n|     10 | KING   | NULL |                                        NULL |\n|     10 | MILLER | 7782 |   .4981755329364317265219896293451123487613 |\n|     20 | ADAMS  | 7788 |   .2014433149685729805230076821603165981221 |\n|     20 | FORD   | 7566 |   .1957010941258632730658803445332505625824 |\n|     20 | JONES  | 7839 |   .2027624738108171025064018002638317684488 |\n|     20 | SCOTT  | 7566 |   .1957010941258632730658803445332505625824 |\n|     20 | SMITH  | 7902 |   .2043920229688833708388298285093505082641 |\n|     30 | ALLEN  | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | BLAKE  | 7839 |   .1447164377492246344705361098803721754541 |\n|     30 | JAMES  | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | MARTIN | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | TURNER | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | WARD   | 7698 |   .1421134249003101462117855560478511298183 |\n|     30 | SCLARK | 7839 |   .1447164377492246344705361098803721754541 |\n+--------+--------+------+---------------------------------------------+\n15 rows in set\n"
        ]
    },
    "RAWTOHEX": {
        "Title": [
            "RAWTOHEX"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823244"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "RAWTOHEX (raw)\n",
        "Description": [
            "该函数将一个二进制格式的字符串转换为一个相应的十六进制表示的字符串。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nraw\n二进制的字符串。\n\n\n",
            "十六进制表示的字符串。"
        ],
        "Examples": [
            "obclient> SELECT RAWTOHEX('AB')  FROM DUAL;\n+----------------+\n| RAWTOHEX('AB') |\n+----------------+\n| 4142           |\n+----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将二进制 AB 转化为对应的十六进制字符串。",
            "obclient> SELECT RAWTOHEX('AB')  FROM DUAL;\n+----------------+\n| RAWTOHEX('AB') |\n+----------------+\n| 4142           |\n+----------------+\n1 row in set\n"
        ]
    },
    "REGEXP_COUNT": {
        "Title": [
            "REGEXP_COUNT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823208"
        ],
        "Category": [
            "Character Functions Returning NumberValues"
        ],
        "Feature": "REGEXP_COUNT (source_char, pattern [, position [, match_param]])\n",
        "Description": [
            "该函数返回正则匹配的值在源字符串中出现的次数。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nsource_char\n指定用作搜索值的字符表达式，数据类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\npattern\n指定正则表达式截取规则。它通常是一个文本文字，字符类型可为 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。 如果子表达式中有括号，会被忽略。例如，12(34)5 等效 12345。\n\n\nposition\n指定开始正则表达式匹配的起始位置，取值是一个正整数，为可选项。默认值是 1，表示从第一个字符开始搜索 source_char。\n\n\nmatch_param\n指定更改正则表达式默认匹配方式，为可选项。该参数是数据类型 VARCHAR2 或 CHAR 的字符表达式。 \n      \ni 表示大小写不敏感。\nc 表示大小写敏感。\nn 表示句点 . 可以匹配换行符。\nm 表示多行模式。\nx 表示忽略空格字符，默认情况下，空格字符会相互匹配。\n\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT REGEXP_COUNT('abc,def,ghi',',',1,'i') FROM DUAL;\n+---------------------------------------+\n| REGEXP_COUNT('ABC,DEF,GHI',',',1,'I') |\n+---------------------------------------+\n|                                     2 |\n+---------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "从第一个字符开始搜索并返回 abc,def,ghi 中逗号的个数。",
            "obclient> SELECT REGEXP_COUNT('abc,def,ghi',',',1,'i') FROM DUAL;\n+---------------------------------------+\n| REGEXP_COUNT('ABC,DEF,GHI',',',1,'I') |\n+---------------------------------------+\n|                                     2 |\n+---------------------------------------+\n1 row in set\n"
        ]
    },
    "REGEXP_INSTR": {
        "Title": [
            "REGEXP_INSTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823206"
        ],
        "Category": [
            "Character Functions Returning NumberValues"
        ],
        "Feature": "REGEXP_INSTR (source_char, pattern\n                [, position[, occurrence[, return_opt[, match_param[, subexpr] ] ] ] ]\n             )\n",
        "Description": [
            "该函数作用是返回正则表达式匹配值在源字符串中的位置。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nsource_char\n指定用作搜索值的字符表达式，数据类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\npattern\n指定正则表达式截取规则。它通常是一个文本文字，字符类型可为 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。\n\n\nposition\n指定开始正则表达式匹配的起始位置，取值是一个正整数，为可选项。默认值是 1，表示从第一个字符开始搜索 source_char。\n\n\noccurrence\n指定 source_char 中第几个正则表达式匹配位置，为可选项。默认值为 1。如果 occurrence 大于 1，则从第一次匹配后的第一个字符开始搜索第二次正则表达式匹配，依此类推。\n\n\nreturn_opt\n指定返回出现匹配值位置选项，为可选项。默认值为 0。 \n      \n如果指定 0，则返回匹配的第一个字符的位置。\n如果指定 1，则返回匹配的最后字符后一位的位置。\n\n\n\nmatch_param\n指定更改正则表达式默认匹配方式，为可选项。是数据类型 VARCHAR2 或 CHAR 的字符表达式。 \n      \ni 表示大小写不敏感。\nc 表示大小写敏感。\nn 表示句点 . 可以匹配换行符。\nm 表示多行模式。\nx 表示忽略空格字符，默认情况下，空格字符会相互匹配。\n\n\n\nsubexpr\n指示 pattern 要返回的子表达式，是一个从 0 到 9 的非负整数，为可选项。默认值为 0，表示返回第一个子表达式出现的位置。\n\n\n",
            "返回 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT REGEXP_INSTR('OceanBase', '(Oc)(e(anB)(ase))',1, 1, 0, 'i', 3) \"first\",\n            REGEXP_INSTR('OceanBase', '(Oc)(e(anB)(ase))', 1, 1, 1, 'i', 3)-1 \"last\"\n          FROM DUAL;\n+-------+------+\n| first | last |\n+-------+------+\n|     4 |    6 |\n+-------+------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回表达式 (Oc)(e(anB)(ase)) 中第四个子表达式 anB 中第一个字符和最后一个字符在字符串 OceanBase 中的位置。",
            "obclient> SELECT REGEXP_INSTR('OceanBase', '(Oc)(e(anB)(ase))',1, 1, 0, 'i', 3) \"first\",\n            REGEXP_INSTR('OceanBase', '(Oc)(e(anB)(ase))', 1, 1, 1, 'i', 3)-1 \"last\"\n          FROM DUAL;\n+-------+------+\n| first | last |\n+-------+------+\n|     4 |    6 |\n+-------+------+\n1 row in set\n"
        ]
    },
    "REGEXP_REPLACE": {
        "Title": [
            "REGEXP_REPLACE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823193"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "REGEXP_REPLACE(source_char, pattern\n                 [, replace_string\n                    [, position\n                      [, occurrence\n                        [, match_param ]\n                      ]\n                    ]\n                 ]\n               )\n",
        "Description": [
            "该函数将字符串 source_char 中与正则表达式相匹配的字符替换为 replace_string 中的字符。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nsource_char\n指定用作搜索值的字符表达式。它通常是一种字符列。数据类型可以是 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\npattern\n指定正则表达式，它通常是一个文本文字，数据类型可以是 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。\n\n\nreplace_string\n表示替换的字符，可以是 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB 类型。\n\n\nposition\n指定开始正则表达式匹配的起始位置，取值是一个正整数，为可选项。默认值是 1，表示从第一个字符开始搜索 source_char。\n\n\noccurrence\n指定替换操作的第几个匹配项，是一个非负整数。 \n      \n如果指定 0，则 OceanBase 数据库替换所有匹配项。\n如果指定一个正整数 n，则 OceanBase 数据库将替换第 n 次出现的匹配项。\n\n\n\nmatch_param\n数据类型 VARCHAR2 或 CHAR 的字符表达式，它允许您更改函数的默认匹配行为。 \n      \ni 表示大小写不敏感。\nc 表示大小写敏感。\nn 表示句点 . 可以匹配换行符。\nm 表示多行模式。\nx 表示忽略空格字符，默认情况下，空格字符会相互匹配。\n\n\n\n",
            "返回结果与 source_char 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT REGEXP_REPLACE('OCEANBASE database', '(A|B){1}', '*',1,0) AS \"REGEXP_REPLACE\" FROM DUAL;\n+--------------------+\n| REGEXP_REPLACE     |\n+--------------------+\n| OCE*N**SE database |\n+--------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 OCEANBASE database 中所有的字母按 (A|B){1} 匹配的字符替换成 *。",
            "obclient> SELECT REGEXP_REPLACE('OCEANBASE database', '(A|B){1}', '*',1,0) AS \"REGEXP_REPLACE\" FROM DUAL;\n+--------------------+\n| REGEXP_REPLACE     |\n+--------------------+\n| OCE*N**SE database |\n+--------------------+\n1 row in set\n"
        ]
    },
    "REGEXP_SUBSTR": {
        "Title": [
            "REGEXP_SUBSTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823188"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "REGEXP_SUBSTR(source_char, pattern\n               [, position [, occurrence [, match_param [, subexpr] ] ] ]\n              )\n",
        "Description": [
            "该函数允许使用正则表达式搜索字符串并返回匹配字符串，扩展了 SUBSTR 函数的功能。 该函数类似于 REGEXP_INSTR，但它不返回子字符串的位置，而是返回子字符串。如果仅需要匹配字符串的内容，但不需要返回其在源字符串中的位置，则此函数很适用。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nsource_char\n指定用作搜索值的字符表达式，数据类型可以为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\npattern\n指定正则表达式截取规则。它通常是一个文本字面量，字符类型可以为 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。\n\n\nposition\n指定开始正则表达式匹配的起始位置，取值是一个正整数，为可选项。默认值是 1，表示从第一个字符开始搜索 source_char。\n\n\noccurrence\n指定 source_char 中第几个正则表达式匹配位置，为可选项。默认值为 1。如果 occurrence 大于 1，则从第一次匹配后的第一个字符开始搜索第二次正则表达式匹配，依此类推。\n\n\nmatch_param\n指定更改正则表达式默认匹配方式，为可选项。是数据类型 VARCHAR2 或 CHAR 的字符表达式。 \n      \ni 表示大小写不敏感。\nc 表示大小写敏感。\nn 表示句点 . 可以匹配换行符。\nm 表示多行模式。\nx 表示忽略空格字符，默认情况下，空格字符会相互匹配。\n\n\n\nsubexpr\n指示 pattern 要返回的子表达式，是一个从 0 到 9 的非负整数，为可选项。默认值为 0，表示返回第一个子表达式。\n\n\n",
            "返回与参数 source_char 相同的 VARCHAR2 或 CLOB 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT REGEXP_SUBSTR('abc,def,ghi', '[^,]+',1,1) AS \"第一个\",\n              REGEXP_SUBSTR('abc,def,ghi', '[^,]+',1,2) AS \"第二个\",\n              REGEXP_SUBSTR('abc,def,ghi', '[^,]+',1,3) AS \"第三个\"\n     FROM DUAL;\n+-----------+-----------+-----------+\n| 第一个    | 第二个    | 第三个    |\n+-----------+-----------+-----------+\n| abc       | def       | ghi       |\n+-----------+-----------+-----------+\n1 row in set\n",
            "obclient> SELECT REGEXP_SUBSTR('abcdefghi', 'abc(d(e(f)gh)i)',1,1,'i',2) FROM DUAL;\n+--------------------------------------------------------+\n| REGEXP_SUBSTR('ABCDEFGHI','ABC(D(E(F)GH)I)',1,1,'I',2) |\n+--------------------------------------------------------+\n| efgh                                                   |\n+--------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "把 abc,def,ghi 拆分为 abc、def 和 ghi。",
            "obclient> SELECT REGEXP_SUBSTR('abc,def,ghi', '[^,]+',1,1) AS \"第一个\",\n              REGEXP_SUBSTR('abc,def,ghi', '[^,]+',1,2) AS \"第二个\",\n              REGEXP_SUBSTR('abc,def,ghi', '[^,]+',1,3) AS \"第三个\"\n     FROM DUAL;\n+-----------+-----------+-----------+\n| 第一个    | 第二个    | 第三个    |\n+-----------+-----------+-----------+\n| abc       | def       | ghi       |\n+-----------+-----------+-----------+\n1 row in set\n",
            "返回表达式 abc(d(e(f)gh)i) 的第三个子表达式。",
            "obclient> SELECT REGEXP_SUBSTR('abcdefghi', 'abc(d(e(f)gh)i)',1,1,'i',2) FROM DUAL;\n+--------------------------------------------------------+\n| REGEXP_SUBSTR('ABCDEFGHI','ABC(D(E(F)GH)I)',1,1,'I',2) |\n+--------------------------------------------------------+\n| efgh                                                   |\n+--------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "REGR_ (Linear Regression)": {
        "Title": [
            "REGR_ (Linear Regression)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822871"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "{ REGR_SLOPE\n | REGR_INTERCEPT\n | REGR_COUNT\n | REGR_R2\n | REGR_AVGX\n | REGR_AVGY\n | REGR_SXX\n | REGR_SYY\n | REGR_SXY\n}(expr1 , expr2)\n  [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数是线性回归函数，将普通最小二乘法回归线拟合到一组数字对上。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nREGR_SLOPE\n返回直线的坡度（斜率）。返回值是数值数据类型，可以为 NULL。 忽略空数值对（expr1,expr2）后，它进行以下计算： sql COVAR_POP(expr1, expr2) / VAR_POP(expr2)\n\n\nREGR_INTERCEPT\n返回回归线的 y 截距。返回值是数值数据类型，可以为 NULL。忽略空数值对（expr1,expr2）后，它进行以下计算： sql AVG(expr1) - REGR_SLOPE(expr1, expr2) * AVG(expr2)\n\n\nREGR_COUNT\n返回用于填充回归线的非空数值对的数目，是一个整数。\n\n\nREGR_R2\n返回回归的确定系数（也称为 R 平方或拟合优度）。返回值是数值数据类型，可以为 NULL。忽略 VAR_POP(expr1) 和 VAR_POP(expr2) 的空值后进行评估。返回值为： sql NULL if VAR_POP(expr2) = 0 1 if VAR_POP(expr1) = 0 and VAR_POP(expr2) != 0 POWER(CORR(expr1,expr),2) if VAR_POP(expr1) > 0 and VAR_POP(expr2 != 0\n\n\nREGR_AVGX\n返回回归线的自变量（expr2）的平均值。忽略空数值对（expr1,expr2）后，进行以下计算： sql AVG(expr2)\n\n\nREGR_AVGY\n返回回归线的因变量（expr1）的平均值。忽略空数值对（expr1,expr2）后，进行以下计算： sql AVG(expr1)\n\n\nREGR_SXX\n返回值等于在忽略空数值对（expr1,expr2）后数值对的个数乘以自变量的值的总体方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * VAR_POP(expr2)\n\n\nREGR_SYY\n返回值等于在忽略空数值对（expr1,expr2）后数值对的个数乘以因变量的值的总体方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * VAR_POP(expr1)\n\n\nREGR_SXY\n返回值等于在忽略空数值对（expr1,expr2）后的数值对的个数乘以总体协方差，即下面公式的计算结果： sql REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2)\n\n\nexpr1\n指定因变量的值（y 值）。\n\n\nexpr2\n指定自变量的值（x 值）。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\nREGR_SXX 、REGR_SYY 和 REGR_SXY 是用于计算各种诊断统计数据的辅助函数。\n",
            "返回值是数值数据类型或 NULL。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n",
            "obclient> SELECT col1,REGR_SXX(col3,col4) \"REGR_SXX\",\n            REGR_SYY(col3,col4) \"REGR_SYY\",\n            REGR_SXY(col3,col4) \"REGR_SXY\"\n          FROM tbl1\n          GROUP BY col1;\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n| COL1 | REGR_SXX                               | REGR_SYY                                 | REGR_SXY                               |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n|    1 | 8.666666666666666666666666666666666667 | 4.66666666666666666666666666666666666701 | 6.333333333333333333333333333333333333 |\n|    2 |                                      5 |                                        5 |                                      5 |\n|    3 |                                   40.8 |                                       10 |                                    -20 |\n|    4 |                                      0 |                                        0 |                                      0 |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n4 rows in set\n",
            "obclient> SELECT col1,col2,col3,col4,\n            REGR_SLOPE(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"REGR_SLOPE\"\n          FROM tbl1;\n+------+------+------+------+--------------------------------------------+\n| COL1 | COL2 | COL3 | COL4 | REGR_SLOPE                                 |\n+------+------+------+------+--------------------------------------------+\n|    1 | A1   |    8 |   12 |                                       NULL |\n|    1 | A2   |   10 |   15 |  .6666666666666666666666666666666666666667 |\n|    1 | A3   |   11 |   16 |  .7307692307692307692307692307692307691642 |\n|    2 | B1   |    9 |   14 |                                       NULL |\n|    2 | B2   |   10 |   15 |                                          1 |\n|    2 | B3   |    8 |   13 |                                          1 |\n|    2 | B4   |   11 |   16 |                                          1 |\n|    3 | C1   |    8 |   18 |                                       NULL |\n|    3 | C2   |    9 |   16 |                                        -.5 |\n|    3 | C3   |   10 |   15 | -.6428571428571428571428571428571428570956 |\n|    3 | C4   |   11 |   12 | -.5066666666666666666666666666666666666667 |\n|    3 | C5   |   12 |   10 | -.4901960784313725490196078431372549019608 |\n|    4 | d1   |    8 | NULL |                                       NULL |\n|    4 | d1   |    9 |   10 |                                       NULL |\n|    4 | d1   |   10 | NULL |                                       NULL |\n+------+------+------+------+--------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "计算数值对列 col3 与列 col4 线性回归的三种类型的诊断统计量。",
            "obclient> SELECT col1,REGR_SXX(col3,col4) \"REGR_SXX\",\n            REGR_SYY(col3,col4) \"REGR_SYY\",\n            REGR_SXY(col3,col4) \"REGR_SXY\"\n          FROM tbl1\n          GROUP BY col1;\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n| COL1 | REGR_SXX                               | REGR_SYY                                 | REGR_SXY                               |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n|    1 | 8.666666666666666666666666666666666667 | 4.66666666666666666666666666666666666701 | 6.333333333333333333333333333333333333 |\n|    2 |                                      5 |                                        5 |                                      5 |\n|    3 |                                   40.8 |                                       10 |                                    -20 |\n|    4 |                                      0 |                                        0 |                                      0 |\n+------+----------------------------------------+------------------------------------------+----------------------------------------+\n4 rows in set\n",
            "分析函数示例",
            "按列 col1 分组和列 col2 升序排序，计算数值对列 col3 与列 col4 的累计斜率。",
            "obclient> SELECT col1,col2,col3,col4,\n            REGR_SLOPE(col3,col4) OVER(PARTITION BY col1 ORDER BY col2) \"REGR_SLOPE\"\n          FROM tbl1;\n+------+------+------+------+--------------------------------------------+\n| COL1 | COL2 | COL3 | COL4 | REGR_SLOPE                                 |\n+------+------+------+------+--------------------------------------------+\n|    1 | A1   |    8 |   12 |                                       NULL |\n|    1 | A2   |   10 |   15 |  .6666666666666666666666666666666666666667 |\n|    1 | A3   |   11 |   16 |  .7307692307692307692307692307692307691642 |\n|    2 | B1   |    9 |   14 |                                       NULL |\n|    2 | B2   |   10 |   15 |                                          1 |\n|    2 | B3   |    8 |   13 |                                          1 |\n|    2 | B4   |   11 |   16 |                                          1 |\n|    3 | C1   |    8 |   18 |                                       NULL |\n|    3 | C2   |    9 |   16 |                                        -.5 |\n|    3 | C3   |   10 |   15 | -.6428571428571428571428571428571428570956 |\n|    3 | C4   |   11 |   12 | -.5066666666666666666666666666666666666667 |\n|    3 | C5   |   12 |   10 | -.4901960784313725490196078431372549019608 |\n|    4 | d1   |    8 | NULL |                                       NULL |\n|    4 | d1   |    9 |   10 |                                       NULL |\n|    4 | d1   |   10 | NULL |                                       NULL |\n+------+------+------+------+--------------------------------------------+\n15 rows in set\n"
        ]
    },
    "REMAINDER": {
        "Title": [
            "REMAINDER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823155"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "REMAINDER (x, y)\n",
        "Description": [
            "该函数返回 x 除以 y 的余数。",
            "\n注意\n该函数在用 REMAINDER (x,y) 和 MOD (x,y) 函数在进行运算时，都用了一个公式 result=x-y*(x/y)，区别在于计算 x/y 时的处理方式不同。在 REMAINDER (x,y) 函数中，采用 ROUND(x/y)，而在 MOD (x,y) 函数中采用 FLOOR(x/y)。\n在 REMAINDER 函数中，当 ROUND(x/y) 的参数 x/y 的值的小数部分恰好为 0.5 时，如果 x/y 的值的整数部分为偶数，不向前一位进位；如果 x/y 的值的整数部分为奇数，向前一位进位。例如，ROUND(1.5)=2、ROUND(2.5)=2、ROUND(3.5)=4、ROUND(4.5)=4。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nx\n被除数，为数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。\n\n\ny\n除数，为数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。 注意 参数 y 不能为 0。\n\n\n",
            "返回类型与数值优先级高的参数的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT MOD(1.5,1),REMAINDER(1.5,1) FROM DUAL;\n+------------+------------------+\n| MOD(1.5,1) | REMAINDER(1.5,1) |\n+------------+------------------+\n|         .5 |              -.5 |\n+------------+------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 MOD 以及 REMAINDER 函数返回 1.5 除以 1 的余数。",
            "obclient> SELECT MOD(1.5,1),REMAINDER(1.5,1) FROM DUAL;\n+------------+------------------+\n| MOD(1.5,1) | REMAINDER(1.5,1) |\n+------------+------------------+\n|         .5 |              -.5 |\n+------------+------------------+\n1 row in set\n"
        ]
    },
    "REPLACE": {
        "Title": [
            "REPLACE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823198"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "REPLACE(char1,char2[,char3])\n",
        "Description": [
            "该函数将字符串 char1 中与 char2 匹配的子字符串替换为 char3。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n指定等待替换的字符串。数据类型可以是 CHAR 、VARCHAR2、NCHAR、NVARCHAR2 和 CLOB。\n\n\nchar2\n指定需要替换的字符串。数据类型可以是 CHAR 、VARCHAR2、NCHAR、NVARCHAR2 和 CLOB。\n\n\nchar3\n指定替换字符串，默认为空，表示删除，不是空格。数据类型可以是 CHAR 、VARCHAR2、NCHAR、NVARCHAR2 和 CLOB。 说明 如果 char3 缺省或者为 NULL，那么所有 char1 中出现的 char2 都将被移除。如果 char2 为空值，那么结果就是 char1。\n\n\n",
            "返回的字符串与 char1 的字符集相同。",
            "如果 char1 是 LOB 数据类型，则函数返回 CLOB 数据类型。",
            "如果 char1 不是 LOB 数据类型，则函数返回 VARCHA2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT REPLACE('Oceanbase','b','B') \"replace\" FROM DUAL;\n+-----------+\n| replace   |\n+-----------+\n| OceanBase |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "把字符串 Oceanbase 中字符 b 替换成 B。",
            "obclient> SELECT REPLACE('Oceanbase','b','B') \"replace\" FROM DUAL;\n+-----------+\n| replace   |\n+-----------+\n| OceanBase |\n+-----------+\n1 row in set\n"
        ]
    },
    "ROLLUP": {
        "Title": [
            "ROLLUP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822878"
        ],
        "Category": [
            "Aggregate Functions"
        ],
        "Feature": "SELECT ... GROUP BY ROLLUP(col_name [,col_name...])\n",
        "Description": [
            "该函数是一个聚合函数，功能是可以为每个分组返回一个小计，同时为所有分组返回总计。它是 GROUP BY 语句的简单扩展，在数据统计和报表生成过程中比 GROUP BY 和 UNION 组合方法效率高。在涉及分组统计的任务中使用 ROLLUP 函数非常高效。例如，沿着时间或地理等层次维度进行小计，只需要查询 ROLLUP(y, m, day) 或 ROLLUP(country, state, city)。数据仓库管理员使用 ROLLUP 函数可以简化和加快汇总表的维护。",
            "ROLLUP 函数的执行顺序如下：",
            "根据参数指定的列从右到左递减分组。",
            "对每个分组小计，再对所有分组合计。",
            "按照 ORDER BY col1 (，col2，col3，col4 ...) 排序。"
        ],
        "Illustration": [
            "col_name 是指进行分组操作的列名。如果 ROLLUP 参数为 N 个 col_name，则相当于 N+1 个 GROUP BY 分组的 UNION 的结合。"
        ],
        "Examples": [
            "obclient> CREATE TABLE group_tbl1 (group_id INT,job VARCHAR2(10),name VARCHAR2(10),salary INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO group_tbl1 VALUES\n    (10,'Coding','Bruce',1000),\n    (10,'Programmer','Clair',1000),\n    (20,'Coding','Jason',2000),\n    (20,'Programmer','Joey',2000),\n    (30,'Coding','Rebecca',3000),\n    (30,'Programmer','Rex',3000),\n    (40,'Coding','Samuel',4000),\n    (40,'Programmer','Susy',4000);\nQuery OK, 8 rows affected (0.01 sec)\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM group_tbl1;\n+----------+------------+---------+--------+\n| GROUP_ID | JOB        | NAME    | SALARY |\n+----------+------------+---------+--------+\n|       10 | Coding     | Bruce   |   1000 |\n|       10 | Programmer | Clair   |   1000 |\n|       20 | Coding     | Jason   |   2000 |\n|       20 | Programmer | Joey    |   2000 |\n|       30 | Coding     | Rebecca |   3000 |\n|       30 | Programmer | Rex     |   3000 |\n|       40 | Coding     | Samuel  |   4000 |\n|       40 | Programmer | Susy    |   4000 |\n+----------+------------+---------+--------+\n8 rows in set\n",
            "obclient> SELECT group_id,SUM(salary) FROM group_tbl1 GROUP BY group_id;\n+----------+-------------+\n| GROUP_ID | SUM(SALARY) |\n+----------+-------------+\n|       10 |        2000 |\n|       20 |        4000 |\n|       30 |        6000 |\n|       40 |        8000 |\n+----------+-------------+\n4 rows in set\n",
            "obclient> SELECT group_id,SUM(salary) FROM group_tbl1 GROUP BY ROLLUP (group_id);\n+----------+-------------+\n| GROUP_ID | SUM(SALARY) |\n+----------+-------------+\n|       10 |        2000 |\n|       20 |        4000 |\n|       30 |        6000 |\n|       40 |        8000 |\n|     NULL |       20000 |\n+----------+-------------+\n5 rows in set\n",
            "obclient> SELECT group_id,job,SUM(salary) FROM group_tbl1 GROUP BY ROLLUP (group_id,job);\n+----------+------------+-------------+\n| GROUP_ID | JOB        | SUM(SALARY) |\n+----------+------------+-------------+\n|       10 | Coding     |        1000 |\n|       10 | Programmer |        1000 |\n|       10 | NULL       |        2000 |\n|       20 | Coding     |        2000 |\n|       20 | Programmer |        2000 |\n|       20 | NULL       |        4000 |\n|       30 | Coding     |        3000 |\n|       30 | Programmer |        3000 |\n|       30 | NULL       |        6000 |\n|       40 | Coding     |        4000 |\n|       40 | Programmer |        4000 |\n|       40 | NULL       |        8000 |\n|     NULL | NULL       |       20000 |\n+----------+------------+-------------+\n13 rows in set\n",
            "obclient> SELECT group_id,job,SUM(salary) FROM group_tbl1 GROUP BY group_id, job\n    UNION ALL\n    SELECT group_id,NULL,SUM(salary) FROM group_tbl1 GROUP BY group_id\n    UNION ALL\n    SELECT NULL,NULL,SUM(salary) FROM group_tbl1 ORDER BY 1,2;\n+----------+------------+-------------+\n| GROUP_ID | JOB        | SUM(SALARY) |\n+----------+------------+-------------+\n|       10 | Coding     |        1000 |\n|       10 | Programmer |        1000 |\n|       10 | NULL       |        2000 |\n|       20 | Coding     |        2000 |\n|       20 | Programmer |        2000 |\n|       20 | NULL       |        4000 |\n|       30 | Coding     |        3000 |\n|       30 | Programmer |        3000 |\n|       30 | NULL       |        6000 |\n|       40 | Coding     |        4000 |\n|       40 | Programmer |        4000 |\n|       40 | NULL       |        8000 |\n|     NULL | NULL       |       20000 |\n+----------+------------+-------------+\n13 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 group_tbl1，并向里面插入数据。",
            "obclient> CREATE TABLE group_tbl1 (group_id INT,job VARCHAR2(10),name VARCHAR2(10),salary INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO group_tbl1 VALUES\n    (10,'Coding','Bruce',1000),\n    (10,'Programmer','Clair',1000),\n    (20,'Coding','Jason',2000),\n    (20,'Programmer','Joey',2000),\n    (30,'Coding','Rebecca',3000),\n    (30,'Programmer','Rex',3000),\n    (40,'Coding','Samuel',4000),\n    (40,'Programmer','Susy',4000);\nQuery OK, 8 rows affected (0.01 sec)\nRecords: 8  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM group_tbl1;\n+----------+------------+---------+--------+\n| GROUP_ID | JOB        | NAME    | SALARY |\n+----------+------------+---------+--------+\n|       10 | Coding     | Bruce   |   1000 |\n|       10 | Programmer | Clair   |   1000 |\n|       20 | Coding     | Jason   |   2000 |\n|       20 | Programmer | Joey    |   2000 |\n|       30 | Coding     | Rebecca |   3000 |\n|       30 | Programmer | Rex     |   3000 |\n|       40 | Coding     | Samuel  |   4000 |\n|       40 | Programmer | Susy    |   4000 |\n+----------+------------+---------+--------+\n8 rows in set\n",
            "对 group_id 进行 GROUP BY 分组操作并对 salary 求和。",
            "obclient> SELECT group_id,SUM(salary) FROM group_tbl1 GROUP BY group_id;\n+----------+-------------+\n| GROUP_ID | SUM(SALARY) |\n+----------+-------------+\n|       10 |        2000 |\n|       20 |        4000 |\n|       30 |        6000 |\n|       40 |        8000 |\n+----------+-------------+\n4 rows in set\n",
            "对 group_id 使用 ROLLUP 函数进行分组，同时求 salary 总和。",
            "obclient> SELECT group_id,SUM(salary) FROM group_tbl1 GROUP BY ROLLUP (group_id);\n+----------+-------------+\n| GROUP_ID | SUM(SALARY) |\n+----------+-------------+\n|       10 |        2000 |\n|       20 |        4000 |\n|       30 |        6000 |\n|       40 |        8000 |\n|     NULL |       20000 |\n+----------+-------------+\n5 rows in set\n",
            "对 group_id 列和 job 列使用 ROLLUP 函数进行分组，同时求 salary 总和。",
            "obclient> SELECT group_id,job,SUM(salary) FROM group_tbl1 GROUP BY ROLLUP (group_id,job);\n+----------+------------+-------------+\n| GROUP_ID | JOB        | SUM(SALARY) |\n+----------+------------+-------------+\n|       10 | Coding     |        1000 |\n|       10 | Programmer |        1000 |\n|       10 | NULL       |        2000 |\n|       20 | Coding     |        2000 |\n|       20 | Programmer |        2000 |\n|       20 | NULL       |        4000 |\n|       30 | Coding     |        3000 |\n|       30 | Programmer |        3000 |\n|       30 | NULL       |        6000 |\n|       40 | Coding     |        4000 |\n|       40 | Programmer |        4000 |\n|       40 | NULL       |        8000 |\n|     NULL | NULL       |       20000 |\n+----------+------------+-------------+\n13 rows in set\n",
            "上面的 SQL 语句可以用 GROUP BY 与 UNION ALL 组合方法替换，可以看到输出结果和 ROLLUP 函数一样，但是 ROLLUP 函数更加简洁、高效。",
            "obclient> SELECT group_id,job,SUM(salary) FROM group_tbl1 GROUP BY group_id, job\n    UNION ALL\n    SELECT group_id,NULL,SUM(salary) FROM group_tbl1 GROUP BY group_id\n    UNION ALL\n    SELECT NULL,NULL,SUM(salary) FROM group_tbl1 ORDER BY 1,2;\n+----------+------------+-------------+\n| GROUP_ID | JOB        | SUM(SALARY) |\n+----------+------------+-------------+\n|       10 | Coding     |        1000 |\n|       10 | Programmer |        1000 |\n|       10 | NULL       |        2000 |\n|       20 | Coding     |        2000 |\n|       20 | Programmer |        2000 |\n|       20 | NULL       |        4000 |\n|       30 | Coding     |        3000 |\n|       30 | Programmer |        3000 |\n|       30 | NULL       |        6000 |\n|       40 | Coding     |        4000 |\n|       40 | Programmer |        4000 |\n|       40 | NULL       |        8000 |\n|     NULL | NULL       |       20000 |\n+----------+------------+-------------+\n13 rows in set\n"
        ]
    },
    "ROUND (date)": {
        "Title": [
            "ROUND (date)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823135"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "ROUND(date,[fmt])\n",
        "Description": [
            "该函数以参数 fmt 为单位距离返回离指定日期 date 最近的日期时间值，根据公历的规则运算。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndate\n所有包含日期的数据类型的值，包括 DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE。\n\n\nfmt\n指定了函数返回值与 date 的距离单位，为可选项。如果省略 fmt，则 date 四舍五入到最近的一天。\n\n\n",
            "以下表格列举了 fmt 参数的可取值（大小写不敏感）。",
            "\n\n\nfmt 取值\n说明\n\n\n\n\nj\n默认值，最近 0 点日期。\n\n\nday、dy、d\n返回离指定日期最近的星期日。\n\n\nmonth、mon、mm、rm\n返回离指定日期最近的月的第一天日期。\n\n\nq\n返回离指定日期最近的季的日期。\n\n\nsyear、year、yyyy、yyy、yy、y\n多个 y 表示不同的精度，返回离指定日期最近的年的第一个日期。\n\n\ncc、scc\n返回离指定日期最近的世纪的初日期。\n\n\n",
            "返回 DATE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE 当时日期,\n    ROUND(SYSDATE) 最近0点日期,\n    ROUND(SYSDATE,'DAY') 最近星期日,\n    ROUND(SYSDATE,'MONTH') 最近月初,\n    ROUND(SYSDATE,'Q') 最近季初日期,\n    ROUND(SYSDATE,'YEAR') 最近年初日期\n    FROM DUAL;\n+--------------+------------------+-----------------+--------------+--------------------+--------------------+\n| 当时日期     | 最近0点日期      | 最近星期日      | 最近月初     | 最近季初日期       | 最近年初日期       |\n+--------------+------------------+-----------------+--------------+--------------------+--------------------+\n| 18-NOV-21    | 18-NOV-21        | 21-NOV-21       | 01-DEC-21    | 01-JAN-22          | 01-JAN-22          |\n+--------------+------------------+-----------------+--------------+--------------------+--------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回距离当前日期最近的 0 点日期、星期日、月初、季初日期和年初日期。",
            "obclient> SELECT SYSDATE 当时日期,\n    ROUND(SYSDATE) 最近0点日期,\n    ROUND(SYSDATE,'DAY') 最近星期日,\n    ROUND(SYSDATE,'MONTH') 最近月初,\n    ROUND(SYSDATE,'Q') 最近季初日期,\n    ROUND(SYSDATE,'YEAR') 最近年初日期\n    FROM DUAL;\n+--------------+------------------+-----------------+--------------+--------------------+--------------------+\n| 当时日期     | 最近0点日期      | 最近星期日      | 最近月初     | 最近季初日期       | 最近年初日期       |\n+--------------+------------------+-----------------+--------------+--------------------+--------------------+\n| 18-NOV-21    | 18-NOV-21        | 21-NOV-21       | 01-DEC-21    | 01-JAN-22          | 01-JAN-22          |\n+--------------+------------------+-----------------+--------------+--------------------+--------------------+\n1 row in set\n"
        ]
    },
    "ROUND": {
        "Title": [
            "ROUND"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823165"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ROUND (numeric[,decimal])\n",
        "Description": [
            "该函数返回参数 numeric 四舍五入后的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nnumeric\n数值类型的（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。\n\n\ndecimal\n\n\n如果 decimal 大于等于 0 则将 numeric 四舍五入到 decimal 位小数。\n如果 decimal 小于 0 则四舍五入到小数点向左第 decimal 位。\n当 decimal 不为整数时，截取 decimal 的整数部分。\n不指定 decimal 时，将 numeric 四舍五入到整数位。\n\n\n\n",
            "不指定 decimal 时，返回类型与参数 numeric 的类型相同。",
            "指定 decimal 时，返回类型为 NUMBER 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT ROUND(666.666,1),ROUND(666.666,-1),ROUND(666.666,2.1),ROUND(666.666) FROM DUAL;\n+------------------+-------------------+--------------------+----------------+\n| ROUND(666.666,1) | ROUND(666.666,-1) | ROUND(666.666,2.1) | ROUND(666.666) |\n+------------------+-------------------+--------------------+----------------+\n|            666.7 |               670 |             666.67 |            667 |\n+------------------+-------------------+--------------------+----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "在 decimal 的值为 1、-1、2.1 和省略 decimal 情况下，返回 666.666 四舍五入的结果。",
            "obclient> SELECT ROUND(666.666,1),ROUND(666.666,-1),ROUND(666.666,2.1),ROUND(666.666) FROM DUAL;\n+------------------+-------------------+--------------------+----------------+\n| ROUND(666.666,1) | ROUND(666.666,-1) | ROUND(666.666,2.1) | ROUND(666.666) |\n+------------------+-------------------+--------------------+----------------+\n|            666.7 |               670 |             666.67 |            667 |\n+------------------+-------------------+--------------------+----------------+\n1 row in set\n"
        ]
    },
    "ROWIDTOCHAR": {
        "Title": [
            "ROWIDTOCHAR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823219"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "ROWIDTOCHAR(rowid)\n",
        "Description": [
            "该函数将 rowid 值转换为 VARCHAR2 数据类型的值。"
        ],
        "Illustration": [
            "参数 rowid 是一个 ROWID 格式的值。",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT LENGTHB(ROWIDTOCHAR(ROWID)),ROWIDTOCHAR(ROWID)\n          FROM tbl1\n          WHERE ROWIDTOCHAR(ROWID) LIKE '%AAIKA%';\n+-----------------------------+--------------------+\n| LENGTHB(ROWIDTOCHAR(ROWID)) | ROWIDTOCHAR(ROWID) |\n+-----------------------------+--------------------+\n|                          17 | *AAIKAQAAAAAAAAA=  |\n|                          17 | *AAIKAgAAAAAAAAA=  |\n|                          17 | *AAIKAwAAAAAAAAA=  |\n+-----------------------------+--------------------+\n3 rows in set\n"
        ],
        "Detailed Examples": [
            "查询表 tbl1 列 ROWID 中包含 AAIKA 的数据。",
            "obclient> SELECT LENGTHB(ROWIDTOCHAR(ROWID)),ROWIDTOCHAR(ROWID)\n          FROM tbl1\n          WHERE ROWIDTOCHAR(ROWID) LIKE '%AAIKA%';\n+-----------------------------+--------------------+\n| LENGTHB(ROWIDTOCHAR(ROWID)) | ROWIDTOCHAR(ROWID) |\n+-----------------------------+--------------------+\n|                          17 | *AAIKAQAAAAAAAAA=  |\n|                          17 | *AAIKAgAAAAAAAAA=  |\n|                          17 | *AAIKAwAAAAAAAAA=  |\n+-----------------------------+--------------------+\n3 rows in set\n"
        ]
    },
    "ROWIDTONCHAR": {
        "Title": [
            "ROWIDTONCHAR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823222"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "ROWIDTONCHAR(rowid)\n",
        "Description": [
            "该函数将 rowid 值转换为 NVARCHAR2 数据类型的值。"
        ],
        "Illustration": [
            "参数 rowid 是一个 ROWID 格式的值。",
            "返回 NVARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT LENGTHB(ROWIDTONCHAR(ROWID)),LENGTHB(ROWID),ROWIDTONCHAR(ROWID) FROM tbl1;\n+------------------------------+----------------+---------------------+\n| LENGTHB(ROWIDTONCHAR(ROWID)) | LENGTHB(ROWID) | ROWIDTONCHAR(ROWID) |\n+------------------------------+----------------+---------------------+\n|                           34 |             17 | *AAIKAQAAAAAAAAA=   |\n|                           34 |             17 | *AAIKAgAAAAAAAAA=   |\n|                           34 |             17 | *AAIKAwAAAAAAAAA=   |\n+------------------------------+----------------+---------------------+\n3 rows in set\n"
        ],
        "Detailed Examples": [
            "将表 tbl1 中 ROWID 值转换为 NVARCHAR2 类型的值并返回对应字节长度。",
            "obclient> SELECT LENGTHB(ROWIDTONCHAR(ROWID)),LENGTHB(ROWID),ROWIDTONCHAR(ROWID) FROM tbl1;\n+------------------------------+----------------+---------------------+\n| LENGTHB(ROWIDTONCHAR(ROWID)) | LENGTHB(ROWID) | ROWIDTONCHAR(ROWID) |\n+------------------------------+----------------+---------------------+\n|                           34 |             17 | *AAIKAQAAAAAAAAA=   |\n|                           34 |             17 | *AAIKAgAAAAAAAAA=   |\n|                           34 |             17 | *AAIKAwAAAAAAAAA=   |\n+------------------------------+----------------+---------------------+\n3 rows in set\n"
        ]
    },
    "ROW_NUMBER": {
        "Title": [
            "ROW_NUMBER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822842"
        ],
        "Category": [
            "Analytic Functions"
        ],
        "Feature": "ROW_NUMBER( ) OVER ([ query_partition_clause ] order_by_clause)\n",
        "Description": [
            "该函数是一个分析函数，作用是为每一条行（分组）记录返回一个唯一的序号，该序号按照 order_by_clause 中指定列进行的排序，从 1 开始。当遇到相同的数据时，排名按照记录集中记录的顺序依次递增，对于不同数据进行依次排名。"
        ],
        "Illustration": [
            "使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。",
            "返回数值类型数据。"
        ],
        "Examples": [
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,\n                 ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC)\n          FROM emp_msg;\n+--------+--------+------+---------------------------------------------------+\n| DEPTNO | ENAME  | SAL  | ROW_NUMBER()OVER(PARTITIONBYDEPTNOORDERBYSALDESC) |\n+--------+--------+------+---------------------------------------------------+\n|     10 | KING   | 5300 |                                                 1 |\n|     10 | CLARK  | 2750 |                                                 2 |\n|     10 | MILLER | 1600 |                                                 3 |\n|     20 | FORD   | 3300 |                                                 1 |\n|     20 | SCOTT  | 3300 |                                                 2 |\n|     20 | JONES  | 3275 |                                                 3 |\n|     20 | ADAMS  | 1400 |                                                 4 |\n|     20 | SMITH  | 1100 |                                                 5 |\n|     30 | BLAKE  | 3150 |                                                 1 |\n|     30 | ALLEN  | 1900 |                                                 2 |\n|     30 | TURNER | 1800 |                                                 3 |\n|     30 | SCLARK | 1750 |                                                 4 |\n|     30 | MARTIN | 1550 |                                                 5 |\n|     30 | WARD   | 1550 |                                                 6 |\n|     30 | JAMES  | 1250 |                                                 7 |\n+--------+--------+------+---------------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 emp_msg。查询 emp_msg 表中，按 deptno 字段分组并按列 sal 降序排序，返回列 sal 中各值的序号。",
            "obclient> SELECT * FROM emp_msg;\n+--------+--------+------+------+\n| DEPTNO | ENAME  | SAL  | MGR  |\n+--------+--------+------+------+\n|     10 | CLARK  | 2750 | 7839 |\n|     10 | KING   | 5300 | NULL |\n|     10 | MILLER | 1600 | 7782 |\n|     20 | ADAMS  | 1400 | 7788 |\n|     20 | FORD   | 3300 | 7566 |\n|     20 | JONES  | 3275 | 7839 |\n|     20 | SCOTT  | 3300 | 7566 |\n|     20 | SMITH  | 1100 | 7902 |\n|     30 | ALLEN  | 1900 | 7698 |\n|     30 | BLAKE  | 3150 | 7839 |\n|     30 | JAMES  | 1250 | 7698 |\n|     30 | MARTIN | 1550 | 7698 |\n|     30 | TURNER | 1800 | 7698 |\n|     30 | WARD   | 1550 | 7698 |\n|     30 | SCLARK | 1750 | 7839 |\n+--------+--------+------+------+\n15 rows in set\n\nobclient> SELECT deptno,ename,sal,\n                 ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC)\n          FROM emp_msg;\n+--------+--------+------+---------------------------------------------------+\n| DEPTNO | ENAME  | SAL  | ROW_NUMBER()OVER(PARTITIONBYDEPTNOORDERBYSALDESC) |\n+--------+--------+------+---------------------------------------------------+\n|     10 | KING   | 5300 |                                                 1 |\n|     10 | CLARK  | 2750 |                                                 2 |\n|     10 | MILLER | 1600 |                                                 3 |\n|     20 | FORD   | 3300 |                                                 1 |\n|     20 | SCOTT  | 3300 |                                                 2 |\n|     20 | JONES  | 3275 |                                                 3 |\n|     20 | ADAMS  | 1400 |                                                 4 |\n|     20 | SMITH  | 1100 |                                                 5 |\n|     30 | BLAKE  | 3150 |                                                 1 |\n|     30 | ALLEN  | 1900 |                                                 2 |\n|     30 | TURNER | 1800 |                                                 3 |\n|     30 | SCLARK | 1750 |                                                 4 |\n|     30 | MARTIN | 1550 |                                                 5 |\n|     30 | WARD   | 1550 |                                                 6 |\n|     30 | JAMES  | 1250 |                                                 7 |\n+--------+--------+------+---------------------------------------------------+\n15 rows in set\n"
        ]
    },
    "RPAD": {
        "Title": [
            "RPAD"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823195"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "RPAD(char1,n[,char2])\n",
        "Description": [
            "该函数将字符串 char1 的右边用字符串 char2 填充，直到长度为 n 时为止。",
            "\n说明\n\n如果 char1 长度大于 n，则返回 char1 左边 n 个字符。\n如果 char1 长度小于 n，char1 和 char2 连接后大于 n，则返回连接后的左边 n 个字符。\n如果 char1 长度小于 n，char1 和 char2 连接后小于 n，则返回 char1 与多个重复 char2 连接（总长度大于等于 n）后的左边 n 个字符。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n表示字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nn\n追加后字符总长度，必须是 NUMBER 类型或可以隐式转换为 NUMBER 类型的值。 说明 对于非整数值，会舍去小数部分转化为整数。\n\n\nchar2\n表示追加的字符串，默认为空格。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\n",
            "如果 char1 是字符型数据，则返回 VARCHAR2 类型。",
            "如果 char1 是国家字符数据类型，则返回 NVARCHAR2 类型。",
            "如果 char1 是 LOB 数据类型，则返回 LOB 类型。"
        ],
        "Examples": [
            "obclient> SELECT  RPAD('ABCDE',10,'*') \"RPAD\" FROM DUAL;\n+------------+\n| RPAD       |\n+------------+\n| ABCDE***** |\n+------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用星号 * 右填充字符串 ABCDE 至 10 个字符长度。",
            "obclient> SELECT  RPAD('ABCDE',10,'*') \"RPAD\" FROM DUAL;\n+------------+\n| RPAD       |\n+------------+\n| ABCDE***** |\n+------------+\n1 row in set\n"
        ]
    },
    "RTRIM": {
        "Title": [
            "RTRIM"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823185"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "RTRIM(char1 [,char2])\n",
        "Description": [
            "该函数功能是从 char1 的右端删除 char2 中包含的所有字符，直到 char1 的右端出现 char2 中不存在的字符为止，然后返回结果。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n表示字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 和 CLOB 数据类型。\n\n\nchar2\n表示要删除的字符集合，为可选项。默认为单个空格。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 和 CLOB 数据类型。\n\n\n",
            "如果 char1 是 CHAR、VARCHAR2 数据类型，则函数返回 VARCHAR2 数据类型。",
            "如果 char1 是 NCHAR、NVARCHAR2 数据类型，则函数返回 NVARCHAR2 数据类型。",
            "如果 char1 是 LOB 数据类型，则返回的字符串为 LOB 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT RTRIM('OceanBaseX**XX*X','*X') \"RTRIM\" FROM DUAL;\n+-----------+\n| RTRIM     |\n+-----------+\n| OceanBase |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "去掉字符串 OceanBaseX**XX*X 中 OceanBase 右边的字符串。",
            "obclient> SELECT RTRIM('OceanBaseX**XX*X','*X') \"RTRIM\" FROM DUAL;\n+-----------+\n| RTRIM     |\n+-----------+\n| OceanBase |\n+-----------+\n1 row in set\n"
        ]
    },
    "SCN_TO_TIMESTAMP": {
        "Title": [
            "SCN_TO_TIMESTAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823224"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "SCN_TO_TIMESTAMP(number)\n",
        "Description": [
            "SCN_TO_TIMESTAMP() 函数将 SCN 作为参数，并返回与该 SCN 关联的时间戳。返回值是 TIMESTAMP 数据类型。"
        ],
        "Illustration": [],
        "Examples": [
            "obclient> SELECT MAX_SCN, SCN_TO_TIMESTAMP(MAX_SCN) FROM gv$ob_log_stat;\n+---------------------+---------------------------------+\n| MAX_SCN             | SCN_TO_TIMESTAMP(MAX_SCN)       |\n+---------------------+---------------------------------+\n| 1676966094432030402 | 21-FEB-23 03.54.54.432030402 PM |\n| 1676966094299077583 | 21-FEB-23 03.54.54.299077583 PM |\n+---------------------+---------------------------------+\n2 rows in set\n"
        ],
        "Detailed Examples": [
            "obclient> SELECT MAX_SCN, SCN_TO_TIMESTAMP(MAX_SCN) FROM gv$ob_log_stat;\n+---------------------+---------------------------------+\n| MAX_SCN             | SCN_TO_TIMESTAMP(MAX_SCN)       |\n+---------------------+---------------------------------+\n| 1676966094432030402 | 21-FEB-23 03.54.54.432030402 PM |\n| 1676966094299077583 | 21-FEB-23 03.54.54.299077583 PM |\n+---------------------+---------------------------------+\n2 rows in set\n",
            "\n说明\ngv$ob_log_stat 是展示日志流日志同步状态的内部表，其 max_scn 字段是一个 SCN 类型，通过 SCN_TO_TIMESTAMP() 函数将 SCN 转换为时间戳。\n"
        ]
    },
    "SESSIONTIMEZONE": {
        "Title": [
            "SESSIONTIMEZONE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823137"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "SESSIONTIMEZONE\n",
        "Description": [
            "该函数返回当前会话时区。"
        ],
        "Illustration": [
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT DBTIMEZONE,SESSIONTIMEZONE FROM DUAL;\n+------------+-----------------+\n| DBTIMEZONE | SESSIONTIMEZONE |\n+------------+-----------------+\n| +00:00     | +08:00          |\n+------------+-----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回数据库时区和当前会话时区。",
            "obclient> SELECT DBTIMEZONE,SESSIONTIMEZONE FROM DUAL;\n+------------+-----------------+\n| DBTIMEZONE | SESSIONTIMEZONE |\n+------------+-----------------+\n| +00:00     | +08:00          |\n+------------+-----------------+\n1 row in set\n"
        ]
    },
    "SIGN": {
        "Title": [
            "SIGN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823161"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "SIGN(numeric_expression)\n",
        "Description": [
            "该函数返回输入数值的符号。符号为 1、-1 和 0。"
        ],
        "Illustration": [
            "numeric_expression 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "返回 NUMBER 数据类型。",
            "如果 numeric_expression > 0，则返回 1。",
            "如果 numeric_expression < 0，则返回 -1。",
            "如果 numeric_expression = 0，则返回 0。"
        ],
        "Examples": [
            "obclient> SELECT SIGN(2),SIGN(-2),SIGN(0),SIGN(3+3) FROM DUAL;\n+---------+----------+---------+-----------+\n| SIGN(2) | SIGN(-2) | SIGN(0) | SIGN(3+3) |\n+---------+----------+---------+-----------+\n|       1 |       -1 |       0 |         1 |\n+---------+----------+---------+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 2、-2、0 和 3+3 的符号。",
            "obclient> SELECT SIGN(2),SIGN(-2),SIGN(0),SIGN(3+3) FROM DUAL;\n+---------+----------+---------+-----------+\n| SIGN(2) | SIGN(-2) | SIGN(0) | SIGN(3+3) |\n+---------+----------+---------+-----------+\n|       1 |       -1 |       0 |         1 |\n+---------+----------+---------+-----------+\n1 row in set\n"
        ]
    },
    "SIN": {
        "Title": [
            "SIN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823144"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "SIN(x)\n",
        "Description": [
            "该函数是正弦函数，返回参数角度的正弦值。返回值范围为 [-1,1]。"
        ],
        "Illustration": [
            "x 是取值为任意实数（以弧度表示的角度）的数值数据类型或可以隐式转换为数值数据类型的参数。",
            "如果参数 x 数据类型是 BINARY_FLOAT，则该函数返回 BINARY_DOUBLE 数据类型。否则，该函数返回与参数 x 相同的数值数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SIN(0),SIN(30*3.14159265/180) FROM DUAL;\n+--------+-------------------------------------------+\n| SIN(0) | SIN(30*3.14159265/180)                    |\n+--------+-------------------------------------------+\n|      0 | .4999999994818579767701332168843926496529 |\n+--------+-------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0 度角和 30 度角的正弦值。",
            "obclient> SELECT SIN(0),SIN(30*3.14159265/180) FROM DUAL;\n+--------+-------------------------------------------+\n| SIN(0) | SIN(30*3.14159265/180)                    |\n+--------+-------------------------------------------+\n|      0 | .4999999994818579767701332168843926496529 |\n+--------+-------------------------------------------+\n1 row in set\n"
        ]
    },
    "SINH": {
        "Title": [
            "SINH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823146"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "SINH(number)\n",
        "Description": [
            "该函数是双曲正弦函数，返回数字参数的双曲正弦值。返回值范围是 (-∞,+∞)。"
        ],
        "Illustration": [
            "number 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "如果参数 number 是 BINARY_FLOAT 类型，则返回类型是 BINARY_DOUBLE。否则，返回与参数 number 相同的数值数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SINH(0) FROM DUAL;\n+---------+\n| SINH(0) |\n+---------+\n|       0 |\n+---------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 0 的双曲正弦值。",
            "obclient> SELECT SINH(0) FROM DUAL;\n+---------+\n| SINH(0) |\n+---------+\n|       0 |\n+---------+\n1 row in set\n"
        ]
    },
    "SQRT": {
        "Title": [
            "SQRT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823162"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "SQRT(numeric_expression)\n",
        "Description": [
            "该函数返回参数 numeric_expression 的平方根。"
        ],
        "Illustration": [
            "numeric_expression 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型且大于等于零的参数。",
            "返回与参数 numeric_expression 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SQRT(64),SQRT(50+50) FROM DUAL;\n+----------+-------------+\n| SQRT(64) | SQRT(50+50) |\n+----------+-------------+\n|        8 |          10 |\n+----------+-------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "计算 64 和 50+50 的平方根。",
            "obclient> SELECT SQRT(64),SQRT(50+50) FROM DUAL;\n+----------+-------------+\n| SQRT(64) | SQRT(50+50) |\n+----------+-------------+\n|        8 |          10 |\n+----------+-------------+\n1 row in set\n"
        ]
    },
    "STDDEV": {
        "Title": [
            "STDDEV"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822891"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "STDDEV([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数用于计算一组数值型数据标准差。它与函数 STDDEV_SAMP 的不同之处在于，STDDEV 只有一行输入数据时返回 0，而 STDDEV_SAMP 返回 NULL。OceanBase 数据库中标准差的值是函数 VARIANCE 计算出的方差的算术平方根。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：全部数值列。\nDISTINCT：去重关键字，表示计算唯一值的总体标准差。\nUNIQUE：去重关键字，表示计算唯一值的总体标准差。\n\n\n\nexpr\n数值类型或者可以转换成数值类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n",
            "返回 NUMBER 类型的数据。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT STDDEV(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV(SALARY)                            |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n",
            "obclient> SELECT last_name,hiredate,salary,STDDEV(salary) OVER (ORDER BY hiredate) \"StdDev\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | StdDev                                    |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |  212.132034355964257320253308631454711785 |\n| Raphaely  | 2017-07-22 |   1700 |  173.205080756887729352744634150587236694 |\n| De Haan   | 2018-05-01 |  11000 | 4702.127178203498995615489088200868644482 |\n| Partners  | 2018-12-01 |  14000 | 6064.899009876421676804205219406952308814 |\n| Russell   | 2019-07-11 |  13000 |  6138.94670661561181357873224397795992899 |\n| Hartstein | 2019-10-05 |  14000 | 6026.474330580265330900400184969999384459 |\n| Weiss     | 2019-10-05 |  13500 | 6026.474330580265330900400184969999384459 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表employees。",
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "计算列 salary 的标准差。",
            "obclient> SELECT STDDEV(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV(SALARY)                            |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "按列 hiredate 升序排序，计算列 salary 的累计标准差。",
            "obclient> SELECT last_name,hiredate,salary,STDDEV(salary) OVER (ORDER BY hiredate) \"StdDev\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | StdDev                                    |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |  212.132034355964257320253308631454711785 |\n| Raphaely  | 2017-07-22 |   1700 |  173.205080756887729352744634150587236694 |\n| De Haan   | 2018-05-01 |  11000 | 4702.127178203498995615489088200868644482 |\n| Partners  | 2018-12-01 |  14000 | 6064.899009876421676804205219406952308814 |\n| Russell   | 2019-07-11 |  13000 |  6138.94670661561181357873224397795992899 |\n| Hartstein | 2019-10-05 |  14000 | 6026.474330580265330900400184969999384459 |\n| Weiss     | 2019-10-05 |  13500 | 6026.474330580265330900400184969999384459 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"
        ]
    },
    "STDDEV_POP": {
        "Title": [
            "STDDEV_POP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822862"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "STDDEV_POP( [ALL] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数将数值型数据作为参数计算总体标准差。总体标准差是总体方差的算术平方根。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nALL\n指定全部数值列，为可选项。默认值为 ALL。\n\n\nexpr\n数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或者可以转换成数值类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回类型与参数 expr 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT STDDEV_POP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_POP(SALARY)                        |\n+-------------------------------------------+\n| 5637.250548804798333699350384281939588505 |\n+-------------------------------------------+\n1 row in set\n",
            "obclient> SELECT department_id,last_name,salary,STDDEV_POP(salary) OVER (PARTITION BY department_id) AS pop_std\n          FROM employees\n          ORDER BY department_id,last_name,salary;\n+---------------+-----------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | POP_STD                                   |\n+---------------+-----------+--------+-------------------------------------------+\n|            30 | De Haan   |  11000 |                                      4650 |\n|            30 | Raphaely  |   1700 |                                      4650 |\n|            40 | Errazuriz |   1400 |                                         0 |\n|            50 | Hartstein |  14000 | 5684.090858606052304285807872404592677763 |\n|            50 | Raphaely  |   1700 | 5684.090858606052304285807872404592677763 |\n|            50 | Weiss     |  13500 | 5684.090858606052304285807872404592677763 |\n|            90 | Partners  |  14000 |                                       500 |\n|            90 | Russell   |  13000 |                                       500 |\n+---------------+-----------+--------+-------------------------------------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 employees。",
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "求列 salary 的总体标准差。",
            "obclient> SELECT STDDEV_POP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_POP(SALARY)                        |\n+-------------------------------------------+\n| 5637.250548804798333699350384281939588505 |\n+-------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 department_id 分组，求列 salary 的总体标准差。",
            "obclient> SELECT department_id,last_name,salary,STDDEV_POP(salary) OVER (PARTITION BY department_id) AS pop_std\n          FROM employees\n          ORDER BY department_id,last_name,salary;\n+---------------+-----------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | POP_STD                                   |\n+---------------+-----------+--------+-------------------------------------------+\n|            30 | De Haan   |  11000 |                                      4650 |\n|            30 | Raphaely  |   1700 |                                      4650 |\n|            40 | Errazuriz |   1400 |                                         0 |\n|            50 | Hartstein |  14000 | 5684.090858606052304285807872404592677763 |\n|            50 | Raphaely  |   1700 | 5684.090858606052304285807872404592677763 |\n|            50 | Weiss     |  13500 | 5684.090858606052304285807872404592677763 |\n|            90 | Partners  |  14000 |                                       500 |\n|            90 | Russell   |  13000 |                                       500 |\n+---------------+-----------+--------+-------------------------------------------+\n8 rows in set\n"
        ]
    },
    "STDDEV_SAMP": {
        "Title": [
            "STDDEV_SAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822869"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "STDDEV_SAMP([ALL] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数将数值型数据作为参数计算样本标准差，样本标准差是样本方差的算术平方根。STDDEV_SAMP 与函数 STDDEV 的不同之处在于，STDDEV 只有一行输入数据时返回 0，而 STDDEV_SAMP 返回 NULL。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nALL\n全部数值列。为可选项，默认值 ALL。\n\n\nexpr\n数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或者可以转换成数值类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回类型与参数 expr 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT STDDEV_SAMP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_SAMP(SALARY)                       |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n",
            "obclient> SELECT department_id, last_name, hiredate, salary,\n                 STDDEV_SAMP(salary) OVER (PARTITION BY department_id\n                  ORDER BY hiredate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s_samp\n          FROM employees;\n+---------------+-----------+------------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | S_SAMP                                    |\n+---------------+-----------+------------+--------+-------------------------------------------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |                                      NULL |\n|            30 | De Haan   | 2018-05-01 |  11000 | 6576.093065034891976927852567575096065349 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |                                      NULL |\n|            50 | Raphaely  | 2017-07-22 |   1700 |                                      NULL |\n|            50 | Hartstein | 2019-10-05 |  14000 | 8697.413408594534550130385653889643183203 |\n|            50 | Weiss     | 2019-10-05 |  13500 | 6961.561127601576503543602300090640831831 |\n|            90 | Partners  | 2018-12-01 |  14000 |                                      NULL |\n|            90 | Russell   | 2019-07-11 |  13000 |  707.106781186547524400844362104849039285 |\n+---------------+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表employees。",
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "求列 salary 的标准差。",
            "obclient> SELECT STDDEV_SAMP(salary) FROM employees;\n+-------------------------------------------+\n| STDDEV_SAMP(SALARY)                       |\n+-------------------------------------------+\n| 6026.474330580265330900400184969999384459 |\n+-------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 department_id 分组和列 hiredate 升序排序，求列 salary 的标准差。",
            "obclient> SELECT department_id, last_name, hiredate, salary,\n                 STDDEV_SAMP(salary) OVER (PARTITION BY department_id\n                  ORDER BY hiredate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s_samp\n          FROM employees;\n+---------------+-----------+------------+--------+-------------------------------------------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY | S_SAMP                                    |\n+---------------+-----------+------------+--------+-------------------------------------------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |                                      NULL |\n|            30 | De Haan   | 2018-05-01 |  11000 | 6576.093065034891976927852567575096065349 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |                                      NULL |\n|            50 | Raphaely  | 2017-07-22 |   1700 |                                      NULL |\n|            50 | Hartstein | 2019-10-05 |  14000 | 8697.413408594534550130385653889643183203 |\n|            50 | Weiss     | 2019-10-05 |  13500 | 6961.561127601576503543602300090640831831 |\n|            90 | Partners  | 2018-12-01 |  14000 |                                      NULL |\n|            90 | Russell   | 2019-07-11 |  13000 |  707.106781186547524400844362104849039285 |\n+---------------+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"
        ]
    },
    "SUBSTR": {
        "Title": [
            "SUBSTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823182"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "SUBSTR(char1,n1[,n2])\n",
        "Description": [
            "该函数功能是从字符串中截取子字符串。其中多字节字符（汉字、全角符等）按 1 个字符计算。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n需要截取的字符串。字符串类型可为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nn1\n截取字符串的开始位置，数据类型是 NUMBER。 说明\n\n如果 n1 为 0，则将其视为 1，即从 char1 第一个字符开始截取。\n如果 n1 为正，则从 char1 第 n1 个字符开始查找截取。\n如果 n1 为负，则从 char1 的末尾开始倒数 n1 个字符，再开始查找截取。\n\n\n\nn2\n要截取的字符串的长度，数据类型是 NUMBER，为可选项。 说明\n\n如果不指定 n2，则从第 n1 个字符开始截取到 char1 结束的字符串。\n如果 n2 小于 0，则返回 NULL。\n\n\n\n",
            "返回与 char1 类型相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SUBSTR('OceanBase',1,5) \"SUBSTR1\",SUBSTR('OceanBase',-3,2.1) \"SUBSTR2\" FROM DUAL;\n+---------+---------+\n| SUBSTR1 | SUBSTR2 |\n+---------+---------+\n| Ocean   | as      |\n+---------+---------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "从字符串 OceanBase 的第 1 个字符开始截取 5 个字符和第 -3 个字符开始截取 2.1 个字符",
            "obclient> SELECT SUBSTR('OceanBase',1,5) \"SUBSTR1\",SUBSTR('OceanBase',-3,2.1) \"SUBSTR2\" FROM DUAL;\n+---------+---------+\n| SUBSTR1 | SUBSTR2 |\n+---------+---------+\n| Ocean   | as      |\n+---------+---------+\n1 row in set\n"
        ]
    },
    "SUM": {
        "Title": [
            "SUM"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822877"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "SUM([ DISTINCT | UNQIUE | ALL ] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数返回指定参数的总和。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNQIUE | ALL\n计算时是否去重。为可选项，默认值 ALL。 \n      \nALL：计算所有值，包含重复行，且忽略值为 NULL 的行。\nDISTINCT：去除重复行，且忽略值为 NULL 的行。\nUNIQUE：去除重复行，且忽略值为 NULL 的行。\n\n\n\nexpr\n数值数据类型或任何可以隐式转换为数值数据类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause 参数。\n",
            "返回与 expr 相同数据类型的值。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n",
            "obclient> SELECT department_id, last_name, salary,\n              SUM(salary) OVER\n                  (PARTITION BY department_id ORDER BY salary RANGE UNBOUNDED PRECEDING) s_sum\n    FROM employees\n    ORDER BY department_id,s_sum;\n+---------------+-----------+--------+-------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | S_SUM |\n+---------------+-----------+--------+-------+\n|            30 | Raphaely  |   1700 |  1700 |\n|            30 | De Haan   |  11000 | 12700 |\n|            40 | Errazuriz |   1400 |  1400 |\n|            50 | Raphaely  |   1700 |  1700 |\n|            50 | Weiss     |  13500 | 15200 |\n|            50 | Hartstein |  14000 | 29200 |\n|            90 | Russell   |  13000 | 13000 |\n|            90 | Partners  |  14000 | 27000 |\n+---------------+-----------+--------+-------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 employees。",
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "求表 employees 中列 salary 的总和。",
            "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n",
            "分析函数示例",
            "以列 department_id 分组及列 salary 升序排序，返回列 salary 的累计总和。",
            "obclient> SELECT department_id, last_name, salary,\n              SUM(salary) OVER\n                  (PARTITION BY department_id ORDER BY salary RANGE UNBOUNDED PRECEDING) s_sum\n    FROM employees\n    ORDER BY department_id,s_sum;\n+---------------+-----------+--------+-------+\n| DEPARTMENT_ID | LAST_NAME | SALARY | S_SUM |\n+---------------+-----------+--------+-------+\n|            30 | Raphaely  |   1700 |  1700 |\n|            30 | De Haan   |  11000 | 12700 |\n|            40 | Errazuriz |   1400 |  1400 |\n|            50 | Raphaely  |   1700 |  1700 |\n|            50 | Weiss     |  13500 | 15200 |\n|            50 | Hartstein |  14000 | 29200 |\n|            90 | Russell   |  13000 | 13000 |\n|            90 | Partners  |  14000 | 27000 |\n+---------------+-----------+--------+-------+\n8 rows in set\n"
        ]
    },
    "SYSDATE": {
        "Title": [
            "SYSDATE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823131"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "SYSDATE\n",
        "Description": [
            "该函数返回当前数据库服务器所在的操作系统的日期。",
            "\n注意\n该函数不依赖于当前会话时区，而是依赖于当前数据库服务器所在操作系统的时区。\n"
        ],
        "Illustration": [
            "返回 DATE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE,TO_CHAR (SYSDATE, 'MM-DD-YYYY HH24:MI:SS') \"NOW\" FROM DUAL;\n+-----------+---------------------+\n| SYSDATE   | NOW                 |\n+-----------+---------------------+\n| 18-NOV-21 | 11-18-2021 10:23:00 |\n+-----------+---------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "以下示例将当前时间按指定格式输出。",
            "obclient> SELECT SYSDATE,TO_CHAR (SYSDATE, 'MM-DD-YYYY HH24:MI:SS') \"NOW\" FROM DUAL;\n+-----------+---------------------+\n| SYSDATE   | NOW                 |\n+-----------+---------------------+\n| 18-NOV-21 | 11-18-2021 10:23:00 |\n+-----------+---------------------+\n1 row in set\n"
        ]
    },
    "SYSTIMESTAMP": {
        "Title": [
            "SYSTIMESTAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823118"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "SYSTIMESTAMP\n",
        "Description": [
            "该函数返回系统当前日期和时间，返回值的秒的小数位包含 6 位精度，且包含当前时区信息。",
            "\n注意\n该函数不依赖于当前会话时区，而是依赖于当前数据库服务器所在操作系统的时区。\n"
        ],
        "Illustration": [
            "返回 TIMESTAMP WITH TIME ZONE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSTIMESTAMP FROM DUAL;\n+-------------------------------------+\n| SYSTIMESTAMP                        |\n+-------------------------------------+\n| 18-NOV-21 10.32.27.176575 AM +08:00 |\n+-------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回系统当前日期且包含当前时区信息。",
            "obclient> SELECT SYSTIMESTAMP FROM DUAL;\n+-------------------------------------+\n| SYSTIMESTAMP                        |\n+-------------------------------------+\n| 18-NOV-21 10.32.27.176575 AM +08:00 |\n+-------------------------------------+\n1 row in set\n"
        ]
    },
    "SYS_CONNECT_BY_PATH": {
        "Title": [
            "SYS_CONNECT_BY_PATH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823142"
        ],
        "Category": [
            "Hierarchical Functions"
        ],
        "Feature": "SYS_CONNECT_BY_PATH(column,'char')\n",
        "Description": [
            "该函数返回从根到节点的列值的路径，由 CONNECT BY 条件返回的每一行的列值用指定分隔符号分隔。",
            "\n说明\n该函数仅在层次查询中有效。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ncolumn\n指定返回数据的列名。可以是 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型。\n\n\nchar\n指定分隔符号。可以是 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型。\n\n\n",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(z_id INT,name VARCHAR2(20),n_id INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(0,'ABC',''),\n    ->                (1,'An',0),(2,'Bn',0),(3,'Cn',0),\n    ->                (4,'A1',1),(5,'B1',2),(6,'C1',3),\n    ->                (7,'C2',6),(8,'A2',4),(9,'B2',5),\n    ->                (10,'A3',8),(11,'A4',10),(12,'B3',9);\nQuery OK, 13 rows affected\nRecords: 13  Duplicates: 0  Warnings: 0\n\nobclient> COMMIT;\nQuery OK, 0 rows affected\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| Z_ID | NAME | N_ID |\n+------+------+------+\n|    0 | ABC  | NULL |\n|    1 | An   |    0 |\n|    2 | Bn   |    0 |\n|    3 | Cn   |    0 |\n|    4 | A1   |    1 |\n|    5 | B1   |    2 |\n|    6 | C1   |    3 |\n|    7 | C2   |    6 |\n|    8 | A2   |    4 |\n|    9 | B2   |    5 |\n|   10 | A3   |    8 |\n|   11 | A4   |   10 |\n|   12 | B3   |    9 |\n+------+------+------+\n13 rows in set\n\nobclient> SELECT z_id,name,n_id,SYS_CONNECT_BY_PATH(name, '/') \"Path\"\n          FROM tbl1\n          START WITH n_id IS NULL\n          CONNECT BY PRIOR n_id = z_id\n          ORDER BY z_id;\n+------+------+------+---------------------+\n| Z_ID | NAME | N_ID | Path                |\n+------+------+------+---------------------+\n|    0 | ABC  | NULL | /ABC                |\n|    1 | An   |    0 | /ABC/An             |\n|    2 | Bn   |    0 | /ABC/Bn             |\n|    3 | Cn   |    0 | /ABC/Cn             |\n|    4 | A1   |    1 | /ABC/An/A1          |\n|    5 | B1   |    2 | /ABC/Bn/B1          |\n|    6 | C1   |    3 | /ABC/Cn/C1          |\n|    7 | C2   |    6 | /ABC/Cn/C1/C2       |\n|    8 | A2   |    4 | /ABC/An/A1/A2       |\n|    9 | B2   |    5 | /ABC/Bn/B1/B2       |\n|   10 | A3   |    8 | /ABC/An/A1/A2/A3    |\n|   11 | A4   |   10 | /ABC/An/A1/A2/A3/A4 |\n|   12 | B3   |    9 | /ABC/Bn/B1/B2/B3    |\n+------+------+------+---------------------+\n13 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1 并插入测试数据，其中列 name 的 ABC 是根值，其它值为节点。查询列 name 中值到 ABC 的所有路径。",
            "obclient> CREATE TABLE tbl1(z_id INT,name VARCHAR2(20),n_id INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(0,'ABC',''),\n    ->                (1,'An',0),(2,'Bn',0),(3,'Cn',0),\n    ->                (4,'A1',1),(5,'B1',2),(6,'C1',3),\n    ->                (7,'C2',6),(8,'A2',4),(9,'B2',5),\n    ->                (10,'A3',8),(11,'A4',10),(12,'B3',9);\nQuery OK, 13 rows affected\nRecords: 13  Duplicates: 0  Warnings: 0\n\nobclient> COMMIT;\nQuery OK, 0 rows affected\n\nobclient> SELECT * FROM tbl1;\n+------+------+------+\n| Z_ID | NAME | N_ID |\n+------+------+------+\n|    0 | ABC  | NULL |\n|    1 | An   |    0 |\n|    2 | Bn   |    0 |\n|    3 | Cn   |    0 |\n|    4 | A1   |    1 |\n|    5 | B1   |    2 |\n|    6 | C1   |    3 |\n|    7 | C2   |    6 |\n|    8 | A2   |    4 |\n|    9 | B2   |    5 |\n|   10 | A3   |    8 |\n|   11 | A4   |   10 |\n|   12 | B3   |    9 |\n+------+------+------+\n13 rows in set\n\nobclient> SELECT z_id,name,n_id,SYS_CONNECT_BY_PATH(name, '/') \"Path\"\n          FROM tbl1\n          START WITH n_id IS NULL\n          CONNECT BY PRIOR n_id = z_id\n          ORDER BY z_id;\n+------+------+------+---------------------+\n| Z_ID | NAME | N_ID | Path                |\n+------+------+------+---------------------+\n|    0 | ABC  | NULL | /ABC                |\n|    1 | An   |    0 | /ABC/An             |\n|    2 | Bn   |    0 | /ABC/Bn             |\n|    3 | Cn   |    0 | /ABC/Cn             |\n|    4 | A1   |    1 | /ABC/An/A1          |\n|    5 | B1   |    2 | /ABC/Bn/B1          |\n|    6 | C1   |    3 | /ABC/Cn/C1          |\n|    7 | C2   |    6 | /ABC/Cn/C1/C2       |\n|    8 | A2   |    4 | /ABC/An/A1/A2       |\n|    9 | B2   |    5 | /ABC/Bn/B1/B2       |\n|   10 | A3   |    8 | /ABC/An/A1/A2/A3    |\n|   11 | A4   |   10 | /ABC/An/A1/A2/A3/A4 |\n|   12 | B3   |    9 | /ABC/Bn/B1/B2/B3    |\n+------+------+------+---------------------+\n13 rows in set\n"
        ]
    },
    "SYS_CONTEXT": {
        "Title": [
            "SYS_CONTEXT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823178"
        ],
        "Category": [
            "Environment and Identifier Functions"
        ],
        "Feature": "SYS_CONTEXT('namespace', 'parameter' [, length ])\n",
        "Description": [
            "该函数返回当前时刻与上下文命名空间关联的参数的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nnamespace\n指定命名空间。目前仅支持 USERENV。\n\n\nparameter\n指定命名空间关联的参数。目前支持的参数如下表 命名空间 USERENV 的预定义参数 所示。\n\n\nlength\n指定返回值的长度，单位为字节，为可选项。取值范围是 [1, 4000]，默认长度是 256 字节。\n\n\n",
            "命名空间 USERENV 的预定义参数",
            "\n\n\n参数名\n返回值\n\n\n\n\nCON_ID\n如果在连接到 CDB（Container DataBase）时查询，则返回当前容器 ID。否则，返回 0。\n\n\nCON_NAME\n如果在连接到 CDB 时进行查询，则返回当前容器名称。否则，返回 DB_NAME 参数指定的数据库名称。\n\n\nCURRENT_SCHEMA\n当前活动的默认 Schema 名称。\n\n\nCURRENT_SCHEMAID\n当前活动的默认 Schema ID。\n\n\nCURRENT_USER\n当前权限处于活动状态的数据库用户名。\n\n\nCURRENT_USERID\n当前权限处于活动状态的数据库用户 ID。\n\n\nDB_NAME\n数据库名称。\n\n\nINSTANCE\n当前实例的标识号。\n\n\nINSTANCE_NAME\n当前实例名称。\n\n\nIP_ADDRESS\n客户端的机器 IP 地址。\n\n\nLANG\n语言的缩写名称，比 LANGUAGE 参数更短的格式。\n\n\nLANGUAGE\n当前会话使用的语言和区域，以及数据库字符集。\n\n\nSESSION_USER\n登录的数据库用户名，在整个会话期间该值保持不变。\n\n\nSESSION_USERID\n登录的数据库用户 ID。\n\n\nSID | SESSIONID\n获取当前会话的 Client Session ID，该 ID 是会话在客户端中的唯一标识。\n\n\n",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient [SYS]> SELECT SYS_CONTEXT ('USERENV', 'SESSIONID') AS Client_Session_ID FROM DUAL;\n",
            "obclient [SYS]> SELECT SYS_CONTEXT ('USERENV', 'SID') AS Client_Session_ID FROM DUAL;\n",
            "+-------------------+\n| CLIENT_SESSION_ID |\n+-------------------+\n| 3221488043        |\n+-------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "查看命名空间 USERENV 中会话的 Client Session ID。",
            "obclient [SYS]> SELECT SYS_CONTEXT ('USERENV', 'SESSIONID') AS Client_Session_ID FROM DUAL;\n",
            "或",
            "obclient [SYS]> SELECT SYS_CONTEXT ('USERENV', 'SID') AS Client_Session_ID FROM DUAL;\n",
            "返回结果如下：",
            "+-------------------+\n| CLIENT_SESSION_ID |\n+-------------------+\n| 3221488043        |\n+-------------------+\n1 row in set\n"
        ]
    },
    "SYS_EXTRACT_UTC": {
        "Title": [
            "SYS_EXTRACT_UTC"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823127"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "SYS_EXTRACT_UTC (datetime_with_timezone)\n",
        "Description": [
            "该函数是从具有时区偏移的日期时间值中返回与指定时间相对应的标准 UTC 时间。如果未指定时区，则指定日期时间与当前会话时区相关联。",
            "\n说明\nUTC（Universal Time Coordinated）是通用协调时间。UTC 与格林尼治标准时间（GMT, Greenwich Mean Time）一样，都与英国伦敦的本地时相同。\n"
        ],
        "Illustration": [
            "datetime_with_timezone 是 TIMESTAMP WITH TIME ZONE 或 TIMESTAMP WITH LOCAL TIME ZONE 数据类型的值。",
            "返回 TIMESTAMP 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYS_EXTRACT_UTC(TIMESTAMP '2021-11-18 10:08:08.18 +08:00') \"SYS_EXTRACT_UTC\" FROM DUAL;\n+---------------------------------+\n| SYS_EXTRACT_UTC                 |\n+---------------------------------+\n| 18-NOV-21 02.08.08.180000000 AM |\n+---------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 2021-11-18 10:08:08.18 +08:00 的标准 UTC 时间。",
            "obclient> SELECT SYS_EXTRACT_UTC(TIMESTAMP '2021-11-18 10:08:08.18 +08:00') \"SYS_EXTRACT_UTC\" FROM DUAL;\n+---------------------------------+\n| SYS_EXTRACT_UTC                 |\n+---------------------------------+\n| 18-NOV-21 02.08.08.180000000 AM |\n+---------------------------------+\n1 row in set\n"
        ]
    },
    "SYS_GUID": {
        "Title": [
            "SYS_GUID"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823176"
        ],
        "Category": [
            "Environment and Identifier Functions"
        ],
        "Feature": "SYS_GUID()\n",
        "Description": [
            "该函数生成并返回由 16 个字节组成的全局唯一标识符，即生成一个全局唯一序列号。"
        ],
        "Illustration": [
            "返回十六进制表示形式的长度为 32 个字符的字符串。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 INT,col2 RAW(16));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,SYS_GUID()),(2,SYS_GUID()),(3,SYS_GUID());\nQuery OK, 3 rows affected\nRecords: 3  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+----------------------------------+\n| COL1 | COL2                             |\n+------+----------------------------------+\n|    1 | 442E52AC599411EC8C99B6945CA6C7B0 |\n|    2 | 442EC8D1599411EC8C99B6945CA6C7B0 |\n|    3 | 442ED1F1599411EC8C99B6945CA6C7B0 |\n+------+----------------------------------+\n3 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入三条具有唯一标识符的数据。",
            "obclient> CREATE TABLE tbl1(col1 INT,col2 RAW(16));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,SYS_GUID()),(2,SYS_GUID()),(3,SYS_GUID());\nQuery OK, 3 rows affected\nRecords: 3  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+----------------------------------+\n| COL1 | COL2                             |\n+------+----------------------------------+\n|    1 | 442E52AC599411EC8C99B6945CA6C7B0 |\n|    2 | 442EC8D1599411EC8C99B6945CA6C7B0 |\n|    3 | 442ED1F1599411EC8C99B6945CA6C7B0 |\n+------+----------------------------------+\n3 rows in set\n"
        ]
    },
    "TAN": {
        "Title": [
            "TAN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823168"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "TAN(x)\n",
        "Description": [
            "该函数是正切函数，返回角度的正切值。"
        ],
        "Illustration": [
            "x 是取值为任意实数（以弧度表示的角度）的数值数据类型或可以隐式转换为数值数据类型的参数。",
            "如果参数 x 数据类型是 BINARY_FLOAT，则该函数返回 BINARY_DOUBLE 数据类型。否则，该函数返回与参数 x 相同的数值数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TAN(0),TAN(135*3.1415926/180) FROM DUAL;\n+--------+-------------------------------------------+\n| TAN(0) | TAN(135*3.1415926/180)                    |\n+--------+-------------------------------------------+\n|      0 | -1.00000008038469308854331997429109563738 |\n+--------+-------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "计算 0 度和 135 度的正切值。",
            "obclient> SELECT TAN(0),TAN(135*3.1415926/180) FROM DUAL;\n+--------+-------------------------------------------+\n| TAN(0) | TAN(135*3.1415926/180)                    |\n+--------+-------------------------------------------+\n|      0 | -1.00000008038469308854331997429109563738 |\n+--------+-------------------------------------------+\n1 row in set\n"
        ]
    },
    "TANH": {
        "Title": [
            "TANH"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823152"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "TANH(number)\n",
        "Description": [
            "该函数是双曲正切函数，返回数值参数的双曲正切值。返回值范围是 (-1,1)。"
        ],
        "Illustration": [
            "number 是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）或可以隐式转换为数值数据类型的参数。",
            "如果参数 number 是 BINARY_FLOAT 类型，则返回类型是 BINARY_DOUBLE。否则，返回与参数 number 相同的数值数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TANH(1) FROM DUAL;\n+-------------------------------------------+\n| TANH(1)                                   |\n+-------------------------------------------+\n| .7615941559557648881194582826047935904128 |\n+-------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回 1 的双曲正切值。",
            "obclient> SELECT TANH(1) FROM DUAL;\n+-------------------------------------------+\n| TANH(1)                                   |\n+-------------------------------------------+\n| .7615941559557648881194582826047935904128 |\n+-------------------------------------------+\n1 row in set\n"
        ]
    },
    "TIMESTAMP_TO_SCN": {
        "Title": [
            "TIMESTAMP_TO_SCN"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823227"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TIMESTAMP_TO_SCN(timestamp)\n",
        "Description": [
            "TIMESTAMP_TO_SCN() 函数将时间戳类型的参数作为输入并返回对应的 SCN（System Change Number）。该函数的输入参数类型为 TIMESTAMP 类型，返回值的数据类型为 NUMBER。"
        ],
        "Illustration": [],
        "Examples": [
            "obclient> SELECT TIMESTAMP_TO_SCN('2022-06-16 11:50:30.123451234') FROM DUAL;\n+--------------------------------------------------+\n| TIMESTAMP_TO_SCN('2022-06-1611:50:30.123451234') |\n+--------------------------------------------------+\n|                              1655351430123451234 |\n+--------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "obclient> SELECT TIMESTAMP_TO_SCN('2022-06-16 11:50:30.123451234') FROM DUAL;\n+--------------------------------------------------+\n| TIMESTAMP_TO_SCN('2022-06-1611:50:30.123451234') |\n+--------------------------------------------------+\n|                              1655351430123451234 |\n+--------------------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_BINARY_DOUBLE": {
        "Title": [
            "TO_BINARY_DOUBLE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823216"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_BINARY_DOUBLE(expr [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数返回一个双精度浮点数。",
            "\n说明\n从字符串或 NUMBER 到 BINARY_DOUBLE 的转换可能不准确，因为 NUMBER 和字符类型使用十进制精度表示数值，而 BINARY_DOUBLE 使用二进制精度。从 BINARY_FLOAT 到 BINARY_DOUBLE 的转换是准确的。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n字符串或 NUMBER、BINARY_FLOAT 或 BINARY_DOUBLE 类型的数值。\n\n\nfmt\n输出格式参数，为可选项。如果省略 fmt，则 n 被转换为 VARCHAR2 值。取值信息请参见 fmt 参数列表。\n\n\nnlsparam\n定义十进制字符、组分隔符、当地货币符号和国际货币符号，为可选项。\n\n\n",
            "\n说明\n当 expr 是字符串时，可选的 fmt 和 nlsparam 参数才有效。它们的作用与 TO_CHAR (number) 功能的作用相同。当 expr 为 BINARY_DOUBLE，则该函数返回 expr。\n",
            "返回 BINARY_DOUBLE 类型的数据。"
        ],
        "Examples": [
            "obclient> SELECT TO_BINARY_DOUBLE('123.123') FROM DUAL;\n+-----------------------------+\n| TO_BINARY_DOUBLE('123.123') |\n+-----------------------------+\n|                1.23123E+002 |\n+-----------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 123.123 转化为双精度浮点数。",
            "obclient> SELECT TO_BINARY_DOUBLE('123.123') FROM DUAL;\n+-----------------------------+\n| TO_BINARY_DOUBLE('123.123') |\n+-----------------------------+\n|                1.23123E+002 |\n+-----------------------------+\n1 row in set\n"
        ]
    },
    "TO_BINARY_FLOAT": {
        "Title": [
            "TO_BINARY_FLOAT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823237"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_BINARY_FLOAT(expr [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数返回一个单精度浮点数。",
            "\n说明\n从字符串或 NUMBER 到 BINARY_FLOAT 的转换可能不精确，因为 NUMBER 和字符类型使用十进制精度表示数值，而 BINARY_FLOAT 使用二进制精度。如果 BINARY_DOUBLE 值使用的精度比BINARY_FLOAT 支持的精度高，则从 BINARY_DOUBLE 到 BINARY_FLOAT 的转换是不精确的。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n字符串或 NUMBER、BINARY_FLOAT 或 BINARY_DOUBLE 类型的数据。\n\n\nexpr\n输出格式参数，为可选项。如果省略 fmt，则 n 被转换为 VARCHAR2 值。取值信息请参见 fmt 参数列表。\n\n\nnlsparam\n定义十进制字符、组分隔符、当地货币符号和国际货币符号，为可选项。\n\n\n",
            "\n说明\n当 expr 是字符串时，可选的 fmt 和 nlsparam 参数才有效。它们的作用与 TO_CHAR (number) 功能的作用相同。当 expr 为 BINARY_FLOAT，则函数返回 expr。\n",
            "返回 BINARY_FLOAT 类型的数据。"
        ],
        "Examples": [
            "obclient> SELECT TO_BINARY_FLOAT('123.123') FROM DUAL;\n+----------------------------+\n| TO_BINARY_FLOAT('123.123') |\n+----------------------------+\n|            1.23123001E+002 |\n+----------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 123.123 转化为单精度浮点数。",
            "obclient> SELECT TO_BINARY_FLOAT('123.123') FROM DUAL;\n+----------------------------+\n| TO_BINARY_FLOAT('123.123') |\n+----------------------------+\n|            1.23123001E+002 |\n+----------------------------+\n1 row in set\n"
        ]
    },
    "TO_BLOB": {
        "Title": [
            "TO_BLOB"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823242"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_BLOB( raw_value )\n",
        "Description": [
            "该函数将 LONG RAW 值和 RAW 值转换为 BLOB 值。"
        ],
        "Illustration": [
            "参数 raw_value 是 LONG RAW 或 RAW 类型的值。",
            "返回 BLOB 的类型。"
        ],
        "Examples": [
            "obclient> SELECT COL_RAW,LENGTHB(COL_RAW) \"LENGTHB_RAW\",LENGTHB(TO_BLOB(COL_RAW)) \"LENGTHB_BLOB\"\n          FROM tbl_raw;\n+------------------+-------------+--------------+\n| COL_RAW          | LENGTHB_RAW | LENGTHB_BLOB |\n+------------------+-------------+--------------+\n| 0ABC             |           4 |            2 |\n| 0123456789ABCDEF |          16 |            8 |\n+------------------+-------------+--------------+\n2 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 tbl_raw，将 RAW 类型的值转换为 BLOB 值并返回对应字节长度。",
            "obclient> SELECT COL_RAW,LENGTHB(COL_RAW) \"LENGTHB_RAW\",LENGTHB(TO_BLOB(COL_RAW)) \"LENGTHB_BLOB\"\n          FROM tbl_raw;\n+------------------+-------------+--------------+\n| COL_RAW          | LENGTHB_RAW | LENGTHB_BLOB |\n+------------------+-------------+--------------+\n| 0ABC             |           4 |            2 |\n| 0123456789ABCDEF |          16 |            8 |\n+------------------+-------------+--------------+\n2 rows in set\n"
        ]
    },
    "TO_CHAR (character)": {
        "Title": [
            "TO_CHAR (character)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823243"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_CHAR(character)\n",
        "Description": [
            "该函数将 NCHAR、NVARCHAR2 或 CLOB 类型的数据转换为 VARCHAR2 数据类型。",
            "\n说明\n当函数将字符 LOB 转换为数据库字符集时，如果要转换的 LOB 值大于目标类型，则数据库返回错误。\n"
        ],
        "Illustration": [
            "参数 character 指定要转换为 VARCHAR2 数据类型表达式，数据类型可以是 NCHAR、NVARCHAR2 或 CLOB。",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_CHAR('010101') FROM DUAL;\n+-------------------+\n| TO_CHAR('010101') |\n+-------------------+\n| 010101            |\n+-------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 010101 转换为字符数据。",
            "obclient> SELECT TO_CHAR('010101') FROM DUAL;\n+-------------------+\n| TO_CHAR('010101') |\n+-------------------+\n| 010101            |\n+-------------------+\n1 row in set\n"
        ]
    },
    "TO_CHAR (datetime)": {
        "Title": [
            "TO_CHAR (datetime)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823122"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "TO_CHAR({ datetime | interval } [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数将日期时间或时间间隔值 DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE、INTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH 等数据类型的值按照参数 fmt 指定的格式转换为 VARCHAR2 数据类型的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndatetime | interval\n指定转换的字符类型。 \n      \ndatetime 属于日期时间，DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE、INTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH 等数据类型的值。\ninterval 属于时间间隔值。\n\n\n\nfmt\n指定输出格式，为可选项。如果不指定参数 fmt，则参数 datetime 的值将按如下格式转换为 VARCHAR2 数据类型： \n      \nDATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE 和 TIMESTAMP WITH LOCAL TIME ZONE 的值被转换为数据库中日期时间值的默认格式。您可在 日期时间和间隔数据类型 章节中查看各日期时间类型的默认格式。\nINTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH 数据类型的值转换为数字格式的间隔值。\n\n\n\nnlsparam\n用来控制返回的月份和日期所使用的语言。\n\n\n",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_CHAR(SYSDATE,'yyyy/mm/dd'),TO_CHAR(SYSDATE,'DS DL') FROM DUAL;\n+-------------------------------+----------------------------------------+\n| TO_CHAR(SYSDATE,'YYYY/MM/DD') | TO_CHAR(SYSDATE,'DSDL')                |\n+-------------------------------+----------------------------------------+\n| 2021/11/18                    | 11/18/2021 Thursday, November 18, 2021 |\n+-------------------------------+----------------------------------------+\n1 row in set\n",
            "obclient> SELECT TO_CHAR(interval'1' year, 'SS-MI-HH', 'nls_language = AMERICAN') FROM DUAL;\n+-------------------------------------------------------------+\n| TO_CHAR(INTERVAL'1'YEAR,'SS-MI-HH','NLS_LANGUAGE=AMERICAN') |\n+-------------------------------------------------------------+\n| +01-00                                                      |\n+-------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "通过 TO_CHAR 函数返回系统当前日期，并且将日期时间值转换为 DS DL 格式。",
            "obclient> SELECT TO_CHAR(SYSDATE,'yyyy/mm/dd'),TO_CHAR(SYSDATE,'DS DL') FROM DUAL;\n+-------------------------------+----------------------------------------+\n| TO_CHAR(SYSDATE,'YYYY/MM/DD') | TO_CHAR(SYSDATE,'DSDL')                |\n+-------------------------------+----------------------------------------+\n| 2021/11/18                    | 11/18/2021 Thursday, November 18, 2021 |\n+-------------------------------+----------------------------------------+\n1 row in set\n",
            "将间隔值转化为指定格式，并且设置返回语言为 AMERICAN。",
            "obclient> SELECT TO_CHAR(interval'1' year, 'SS-MI-HH', 'nls_language = AMERICAN') FROM DUAL;\n+-------------------------------------------------------------+\n| TO_CHAR(INTERVAL'1'YEAR,'SS-MI-HH','NLS_LANGUAGE=AMERICAN') |\n+-------------------------------------------------------------+\n| +01-00                                                      |\n+-------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_CHAR (number)": {
        "Title": [
            "TO_CHAR (number)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823228"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_CHAR(n [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数将 NUMBER、BINARY_FLOAT 或 BINARY_DOUBLE 类型的数值按照指定数值格式转换为 varchar2 数据类型的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nn\n属于 NUMBER、BINARY_FLOAT 或 BINARY_DOUBLE 数据类型的数值。 说明 如果 n 为负值，则负号显示在输出值最左侧，例如 TO_CHAR(-1,'$9') 返回 -$1，而不是 $-1。\n\n\nfmt\n输出格式参数，为可选项。如果省略 fmt，则 n 被转换为 VARCHAR2 值。取值信息请参见 fmt 参数列表。\n\n\nnlsparam\n定义十进制字符、组分隔符、当地货币符号和国际货币符号，为可选项。\n\n\n",
            "fmt 参数列表",
            "\n\n\nfmt 参数取值\n说明\n\n\n\n\n9\n返回指定位数的值。\n\n\n0\n它返回前导 0。\n\n\n,（逗号）\n返回指定位置的逗号。您可以在数字格式模型中指定多个逗号。 限制条件 ：格式模型数值不能以逗号开头，且逗号不能出现在小数字符或句点的右边。\n\n\n.（小数点）\n返回一个小数，且小数点在指定位置。 限制条件 ：在数字格式模型中，您只能指定一个小数点。\n\n\n",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_CHAR(123456789.123,'999,999,999') FROM DUAL;\n+--------------------------------------+\n| TO_CHAR(123456789.123,'999,999,999') |\n+--------------------------------------+\n|  123,456,789                         |\n+--------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将 123456789.123 转化为 999,999,999 格式的值。",
            "obclient> SELECT TO_CHAR(123456789.123,'999,999,999') FROM DUAL;\n+--------------------------------------+\n| TO_CHAR(123456789.123,'999,999,999') |\n+--------------------------------------+\n|  123,456,789                         |\n+--------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_CLOB": {
        "Title": [
            "TO_CLOB"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823235"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_CLOB(lob_column | char)\n",
        "Description": [
            "该函数将 LOB 列或其他字符串中的 NCLOB 值转换为 CLOB 值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nlob_column\n属于 LOB 列或其他字符串中的 NCLOB 值。\n\n\nchar\n属于 CHAR、VARCHAR2、NCHAR、NVARCHAR2、CLOB 或 NCLOB 类型的值。\n\n\n",
            "返回 CLOB 类型。"
        ],
        "Examples": [
            "obclient> DESC tbl_nclob;\n+----------+---------------+------+-----+---------+-------+\n| FIELD    | TYPE          | NULL | KEY | DEFAULT | EXTRA |\n+----------+---------------+------+-----+---------+-------+\n| COL1     | NUMBER(38)    | YES  | NULL | NULL    | NULL  |\n| COL_CHAR | VARCHAR2(100) | YES  | NULL | NULL    | NULL  |\n| COL_CLOB | CLOB          | YES  | NULL | NULL    | NULL  |\n+----------+---------------+------+-----+---------+-------+\n3 rows in set\n\nobclient> UPDATE tbl_nclob SET col_clob = TO_CLOB (col_char);\nQuery OK, 1 row affected\nRows matched: 1  Changed: 1  Warnings: 0\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 tbl_nclob，现将 VARCHAR2 类型的值转换为 CLOB 类型的值并将其插入 CLOB 类型的列中。",
            "obclient> DESC tbl_nclob;\n+----------+---------------+------+-----+---------+-------+\n| FIELD    | TYPE          | NULL | KEY | DEFAULT | EXTRA |\n+----------+---------------+------+-----+---------+-------+\n| COL1     | NUMBER(38)    | YES  | NULL | NULL    | NULL  |\n| COL_CHAR | VARCHAR2(100) | YES  | NULL | NULL    | NULL  |\n| COL_CLOB | CLOB          | YES  | NULL | NULL    | NULL  |\n+----------+---------------+------+-----+---------+-------+\n3 rows in set\n\nobclient> UPDATE tbl_nclob SET col_clob = TO_CLOB (col_char);\nQuery OK, 1 row affected\nRows matched: 1  Changed: 1  Warnings: 0\n"
        ]
    },
    "TO_DATE": {
        "Title": [
            "TO_DATE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823231"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_DATE(char [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数将 CHAR、VARCHAR、NCHAR 或 NVARCHAR2 数据类型的字符转换为日期数据类型的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\nCHAR、VARCHAR、NCHAR 或 NVARCHAR2 数据类型的值。\n\n\nfmt\n指定 char 的时间格式，为可选项。如果省略 fmt，则 char 必须采用默认日期格式，默认日期格式由 nls_territory 初始化参数隐式指定或由 nls_date_format 参数显式指定。\n\n\nnlsparam\n指定要转换为日期的文本字符串的语言，为可选项。\n\n\n",
            "返回 DATE 类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_DATE('202111','YYYYMM'),\n    TO_DATE('2021.11.11','YYYY.MM.DD'),\n    TO_DATE('2021-11-11 11:11:11','YYYY-MM-DD HH24:MI:SS')\n    FROM DUAL;\n+----------------------------+------------------------------------+------------------------------------------------------+\n| TO_DATE('202111','YYYYMM') | TO_DATE('2021.11.11','YYYY.MM.DD') | TO_DATE('2021-11-1111:11:11','YYYY-MM-DDHH24:MI:SS') |\n+----------------------------+------------------------------------+------------------------------------------------------+\n| 01-NOV-21                  | 11-NOV-21                          | 11-NOV-21                                            |\n+----------------------------+------------------------------------+------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 202111、2021.11.11 和 2021-11-11 11:11:11 转换为日期数据类型的值。",
            "obclient> SELECT TO_DATE('202111','YYYYMM'),\n    TO_DATE('2021.11.11','YYYY.MM.DD'),\n    TO_DATE('2021-11-11 11:11:11','YYYY-MM-DD HH24:MI:SS')\n    FROM DUAL;\n+----------------------------+------------------------------------+------------------------------------------------------+\n| TO_DATE('202111','YYYYMM') | TO_DATE('2021.11.11','YYYY.MM.DD') | TO_DATE('2021-11-1111:11:11','YYYY-MM-DDHH24:MI:SS') |\n+----------------------------+------------------------------------+------------------------------------------------------+\n| 01-NOV-21                  | 11-NOV-21                          | 11-NOV-21                                            |\n+----------------------------+------------------------------------+------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_DSINTERVAL": {
        "Title": [
            "TO_DSINTERVAL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823134"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "/*SQL 日期格式*/\nTO_DSINTERVAL ('[+ | -] days hours:minutes:seconds[.frac_secs]')\n\n/*ISO 日期格式*/\nTO_DSINTERVAL ('[-] P[days D]\n[T[hours H][minutes M][seconds[.frac_secs]S]]')\n",
        "Description": [
            "该函数将一个 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串转换为一个 INTERVAL DAY TO SECOND 数据类型的值，可以用来对一个日期时间值进行加减计算。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\n[+ | -]days hours：minutes：seconds[.frac_secs]\n符合该参数格式的 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串。 \n      \ndays 表示天，取整数值，范围为 [0,999999999]。\nhours 表示小时，取整数值，范围为 [0,23]。\nminutes 表示分钟，取整数值，范围为 [0,59]。\nseconds 表示秒，取整数值，范围为 [0,59]。\n\n\n\n[-] P[days D] [T[hours H][minutes M][seconds[.frac_secs]S]\n符合该参数格式的 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串。 注意 值中不允许有空格。\n\n\nfrac_secs\n表示秒的小数部分，取整数值，范围为 [0,999999999]。\n\n\n",
            "返回 INTERVAL DAY TO SECOND 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_CHAR(TIMESTAMP '2021-11-11 00:00:00'+TO_DSINTERVAL('100 00:00:00'),\n     'YYYY-MM-DD HH24:MI:SS') \"Time Stamp\" FROM DUAL;\n+---------------------+\n| Time Stamp          |\n+---------------------+\n| 2022-02-19 00:00:00 |\n+---------------------+\n1 row in set\n",
            "obclient> SELECT TO_CHAR(TIMESTAMP '2021-11-11 00:00:00'+TO_DSINTERVAL('P100DT5H'),\n    'YYYY-MM-DD HH24:MI:SS') \"Time Stamp\" FROM DUAL;\n+---------------------+\n| Time Stamp          |\n+---------------------+\n| 2022-02-19 05:00:00 |\n+---------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "以 SQL 格式返回 2021 年 11 月 11 日在 100 天后的日期时间值。",
            "obclient> SELECT TO_CHAR(TIMESTAMP '2021-11-11 00:00:00'+TO_DSINTERVAL('100 00:00:00'),\n     'YYYY-MM-DD HH24:MI:SS') \"Time Stamp\" FROM DUAL;\n+---------------------+\n| Time Stamp          |\n+---------------------+\n| 2022-02-19 00:00:00 |\n+---------------------+\n1 row in set\n",
            "以 ISO 格式返回 2021 年 12 月 12 日在 100 天 10 小时后的日期时间值。",
            "obclient> SELECT TO_CHAR(TIMESTAMP '2021-11-11 00:00:00'+TO_DSINTERVAL('P100DT5H'),\n    'YYYY-MM-DD HH24:MI:SS') \"Time Stamp\" FROM DUAL;\n+---------------------+\n| Time Stamp          |\n+---------------------+\n| 2022-02-19 05:00:00 |\n+---------------------+\n1 row in set\n"
        ]
    },
    "TO_MULTI_BYTE": {
        "Title": [
            "TO_MULTI_BYTE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823234"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_MULTI_BYTE(char)\n",
        "Description": [
            "该函数用于将所有单字节字符转换为相应的多字节字符。仅当您的数据库字符集同时包含单字节和多字节字符时，此函数才有效。"
        ],
        "Illustration": [
            "char 可以是数据类型 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。如果 char 中任何单字节字符没有多字节等效项，则在输出字符串中显示为单字节字符。",
            "返回值与 char 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT dump(TO_MULTI_BYTE( 'B')) FROM DUAL;\n+---------------------------+\n| DUMP(TO_MULTI_BYTE('B'))  |\n+---------------------------+\n| Typ=22 Len=3: 239,188,162 |\n+---------------------------+\n1 row in set\n",
            "obclient> SELECT TO_MULTI_BYTE('中国A') text FROM DUAL;\n+-----------+\n| TEXT      |\n+-----------+\n| 中国Ａ    |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "从单字节 B 转换为 UTF8 中的多字节 B。",
            "obclient> SELECT dump(TO_MULTI_BYTE( 'B')) FROM DUAL;\n+---------------------------+\n| DUMP(TO_MULTI_BYTE('B'))  |\n+---------------------------+\n| Typ=22 Len=3: 239,188,162 |\n+---------------------------+\n1 row in set\n",
            "将字符串中的半角字符转化为全角字符。",
            "obclient> SELECT TO_MULTI_BYTE('中国A') text FROM DUAL;\n+-----------+\n| TEXT      |\n+-----------+\n| 中国Ａ    |\n+-----------+\n1 row in set\n"
        ]
    },
    "TO_NCHAR (character)": {
        "Title": [
            "TO_NCHAR (character)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823223"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_NCHAR(character)\n",
        "Description": [
            "该函数将 CHAR、VARCHAR2、CLOB 或 NCLOB 类型的数据转换为国家字符集，返回 NVARCHAR2 数据类型。"
        ],
        "Illustration": [
            "character 可以是 CHAR、VARCHAR2、CLOB 或 NCLOB 类型的数据。",
            "返回 NVARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 INT,col2 VARCHAR2(20));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'OceanBase');\nQuery OK, 1 row affected\n\nobclient> SELECT TO_NCHAR(col2) FROM tbl1;\n+----------------+\n| TO_NCHAR(COL2) |\n+----------------+\n| OceanBase      |\n+----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1 并插入数据，将表 tbl1 中 VARCHAR2 数据转换为国家字符集。",
            "obclient> CREATE TABLE tbl1(col1 INT,col2 VARCHAR2(20));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,'OceanBase');\nQuery OK, 1 row affected\n\nobclient> SELECT TO_NCHAR(col2) FROM tbl1;\n+----------------+\n| TO_NCHAR(COL2) |\n+----------------+\n| OceanBase      |\n+----------------+\n1 row in set\n"
        ]
    },
    "TO_NCHAR (datetime)": {
        "Title": [
            "TO_NCHAR (datetime)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823238"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_NCHAR({ datetime | interval }[, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数将 DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE、INTERVAL YEAR TO MONTH 或 INTERVAL DAY TO SECOND 等数据类型的值从数据库字符集转换为国家字符集的数据类型。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndatetime\nDATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE、TIMESTAMP WITH LOCAL TIME ZONE、INTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH 等数据类型的值。\n\n\ninterval\nINTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH 数据类型的值。间隔单位如下： \n      \nYEAR 表示年。\nMONTH 表示月。\nDAY 表示天。\nHOUR 表示小时。\nMINUTE 表示分钟。\nSECOND 表示秒数。\n\n\n\nfmt\n指定输出格式，为可选项。如果不指定参数 fmt，则参数 datetime 的值将按如下格式转换为 VARCHAR2 数据类型： \n      \nDATE、TIMESTAMP、TIMESTAMP WITH TIME ZONE 和 TIMESTAMP WITH LOCAL TIME ZONE 的值被转换为数据库中日期时间值的默认格式。您可在 日期时间和间隔数据类型 章节中查看各日期时间类型的默认格式。\nINTERVAL DAY TO SECOND 和 INTERVAL YEAR TO MONTH 数据类型的值转换为数字格式的间隔值。\n\n\n\nnlsparam\n用来控制返回的月份和日份所使用的语言，为可选项。\n\n\n",
            "返回国家字符集的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_NCHAR(SYSDATE,'yyyy/mm/dd'),TO_NCHAR(SYSDATE,'DSDL') FROM DUAL;\n+--------------------------------+----------------------------------------+\n| TO_NCHAR(SYSDATE,'YYYY/MM/DD') | TO_NCHAR(SYSDATE,'DSDL')               |\n+--------------------------------+----------------------------------------+\n| 2021/12/09                     | 12/09/2021 Thursday, December 09, 2021 |\n+--------------------------------+----------------------------------------+\n1 row in set\n",
            "obclient> SELECT TO_NCHAR(interval'90' MINUTE, 'SS-MI-HH', 'nls_language = AMERICAN') FROM DUAL;\n+-----------------------------------------------------------------+\n| TO_NCHAR(INTERVAL'90'MINUTE,'SS-MI-HH','NLS_LANGUAGE=AMERICAN') |\n+-----------------------------------------------------------------+\n| +00 01:30:00                                                    |\n+-----------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "通过 TO_NCHAR 函数将当前日期分别按 YYYY/MM/DD 和 DSDL 格式返回。",
            "obclient> SELECT TO_NCHAR(SYSDATE,'yyyy/mm/dd'),TO_NCHAR(SYSDATE,'DSDL') FROM DUAL;\n+--------------------------------+----------------------------------------+\n| TO_NCHAR(SYSDATE,'YYYY/MM/DD') | TO_NCHAR(SYSDATE,'DSDL')               |\n+--------------------------------+----------------------------------------+\n| 2021/12/09                     | 12/09/2021 Thursday, December 09, 2021 |\n+--------------------------------+----------------------------------------+\n1 row in set\n",
            "将时间间隔值转化为数字格式的间隔值，并且设置返回语言为 AMERICAN。",
            "obclient> SELECT TO_NCHAR(interval'90' MINUTE, 'SS-MI-HH', 'nls_language = AMERICAN') FROM DUAL;\n+-----------------------------------------------------------------+\n| TO_NCHAR(INTERVAL'90'MINUTE,'SS-MI-HH','NLS_LANGUAGE=AMERICAN') |\n+-----------------------------------------------------------------+\n| +00 01:30:00                                                    |\n+-----------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_NCHAR (number)": {
        "Title": [
            "TO_NCHAR (number)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823246"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_NCHAR(n [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数将 NUMBER、BINARY_FLOAT 或 BINARY_DOUBLE 类型的数值转换为国家字符集中的字符串。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nn\n属于 NUMBER、BINARY_FLOAT 或 BINARY_DOUBLE 数据类型的数值。\n\n\nfmt\n输出格式参数，为可选项。如果省略 fmt，则 n 被转换为 NVARCHAR2 值返回。 取值信息请参见 fmt 参数列表。\n\n\nnlsparam\n定义十进制字符、组分隔符、当地货币符号和国际货币符号，为可选项。\n\n\n",
            "fmt 参数列表",
            "\n\n\nfmt 参数取值\n说明\n\n\n\n\n9\n返回指定位数的值。\n\n\n0\n返回指定前导和尾随 0。\n\n\n,（逗号）\n返回指定位置的逗号。您可以在数字格式模型中指定多个逗号。 限制条件 ：格式模型数值不能以逗号开头，且逗号不能出现在小数字符或句点的右边。\n\n\n.（小数点）\n返回一个小数，且小数点在指定位置。 限制条件 ：在数字格式模型中，您只能指定一个小数点。\n\n\n",
            "返回 NVARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_NCHAR(123456789.123,'999,999,999') FROM DUAL;\n+---------------------------------------+\n| TO_NCHAR(123456789.123,'999,999,999') |\n+---------------------------------------+\n|  123,456,789                          |\n+---------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将 123456789.123 转化为 999,999,999 格式的值。",
            "obclient> SELECT TO_NCHAR(123456789.123,'999,999,999') FROM DUAL;\n+---------------------------------------+\n| TO_NCHAR(123456789.123,'999,999,999') |\n+---------------------------------------+\n|  123,456,789                          |\n+---------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_NUMBER": {
        "Title": [
            "TO_NUMBER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823220"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_NUMBER(expr [, fmt [, 'nlsparam' ] ])\n",
        "Description": [
            "该函数功能是将 CHAR、VARCHAR2、NCHAR、NVARCHAR2、BINARY_FLOAT 或 BINARY_DOUBLE 类型的字符串转换为 NUMBER 数值数据类型的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n属于 CHAR、VARCHAR2、NCHAR、NVARCHAR2、BINARY_FLOAT 或 BINARY_DOUBLE 数据类型的数值。\n\n\nfmt\nexpr 的格式模型，为可选项。 说明 expr 必须在 fmt 范围内。例如：TO_NUMBER('$123456.78','$999999999.999')。\n\n\nnlsparam\n用来控制返回数据的所使用的语言，为可选项。\n\n\n",
            "返回 NUMBER 类型的数据。"
        ],
        "Examples": [
            "obclient> SELECT TO_NUMBER('0123456') FROM DUAL;\n+----------------------+\n| TO_NUMBER('0123456') |\n+----------------------+\n|               123456 |\n+----------------------+\n1 row in set\n",
            "obclient> SELECT TO_NUMBER('16f','xxx') FROM DUAL;\n+------------------------+\n| TO_NUMBER('16F','XXX') |\n+------------------------+\n|                    367 |\n+------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 0123456 转换为数值。",
            "obclient> SELECT TO_NUMBER('0123456') FROM DUAL;\n+----------------------+\n| TO_NUMBER('0123456') |\n+----------------------+\n|               123456 |\n+----------------------+\n1 row in set\n",
            "将十六进制数 16f 转换为十进制数。",
            "obclient> SELECT TO_NUMBER('16f','xxx') FROM DUAL;\n+------------------------+\n| TO_NUMBER('16F','XXX') |\n+------------------------+\n|                    367 |\n+------------------------+\n1 row in set\n"
        ]
    },
    "TO_SINGLE_BYTE": {
        "Title": [
            "TO_SINGLE_BYTE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823233"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "TO_SINGLE_BYTE(char)\n",
        "Description": [
            "该函数用于将所有多字节字符转换为相应的单字节字符。仅当您的数据库字符集同时包含单字节和多字节字符时，此函数才有效。"
        ],
        "Illustration": [
            "char 可以是数据类型 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。如果 char 中任何多字节字符没有单字节等效项，则在输出字符串中显示为多字节字符。",
            "返回值与 char 的数据类型相同。"
        ],
        "Examples": [
            "obclient> SELECT TO_SINGLE_BYTE(CHR(15711394)) FROM DUAL;\n+-------------------------------+\n| TO_SINGLE_BYTE(CHR(15711394)) |\n+-------------------------------+\n| B                             |\n+-------------------------------+\n1 row in set\n",
            "obclient> SELECT TO_SINGLE_BYTE('中国Ａ') text FROM DUAL;\n+---------+\n| TEXT    |\n+---------+\n| 中国A   |\n+---------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "从 UTF8 中的多字节 B 转换为相应的 ASCII 中的单字节 B。",
            "obclient> SELECT TO_SINGLE_BYTE(CHR(15711394)) FROM DUAL;\n+-------------------------------+\n| TO_SINGLE_BYTE(CHR(15711394)) |\n+-------------------------------+\n| B                             |\n+-------------------------------+\n1 row in set\n",
            "将字符串中的全角字符转化为半角字符。",
            "obclient> SELECT TO_SINGLE_BYTE('中国Ａ') text FROM DUAL;\n+---------+\n| TEXT    |\n+---------+\n| 中国A   |\n+---------+\n1 row in set\n"
        ]
    },
    "TO_TIMESTAMP": {
        "Title": [
            "TO_TIMESTAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823141"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "TO_TIMESTAMP (char，[fmt],['nlsparam'])\n",
        "Description": [
            "该函数将字符串转换为 TIMESTAMP 数据类型。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\n属于 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串。\n\n\nfmt\n指定 char 的格式，为可选项。如果省略 fmt，则 char 必须采用 TIMESTAMP 数据类型的默认格式。\n\n\nnlsparam\n通过指定 nlsparam 参数，可以在 TO_TIMESTAMP 函数中自定义日期、时间和数字的格式化和解析规则。 OceanBase 数据库当前支持的 nlsparam 为 nls_date_language，用来控制返回的月份和日份所使用的语言。 默认值为 AMERICA，不支持修改。\n\n\n",
            "返回 TIMESTAMP 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_TIMESTAMP ('2021-11-11 11:11:11.11', 'YYYY-MM-DD HH24:MI:SS.FF')\n    FROM DUAL;\n+-----------------------------------------------------------------+\n| TO_TIMESTAMP('2021-11-1111:11:11.11','YYYY-MM-DDHH24:MI:SS.FF') |\n+-----------------------------------------------------------------+\n| 11-NOV-21 11.11.11.110000000 AM                                 |\n+-----------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 2021-11-11 11:11:11.11 转换为TIMESTAMP 数据类型。",
            "obclient> SELECT TO_TIMESTAMP ('2021-11-11 11:11:11.11', 'YYYY-MM-DD HH24:MI:SS.FF')\n    FROM DUAL;\n+-----------------------------------------------------------------+\n| TO_TIMESTAMP('2021-11-1111:11:11.11','YYYY-MM-DDHH24:MI:SS.FF') |\n+-----------------------------------------------------------------+\n| 11-NOV-21 11.11.11.110000000 AM                                 |\n+-----------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_TIMESTAMP_TZ": {
        "Title": [
            "TO_TIMESTAMP_TZ"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823138"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "TO_TIMESTAMP_TZ (char，[fmt],['nlsparam'])\n",
        "Description": [
            "该函数将字符串转换为 TIMESTAMP WITH TIME ZONE 数据类型，包含时区信息。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\nCHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串。\n\n\nfmt\n指定 char 的格式，为可选项。如果省略 fmt，则 char 必须采用 TIMESTAMP WITH TIME ZONE 数据类型的默认格式。\n\n\nnlsparam\n用来控制返回的月份和日期所使用的语言，为可选项。\n\n\n",
            "返回 TIMESTAMP WITH TIME ZONE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TO_TIMESTAMP_TZ ('2021-11-11 11:11:11.11', 'YYYY-MM-DD HH24:MI:SS.FF')\n    FROM DUAL;\n+--------------------------------------------------------------------+\n| TO_TIMESTAMP_TZ('2021-11-1111:11:11.11','YYYY-MM-DDHH24:MI:SS.FF') |\n+--------------------------------------------------------------------+\n| 11-NOV-21 11.11.11.110000000 AM +08:00                             |\n+--------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 2021-11-11 11:11:11.11 转换为 TIMESTAMP WITH TIME ZONE 数据类型。",
            "obclient> SELECT TO_TIMESTAMP_TZ ('2021-11-11 11:11:11.11', 'YYYY-MM-DD HH24:MI:SS.FF')\n    FROM DUAL;\n+--------------------------------------------------------------------+\n| TO_TIMESTAMP_TZ('2021-11-1111:11:11.11','YYYY-MM-DDHH24:MI:SS.FF') |\n+--------------------------------------------------------------------+\n| 11-NOV-21 11.11.11.110000000 AM +08:00                             |\n+--------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "TO_YMINTERVAL": {
        "Title": [
            "TO_YMINTERVAL"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823130"
        ],
        "Category": [
            "Datetime Functions",
            "Conversion Functions"
        ],
        "Feature": "/*SQL 日期格式*/\nTO_YMINTERVAL([+|-] years-months)\n\n/*ISO 日期格式*/\nTO_YMINTERVAL([-]P[ years Y][months M][days D][T[hours H][minutes M][seconds[.frac_secs]S]])\n",
        "Description": [
            "该函数将一个 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串转换为一个 INTERVAL YEAR TO MONTH 数据类型的值，可以用来对一个日期时间值进行加减计算。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\n[+|-] years-months\n符合该参数格式的 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串。 \n      \nyears 表示年，取整数值，范围为 [0,999999999]。\nmonths 表示月，取整数值，范围为 [0,11]。\n\n\n\n[-]P[ years Y][months M][days D][T[hours H][minutes M][seconds[.frac_secs]S]]\n符合该参数格式的 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2 数据类型的字符串。 frac_secs 表示秒的小数部分，取整数值，范围是[0,999999999]。 注意 值中不允许有空格。\n\n\n",
            "返回 INTERVAL YEAR TO MONTH 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE,SYSDATE+TO_YMINTERVAL('01-02') FROM DUAL;\n+-----------+--------------------------------+\n| SYSDATE   | SYSDATE+TO_YMINTERVAL('01-02') |\n+-----------+--------------------------------+\n| 18-NOV-21 | 18-JAN-23                      |\n+-----------+--------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回当前时间 1 年 2 个月后的时间日期值。",
            "obclient> SELECT SYSDATE,SYSDATE+TO_YMINTERVAL('01-02') FROM DUAL;\n+-----------+--------------------------------+\n| SYSDATE   | SYSDATE+TO_YMINTERVAL('01-02') |\n+-----------+--------------------------------+\n| 18-NOV-21 | 18-JAN-23                      |\n+-----------+--------------------------------+\n1 row in set\n"
        ]
    },
    "TRANSLATE ... USING": {
        "Title": [
            "TRANSLATE ... USING"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823199"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "TRANSLATE(char USING{ CHAR_CS | NCHAR_CS })\n",
        "Description": [
            "该函数作用是将字符转换为指定的数据库字符集或国家字符集。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar\n要转换的字符串。数据类型可以是 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\nCHAR_CS\n指定转化为数据库字符集。\n\n\nNCHAR_CS\n指定转化为国家字符集。\n\n\n",
            "如果指定 CHAR_CS，则返回 VARCHAR2 类型。",
            "如果指定 NCHAR_CS，则返回 NVARCHAR2 类型。"
        ],
        "Examples": [
            "obclient> SELECT LENGTHB(TRANSLATE('OceanBase' USING CHAR_CS)) \"VARCHAR2\",\n                 LENGTHB(TRANSLATE('OceanBase' USING NCHAR_CS)) \"NVARCHAR2\"\n          FROM DUAL;\n+----------+-----------+\n| VARCHAR2 | NVARCHAR2 |\n+----------+-----------+\n|        9 |        18 |\n+----------+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "指定字符串 OceanBase 输出类型是 VARCHAR2 类型和 NVARCHAR2 类型，并输出字符串字节长度。",
            "obclient> SELECT LENGTHB(TRANSLATE('OceanBase' USING CHAR_CS)) \"VARCHAR2\",\n                 LENGTHB(TRANSLATE('OceanBase' USING NCHAR_CS)) \"NVARCHAR2\"\n          FROM DUAL;\n+----------+-----------+\n| VARCHAR2 | NVARCHAR2 |\n+----------+-----------+\n|        9 |        18 |\n+----------+-----------+\n1 row in set\n"
        ]
    },
    "TRANSLATE": {
        "Title": [
            "TRANSLATE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823187"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "TRANSLATE(char1,char2,char3)\n",
        "Description": [
            "该函数用于 char1 中与 char2 匹配的字符替换为 char2 与 char3 对应顺序的字符。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nchar1\n指定字符表达式或变量。\n\n\nchar2\n指定 char1 中需要被替换的字符集合。\n\n\nchar3\n指定用于替换 char2 的字符集合。\n\n\n",
            "\n说明\n\nchar1、char2 和 char3 的数据类型可以是 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n如果 char3 长度大于 char2，则 char3 后面多余的字符无效。\n如果 char3 长度小于 char2，则 char2 后面多余的字符均替换为空（删除）。\n如果 char3 长度为 0，则返回 NULL。\n如果 char2 里有重复的字符，则按重复字符首次出现的位置作为替换依据。例如，char2 为 aab，char3 为 123，则替换依据为 char1 中的所有 a 替换为 1，所有 b 替换为 3。\n\n",
            "返回与 char1 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TRANSLATE('OceanBase','ae','AE') \"TRANSLATE\" FROM DUAL;\n+-----------+\n| TRANSLATE |\n+-----------+\n| OcEAnBAsE |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 OceanBase 中的 a 和 e 替换为 A 和 E。",
            "obclient> SELECT TRANSLATE('OceanBase','ae','AE') \"TRANSLATE\" FROM DUAL;\n+-----------+\n| TRANSLATE |\n+-----------+\n| OcEAnBAsE |\n+-----------+\n1 row in set\n"
        ]
    },
    "TRIM": {
        "Title": [
            "TRIM"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823183"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "TRIM([{{ LEADING | TRAILING | BOTH }[ trim_character ]|trim_character }FROM] trim_source)\n",
        "Description": [
            "该函数用来删除一个字符串的开头或结尾（或两者）的字符。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nLEADING | TRAILING | BOTH\n指定删除字符的位置。 \n      \nLEADING 为开头字符。如果指定 LEADING，则删除所有与前导字符相等的 trim_character。\nTRAILING 为结尾字符。如果指定 TRAILING，则删除所有与结尾字符相等的 trim_character。\nBOTH 为开头和结尾字符。如果您指定 BOTH 或三个都不指定，则删除与前导和结尾字符相等的 trim_character。\n\n\n\ntrim_character\n删除的字符，只能是单个字符。如果未指定 trim_character，则默认值为空格。\n\n\ntrim_source\n需要被删除字符的字符串。如果仅指定 trim_source，则删除前导和尾随空格。\n\n\n",
            "\n说明\ntrim_character 和 trim_source 都可以是 VARCHAR2 或任何可以隐式转换为 VARCHAR2 的数据类型。如果函数返回值的数据类型为 VARCHAR2，则该值的最大长度为 trim_source。\n",
            "如果 trim_source 为 CHAR、VARCHAR2 数据类型，则函数返回 VARCHAR2 数据类型。",
            "如果 trim_source 为 NCHAR、NVARCHAR2 数据类型，则函数返回 NVARCHAR2 数据类型。",
            "如果 trim_source 为 CLOB 数据类型，则函数返回 CLOB 数据类型。",
            "如果 trim_source 或 trim_character 为 NULL，则 TRIM 函数返回 NULL。"
        ],
        "Examples": [
            "obclient> SELECT TRIM('X' FROM 'XXOceanBaseXX') \"TRIM\" FROM DUAL;\n+-----------+\n| TRIM      |\n+-----------+\n| OceanBase |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "删除字符串 XXOceanBaseXX 开头和结尾的 XX。",
            "obclient> SELECT TRIM('X' FROM 'XXOceanBaseXX') \"TRIM\" FROM DUAL;\n+-----------+\n| TRIM      |\n+-----------+\n| OceanBase |\n+-----------+\n1 row in set\n"
        ]
    },
    "TRUNC (date)": {
        "Title": [
            "TRUNC (date)"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823120"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "TRUNC(date,[fmt])\n",
        "Description": [
            "该函数返回以参数 fmt 为单位距离的离指定日期 date 最近的日期时间值，并且返回的日期值在 date 之前。",
            "\n注意\n与函数 ROUND( ) 返回值的区别为，TRUNC(date) 返回的值必须是在 date 之前的离 date 最近的日期，ROUND( ) 可以是 date 之前也可以是 date 之后的离它最近的日期值。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\ndate\nDATE 数据类型。\n\n\nfmt\n指定了函数返回值与 date 的距离单位。\n\n\n",
            "如下表格列出了 fmt 参数的取值说明，该参数对大小写不敏感。",
            "\n\n\nfmt 参数的取值\n说明\n\n\n\n\nj\n默认值，最近 0 点日期。\n\n\nday、dy、d\n返回离指定日期最近的星期日。\n\n\nmonth、mon、mm、rm\n返回离指定日期最近的月的第一天日期。\n\n\nq\n返回离指定日期最近的季的日期。\n\n\nyyyy、yyy、yy、y\n多个 y 表示不同的精度，返回离指定日期最近的年的第一个日期。\n\n\ncc、scc\n返回离指定日期最近的世纪的初日期。\n\n\n",
            "返回 DATE 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT SYSDATE 当时日期,\n    TRUNC(SYSDATE) 今天日期,\n    TRUNC(SYSDATE,'DAY') 本周星期日,\n    TRUNC(SYSDATE,'MONTH') 本月初,\n    TRUNC(SYSDATE,'Q') 本季初日期,\n    TRUNC(SYSDATE,'YEAR') 本年初日期 FROM DUAL;\n+--------------+--------------+-----------------+-----------+-----------------+-----------------+\n| 当时日期     | 今天日期     | 本周星期日      | 本月初    | 本季初日期      | 本年初日期      |\n+--------------+--------------+-----------------+-----------+-----------------+-----------------+\n| 18-NOV-21    | 18-NOV-21    | 14-NOV-21       | 01-NOV-21 | 01-OCT-21       | 01-JAN-21       |\n+--------------+--------------+-----------------+-----------+-----------------+-----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "用 TRUNC 计算距离当前时间最近的符合要求的日期值。",
            "obclient> SELECT SYSDATE 当时日期,\n    TRUNC(SYSDATE) 今天日期,\n    TRUNC(SYSDATE,'DAY') 本周星期日,\n    TRUNC(SYSDATE,'MONTH') 本月初,\n    TRUNC(SYSDATE,'Q') 本季初日期,\n    TRUNC(SYSDATE,'YEAR') 本年初日期 FROM DUAL;\n+--------------+--------------+-----------------+-----------+-----------------+-----------------+\n| 当时日期     | 今天日期     | 本周星期日      | 本月初    | 本季初日期      | 本年初日期      |\n+--------------+--------------+-----------------+-----------+-----------------+-----------------+\n| 18-NOV-21    | 18-NOV-21    | 14-NOV-21       | 01-NOV-21 | 01-OCT-21       | 01-JAN-21       |\n+--------------+--------------+-----------------+-----------+-----------------+-----------------+\n1 row in set\n"
        ]
    },
    "TRUNC": {
        "Title": [
            "TRUNC"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823167"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "TRUNC (numeric[,precision])\n",
        "Description": [
            "该函数返回参数 numeric 按精度 precision 截取后的值。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nnumeric\n表示被截取的数字，属于数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。\n\n\nprecision\n表示精度，为可选项，默认值为 0。属于数值类型（NUMBER、FLOAT、BINARY_FLOAT 和 BINARY_DOUBLE）表达式。 \n      \n如果 precision 不为整数，则按 precision 的整数部分作精度截取 numeric。\n如果 precision 大于 0，则截取 numeric 到 precision 位小数。\n如果 precision 小于 0，则截取到 numeric 小数点向左第 precision 位。\n如果 precision 等于 0，则截取到 numeric 的整数部分，小数部分舍去。\n\n\n\n",
            "不指定 precision 时，返回类型与参数 numeric 的数据类型相同。指定 precision 时，返回类型为 NUMBER。"
        ],
        "Examples": [
            "obclient> SELECT TRUNC(555.666,2.2),TRUNC(555.666,-2),TRUNC(555.666) FROM DUAL;\n+--------------------+-------------------+----------------+\n| TRUNC(555.666,2.2) | TRUNC(555.666,-2) | TRUNC(555.666) |\n+--------------------+-------------------+----------------+\n|             555.66 |               500 |            555 |\n+--------------------+-------------------+----------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "在 precision 的值为 2.2、-2 和省略 precision 时，对数字 555.666 进行截取。",
            "obclient> SELECT TRUNC(555.666,2.2),TRUNC(555.666,-2),TRUNC(555.666) FROM DUAL;\n+--------------------+-------------------+----------------+\n| TRUNC(555.666,2.2) | TRUNC(555.666,-2) | TRUNC(555.666) |\n+--------------------+-------------------+----------------+\n|             555.66 |               500 |            555 |\n+--------------------+-------------------+----------------+\n1 row in set\n"
        ]
    },
    "TZ_OFFSET": {
        "Title": [
            "TZ_OFFSET"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823133"
        ],
        "Category": [
            "Datetime Functions"
        ],
        "Feature": "TZ_OFFSET({ SESSIONTIMEZONE | DBTIMEZONE})\n",
        "Description": [
            "该函数返回当前会话时区 SESSIONTIMEZONE 或数据库时区 DBTIMEZONE 的时区偏移量。",
            "\n说明\n时区偏移量是指与格林尼治标准时间 GMT 的差（计算单位为小时和分钟）。\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nSESSIONTIMEZONE\n当前会话时区。\n\n\nDBTIMEZONE\n数据库时区。\n\n\n",
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT TZ_OFFSET(SESSIONTIMEZONE),TZ_OFFSET(DBTIMEZONE) FROM DUAL;\n+----------------------------+-----------------------+\n| TZ_OFFSET(SESSIONTIMEZONE) | TZ_OFFSET(DBTIMEZONE) |\n+----------------------------+-----------------------+\n| +08:00                     | +00:00                |\n+----------------------------+-----------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回当前会话时区 SESSIONTIMEZONE 、数据库时区 DBTIMEZONE 的时区偏移量。",
            "obclient> SELECT TZ_OFFSET(SESSIONTIMEZONE),TZ_OFFSET(DBTIMEZONE) FROM DUAL;\n+----------------------------+-----------------------+\n| TZ_OFFSET(SESSIONTIMEZONE) | TZ_OFFSET(DBTIMEZONE) |\n+----------------------------+-----------------------+\n| +08:00                     | +00:00                |\n+----------------------------+-----------------------+\n1 row in set\n"
        ]
    },
    "UID": {
        "Title": [
            "UID"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823177"
        ],
        "Category": [
            "Environment and Identifier Functions"
        ],
        "Feature": "UID\n",
        "Description": [
            "该函数返回当前登录用户的用户 ID。"
        ],
        "Illustration": [
            "返回一个整数。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1(col1 INT,user_id INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,UID),(2,UID),(3,UID);\nQuery OK, 3 rows affected\nRecords: 3  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------------------+\n| COL1 | USER_ID          |\n+------+------------------+\n|    1 | 1101710651031555 |\n|    2 | 1101710651031555 |\n|    3 | 1101710651031555 |\n+------+------------------+\n3 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并把当前用户的 ID 数据插入表 tbl1 中。",
            "obclient> CREATE TABLE tbl1(col1 INT,user_id INT);\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,UID),(2,UID),(3,UID);\nQuery OK, 3 rows affected\nRecords: 3  Duplicates: 0  Warnings: 0\n\nobclient> SELECT * FROM tbl1;\n+------+------------------+\n| COL1 | USER_ID          |\n+------+------------------+\n|    1 | 1101710651031555 |\n|    2 | 1101710651031555 |\n|    3 | 1101710651031555 |\n+------+------------------+\n3 rows in set\n"
        ]
    },
    "UNIFORM": {
        "Title": [
            "UNIFORM"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823157"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "UNIFORM(<min> , <max> , <gen>)\n",
        "Description": [],
        "Illustration": [
            "该函数返回一个符合均匀分布（Uniform Distribution）的整数或浮点数。",
            "min",
            ", ",
            "max",
            " 的取值必须是标量值，不随行迭代而变。例如，常量、标量函数等。PL 里还可以是 ",
            "@v1",
            "、",
            "1+@v3",
            " 等。",
            "Oracle 模式下，无论 ",
            "min",
            "、",
            "max",
            " 是否为整数，都当做 ",
            "NUMBER",
            " 类型处理，",
            "UNIFORM()",
            " 函数的输出结果为浮点数。如果希望生成整数，可以配合 ",
            "FLOOR()",
            " 函数使用。",
            "gen",
            " 是一个数值生成函数，通常使用 ",
            "RANDOM()",
            " 函数生成。如果传入值是一个常量，则 ",
            "UNIFORM()",
            " 函数返回值也为一个定值。"
        ],
        "Examples": [
            "obclient> SELECT UNIFORM(0.0, 10, RANDOM()) FROM TABLE(GENERATOR(4)) ORDER BY 1;\n+--------------------------+\n| UNIFORM(0.0,10,RANDOM()) |\n+--------------------------+\n|        .8657087411722835 |\n|       1.0922542185892958 |\n|       1.1803956370514672 |\n|        5.613282729140028 |\n+--------------------------+\n4 rows in set\n\nobclient> SELECT UNIFORM(0, 10, RANDOM()) FROM TABLE(GENERATOR(4)) ORDER BY 1;\n+------------------------+\n| UNIFORM(0,10,RANDOM()) |\n+------------------------+\n|     2.6761305377880125 |\n|     3.0277418674828116 |\n|      5.170644071608517 |\n|      5.805950943815582 |\n+------------------------+\n4 rows in set\n"
        ],
        "Detailed Examples": [
            "如下示例说明返回的结果类型和 UNIFORM() 参数的类型有关。",
            "obclient> SELECT UNIFORM(0.0, 10, RANDOM()) FROM TABLE(GENERATOR(4)) ORDER BY 1;\n+--------------------------+\n| UNIFORM(0.0,10,RANDOM()) |\n+--------------------------+\n|        .8657087411722835 |\n|       1.0922542185892958 |\n|       1.1803956370514672 |\n|        5.613282729140028 |\n+--------------------------+\n4 rows in set\n\nobclient> SELECT UNIFORM(0, 10, RANDOM()) FROM TABLE(GENERATOR(4)) ORDER BY 1;\n+------------------------+\n| UNIFORM(0,10,RANDOM()) |\n+------------------------+\n|     2.6761305377880125 |\n|     3.0277418674828116 |\n|      5.170644071608517 |\n|      5.805950943815582 |\n+------------------------+\n4 rows in set\n"
        ]
    },
    "UNISTR": {
        "Title": [
            "UNISTR"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823241"
        ],
        "Category": [
            "Conversion Functions"
        ],
        "Feature": "UNISTR(string)\n",
        "Description": [
            "该函数将文本字面量和 Unicode 编码转换为国家字符集中的字符串。",
            "Unicode 编码值的格式为 \\xxxx，其中 xxxx 是 UCS-2 编码格式的字符的十六进制值（UTF-16 代码单元）。要在字符串本身中包含反斜杠，需在其前面加上另一个反斜杠（\\\\）。"
        ],
        "Illustration": [
            "参数 string 是任何字符集的字符串。",
            "返回一个字符串值。"
        ],
        "Examples": [
            "obclient> SELECT UNISTR('A B C \\FF20 \\00C4 \\00CA \\00CD \\00D5 \\00D8') FROM DUAL;\n+---------------------------------------------+\n| UNISTR('ABC\\FF20\\00C4\\00CA\\00CD\\00D5\\00D8') |\n+---------------------------------------------+\n| A B C ＠ Ä Ê Í Õ Ø                          |\n+---------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将 ASCII 字符 和 Unicode 编码的值转换为国家字符集的字符串。",
            "obclient> SELECT UNISTR('A B C \\FF20 \\00C4 \\00CA \\00CD \\00D5 \\00D8') FROM DUAL;\n+---------------------------------------------+\n| UNISTR('ABC\\FF20\\00C4\\00CA\\00CD\\00D5\\00D8') |\n+---------------------------------------------+\n| A B C ＠ Ä Ê Í Õ Ø                          |\n+---------------------------------------------+\n1 row in set\n"
        ]
    },
    "UPDATEXML": {
        "Title": [
            "UPDATEXML"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823516"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "UPDATEXML\n      (XMLType_instance,\n        XPath_string, value_expr\n          [, XPath_string, value_expr ]...\n        [, namespace_string ]\n      )\n",
        "Description": [
            "该函数用于修改更新 XMLType 数据的表达式，通过指定一个或者多个 XPath 和 Value 值对，将所输入的原 XMLType 数据的表达式按照指定的顺序将 XPath 查找到的节点更新成 value_expr 指定的更新值。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n指定 XMLType 类型的数据，可以是 XMLType 列或者返回类型为 XMLType 的表达式。\n\n\nXPath_string\n通过 XPath 指定需要更新的 XML 内容。\n\n\nvalue_expr\n指定更新值，数据类型可以是 XMLType 类型数据、标量类型（例如 CHAR/VARCHAR2）、CLOB 和 NULL。\n\n\nnamespace_string\n指定 XML 命名空间。\n\n\n"
        ],
        "Examples": [
            "obclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a/text()', 'bbb') RES FROM DUAL;\n+------------------------------+\n| RES                          |\n+------------------------------+\n| <root>\n  <a>bbb</a>\n</root>\n |\n+------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a/text()', NULL) RES FROM DUAL;\n+------------------------+\n| RES                    |\n+------------------------+\n| <root>\n  <a/>\n</root>\n |\n+------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a/text()', XMLPARSE(content '<a>bbb</a>')) RES FROM DUAL;\n+---------------------------------------------+\n| RES                                         |\n+---------------------------------------------+\n| <root>\n  <a>\n    <a>bbb</a>\n  </a>\n</root>\n |\n+---------------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root a1=\"aaa\"><a>aaa</a></root>'), '/root/@a1', 'bbb') RES FROM DUAL;\n+---------------------------------------+\n| RES                                   |\n+---------------------------------------+\n| <root a1=\"bbb\">\n  <a>aaa</a>\n</root>\n |\n+---------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root a1=\"aaa\"><a>aaa</a></root>'), '/root/@a1', NULL) RES FROM DUAL;\n+------------------------------------+\n| RES                                |\n+------------------------------------+\n| <root a1=\"\">\n  <a>aaa</a>\n</root>\n |\n+------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root a1=\"aaa\"><a>aaa</a></root>'), '/root/@a1', XMLPARSE(CONTENT '<a>a1</a>')) RES FROM DUAL;\n+------------------------------------------+\n| RES                                      |\n+------------------------------------------+\n| <root>\n  <a>a1</a>\n  <a>aaa</a>\n</root>\n |\n+------------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a', 'bbb') RES FROM DUAL;\n+-------------------+\n| RES               |\n+-------------------+\n| <root>bbb</root>\n |\n+-------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<a a1=\"a1\" xmlns:f=\"ns1\" xmlns=\"ns2\"><c/>cccc</a>'), '/a', NULL, 'xmlns=\"ns2\"') RES FROM DUAL;\n+-------------------+\n| RES               |\n+-------------------+\n| <a xmlns=\"ns2\"/>\n |\n+-------------------+\n1 row in set (0.01 sec)\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a', xmltype('<b>bbb</b>')) RES FROM DUAL;\n+------------------------------+\n| RES                          |\n+------------------------------+\n| <root>\n  <b>bbb</b>\n</root>\n |\n+------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "obclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a/text()', 'bbb') RES FROM DUAL;\n+------------------------------+\n| RES                          |\n+------------------------------+\n| <root>\n  <a>bbb</a>\n</root>\n |\n+------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a/text()', NULL) RES FROM DUAL;\n+------------------------+\n| RES                    |\n+------------------------+\n| <root>\n  <a/>\n</root>\n |\n+------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a/text()', XMLPARSE(content '<a>bbb</a>')) RES FROM DUAL;\n+---------------------------------------------+\n| RES                                         |\n+---------------------------------------------+\n| <root>\n  <a>\n    <a>bbb</a>\n  </a>\n</root>\n |\n+---------------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root a1=\"aaa\"><a>aaa</a></root>'), '/root/@a1', 'bbb') RES FROM DUAL;\n+---------------------------------------+\n| RES                                   |\n+---------------------------------------+\n| <root a1=\"bbb\">\n  <a>aaa</a>\n</root>\n |\n+---------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root a1=\"aaa\"><a>aaa</a></root>'), '/root/@a1', NULL) RES FROM DUAL;\n+------------------------------------+\n| RES                                |\n+------------------------------------+\n| <root a1=\"\">\n  <a>aaa</a>\n</root>\n |\n+------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root a1=\"aaa\"><a>aaa</a></root>'), '/root/@a1', XMLPARSE(CONTENT '<a>a1</a>')) RES FROM DUAL;\n+------------------------------------------+\n| RES                                      |\n+------------------------------------------+\n| <root>\n  <a>a1</a>\n  <a>aaa</a>\n</root>\n |\n+------------------------------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a', 'bbb') RES FROM DUAL;\n+-------------------+\n| RES               |\n+-------------------+\n| <root>bbb</root>\n |\n+-------------------+\n1 row in set\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<a a1=\"a1\" xmlns:f=\"ns1\" xmlns=\"ns2\"><c/>cccc</a>'), '/a', NULL, 'xmlns=\"ns2\"') RES FROM DUAL;\n+-------------------+\n| RES               |\n+-------------------+\n| <a xmlns=\"ns2\"/>\n |\n+-------------------+\n1 row in set (0.01 sec)\n\nobclient> SELECT UPDATEXML(XMLPARSE(CONTENT '<root><a>aaa</a></root>'), '/root/a', xmltype('<b>bbb</b>')) RES FROM DUAL;\n+------------------------------+\n| RES                          |\n+------------------------------+\n| <root>\n  <b>bbb</b>\n</root>\n |\n+------------------------------+\n1 row in set\n"
        ]
    },
    "UPPER": {
        "Title": [
            "UPPER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823191"
        ],
        "Category": [
            "Character Functions Returning CharacterValues"
        ],
        "Feature": "UPPER(char)\n",
        "Description": [
            "该函数将字符串中英文字母全部转为大写。"
        ],
        "Illustration": [
            "char 是要转换的字符串，数据类型可以为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。",
            "返回与 char 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT UPPER('OceanBase') \"UPPER\" FROM DUAL;\n+-----------+\n| UPPER     |\n+-----------+\n| OCEANBASE |\n+-----------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "将字符串 OceanBase 全部转换为大写。",
            "obclient> SELECT UPPER('OceanBase') \"UPPER\" FROM DUAL;\n+-----------+\n| UPPER     |\n+-----------+\n| OCEANBASE |\n+-----------+\n1 row in set\n"
        ]
    },
    "USER": {
        "Title": [
            "USER"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823180"
        ],
        "Category": [
            "Environment and Identifier Functions"
        ],
        "Feature": "USER\n",
        "Description": [
            "该函数返回当前登录用户的名称。"
        ],
        "Illustration": [
            "返回 VARCHAR2 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT USER FROM DUAL;\n+------+\n| USER |\n+------+\n| SYS  |\n+------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "返回当前用户的名称。",
            "obclient> SELECT USER FROM DUAL;\n+------+\n| USER |\n+------+\n| SYS  |\n+------+\n1 row in set\n"
        ]
    },
    "USERENV": {
        "Title": [
            "USERENV"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823175"
        ],
        "Category": [
            "Environment and Identifier Functions"
        ],
        "Feature": "USERENV('parameter')\n",
        "Description": [
            "该函数返回有关当前会话的信息。该函数不能在 CHECK 约束的条件下使用。"
        ],
        "Illustration": [
            "parameter自变量的取值如下：",
            "\n\n\n取值\n说明\n\n\n\n\nCLIENT_INFO\n返回用户会话信息（最多 64 字节），应用程序可以使用 DBMS_APPLICATION_INFO 系统包存储这些信息。\n\n\nINSTANCE\n当前实例的标识号。\n\n\nLANG\n语言的缩写名称，是比 LANGUAGE 参数更短的格式。\n\n\nLANGUAGE\n当前会话使用的语言和区域，以及数据库字符集。格式为 language_territory.characterset。\n\n\nSCHEMAID\nSchema ID。\n\n\nSID | SESSIONID\n返回当前会话的 Client Session ID，该 ID 是会话在客户端中的唯一标识。\n\n\n"
        ],
        "Examples": [
            "obclient [SYS]> SELECT USERENV('LANGUAGE') \"Language\" FROM DUAL;\n",
            "+---------------------------+\n| Language                  |\n+---------------------------+\n| AMERICAN_AMERICA.AL32UTF8 |\n+---------------------------+\n1 row in set\n",
            "obclient [SYS]> SELECT USERENV('SCHEMAID') FROM DUAL;\n",
            "+---------------------+\n| USERENV('SCHEMAID') |\n+---------------------+\n|              201006 |\n+---------------------+\n1 row in set\n",
            "obclient [SYS]> SELECT USERENV('SESSIONID') AS Client_Session_ID FROM DUAL;\n",
            "obclient [SYS]> SELECT USERENV('SID') AS Client_Session_ID FROM DUAL;\n",
            "+-------------------+\n| CLIENT_SESSION_ID |\n+-------------------+\n|        3221488033 |\n+-------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "获取当前会话使用的语言和区域，以及数据库字符集。",
            "obclient [SYS]> SELECT USERENV('LANGUAGE') \"Language\" FROM DUAL;\n",
            "返回结果如下：",
            "+---------------------------+\n| Language                  |\n+---------------------------+\n| AMERICAN_AMERICA.AL32UTF8 |\n+---------------------------+\n1 row in set\n",
            "获取当前会话的 Schema ID。",
            "obclient [SYS]> SELECT USERENV('SCHEMAID') FROM DUAL;\n",
            "返回结果如下：",
            "+---------------------+\n| USERENV('SCHEMAID') |\n+---------------------+\n|              201006 |\n+---------------------+\n1 row in set\n",
            "获取当前会话的 Client Session ID。",
            "obclient [SYS]> SELECT USERENV('SESSIONID') AS Client_Session_ID FROM DUAL;\n",
            "或",
            "obclient [SYS]> SELECT USERENV('SID') AS Client_Session_ID FROM DUAL;\n",
            "返回结果如下：",
            "+-------------------+\n| CLIENT_SESSION_ID |\n+-------------------+\n|        3221488033 |\n+-------------------+\n1 row in set\n"
        ]
    },
    "VARIANCE": {
        "Title": [
            "VARIANCE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822879"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "VARIANCE([ DISTINCT | UNIQUE | ALL ] expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数功能是返回指定列的方差。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT | UNIQUE | ALL\n查询时是否去重。为可选项，默认值 ALL。 \n      \nALL：查询时不去除数据中的重复值，且忽略数据中的 NULL 值。\nDISTINCT：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\nUNIQUE：查询时去除数据中的重复值，且忽略数据中的 NULL 值。\n\n\n\nexpr\n数值数据类型或任何可以隐式转换为数值数据类型的表达式。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n注意\n如果您指定了 DISTINCT 或 UNIQUE 关键字，则 analytic_clause 中不允许出现 order_by_clause 和 windowing_clause。\n",
            "返回与参数 expr 相同的数据类型。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n",
            "obclient> SELECT last_name,hiredate,salary,VARIANCE(salary) OVER (ORDER BY hiredate) \"Variance\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | Variance                                  |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |                                     45000 |\n| Raphaely  | 2017-07-22 |   1700 |                                     30000 |\n| De Haan   | 2018-05-01 |  11000 |                                  22110000 |\n| Partners  | 2018-12-01 |  14000 |                                  36783000 |\n| Russell   | 2019-07-11 |  13000 |  37686666.6666666666666666666666666666666 |\n| Hartstein | 2019-10-05 |  14000 | 36318392.85714285714285714285714285714286 |\n| Weiss     | 2019-10-05 |  13500 | 36318392.85714285714285714285714285714286 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 employees。",
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "求列 salary 中所有值的方差。",
            "obclient> SELECT SUM(salary) FROM employees;\n+-------------+\n| SUM(SALARY) |\n+-------------+\n|       70300 |\n+-------------+\n1 row in set\n",
            "分析函数示例",
            "以列 hiredate 升序排序求列 salary 的累计方差。",
            "obclient> SELECT last_name,hiredate,salary,VARIANCE(salary) OVER (ORDER BY hiredate) \"Variance\"\n          FROM employees;\n+-----------+------------+--------+-------------------------------------------+\n| LAST_NAME | HIREDATE   | SALARY | Variance                                  |\n+-----------+------------+--------+-------------------------------------------+\n| Raphaely  | 2017-07-01 |   1700 |                                         0 |\n| Errazuriz | 2017-07-21 |   1400 |                                     45000 |\n| Raphaely  | 2017-07-22 |   1700 |                                     30000 |\n| De Haan   | 2018-05-01 |  11000 |                                  22110000 |\n| Partners  | 2018-12-01 |  14000 |                                  36783000 |\n| Russell   | 2019-07-11 |  13000 |  37686666.6666666666666666666666666666666 |\n| Hartstein | 2019-10-05 |  14000 | 36318392.85714285714285714285714285714286 |\n| Weiss     | 2019-10-05 |  13500 | 36318392.85714285714285714285714285714286 |\n+-----------+------------+--------+-------------------------------------------+\n8 rows in set\n"
        ]
    },
    "VAR_POP": {
        "Title": [
            "VAR_POP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822885"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "VAR_POP(expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数返回一组数值集合的总体方差（忽略 NULL）。可以将该函数用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定参与计算的数值表达式。属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\n如果该函数应用于空集，则返回 NULL。返回结果计算公式为：SUM((expr - (SUM(expr) / COUNT(expr)))²)/ COUNT(expr)。\n",
            "返回与参数 expr 相同的数据类型或 NULL。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n",
            "obclient> SELECT VAR_POP(col4) FROM tbl1;\n+------------------------------------------+\n| VAR_POP(COL4)                            |\n+------------------------------------------+\n| 5.53846153846153846153846153846153846154 |\n+------------------------------------------+\n1 row in set\n",
            "obclient> SELECT col1,col2,col4,VAR_POP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                        0 |\n|    1 | A2   |   15 |                                     2.25 |\n|    1 | A3   |   16 |   2.888888888888888888888888888888888889 |\n|    2 | B1   |   14 |                                   2.1875 |\n|    2 | B2   |   15 |                                     1.84 |\n|    2 | B3   |   13 |  1.8055555555555555555555555555555555555 |\n|    2 | B4   |   16 | 1.95918367346938775510204081632653061229 |\n|    3 | C1   |   18 |                                 3.109375 |\n|    3 | C2   |   16 | 2.88888888888888888888888888888888888889 |\n|    3 | C3   |   15 |                                      2.6 |\n|    3 | C4   |   12 | 3.10743801652892561983471074380165289255 |\n|    3 | C5   |   10 | 4.55555555555555555555555555555555555558 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n|    4 | d1   |   10 | 5.53846153846153846153846153846153846154 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "计算列 col4 的总体方差。",
            "obclient> SELECT VAR_POP(col4) FROM tbl1;\n+------------------------------------------+\n| VAR_POP(COL4)                            |\n+------------------------------------------+\n| 5.53846153846153846153846153846153846154 |\n+------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col2 升序排序，计算列 col4 的累计总体方差。",
            "obclient> SELECT col1,col2,col4,VAR_POP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                        0 |\n|    1 | A2   |   15 |                                     2.25 |\n|    1 | A3   |   16 |   2.888888888888888888888888888888888889 |\n|    2 | B1   |   14 |                                   2.1875 |\n|    2 | B2   |   15 |                                     1.84 |\n|    2 | B3   |   13 |  1.8055555555555555555555555555555555555 |\n|    2 | B4   |   16 | 1.95918367346938775510204081632653061229 |\n|    3 | C1   |   18 |                                 3.109375 |\n|    3 | C2   |   16 | 2.88888888888888888888888888888888888889 |\n|    3 | C3   |   15 |                                      2.6 |\n|    3 | C4   |   12 | 3.10743801652892561983471074380165289255 |\n|    3 | C5   |   10 | 4.55555555555555555555555555555555555558 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n|    4 | d1   |   10 | 5.53846153846153846153846153846153846154 |\n|    4 | d1   | NULL | 5.53846153846153846153846153846153846154 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"
        ]
    },
    "VAR_SAMP": {
        "Title": [
            "VAR_SAMP"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822867"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "VAR_SAMP(expr) [ OVER (analytic_clause) ]\n",
        "Description": [
            "该函数返回一组数值集合的样本方差（忽略 NULL）。可以将该函数用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。它对一组行的集合进行计算并返回多个值。\n作为聚合函数使用时，该函数对一组行的集合进行聚合计算，结果只能返回一个值，此时不需要加 OVER 子句。\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定参与计算的数值表达式。属于数值数据类型或可以隐式转换为数值数据类型的值。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "\n说明\n如果该函数应用于空集，则返回 NULL。返回结果计算公式为：(SUM(expr - (SUM(expr) / COUNT(expr)))²) /(COUNT(expr) - 1)。\n",
            "返回与参数 expr 相同的数据类型或 NULL。"
        ],
        "Examples": [
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n",
            "obclient> SELECT VAR_SAMP(col4) FROM tbl1;\n+----------------+\n| VAR_SAMP(COL4) |\n+----------------+\n|              6 |\n+----------------+\n1 row in set\n",
            "obclient> SELECT col1,col2,col4,VAR_SAMP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                     NULL |\n|    1 | A2   |   15 |                                      4.5 |\n|    1 | A3   |   16 |  4.3333333333333333333333333333333333335 |\n|    2 | B1   |   14 | 2.91666666666666666666666666666666666667 |\n|    2 | B2   |   15 |                                      2.3 |\n|    2 | B3   |   13 |  2.1666666666666666666666666666666666666 |\n|    2 | B4   |   16 | 2.28571428571428571428571428571428571433 |\n|    3 | C1   |   18 | 3.55357142857142857142857142857142857143 |\n|    3 | C2   |   16 |                                     3.25 |\n|    3 | C3   |   15 | 2.88888888888888888888888888888888888889 |\n|    3 | C4   |   12 |  3.4181818181818181818181818181818181818 |\n|    3 | C5   |   10 |   4.969696969696969696969696969696969697 |\n|    4 | d1   | NULL |                                        6 |\n|    4 | d1   |   10 |                                        6 |\n|    4 | d1   | NULL |                                        6 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建表 tbl1。",
            "obclient> SELECT * FROM tbl1;\n+------+------+------+------+\n| COL1 | COL2 | COL3 | COL4 |\n+------+------+------+------+\n|    1 | A1   |    8 |   12 |\n|    1 | A2   |   10 |   15 |\n|    1 | A3   |   11 |   16 |\n|    2 | B1   |    9 |   14 |\n|    2 | B2   |   10 |   15 |\n|    2 | B3   |    8 |   13 |\n|    2 | B4   |   11 |   16 |\n|    3 | C1   |    8 |   18 |\n|    3 | C2   |    9 |   16 |\n|    3 | C3   |   10 |   15 |\n|    3 | C4   |   11 |   12 |\n|    3 | C5   |   12 |   10 |\n|    4 | d1   |    8 | NULL |\n|    4 | d1   |    9 |   10 |\n|    4 | d1   |   10 | NULL |\n+------+------+------+------+\n15 rows in set\n",
            "聚合函数示例",
            "计算列 col4 的样本方差。",
            "obclient> SELECT VAR_SAMP(col4) FROM tbl1;\n+----------------+\n| VAR_SAMP(COL4) |\n+----------------+\n|              6 |\n+----------------+\n1 row in set\n",
            "分析函数示例",
            "按列 col2 升序排序，计算列 col4 的累计样本方差。",
            "obclient> SELECT col1,col2,col4,VAR_SAMP(col4) OVER(ORDER BY col2) \"VAR_POP\" FROM tbl1;\n+------+------+------+------------------------------------------+\n| COL1 | COL2 | COL4 | VAR_POP                                  |\n+------+------+------+------------------------------------------+\n|    1 | A1   |   12 |                                     NULL |\n|    1 | A2   |   15 |                                      4.5 |\n|    1 | A3   |   16 |  4.3333333333333333333333333333333333335 |\n|    2 | B1   |   14 | 2.91666666666666666666666666666666666667 |\n|    2 | B2   |   15 |                                      2.3 |\n|    2 | B3   |   13 |  2.1666666666666666666666666666666666666 |\n|    2 | B4   |   16 | 2.28571428571428571428571428571428571433 |\n|    3 | C1   |   18 | 3.55357142857142857142857142857142857143 |\n|    3 | C2   |   16 |                                     3.25 |\n|    3 | C3   |   15 | 2.88888888888888888888888888888888888889 |\n|    3 | C4   |   12 |  3.4181818181818181818181818181818181818 |\n|    3 | C5   |   10 |   4.969696969696969696969696969696969697 |\n|    4 | d1   | NULL |                                        6 |\n|    4 | d1   |   10 |                                        6 |\n|    4 | d1   | NULL |                                        6 |\n+------+------+------+------------------------------------------+\n15 rows in set\n"
        ]
    },
    "VSIZE": {
        "Title": [
            "VSIZE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823117"
        ],
        "Category": [
            "Encoding and Decoding Functions"
        ],
        "Feature": "VSIZE (expr)\n",
        "Description": [
            "该函数返回参数 expr 的大小（字节数）。"
        ],
        "Illustration": [
            "expr 可以是数值数据类型（NUMBER、FLOAT、BINARY_FLOAT 或 BINARY_DOUBLE）或字符数据类型（ CHAR、VARCHAR2、NCHAR 或 NVARCHAR2）的值或表达式。",
            "返回一个 NUMBER 类型的值。",
            "如果 expr 为 NULL，则函数返回 NULL。"
        ],
        "Examples": [
            "obclient> SELECT VSIZE(123456),VSIZE('ABCDEF'),VSIZE ('中华人民共和国') FROM DUAL;\n+---------------+-----------------+--------------------------------+\n| VSIZE(123456) | VSIZE('ABCDEF') | VSIZE('中华人民共和国')        |\n+---------------+-----------------+--------------------------------+\n|             8 |               6 |                             21 |\n+---------------+-----------------+--------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "使用 VSIZE 函数查询 123456、ABCDEF 和 中华人民共和国 的字节数。",
            "obclient> SELECT VSIZE(123456),VSIZE('ABCDEF'),VSIZE ('中华人民共和国') FROM DUAL;\n+---------------+-----------------+--------------------------------+\n| VSIZE(123456) | VSIZE('ABCDEF') | VSIZE('中华人民共和国')        |\n+---------------+-----------------+--------------------------------+\n|             8 |               6 |                             21 |\n+---------------+-----------------+--------------------------------+\n1 row in set\n"
        ]
    },
    "WIDTH_BUCKET": {
        "Title": [
            "WIDTH_BUCKET"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823159"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "WIDTH_BUCKET\n(expr, min_value, max_value, num_buckets)\n",
        "Description": [
            "该函数根据输入参数创建等长的段，并返回 expr 所在的段号。即构建等宽直方图，其中直方图范围被划分为具有相同大小的区间。"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nexpr\n指定需创建等长段的表达式，属于数值或日期时间值，或者是可以隐式转换为数值或日期时间值的值。\n\n\nmin_value\n指定表达式 expr 所在范围的左端点。数据类型跟 expr 相同，并且不能为 NULL。\n\n\nmax_value\n指定表达式 expr 所在范围的右端点。数据类型跟 expr 相同，并且不能为 NULL。\n\n\nnum_buckets\n指定范围 min_value 与 max_value之间的段数。此表达式的计算结果必须为正整数。\n\n\n",
            "\n说明\n\n当 min_value < max_value 时： \n     \n如果 expr< min_value，该函数返回 0。\n如果 expr >= min_value，该函数返回 num_buckets 的值加 1。\n\n当 min_value > max_value 时： \n     \n如果 expr > min_value，该函数返回 0。\n如果 expr <= min_value，该函数返回 num_buckets 的值加 1。\n\n\n",
            "返回 NUMERIC 类型数据。"
        ],
        "Examples": [
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 NUMBER(10,2));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,0.5),(2,1),(3,9),(4,10),(5,11),(6,55),(7,100),(8,101),(9,'');\nQuery OK, 9 rows affected\nRecords: 9  Duplicates: 0  Warnings: 0\n\nobclient> SELECT col1,col2,WIDTH_BUCKET(col2,1,100,10) FROM tbl1;\n+------+------+-----------------------------+\n| COL1 | COL2 | WIDTH_BUCKET(COL2,1,100,10) |\n+------+------+-----------------------------+\n|    1 |   .5 |                           0 |\n|    2 |    1 |                           1 |\n|    3 |    9 |                           1 |\n|    4 |   10 |                           1 |\n|    5 |   11 |                           2 |\n|    6 |   55 |                           6 |\n|    7 |  100 |                          11 |\n|    8 |  101 |                          11 |\n|    9 | NULL |                        NULL |\n+------+------+-----------------------------+\n9 rows in set\n"
        ],
        "Detailed Examples": [
            "创建表 tbl1，并插入测试数据。设置范围为 1 至 100，分 10 个段，返回 col2 所在的段号。",
            "obclient> CREATE TABLE tbl1 (col1 INT,col2 NUMBER(10,2));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO tbl1 VALUES(1,0.5),(2,1),(3,9),(4,10),(5,11),(6,55),(7,100),(8,101),(9,'');\nQuery OK, 9 rows affected\nRecords: 9  Duplicates: 0  Warnings: 0\n\nobclient> SELECT col1,col2,WIDTH_BUCKET(col2,1,100,10) FROM tbl1;\n+------+------+-----------------------------+\n| COL1 | COL2 | WIDTH_BUCKET(COL2,1,100,10) |\n+------+------+-----------------------------+\n|    1 |   .5 |                           0 |\n|    2 |    1 |                           1 |\n|    3 |    9 |                           1 |\n|    4 |   10 |                           1 |\n|    5 |   11 |                           2 |\n|    6 |   55 |                           6 |\n|    7 |  100 |                          11 |\n|    8 |  101 |                          11 |\n|    9 | NULL |                        NULL |\n+------+------+-----------------------------+\n9 rows in set\n"
        ]
    },
    "WMSYS.WM_CONCAT/WM_CONCAT": {
        "Title": [
            "WMSYS.WM_CONCAT/WM_CONCAT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000822884"
        ],
        "Category": [
            "Aggregate Functions",
            "Analytic Functions"
        ],
        "Feature": "WM_CONCAT ([DISTINCT] measure_expr) [OVER query_partition_clause]\n",
        "Description": [
            "该函数用于列转行，将度量列的值进行合并。可以将其用作聚合或分析函数。",
            "\n说明\n\n作为分析函数使用时，需要使用 OVER 子句定义窗口进行计算。该函数基于 query_partition_clause 中的一个或多个表达式将查询结果集分为几组。\n作为聚合函数使用时，不需要加 OVER 关键字。 \n     \n作为单个集合的聚合函数，WM_CONCAT 对所有行进行操作并返回单个输出行。\n作为组集聚合，WM_CONCAT 将对 GROUP BY 子句定义的每个组进行操作并返回输出行。\n\n\n"
        ],
        "Illustration": [
            "\n\n\n参数\n说明\n\n\n\n\nDISTINCT\n如果指定 DISTINCT，会在返回结果中删除重复值。为可选项。\n\n\nmeasure_expr\n可以是任何表达式。度量列中的空值将被忽略。\n\n\nOVER\n使用 OVER 子句定义窗口进行计算。详细信息请参见 分析函数说明。\n\n\n",
            "返回 CLOB 类型的数据值。"
        ],
        "Examples": [
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "obclient> SELECT WM_CONCAT(last_name) \"Emp_list\" FROM employees;\n+----------------------------------------------------------------------+\n| Emp_list                                                             |\n+----------------------------------------------------------------------+\n| Raphaely,De Haan,Errazuriz,Hartstein,Raphaely,Weiss,Russell,Partners |\n+----------------------------------------------------------------------+\n1 row in set\n",
            "obclient> SELECT department_id,hiredate,last_name,\n              WM_CONCAT(last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n    FROM employees\n    ORDER BY 1,2;\n+---------------+------------+-----------+--------------------------+\n| DEPARTMENT_ID | HIREDATE   | LAST_NAME | Emp_list                 |\n+---------------+------------+-----------+--------------------------+\n|            30 | 2017-07-01 | Raphaely  | Raphaely,De Haan         |\n|            30 | 2018-05-01 | De Haan   | Raphaely,De Haan         |\n|            40 | 2017-07-21 | Errazuriz | Errazuriz                |\n|            50 | 2017-07-22 | Raphaely  | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Hartstein | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Weiss     | Hartstein,Raphaely,Weiss |\n|            90 | 2018-12-01 | Partners  | Russell,Partners         |\n|            90 | 2019-07-11 | Russell   | Russell,Partners         |\n+---------------+------------+-----------+--------------------------+\n8 rows in set\n"
        ],
        "Detailed Examples": [
            "现有已创建的表 employees。",
            "obclient> SELECT * FROM employees;\n+---------------+-----------+------------+--------+\n| DEPARTMENT_ID | LAST_NAME | HIREDATE   | SALARY |\n+---------------+-----------+------------+--------+\n|            30 | Raphaely  | 2017-07-01 |   1700 |\n|            30 | De Haan   | 2018-05-01 |  11000 |\n|            40 | Errazuriz | 2017-07-21 |   1400 |\n|            50 | Hartstein | 2019-10-05 |  14000 |\n|            50 | Raphaely  | 2017-07-22 |   1700 |\n|            50 | Weiss     | 2019-10-05 |  13500 |\n|            90 | Russell   | 2019-07-11 |  13000 |\n|            90 | Partners  | 2018-12-01 |  14000 |\n+---------------+-----------+------------+--------+\n8 rows in set\n",
            "聚合函数示例",
            "把列 last_name 中所有的人名放在一行展示。",
            "obclient> SELECT WM_CONCAT(last_name) \"Emp_list\" FROM employees;\n+----------------------------------------------------------------------+\n| Emp_list                                                             |\n+----------------------------------------------------------------------+\n| Raphaely,De Haan,Errazuriz,Hartstein,Raphaely,Weiss,Russell,Partners |\n+----------------------------------------------------------------------+\n1 row in set\n",
            "分析函数示例",
            "以列 department_id 分组，查询同组中所有的 last_name。",
            "obclient> SELECT department_id,hiredate,last_name,\n              WM_CONCAT(last_name) OVER (PARTITION BY department_id) as \"Emp_list\"\n    FROM employees\n    ORDER BY 1,2;\n+---------------+------------+-----------+--------------------------+\n| DEPARTMENT_ID | HIREDATE   | LAST_NAME | Emp_list                 |\n+---------------+------------+-----------+--------------------------+\n|            30 | 2017-07-01 | Raphaely  | Raphaely,De Haan         |\n|            30 | 2018-05-01 | De Haan   | Raphaely,De Haan         |\n|            40 | 2017-07-21 | Errazuriz | Errazuriz                |\n|            50 | 2017-07-22 | Raphaely  | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Hartstein | Hartstein,Raphaely,Weiss |\n|            50 | 2019-10-05 | Weiss     | Hartstein,Raphaely,Weiss |\n|            90 | 2018-12-01 | Partners  | Russell,Partners         |\n|            90 | 2019-07-11 | Russell   | Russell,Partners         |\n+---------------+------------+-----------+--------------------------+\n8 rows in set\n"
        ]
    },
    "XMLAGG": {
        "Title": [
            "XMLAGG"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823505"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLAGG(XMLType_instance [ ORDER BY [list of: expr [ASC|DESC] [NULLS {FIRST|LAST}]] ])\n",
        "Description": [
            "该函数获取一组 XML 片段并返回一个聚合的 XML 文档。可以将其用作聚合函数。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n指定 XMLType 类型的数据，可以是 XMLType 列或者返回类型为 XMLType 的表达式。\n\n\nexpr\n指定要排序的值对应的列名。注意 数字类型不能作为列的位置信息，例如 ORDER BY 1 并不是按照第一列排序的意思。\n\n\nASC | DESC\n指定列表的排序方式，为可选项。 \n      \nASC 为升序排序，为默认值。\nDESC 为降序排序。\n\n\n\nNULLS {FIRST | LAST}\n排序后 expr 中 NULL 值的位置，为可选项。 \n      \nNULLS FIRST： 表示 NULL 值排在非空值的前面。\nNULLS LAST ：表示 NULL 值排在非空值的后面，为默认值。\n\n\n\n",
            "返回 XMLType 数据类型。"
        ],
        "Examples": [
            "# 现有已创建表 employees\nobclient> SELECT * FROM EMPLOYEES;\n+------+-----------+------+\n| ID   | LAST_NAME | SAL  |\n+------+-----------+------+\n|    1 | CLARK     | 2750 |\n|    2 | KING      | 5300 |\n|    3 | MILLER    | 1600 |\n|    4 | ADAMS     | 1400 |\n+------+-----------+------+\n4 rows in set\n\n# 使用 XMLELEMENT 函数构建 XML 片段\nobclient> SELECT XMLELEMENT(EVALNAME LAST_NAME, SAL) AS \"RESULT\" FROM EMPLOYEES;\n+------------------------+\n| RESULT                 |\n+------------------------+\n| <CLARK>2750</CLARK>\n   |\n| <KING>5300</KING>\n     |\n| <MILLER>1600</MILLER>\n |\n| <ADAMS>1400</ADAMS>\n   |\n+------------------------+\n4 rows in set\n\n#使用 XMLAGG 将上述结果按照 SAL 顺序排序并聚合返回\nobclient> SELECT XMLAGG(XMLELEMENT(EVALNAME LAST_NAME, SAL) ORDER BY SAL) AS \"RESULT\" FROM EMPLOYEES;\n+----------------------------------------------------------------------------------+\n| RESULT                                                                           |\n+----------------------------------------------------------------------------------+\n| <ADAMS>1400</ADAMS>\n<MILLER>1600</MILLER>\n<CLARK>2750</CLARK>\n<KING>5300</KING>\n |\n+----------------------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 现有已创建表 employees\nobclient> SELECT * FROM EMPLOYEES;\n+------+-----------+------+\n| ID   | LAST_NAME | SAL  |\n+------+-----------+------+\n|    1 | CLARK     | 2750 |\n|    2 | KING      | 5300 |\n|    3 | MILLER    | 1600 |\n|    4 | ADAMS     | 1400 |\n+------+-----------+------+\n4 rows in set\n\n# 使用 XMLELEMENT 函数构建 XML 片段\nobclient> SELECT XMLELEMENT(EVALNAME LAST_NAME, SAL) AS \"RESULT\" FROM EMPLOYEES;\n+------------------------+\n| RESULT                 |\n+------------------------+\n| <CLARK>2750</CLARK>\n   |\n| <KING>5300</KING>\n     |\n| <MILLER>1600</MILLER>\n |\n| <ADAMS>1400</ADAMS>\n   |\n+------------------------+\n4 rows in set\n\n#使用 XMLAGG 将上述结果按照 SAL 顺序排序并聚合返回\nobclient> SELECT XMLAGG(XMLELEMENT(EVALNAME LAST_NAME, SAL) ORDER BY SAL) AS \"RESULT\" FROM EMPLOYEES;\n+----------------------------------------------------------------------------------+\n| RESULT                                                                           |\n+----------------------------------------------------------------------------------+\n| <ADAMS>1400</ADAMS>\n<MILLER>1600</MILLER>\n<CLARK>2750</CLARK>\n<KING>5300</KING>\n |\n+----------------------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "XMLATTRIBUTES": {
        "Title": [
            "XMLATTRIBUTES"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823507"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLATTRIBUTES\n  ( [ ENTITYESCAPING | NOENTITYESCAPING ]\n    [ SCHEMACHECK | NOSCHEMACHECK ]\n    value_expr [ { AS c_alias } | { AS EVALNAME value_expr } ]\n      [, value_expr [ { AS c_alias } | { AS EVALNAME value_expr } ] ]...\n  )\n",
        "Description": [
            "XMLATTRIBUTES 为 XMLELEMENT 的子表达式，用于指定 XML 元素中的属性集合。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nENTITYESCAPING|NOENTITYESCAPING\n可选项，是否需要强制转译，不指定则默认强制转译（ENTITYESCAPING）。\n\n\nSCHEMACHECK|NOSCHEMACHECK\n可选项，是否执行运行时的检查，不指定则默认不执行（NOSCHEMACHECK），目前不支持执行运行时检查。\n\n\nvalue_expr\n指定计算结果为字符串文字生成的属性值。\n\n\nc_alias\n指定生成的属性名，为字符串类型。\n\n\nEVALNAME\n指定该关键字表示后跟计算结果为字符串文字的表达式。\n\n\n",
            "XMLATTRIBUTES 作为 XMLELEMENT 子句，无法单独使用，无返回类型。"
        ],
        "Examples": [
            "# 创建表 t1，并插入一条数据。\nobclient> CREATE TABLE t1(col1 varchar(10));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO t1 VALUES('a');\nQuery OK, 1 row affected\n\n# 生成一个名为 key 的属性，属性内容为 col1。\nobclient> SELECT XMLELEMENT(emp, XMLATTRIBUTES(col1 as \"key\")) FROM t1;\n+--------------------------------------------+\n| XMLELEMENT(EMP,XMLATTRIBUTES(COL1AS\"KEY\")) |\n+--------------------------------------------+\n| <EMP key=\"a\"/>\n                            |\n+--------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 创建表 t1，并插入一条数据。\nobclient> CREATE TABLE t1(col1 varchar(10));\nQuery OK, 0 rows affected\n\nobclient> INSERT INTO t1 VALUES('a');\nQuery OK, 1 row affected\n\n# 生成一个名为 key 的属性，属性内容为 col1。\nobclient> SELECT XMLELEMENT(emp, XMLATTRIBUTES(col1 as \"key\")) FROM t1;\n+--------------------------------------------+\n| XMLELEMENT(EMP,XMLATTRIBUTES(COL1AS\"KEY\")) |\n+--------------------------------------------+\n| <EMP key=\"a\"/>\n                            |\n+--------------------------------------------+\n1 row in set\n"
        ]
    },
    "XMLCAST": {
        "Title": [
            "XMLCAST"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823512"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLCAST ( value_expression AS datatype )\n",
        "Description": [
            "该函数用于抽取 XML 文档的内容（不包括元素名称），并将其转换为 CHAR、VARCHAR、VARCHAR2、NUMBER、FLOAT、BLOB 或 CLOB 及任何日期时间数据类型。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nvalue_expression\n指定解析的内容必须为一个有效的 XML 片段。\n\n\nAS datatype\n指定返回的类型，可以为 CHAR、VARCHAR、VARCHAR2、NUMBER、FLOAT、BLOB 或 CLOB 及任何日期时间数据类型。\n\n\n",
            "返回 CHAR、VARCHAR、VARCHAR2、NUMBER、FLOAT、BLOB 或 CLOB 及任何日期时间数据类型。"
        ],
        "Examples": [
            "# 转换为 CHAR\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\"?><a>a</a>') AS CHAR) FROM DUAL;\n+-----------------------------------------------------------------+\n| XMLCAST(XMLPARSE(DOCUMENT'<?XMLVERSION=\"1.0\"?><A>A</A>')ASCHAR) |\n+-----------------------------------------------------------------+\n| a                                                               |\n+-----------------------------------------------------------------+\n1 row in set\n\n# 转换为 VARCHAR2\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\"?><a>aaaaaa</a>') AS VARCHAR2(5)) FROM DUAL;\n+-----------------------------------------------------------------------------+\n| XMLCAST(XMLPARSE(DOCUMENT'<?XMLVERSION=\"1.0\"?><A>AAAAAA</A>')ASVARCHAR2(5)) |\n+-----------------------------------------------------------------------------+\n| aaaaa                                                                       |\n+-----------------------------------------------------------------------------+\n1 row in set\n\n# 转换为 BLOB\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\"?><root><a>1</a><b>23f</b></root>') AS BLOB) FROM DUAL;\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| XMLCAST(XMLPARSE(DOCUMENT'<?XMLVERSION=\"1.0\"?><ROOT><A>1</A><B>23F</B></ROOT>')ASBLOB)                                                                                       |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| 123F                                                                                                                                                                         |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\n# 转换为 CLOB\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <note>\n    <to>To</to>\n    <FROM>Jani</FROM>\n    <heading>Reminder</heading>\n    <body>Do not forget me this weekend!</body>\n    </note>') AS CLOB) RES FROM DUAL;\n+----------------------------------------------+\n| RES                                          |\n+----------------------------------------------+\n| ToJaniReminderDo not forget me this weekend! |\n+----------------------------------------------+\n1 row in set\n\n# 转换为 NUMBER\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>123.01</a>') AS NUMBER) FROM DUAL;\n+---------------------------------------------------+\n| XMLCAST(XMLPARSE(CONTENT'<A>123.01</A>')ASNUMBER) |\n+---------------------------------------------------+\n|                                            123.01 |\n+---------------------------------------------------+\n1 row in set\n\n# 转换为 FLOAT\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>123.01</a>') AS FLOAT) FROM DUAL;\n+--------------------------------------------------+\n| XMLCAST(XMLPARSE(CONTENT'<A>123.01</A>')ASFLOAT) |\n+--------------------------------------------------+\n|                                           123.01 |\n+--------------------------------------------------+\n1 row in set\n\n# 转换为 DECIMAL\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>123.01</a>') AS DECIMAL) FROM DUAL;\n+----------------------------------------------------+\n| XMLCAST(XMLPARSE(CONTENT'<A>123.01</A>')ASDECIMAL) |\n+----------------------------------------------------+\n|                                                123 |\n+----------------------------------------------------+\n1 row in set\n\n# 转换为 TIMESTAMP\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>2023-04-01 15:13:00</a>') AS TIMESTAMP) AS RES FROM DUAL;\n+----------------------------+\n| RES                        |\n+----------------------------+\n| 2023-04-01 15:13:00.000000 |\n+----------------------------+\n1 row in set\n\n# 转换为 DATE\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>2023-04-01 15:13:00</a>') AS DATE) AS RES FROM DUAL;\n+---------------------+\n| RES                 |\n+---------------------+\n| 2023-04-01 15:13:00 |\n+---------------------+\n1 row in set\n\n# 转换为 INTERVAL YEAR TO MONTH\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>12-3</a>') AS INTERVAL YEAR(3) TO MONTH) AS RES FROM DUAL;\n+---------+\n| RES     |\n+---------+\n| +012-03 |\n+---------+\n1 row in set\n\n# 转换为 INTERVAL DAY TO SECOND\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>140 5:12:10.2222222</a>') AS INTERVAL DAY(3) TO SECOND(7)) AS RES FROM DUAL;\n+-----------------------+\n| RES                   |\n+-----------------------+\n| +140 05:12:10.2222222 |\n+-----------------------+\n1 row in set\n\n"
        ],
        "Detailed Examples": [
            "# 转换为 CHAR\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\"?><a>a</a>') AS CHAR) FROM DUAL;\n+-----------------------------------------------------------------+\n| XMLCAST(XMLPARSE(DOCUMENT'<?XMLVERSION=\"1.0\"?><A>A</A>')ASCHAR) |\n+-----------------------------------------------------------------+\n| a                                                               |\n+-----------------------------------------------------------------+\n1 row in set\n\n# 转换为 VARCHAR2\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\"?><a>aaaaaa</a>') AS VARCHAR2(5)) FROM DUAL;\n+-----------------------------------------------------------------------------+\n| XMLCAST(XMLPARSE(DOCUMENT'<?XMLVERSION=\"1.0\"?><A>AAAAAA</A>')ASVARCHAR2(5)) |\n+-----------------------------------------------------------------------------+\n| aaaaa                                                                       |\n+-----------------------------------------------------------------------------+\n1 row in set\n\n# 转换为 BLOB\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\"?><root><a>1</a><b>23f</b></root>') AS BLOB) FROM DUAL;\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| XMLCAST(XMLPARSE(DOCUMENT'<?XMLVERSION=\"1.0\"?><ROOT><A>1</A><B>23F</B></ROOT>')ASBLOB)                                                                                       |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| 123F                                                                                                                                                                         |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\n# 转换为 CLOB\nobclient> SELECT XMLCAST(XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <note>\n    <to>To</to>\n    <FROM>Jani</FROM>\n    <heading>Reminder</heading>\n    <body>Do not forget me this weekend!</body>\n    </note>') AS CLOB) RES FROM DUAL;\n+----------------------------------------------+\n| RES                                          |\n+----------------------------------------------+\n| ToJaniReminderDo not forget me this weekend! |\n+----------------------------------------------+\n1 row in set\n\n# 转换为 NUMBER\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>123.01</a>') AS NUMBER) FROM DUAL;\n+---------------------------------------------------+\n| XMLCAST(XMLPARSE(CONTENT'<A>123.01</A>')ASNUMBER) |\n+---------------------------------------------------+\n|                                            123.01 |\n+---------------------------------------------------+\n1 row in set\n\n# 转换为 FLOAT\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>123.01</a>') AS FLOAT) FROM DUAL;\n+--------------------------------------------------+\n| XMLCAST(XMLPARSE(CONTENT'<A>123.01</A>')ASFLOAT) |\n+--------------------------------------------------+\n|                                           123.01 |\n+--------------------------------------------------+\n1 row in set\n\n# 转换为 DECIMAL\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>123.01</a>') AS DECIMAL) FROM DUAL;\n+----------------------------------------------------+\n| XMLCAST(XMLPARSE(CONTENT'<A>123.01</A>')ASDECIMAL) |\n+----------------------------------------------------+\n|                                                123 |\n+----------------------------------------------------+\n1 row in set\n\n# 转换为 TIMESTAMP\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>2023-04-01 15:13:00</a>') AS TIMESTAMP) AS RES FROM DUAL;\n+----------------------------+\n| RES                        |\n+----------------------------+\n| 2023-04-01 15:13:00.000000 |\n+----------------------------+\n1 row in set\n\n# 转换为 DATE\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>2023-04-01 15:13:00</a>') AS DATE) AS RES FROM DUAL;\n+---------------------+\n| RES                 |\n+---------------------+\n| 2023-04-01 15:13:00 |\n+---------------------+\n1 row in set\n\n# 转换为 INTERVAL YEAR TO MONTH\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>12-3</a>') AS INTERVAL YEAR(3) TO MONTH) AS RES FROM DUAL;\n+---------+\n| RES     |\n+---------+\n| +012-03 |\n+---------+\n1 row in set\n\n# 转换为 INTERVAL DAY TO SECOND\nobclient> SELECT XMLCAST(XMLPARSE(CONTENT '<a>140 5:12:10.2222222</a>') AS INTERVAL DAY(3) TO SECOND(7)) AS RES FROM DUAL;\n+-----------------------+\n| RES                   |\n+-----------------------+\n| +140 05:12:10.2222222 |\n+-----------------------+\n1 row in set\n\n"
        ]
    },
    "XMLELEMENT": {
        "Title": [
            "XMLELEMENT"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823506"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLELEMENT ( [ ENTITYESCAPING | NOENTITYESCAPING ]\n   { ( [ NAME ] identifier ) | ( EVALNAME value_expr ) }\n   [ , XML_attributes_clause ]\n   [ , value_expr [ [ AS ] c_alias ]]...\n )\n",
        "Description": [
            "该函数生成具有指定名称、属性和内容的 XML 元素。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nENTITYESCAPING | NOENTITYESCAPING\n可选项，指定元素的名字和内容是否需要强制转译的关键字。建议直接使用表达式默认的行为ENTITYESCAPING。\n\n\nNAME\n指定根元素名称为文字标识符的关键字，NAME 表示其后面的值就是标识符，为可选项。\n\n\nEVALNAME\n指定根元素名称是计算结果为字符串的关键字。EVALNAME 表示其后面的值需要经过计算获取结果。\n\n\nidentifier\n指定字符串类型的标签名。\n\n\nvalue_expr\n元素值表达式。该参数可以是其他元素也可以是文本。如果是其他元素，可以是 XMLType 列或者 XMLELEMENT、XMLAGG 等生成 XMLType 的表达式。\n\n\nXML_attributes_clause\n可选项，指定元素属性的表达式，具体信息参见 XMLATTRIBUTES。\n\n\nc_alias\n指定内容别名的字符串类型。\n\n\n",
            "返回 XMLType 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT XMLELEMENT(NAME \"Emp\", 'value') FROM DUAL;\n+-------------------------------+\n| XMLELEMENT(NAME\"EMP\",'VALUE') |\n+-------------------------------+\n| <Emp>value</Emp>\n             |\n+-------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "如下示例为构建一个元素名称为 Emp，元素内容为value 的 XML 元素。",
            "obclient> SELECT XMLELEMENT(NAME \"Emp\", 'value') FROM DUAL;\n+-------------------------------+\n| XMLELEMENT(NAME\"EMP\",'VALUE') |\n+-------------------------------+\n| <Emp>value</Emp>\n             |\n+-------------------------------+\n1 row in set\n"
        ]
    },
    "XMLPARSE": {
        "Title": [
            "XMLPARSE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823504"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLPARSE\n({ DOCUMENT | CONTENT } value_expr [ WELLFORMED ])\n",
        "Description": [
            "该函数解析输入的字符串并生成 XMLType 数据类型。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nDOCUMENT\n指定解析的内容必须为一个单根节点的 XML 文档。DOCUMENT 可以带声明头也可以不带。\n\n\nCONTENT\n指定解析的内容必须为一个有效的 XML 片段。CONTENT 一定不带声明头，否则会报错。\n\n\nvalue_expr\n指定被解析的字符串。结果的字符类型可以为 CHAR、VARCHAR2、NCHAR、NVARCHAR2 或 CLOB。\n\n\n注意：如果 value_expr 计算结果为 NULL，函数也会返回 NULL。\n\n\nWELLFORMED\n如果标记 WELLFORMED，将不执行解析内容的有效性检查，为可选项。\n\n\n",
            "返回 XMLType 数据类型。"
        ],
        "Examples": [
            "# 解析一个有效的 XML 片段 'abc'\nobclient> SELECT XMLPARSE(CONTENT '<a>abc</a>') FROM DUAL;\n+-------------------------------+\n| XMLPARSE(CONTENT'<A>ABC</A>') |\n+-------------------------------+\n| <a>abc</a>\n                   |\n+-------------------------------+\n1 row in set\n\n# 解析 XML DOCUMENT\nobclient> SELECT XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\" ?><body>135 <purchaseOrder poNo=\"12435\">\n         <customerName>  Enterprises</customerName>\n         <itemNo>123456</itemNo>\n         </purchaseOrder></body>'\n        WELLFORMED) AS PRO FROM DUAL;\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| PRO                                                                                                                                                                                   |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<body>135 <purchaseOrder poNo=\"12435\">\n    <customerName>  Enterprises</customerName>\n    <itemNo>123456</itemNo>\n  </purchaseOrder>\n</body>\n |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "# 解析一个有效的 XML 片段 'abc'\nobclient> SELECT XMLPARSE(CONTENT '<a>abc</a>') FROM DUAL;\n+-------------------------------+\n| XMLPARSE(CONTENT'<A>ABC</A>') |\n+-------------------------------+\n| <a>abc</a>\n                   |\n+-------------------------------+\n1 row in set\n\n# 解析 XML DOCUMENT\nobclient> SELECT XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\" ?><body>135 <purchaseOrder poNo=\"12435\">\n         <customerName>  Enterprises</customerName>\n         <itemNo>123456</itemNo>\n         </purchaseOrder></body>'\n        WELLFORMED) AS PRO FROM DUAL;\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| PRO                                                                                                                                                                                   |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<body>135 <purchaseOrder poNo=\"12435\">\n    <customerName>  Enterprises</customerName>\n    <itemNo>123456</itemNo>\n  </purchaseOrder>\n</body>\n |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "XMLSEQUENCE": {
        "Title": [
            "XMLSEQUENCE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823511"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLSEQUENCE( XMLType_instance)\n",
        "Description": [
            "该函数用于将 XML 文档内容转换为一个包含 XML 元素的 VARRAY。它将 XML 文档中的每个元素作为行返回，从而形成了一个包含 XML 元素的集合。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLType_instance\n此参数为 XML 类型的实例，作为函数的输入。\n\n\n",
            "返回一个 XMLType 集合。"
        ],
        "Examples": [
            "SELECT rownum, column_value\nFROM TABLE(\n    XMLSEQUENCE(\n        extract(\n            XMLtype('<Videogame>\n                <Type>Racing</Type>\n                <Name>NFS Most Wanted</Name>\n                <Version>2.0</Version>\n                <Size>5.5 GB</Size>\n            </Videogame>'),\n            '/Videogame/*'\n        )\n    )\n);\n",
            "+--------+-------------------------------+\n| ROWNUM | COLUMN_VALUE                  |\n+--------+-------------------------------+\n|      1 | <Type>Racing</Type>           |\n|      2 | <Name>NFS Most Wanted</Name>  |\n|      3 | <Version>2.0</Version>        |\n|      4 | <Size>5.5 GB</Size>           |\n+--------+-------------------------------+\n4 rows in set\n"
        ],
        "Detailed Examples": [
            "使用 XMLSEQUENCE 函数和 EXTRACT 函数来提取目标 XML 中指定的节点。其中，目标 XML 片段是 <Videogame> 节点及其子节点；XPath 表达式是 /Videogame/*，它指示要提取 <Videogame> 节点下的所有子节点；XMLSEQUENCE 函数将提取的节点作为表的一部分返回；使用 TABLE 函数将其转化为可查询的表。查询的结果使用 ROWNUM 作为行号，并将提取的节点值作为 column_value 列中的值返回。",
            "SELECT rownum, column_value\nFROM TABLE(\n    XMLSEQUENCE(\n        extract(\n            XMLtype('<Videogame>\n                <Type>Racing</Type>\n                <Name>NFS Most Wanted</Name>\n                <Version>2.0</Version>\n                <Size>5.5 GB</Size>\n            </Videogame>'),\n            '/Videogame/*'\n        )\n    )\n);\n",
            "返回结果如下：",
            "+--------+-------------------------------+\n| ROWNUM | COLUMN_VALUE                  |\n+--------+-------------------------------+\n|      1 | <Type>Racing</Type>           |\n|      2 | <Name>NFS Most Wanted</Name>  |\n|      3 | <Version>2.0</Version>        |\n|      4 | <Size>5.5 GB</Size>           |\n+--------+-------------------------------+\n4 rows in set\n"
        ]
    },
    "XMLSERIALIZE": {
        "Title": [
            "XMLSERIALIZE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823510"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLSERIALIZE\n  ( { DOCUMENT | CONTENT } value_expr [ AS datatype ]\n    [ ENCODING xml_encoding_spec ]\n    [ VERSION string_literal ]\n    [ NO INDENT | { INDENT [SIZE = number] } ]\n    [ { HIDE | SHOW } DEFAULTS ]\n  )\n",
        "Description": [
            "该函数将 XMLType 数据序列化为 VARCHAR、VARCHAR2、CLOB 或者 BLOB 类型，可通过参数进行格式化。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nDOCUMENT\n指定解析的内容，需符合 XML Document 规范。\n\n\nCONTENT\n指定解析的内容必须为一个有效的 XML 片段，但不一定合法。\n\n\nAS datatype\n指定返回的类型，可以定义为 VARCHAR、VARCHAR2、BLOB 或 CLOB，默认为 CLOB。如果返回类型是 BLOB，可以指定ENCODING。\n\n\nENCODING\n使用指定的编码。\n\n\nVERSION\n指定版本。\n\n\nNO INDENT ELEMENT\n指定层级之间不换行，不缩进。\n\n\nINDENT SIZE\n设置缩进空格数量。如果设置为 0，表示 ELEMENT 层级之间只换行，不缩进，默认值为 2。\n\n\nHIDE | SHOW DEFAULTS\n是否显示 XML Schema 所定义的默认值。\n\n\n",
            "返回 VARCHAR、VARCHAR2、CLOB 或者 BLOB 数据类型。"
        ],
        "Examples": [
            "obclient> SELECT XMLSERIALIZE(CONTENT XMLPARSE(CONTENT 'aaa' WELLFORMED) AS varchar2(100) VERSION '1.0') AS RES FROM DUAL;\n+---------------------------+\n| RES                       |\n+---------------------------+\n| <?xml version=\"1.0\"?>\naaa |\n+---------------------------+\n1 row in set\n\nobclient> SELECT XMLSERIALIZE(DOCUMENT XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<FROM>Jani</FROM>\n<heading>Reminder</heading>\n<body><p>Do not forget me this weekend!</p></body>\n</note>') AS varchar2(200) NO INDENT) AS RES FROM DUAL;\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| RES                                                                                                                                                            |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <?xml version=\"1.0\" encoding=\"UTF-8\"?><note><to>Tove</to><FROM>Jani</FROM><heading>Reminder</heading><body><p>Do not forget me this weekend!</p></body></note> |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\nobclient> SELECT XMLSERIALIZE(DOCUMENT XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<FROM>Jani</FROM>\n<heading>Reminder</heading>\n<body><p>Do not forget me this weekend!</p></body>\n</note>') AS varchar2(200)) AS RES FROM DUAL;\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| RES                                                                                                                                                                                   |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n  <to>Tove</to>\n  <FROM>Jani</FROM>\n  <heading>Reminder</heading>\n  <body>\n    <p>Do not forget me this weekend!</p>\n  </body>\n</note>\n |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "obclient> SELECT XMLSERIALIZE(CONTENT XMLPARSE(CONTENT 'aaa' WELLFORMED) AS varchar2(100) VERSION '1.0') AS RES FROM DUAL;\n+---------------------------+\n| RES                       |\n+---------------------------+\n| <?xml version=\"1.0\"?>\naaa |\n+---------------------------+\n1 row in set\n\nobclient> SELECT XMLSERIALIZE(DOCUMENT XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<FROM>Jani</FROM>\n<heading>Reminder</heading>\n<body><p>Do not forget me this weekend!</p></body>\n</note>') AS varchar2(200) NO INDENT) AS RES FROM DUAL;\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| RES                                                                                                                                                            |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <?xml version=\"1.0\" encoding=\"UTF-8\"?><note><to>Tove</to><FROM>Jani</FROM><heading>Reminder</heading><body><p>Do not forget me this weekend!</p></body></note> |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\nobclient> SELECT XMLSERIALIZE(DOCUMENT XMLPARSE(DOCUMENT '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<FROM>Jani</FROM>\n<heading>Reminder</heading>\n<body><p>Do not forget me this weekend!</p></body>\n</note>') AS varchar2(200)) AS RES FROM DUAL;\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| RES                                                                                                                                                                                   |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n  <to>Tove</to>\n  <FROM>Jani</FROM>\n  <heading>Reminder</heading>\n  <body>\n    <p>Do not forget me this weekend!</p>\n  </body>\n</note>\n |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n"
        ]
    },
    "XMLTABLE": {
        "Title": [
            "XMLTABLE"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823513"
        ],
        "Category": [
            "XML Functions"
        ],
        "Feature": "XMLTABLE( [ XMLnamespaces_clause , ] XQuery_string XMLTABLE_options )\n\nXMLnamespaces_clause：\n XMLNAMESPACES( { string AS identifier } | { DEFAULT string } [, { string AS identifier } | { DEFAULT string } ]...)\n\nXMLTABLE_options：\n  [ XML_passing_clause ]\n  [ COLUMNS XML_table_column [, XML_table_column]...]\n\nXML_passing_clause：\n  PASSING [ BY VALUE ] expr [ AS identifier ]\n\nXML_table_column：\n  column { FOR ORDINALITY \n          | { datatype | XMLTYPE } [ PATH string ] [ DEFAULT expr ]\n  }\n",
        "Description": [
            "该函数用于将 Xpath 返回的结果映射到关系表的行和列中。您可以使用 SQL 查询函数返回的结果作为虚拟关系表。",
            "XMLTABLE 功能的关键能力包括：",
            "数据提取能力：通过在 XMLTABLE 中指定适当的 XPath 表达式，可以精准地从复杂的 XML 文档中提取所需的数据部分。",
            "数据结构化：XMLTABLE 能够将 XML 数据的特定部分映射到关系型表的行和列上，从而将半结构化的 XML 数据转换成结构化的表格形式，使其易于进行 SQL 查询和分析。",
            "表格转换：你可以利用 XMLTABLE 产生的结构化数据建立虚拟表，并且可以将这些表数据用于生成新的表格或视图，从而在数据库中保存或进一步操作这些处理过的数据。"
        ],
        "Illustration": [
            "\n\n\n字段\n说明\n\n\n\n\nXMLnamespaces_clause\n定义命名空间前缀和 URI，用于在 XML 查询中引用具有命名空间的元素和属性。该子句包含一组 XML 命名空间声明，这些声明被 XML_table_column 的 PATH 子句中的 XPath 表达式引用，该表达式计算整个 XMLTable 函数的列。如果您想在 COLUMNS 子句的 PATH 表达式中使用限定名称，则需要指定该子句。\n\n\nXQuery_string\n指定 XQuery 表达式，用于从 XML 数据中选择需要转换的数据。XQuery 是一种 XML 查询语言，用于从 XML 文档中提取数据和实现复杂的查询操作，这个参数允许你使用 XQuery 语法来定义从 XML 数据中提取哪些元素或属性的指令。 \n      \n注意\nOceanBase 数据库当前版本暂不支持 XQuery。\n\n\n\nXML_passing_clause\n通过 PASSING 关键字指定传递给 XQuery 的 XML 数据。可以指定按值传递以及传递数据的别名。具体如下： \n      \nPASSING: 用来带出 XML_passing_clause 的开始。PASSING 子句的内容是 XMLTABLE 的输入。\nBY VALUE: 可选关键字，表示传递的数据将按值传递，而不是按引用传递。在大多数情况下，可以省略这个选项，因为按值传递是默认的行为。\nexpr: 是一个返回 XMLType 或 SQL 标量数据类型实例的表达式，其结果是要传递给 XQuery 的 XML 数据。这个表达式通常是一个返回 XML 类型数据的列名、变量或者更复杂的表达式。PASSING 子句当前在当前版本仅支持指定一个 expr。\nAS identifier: 可选项，它为 expr 参数结果指定一个别名（即标识符）。在 XQuery 表达式中，可以使用这个别名来引用传递的数据。\n\n\n\nCOLUMNS\n可选的 COLUMNS 子句定义了由 XMLTable 创建的虚拟表的列。 如果您省略 COLUMNS 子句，则 XMLTable 返回一个带有名为 COLUMN_VALUE 的单个 XMLType 伪列的行。\n\n\nXML_table_column\n定义要生成的表列，可以是普通数据类型列或 XMLTYPE 列。还可以指定列值的 XPath 路径和默认值。FOR ORDINALITY 用于生成行号。具体如下： \n      \nFOR ORDINALITY：指定该列将是生成的行号列。最多只能有一个 FOR ORDINALITY 子句。它被创建为一个 NUMBER 列。\ndatatype 或 XMLTYPE：除了 FOR ORDINALITY 列之外，对于每个结果列，您必须指定列的数据类型，可以是 XMLType 或任何其他数据类型。如果列的数据类型是 XMLType，则需要指定 XMLTYPE 子句。 通过引用返回 XMLType 数据可以让您指定其他列，其路径定位的节点在源数据中位于列的 PATH 表达式所定位的节点之外。如果列的数据类型是任何其他数据类型，则需要指定数据类型。 \n        \nPATH string：可选项，指定由 XQuery 表达式字符串处理的 XQuery 结果的部分将用作列内容。如果省略 PATH，则假定为 XQuery 表达式列。例如：XMLTable(... COLUMNS xyz)。\nDEFAULT expr：可选项，指定在 PATH 表达式结果为空序列时要使用的值。其 expr 是一个 XQuery 表达式，用于生成默认值。\n\n\n\n\n",
            "返回的数据类型取决于 XMLTable 函数中指定的列的数据类型。"
        ],
        "Examples": [
            "SELECT *\nFROM XMLTABLE(\n       XMLNAMESPACES(DEFAULT 'http://www.example.com/employees'),\n       '/employees/employee'\n       PASSING XMLTYPE('\n          <employees xmlns=\"http://www.example.com/employees\">\n               <employee>\n                    <emp_id>1</emp_id>\n                    <name>John Doe</name>\n                    <position>Developer</position>\n                    <salary>5000</salary>\n               </employee>\n               <employee>\n                    <emp_id>2</emp_id>\n                    <name>Jane Smith</name>\n                    <position>Manager</position>\n                    <salary>6500</salary>\n               </employee>\n          </employees>'\n     )\n     COLUMNS\n          employee_id    INT           PATH 'emp_id',\n          employee_name  VARCHAR2(100) PATH 'name',\n          position       VARCHAR2(50)  PATH 'position',\n          salary         NUMBER        PATH 'salary'\n) AS emp_tab;\n",
            "+-------------+---------------+-----------+--------+\n| EMPLOYEE_ID | EMPLOYEE_NAME | POSITION  | SALARY |\n+-------------+---------------+-----------+--------+\n|           1 | John Doe      | Developer |   5000 |\n|           2 | Jane Smith    | Manager   |   6500 |\n+-------------+---------------+-----------+--------+\n2 rows in set\n"
        ],
        "Detailed Examples": [
            "使用 XMLTABLE 函数将 XML 数据转换为一个 SQL 表，其中包含员工的 ID、姓名、职位和薪水。具体如下：",
            "定义默认命名空间为 http://www.example.com/employees 来匹配 XML 数据中的命名空间。",
            "定义 XQuery 表达式为 '/employees/employee' 来选择所有员工（employee）元素。",
            "通过 PASSING 子句用来指定传递给 XQuery 表达式的 XML 文档。在本示例中，整个 XML 文档通过 XMLTYPE 构造函数进行了封装。XMLTYPE 将字符串形式的 XML 数据转换为数据库可以处理的 XML 类型。",
            "在 COLUMNS 子句中，定义了四列来映射从 XML 中提取的数据。对应关系如下：",
            "\nemployee_id 列映射到每个 employee 元素下的 emp_id。\nemployee_name 列映射到每个 employee 元素下的 name。\nposition 列映射到每个 employee 元素下的 position。\nsalary 列映射到每个 employee 元素下的 salary。\n",
            "每个列后的 PATH 子句定义了从哪里提取相应的值。",
            "employee_id",
            " 列映射到每个 ",
            "employee",
            " 元素下的 ",
            "emp_id",
            "。",
            "employee_name",
            " 列映射到每个 ",
            "employee",
            " 元素下的 ",
            "name",
            "。",
            "position",
            " 列映射到每个 ",
            "employee",
            " 元素下的 ",
            "position",
            "。",
            "salary",
            " 列映射到每个 ",
            "employee",
            " 元素下的 ",
            "salary",
            "。",
            "SELECT *\nFROM XMLTABLE(\n       XMLNAMESPACES(DEFAULT 'http://www.example.com/employees'),\n       '/employees/employee'\n       PASSING XMLTYPE('\n          <employees xmlns=\"http://www.example.com/employees\">\n               <employee>\n                    <emp_id>1</emp_id>\n                    <name>John Doe</name>\n                    <position>Developer</position>\n                    <salary>5000</salary>\n               </employee>\n               <employee>\n                    <emp_id>2</emp_id>\n                    <name>Jane Smith</name>\n                    <position>Manager</position>\n                    <salary>6500</salary>\n               </employee>\n          </employees>'\n     )\n     COLUMNS\n          employee_id    INT           PATH 'emp_id',\n          employee_name  VARCHAR2(100) PATH 'name',\n          position       VARCHAR2(50)  PATH 'position',\n          salary         NUMBER        PATH 'salary'\n) AS emp_tab;\n",
            "返回结果如下：",
            "+-------------+---------------+-----------+--------+\n| EMPLOYEE_ID | EMPLOYEE_NAME | POSITION  | SALARY |\n+-------------+---------------+-----------+--------+\n|           1 | John Doe      | Developer |   5000 |\n|           2 | Jane Smith    | Manager   |   6500 |\n+-------------+---------------+-----------+--------+\n2 rows in set\n"
        ]
    },
    "ZIPF": {
        "Title": [
            "ZIPF"
        ],
        "HTML": [
            "https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-1000000000823154"
        ],
        "Category": [
            "Numeric Functions"
        ],
        "Feature": "ZIPF(<s> , <N> , <gen>)\n",
        "Description": [],
        "Illustration": [
            "该函数返回一个符合齐夫分布（Zipf-distributed）的整数，取值范围为 [0, N)，分区的特征指数为 s。",
            "s",
            " 为特征指数，",
            "s",
            " 越大生成的序列越倾斜。将序列绘制成曲线时，曲线越陡峭。",
            "s",
            " 和 ",
            "N",
            " 取值要求：必须是一个标量值，不随行迭代而变。例如，整形或浮点型常量、标量函数等，PL 里还可以是 ",
            "@v1",
            "、",
            "1+@v3",
            " 等。",
            "s",
            " 的取值范围为 [1, +∞)，",
            "N",
            " 的取值范围为 [1，16777215]。",
            "zipf",
            " 算法实现时消耗的存储、计算资源和 ",
            "N",
            " 的取值相关。算法空间复杂度为 ",
            "O(N)",
            "，每生成一个整数的时间复杂度为 ",
            "O(logN)",
            "。所以，",
            "N",
            " 的取值范围被限制为 [1, 16777215]。",
            "gen",
            " 是一个数值生成函数，通常使用 ",
            "RANDOM()",
            " 函数生成。如果传入值是一个常量，则 ",
            "zipf()",
            " 函数返回值也为一个定值。"
        ],
        "Examples": [
            "obclient> SELECT ZIPF(1, 10, RANDOM()) FROM TABLE(GENERATOR(6));\n+-----------------------+\n|  ZIPF(1,10,RANDOM())  |\n+-----------------------+\n|                     2 |\n|                     0 |\n|                     0 |\n|                     0 |\n|                     3 |\n|                     3 |\n+-----------------------+\n6 rows in set\n\nobclient> SELECT ZIPF(1, 10, 0415) FROM TABLE(GENERATOR(6));\n+-------------------+\n| ZIPF(1, 10, 0415) |\n+-------------------+\n|                 1 |\n|                 1 |\n|                 1 |\n|                 1 |\n|                 1 |\n|                 1 |\n+-------------------+\n6 rows in set\n\nobclient> SELECT ZIPF(ABS(-1), 23, RANDOM()) FROM DUAL;\n+-----------------------------+\n| ZIPF(ABS(-1),23,RANDOM()) |\n+-----------------------------+\n|                           9 |\n+-----------------------------+\n1 row in set\n"
        ],
        "Detailed Examples": [
            "如下示例为使用 ZIPF() 函数返回符合齐夫分布的整数。",
            "obclient> SELECT ZIPF(1, 10, RANDOM()) FROM TABLE(GENERATOR(6));\n+-----------------------+\n|  ZIPF(1,10,RANDOM())  |\n+-----------------------+\n|                     2 |\n|                     0 |\n|                     0 |\n|                     0 |\n|                     3 |\n|                     3 |\n+-----------------------+\n6 rows in set\n\nobclient> SELECT ZIPF(1, 10, 0415) FROM TABLE(GENERATOR(6));\n+-------------------+\n| ZIPF(1, 10, 0415) |\n+-------------------+\n|                 1 |\n|                 1 |\n|                 1 |\n|                 1 |\n|                 1 |\n|                 1 |\n+-------------------+\n6 rows in set\n\nobclient> SELECT ZIPF(ABS(-1), 23, RANDOM()) FROM DUAL;\n+-----------------------------+\n| ZIPF(ABS(-1),23,RANDOM()) |\n+-----------------------------+\n|                           9 |\n+-----------------------------+\n1 row in set\n"
        ]
    }
}