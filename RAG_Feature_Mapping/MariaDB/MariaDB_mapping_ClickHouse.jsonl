{
  "index": 0,
  "doc": "ABS(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " abs(a)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " floor(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " sign(x)"
    }
  ]
}
{
  "index": 1,
  "doc": "ACOS(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " acos(x)"
    },
    {
      "index": "Feature",
      "doc": " cos(x)"
    },
    {
      "index": "Feature",
      "doc": " asinh(x)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    }
  ]
}
{
  "index": 2,
  "doc": "ADDDATE(date,INTERVAL expr unit), ADDDATE(expr,days)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addDate(date, interval)"
    },
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " addDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    }
  ]
}
{
  "index": 3,
  "doc": "ADDTIME(expr1,expr2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    }
  ]
}
{
  "index": 4,
  "doc": "ADD_MONTHS(date, months)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addMonths(date, num)"
    },
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " changeMonth(date_or_datetime, value)"
    },
    {
      "index": "Feature",
      "doc": " monthName(date)"
    }
  ]
}
{
  "index": 5,
  "doc": "AES_DECRYPT(crypt_str,key_str)\nFrom MariaDB 11.2.0AES_ENCRYPT(crypt_str, key_str, [, iv [, mode]])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 6,
  "doc": "AES_ENCRYPT(str,key_str)\nFrom MariaDB 11.2.0AES_ENCRYPT(str, key, [, iv [, mode]])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 7,
  "doc": "ASCII(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " asin(x)"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    }
  ]
}
{
  "index": 8,
  "doc": "ASIN(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " asin(x)"
    },
    {
      "index": "Feature",
      "doc": " asinh(x)"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    }
  ]
}
{
  "index": 10,
  "doc": "ATAN(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " atan(x)"
    },
    {
      "index": "Feature",
      "doc": " atan2(y, x)"
    },
    {
      "index": "Feature",
      "doc": " atanh(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    }
  ]
}
{
  "index": 11,
  "doc": "ATAN(Y,X), ATAN2(Y,X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " atan2(y, x)"
    },
    {
      "index": "Feature",
      "doc": " atan(x)"
    },
    {
      "index": "Feature",
      "doc": " atanh(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    }
  ]
}
{
  "index": 12,
  "doc": "AVG([DISTINCT] expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " arrayReduceInRanges(agg_func, ranges, arr1, arr2, ..., arrN)"
    },
    {
      "index": "Feature",
      "doc": " arrayReduce(agg_func, arr1, arr2, ..., arrN)"
    },
    {
      "index": "Feature",
      "doc": " groupArrayMovingSum(numbers_for_summing)groupArrayMovingSum(window_size)(numbers_for_summing)"
    }
  ]
}
{
  "index": 13,
  "doc": "BENCHMARK(count,expr)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " quantilesGK(accuracy, level1, level2, ...)(expr)"
    },
    {
      "index": "Feature",
      "doc": " quantileTiming(level)(expr)"
    },
    {
      "index": "Feature",
      "doc": " quantileExactExclusive(level)(expr)"
    },
    {
      "index": "Feature",
      "doc": " quantileGK(accuracy, level)(expr)"
    }
  ]
}
{
  "index": 14,
  "doc": "BIN(N)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bin(arg)"
    },
    {
      "index": "Feature",
      "doc": " histogram(number_of_bins)(values)"
    },
    {
      "index": "Feature",
      "doc": " byteHammingDistance(string1, string2)"
    },
    {
      "index": "Feature",
      "doc": " MACStringToOUI(s)"
    }
  ]
}
{
  "index": 15,
  "doc": "BINARY\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " byteHammingDistance(string1, string2)"
    },
    {
      "index": "Feature",
      "doc": " MACStringToOUI(s)"
    },
    {
      "index": "Feature",
      "doc": " bitAnd(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitXor(a, b)"
    }
  ]
}
{
  "index": 16,
  "doc": "BINLOG_GTID_POS(binlog_filename,binlog_offset)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bin(arg)"
    },
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " addressToLine(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " addressToLineWithInlines(address_of_binary_instruction)"
    }
  ]
}
{
  "index": 17,
  "doc": "BIT_AND(expr) [over_clause]\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bitAnd(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitXor(a, b)"
    },
    {
      "index": "Feature",
      "doc": " SELECT bitTest(number, index)"
    },
    {
      "index": "Feature",
      "doc": " bitCount(x)"
    }
  ]
}
{
  "index": 18,
  "doc": "BIT_LENGTH(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bitSlice(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " bitAnd(a, b)"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 19,
  "doc": "BIT_OR(expr) [over_clause]\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SELECT bitTest(number, index)"
    },
    {
      "index": "Feature",
      "doc": " bitAnd(a, b)"
    },
    {
      "index": "Feature",
      "doc": " SELECT bitTestAll(number, index1, index2, index3, index4, ...)"
    },
    {
      "index": "Feature",
      "doc": " bitXor(a, b)"
    }
  ]
}
{
  "index": 20,
  "doc": "BIT_XOR(expr) [over_clause]\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bitXor(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitOr(a, b)"
    },
    {
      "index": "Feature",
      "doc": " groupBitXor(expr)"
    },
    {
      "index": "Feature",
      "doc": " bitCount(x)"
    }
  ]
}
{
  "index": 22,
  "doc": "CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN\nresult ...] [ELSE result] END\n\nCASE WHEN [condition] THEN result [WHEN [condition] THEN result ...]\n[ELSE result] END\n,Control Flow Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " if(cond, then, else)"
    },
    {
      "index": "Feature",
      "doc": " Using Conditional Results Directly"
    },
    {
      "index": "Feature",
      "doc": " multiIf(cond_1, then_1, cond_2, then_2, ..., else)"
    },
    {
      "index": "Feature",
      "doc": " NULL Values in Conditionals"
    }
  ]
}
{
  "index": 23,
  "doc": "CAST(expr AS type)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toInt256OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toInt32OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toInt128OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toUInt256OrDefault(expr[, default])"
    }
  ]
}
{
  "index": 24,
  "doc": "CEIL(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " intExp10(x)"
    },
    {
      "index": "Feature",
      "doc": " exp(x)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    },
    {
      "index": "Feature",
      "doc": " intExp2(x)"
    }
  ]
}
{
  "index": 25,
  "doc": "CEILING(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ceiling(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " floor(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " isZeroOrNull(x)"
    }
  ]
}
{
  "index": 27,
  "doc": "CHAR(N,... [USING charset_name])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " char(number_1, [number_2, ..., number_n]);"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 28,
  "doc": "CHARACTER_LENGTH(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    }
  ]
}
{
  "index": 29,
  "doc": "CHARSET(str)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " char(number_1, [number_2, ..., number_n]);"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    }
  ]
}
{
  "index": 30,
  "doc": "CHAR_LENGTH(str)\nCHARACTER_LENGTH(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " lengthUTF8(s)"
    }
  ]
}
{
  "index": 31,
  "doc": "CHR(N)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " char(number_1, [number_2, ..., number_n]);"
    },
    {
      "index": "Feature",
      "doc": " substringIndexUTF8(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    }
  ]
}
{
  "index": 32,
  "doc": "COERCIBILITY(str)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " entropy(val)"
    },
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " Distance functions"
    },
    {
      "index": "Feature",
      "doc": " quantileDeterministic(level)(expr, determinator)"
    }
  ]
}
{
  "index": 33,
  "doc": "COLLATION(str)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " translateUTF8(s, from, to)"
    },
    {
      "index": "Feature",
      "doc": " format(pattern, s0, s1, ...)"
    },
    {
      "index": "Feature",
      "doc": " translate(s, from, to)"
    }
  ]
}
{
  "index": 34,
  "doc": "COLUMN_ADD(dyncol_blob, column_nr, value [as type], [column_nr, value [as type]]...);\nCOLUMN_ADD(dyncol_blob, column_name, value [as type], [column_name, value [as type]]...);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " theilsU(column1, column2)"
    }
  ]
}
{
  "index": 35,
  "doc": "COLUMN_CHECK(dyncol_blob);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " generateRandomStructure([number_of_columns, seed])"
    }
  ]
}
{
  "index": 36,
  "doc": "COLUMN_CREATE(column_nr, value [as type], [column_nr, value [as type]]...);\nCOLUMN_CREATE(column_name, value [as type], [column_name, value [as type]]...);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " toColumnTypeName(value)"
    }
  ]
}
{
  "index": 37,
  "doc": "COLUMN_DELETE(dyncol_blob, column_nr, column_nr...);\nCOLUMN_DELETE(dyncol_blob, column_name, column_name...);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " theilsU(column1, column2)"
    }
  ]
}
{
  "index": 38,
  "doc": "COLUMN_EXISTS(dyncol_blob, column_nr);\nCOLUMN_EXISTS(dyncol_blob, column_name);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " theilsU(column1, column2)"
    }
  ]
}
{
  "index": 39,
  "doc": "COLUMN_GET(dyncol_blob, column_nr as type);\nCOLUMN_GET(dyncol_blob, column_name as type);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " theilsU(column1, column2)"
    }
  ]
}
{
  "index": 40,
  "doc": "COLUMN_JSON(dyncol_blob)\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " generateRandomStructure([number_of_columns, seed])"
    }
  ]
}
{
  "index": 41,
  "doc": "COLUMN_LIST(dyncol_blob);\n,Dynamic Columns Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " Virtual Columns"
    },
    {
      "index": "Feature",
      "doc": " dumpColumnStructure(value)"
    },
    {
      "index": "Feature",
      "doc": " theilsU(column1, column2)"
    }
  ]
}
{
  "index": 42,
  "doc": "COMPRESS(string_to_compress)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 43,
  "doc": "CONCAT(str1,str2,...)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " concat(s1, s2, ...)"
    },
    {
      "index": "Feature",
      "doc": " concatWithSeparator(sep, expr1, expr2, expr3...)"
    },
    {
      "index": "Feature",
      "doc": " concatAssumeInjective(s1, s2, ...)"
    },
    {
      "index": "Feature",
      "doc": " stringJaccardIndex(string1, string2)"
    }
  ]
}
{
  "index": 44,
  "doc": "CONCAT_WS(separator,str1,str2,...)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " concat(s1, s2, ...)"
    },
    {
      "index": "Feature",
      "doc": " splitByChar(separator, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " splitByString(separator, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " concatWithSeparator(sep, expr1, expr2, expr3...)"
    }
  ]
}
{
  "index": 45,
  "doc": "CONNECTION_ID()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " connection_id()"
    },
    {
      "index": "Feature",
      "doc": " connectionId()"
    },
    {
      "index": "Feature",
      "doc": " queryID()"
    },
    {
      "index": "Feature",
      "doc": " transactionID()"
    }
  ]
}
{
  "index": 46,
  "doc": "Contains(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " regionIn(lhs, rhs\\[, geobase\\])"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " regionHierarchy(id\\[, geobase\\])"
    },
    {
      "index": "Feature",
      "doc": " regionToCity(id [, geobase])"
    }
  ]
}
{
  "index": 47,
  "doc": "CONV(N,from_base,to_base)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ceiling(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " roundBankers(x [, N])"
    },
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " approx_top_k(N)(column)approx_top_k(N, reserved)(column)"
    }
  ]
}
{
  "index": 48,
  "doc": "CONVERT(expr,type), CONVERT(expr USING transcoding_name)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " basename(expr)"
    },
    {
      "index": "Feature",
      "doc": " trimLeft(input_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    }
  ]
}
{
  "index": 49,
  "doc": "CONVERT_TZ(dt,from_tz,to_tz)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_trunc(unit, value[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " toWeek(t[, mode[, time_zone]])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTimeBestEffort(time_string [, time_zone])"
    },
    {
      "index": "Feature",
      "doc": " fromUTCTimestamp(time_val, time_zone)"
    }
  ]
}
{
  "index": 51,
  "doc": "COS(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " cos(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " corr(x, y)"
    }
  ]
}
{
  "index": 52,
  "doc": "COT(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " tan(x)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    },
    {
      "index": "Feature",
      "doc": " sin(x)"
    },
    {
      "index": "Feature",
      "doc": " cos(x)"
    }
  ]
}
{
  "index": 53,
  "doc": "COUNT(DISTINCT expr,[expr...])\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " countDigits(x)"
    },
    {
      "index": "Feature",
      "doc": " count"
    },
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " countMatches(haystack, pattern)"
    }
  ]
}
{
  "index": 54,
  "doc": "COUNT(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " count"
    },
    {
      "index": "Feature",
      "doc": " countDigits(x)"
    },
    {
      "index": "Feature",
      "doc": " countEqual(arr, x)"
    },
    {
      "index": "Feature",
      "doc": " countMatches(haystack, pattern)"
    }
  ]
}
{
  "index": 55,
  "doc": "<= MariaDB 10.7CRC32(expr)\nFrom MariaDB 10.8CRC32([par,]expr)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt256(expr)"
    },
    {
      "index": "Feature",
      "doc": " quantile(level)(expr)"
    },
    {
      "index": "Feature",
      "doc": " intExp10(x)"
    }
  ]
}
{
  "index": 56,
  "doc": "CRC32C([par,]expr)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toDate32(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt32(expr)"
    },
    {
      "index": "Feature",
      "doc": " toUInt64OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toUInt32OrDefault(expr[, default])"
    }
  ]
}
{
  "index": 57,
  "doc": "Crosses(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 58,
  "doc": "CUME_DIST() OVER ( \n  [ PARTITION BY partition_expression ] \n  [ ORDER BY order_list ]\n)\n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " row_number (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " leadInFrame(x[, offset[, default]])  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " lagInFrame(x[, offset[, default]])  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 59,
  "doc": "CURDATE()\nCURRENT_DATE\nCURRENT_DATE()\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " toDaysSinceYearZero(date[, time_zone])"
    },
    {
      "index": "Feature",
      "doc": " changeDay(date_or_datetime, value)"
    }
  ]
}
{
  "index": 60,
  "doc": "CURRENT_DATE, CURRENT_DATE()\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " changeDay(date_or_datetime, value)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    }
  ]
}
{
  "index": 61,
  "doc": "CURRENT_ROLE, CURRENT_ROLE()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " currentRoles()"
    },
    {
      "index": "Feature",
      "doc": " defaultRoles()"
    },
    {
      "index": "Feature",
      "doc": " enabledRoles()"
    },
    {
      "index": "Feature",
      "doc": " currentUser()"
    }
  ]
}
{
  "index": 62,
  "doc": "CURRENT_TIME\nCURRENT_TIME([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMicroseconds(date_time, num)"
    }
  ]
}
{
  "index": 63,
  "doc": "CURRENT_TIMESTAMP\nCURRENT_TIMESTAMP([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 64,
  "doc": "CURRENT_USER, CURRENT_USER()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " currentUser()"
    },
    {
      "index": "Feature",
      "doc": " currentRoles()"
    },
    {
      "index": "Feature",
      "doc": " currentProfiles()"
    },
    {
      "index": "Feature",
      "doc": " currentDatabase()"
    }
  ]
}
{
  "index": 65,
  "doc": "CURTIME([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDateTime64(year, month, day, hour, minute, second[, precision])"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " toRelativeSecondNum(date)"
    }
  ]
}
{
  "index": 66,
  "doc": "DATABASE()\nSCHEMA()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " currentDatabase()"
    },
    {
      "index": "Feature",
      "doc": " Usage Example"
    },
    {
      "index": "Feature",
      "doc": " stddevSampStable(x)"
    },
    {
      "index": "Feature",
      "doc": " Usage"
    }
  ]
}
{
  "index": 67,
  "doc": "DATE(expr)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " toRelativeSecondNum(date)"
    },
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    }
  ]
}
{
  "index": 68,
  "doc": "DATEDIFF(expr1,expr2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractHours(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMinutes(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    }
  ]
}
{
  "index": 69,
  "doc": "DATE_ADD(date,INTERVAL expr unit)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addDate(date, interval)"
    }
  ]
}
{
  "index": 70,
  "doc": "DATE_FORMAT(date, format[, locale])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime(str[, format[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " date_trunc(unit, value[, timezone])"
    }
  ]
}
{
  "index": 71,
  "doc": "DATE_SUB(date,INTERVAL expr unit)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subDate(date, interval)"
    }
  ]
}
{
  "index": 72,
  "doc": "DAY(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " addDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    },
    {
      "index": "Feature",
      "doc": " toRelativeDayNum(date)"
    }
  ]
}
{
  "index": 73,
  "doc": "DAYNAME(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toRelativeDayNum(date)"
    },
    {
      "index": "Feature",
      "doc": " addDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    }
  ]
}
{
  "index": 74,
  "doc": "DAYOFMONTH(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toDayOfMonth(value)"
    },
    {
      "index": "Feature",
      "doc": " toLastDayOfMonth(value)"
    },
    {
      "index": "Feature",
      "doc": " makeDate32(year, [month,] day)"
    },
    {
      "index": "Feature",
      "doc": " addMonths(date, num)"
    }
  ]
}
{
  "index": 75,
  "doc": "DAYOFWEEK(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " addWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toRelativeWeekNum(date)"
    },
    {
      "index": "Feature",
      "doc": " toDayOfWeek(t[, mode[, timezone]])"
    }
  ]
}
{
  "index": 76,
  "doc": "DAYOFYEAR(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    },
    {
      "index": "Feature",
      "doc": " fromDaysSinceYearZero(days)"
    },
    {
      "index": "Feature",
      "doc": " toDayOfYear(value)"
    },
    {
      "index": "Feature",
      "doc": " subtractYears(date, num)"
    }
  ]
}
{
  "index": 77,
  "doc": "DECODE(crypt_str,pass_str)\nIn Oracle mode from MariaDB 10.3.2:DECODE(expr, search_expr, result_expr [, search_expr2, result_expr2 ...] [default_expr])\nIn all modes from MariaDB 10.3.2:DECODE_ORACLE(expr, search_expr, result_expr [, search_expr2, result_expr2 ...] [default_expr])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 78,
  "doc": "DECODE_HISTOGRAM(hist_type,histogram)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " histogram(number_of_bins)(values)"
    },
    {
      "index": "Feature",
      "doc": " base58Decode(encoded)"
    },
    {
      "index": "Feature",
      "doc": " bitShiftLeft(a, b)"
    },
    {
      "index": "Feature",
      "doc": " base58Encode(plaintext)"
    }
  ]
}
{
  "index": 79,
  "doc": "DEFAULT(col_name)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " defaultValueOfTypeName(type)"
    },
    {
      "index": "Feature",
      "doc": " displayName()"
    },
    {
      "index": "Feature",
      "doc": " tupleElement(tuple, index, [, default_value])tupleElement(tuple, name, [, default_value])"
    }
  ]
}
{
  "index": 80,
  "doc": "DEGREES(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " degrees(x)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " sin(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    }
  ]
}
{
  "index": 81,
  "doc": "DENSE_RANK() OVER (\n  [ PARTITION BY partition_expression ]\n  [ ORDER BY order_list ]\n) \n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " dense_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " percent_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]] | [window_name])FROM table_nameWINDOW window_name as ([PARTITION BY grouping_column] [ORDER BY sorting_column] RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)"
    },
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 82,
  "doc": "DES_DECRYPT(crypt_str[,key_str])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 83,
  "doc": "DES_ENCRYPT(str[,{key_num|key_str}])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    }
  ]
}
{
  "index": 85,
  "doc": "Disjoint(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geoToS2(lon, lat)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    }
  ]
}
{
  "index": 86,
  "doc": "ELT(N, str1[, str2, str3,...])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " char(number_1, [number_2, ..., number_n]);"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " arrayElement(arr, n), operator arr[n]"
    },
    {
      "index": "Feature",
      "doc": " truncate(x[, N])"
    }
  ]
}
{
  "index": 87,
  "doc": "ENCODE(str,pass_str)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " base64Decode(encoded)"
    },
    {
      "index": "Feature",
      "doc": " base64Encode(plaintext)"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 88,
  "doc": "ENCRYPT(str[,salt])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    }
  ]
}
{
  "index": 89,
  "doc": "Equals(g1,g2)\nFrom MariaDB 10.2.3:MBREQUALS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " notEquals(a, b)"
    },
    {
      "index": "Feature",
      "doc": " lessOrEquals(a, b)"
    },
    {
      "index": "Feature",
      "doc": " equals(a, b)"
    },
    {
      "index": "Feature",
      "doc": " greaterOrEquals(a, b)"
    }
  ]
}
{
  "index": 90,
  "doc": "EXP(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " exp(x)"
    },
    {
      "index": "Feature",
      "doc": " exp2(x)"
    },
    {
      "index": "Feature",
      "doc": " exp10(x)"
    },
    {
      "index": "Feature",
      "doc": " intExp10(x)"
    }
  ]
}
{
  "index": 91,
  "doc": "EXPORT_SET(bits, on, off[, separator[, number_of_bits]])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bitSlice(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " bitXor(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitAnd(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitShiftRight(a, b)"
    }
  ]
}
{
  "index": 92,
  "doc": "EXTRACT(unit FROM date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " date_trunc(unit, value[, timezone])"
    }
  ]
}
{
  "index": 93,
  "doc": "EXTRACTVALUE(xml_frag, xpath_expr)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " extractTextFromHTML(x)"
    },
    {
      "index": "Feature",
      "doc": " extractAllGroups(text, regexp)"
    },
    {
      "index": "Feature",
      "doc": " splitByRegexp(regexp, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " decodeXMLComponent(x)"
    }
  ]
}
{
  "index": 94,
  "doc": "sys.extract_schema_from_file_name(path)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " catboostEvaluate(path_to_model, feature_1, feature_2, ..., feature_n)"
    },
    {
      "index": "Feature",
      "doc": " merge(['db_name',] 'tables_regexp')"
    },
    {
      "index": "Feature",
      "doc": " hdfsCluster(cluster_name, URI, format, structure)"
    },
    {
      "index": "Feature",
      "doc": " structureToProtobufSchema(structure)"
    }
  ]
}
{
  "index": 95,
  "doc": "sys.extract_table_from_file_name(path)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " merge(['db_name',] 'tables_regexp')"
    },
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    },
    {
      "index": "Feature",
      "doc": " row_number (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    }
  ]
}
{
  "index": 96,
  "doc": "FIELD(pattern, str1[,str2,...])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " format(pattern, s0, s1, ...)"
    },
    {
      "index": "Feature",
      "doc": " char(number_1, [number_2, ..., number_n]);"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " multiMatchAnyIndex(haystack, \\[pattern<sub>1</sub>, pattern<sub>2</sub>, ..., pattern<sub>n</sub>\\])"
    }
  ]
}
{
  "index": 97,
  "doc": "FIND_IN_SET(pattern, strlist)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " match(haystack, pattern)"
    },
    {
      "index": "Feature",
      "doc": " multiFuzzyMatchAnyIndex(haystack, distance, \\[pattern<sub>1</sub>, pattern<sub>2</sub>, ..., pattern<sub>n</sub>\\])"
    },
    {
      "index": "Feature",
      "doc": " like(haystack, pattern)"
    },
    {
      "index": "Feature",
      "doc": " multiFuzzyMatchAny(haystack, distance, \\[pattern<sub>1</sub>, pattern<sub>2</sub>, ..., pattern<sub>n</sub>\\])"
    }
  ]
}
{
  "index": 98,
  "doc": "FLOOR(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " floor(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " isZeroOrNull(x)"
    },
    {
      "index": "Feature",
      "doc": " ceiling(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    }
  ]
}
{
  "index": 99,
  "doc": "FORMAT(num, decimal_position[, locale])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " MACNumToString(num)"
    },
    {
      "index": "Feature",
      "doc": " formatRow(format, x, y, ...)"
    },
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime(str[, format[, timezone]])"
    }
  ]
}
{
  "index": 100,
  "doc": "sys.format_bytes(double)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " byteSize(argument [, ...])"
    },
    {
      "index": "Feature",
      "doc": " formatReadableDecimalSize(x)"
    },
    {
      "index": "Feature",
      "doc": " byteSlice(s, offset, length)"
    },
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    }
  ]
}
{
  "index": 101,
  "doc": "sys.format_path(path)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatRow(format, x, y, ...)"
    },
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " formatQuerySingleLine(query)formatQuerySingleLineOrNull(query)"
    },
    {
      "index": "Feature",
      "doc": " formatRowNoNewline(format, x, y, ...)"
    }
  ]
}
{
  "index": 102,
  "doc": "FORMAT_PICO_TIME(time_val)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addMicroseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " fromUTCTimestamp(time_val, time_zone)"
    },
    {
      "index": "Feature",
      "doc": " toUTCTimestamp(time_val, time_zone)"
    }
  ]
}
{
  "index": 103,
  "doc": "sys.format_statement(statement)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatQuery(query)formatQueryOrNull(query)"
    },
    {
      "index": "Feature",
      "doc": " formatRow(format, x, y, ...)"
    },
    {
      "index": "Feature",
      "doc": " formatQuerySingleLine(query)formatQuerySingleLineOrNull(query)"
    },
    {
      "index": "Feature",
      "doc": " format(pattern, s0, s1, ...)"
    }
  ]
}
{
  "index": 104,
  "doc": "sys.format_time(picoseconds)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " addMicroseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime(str[, format[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 105,
  "doc": "FOUND_ROWS()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    },
    {
      "index": "Feature",
      "doc": " approx_top_k(N)(column)approx_top_k(N, reserved)(column)"
    },
    {
      "index": "Feature",
      "doc": " SELECT * FROM table WHERE indexHint(<expression>)"
    },
    {
      "index": "Feature",
      "doc": " topK(N)(column)topK(N, load_factor)(column)topK(N, load_factor, 'counts')(column)"
    }
  ]
}
{
  "index": 106,
  "doc": "FROM_BASE64(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " base64Encode(plaintext)"
    },
    {
      "index": "Feature",
      "doc": " base64Decode(encoded)"
    },
    {
      "index": "Feature",
      "doc": " base64URLEncode(url)"
    },
    {
      "index": "Feature",
      "doc": " base64URLDecode(encodedUrl)"
    }
  ]
}
{
  "index": 107,
  "doc": "FROM_DAYS(N)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " fromDaysSinceYearZero(days)"
    },
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " addDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    }
  ]
}
{
  "index": 108,
  "doc": "FROM_UNIXTIME(unix_timestamp), FROM_UNIXTIME(unix_timestamp,format)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " fromUTCTimestamp(time_val, time_zone)"
    },
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    }
  ]
}
{
  "index": 109,
  "doc": "GeometryCollection(g1,g2,...)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsIntersectionSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsIntersectionCartesian"
    },
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    },
    {
      "index": "Feature",
      "doc": " polygonAreaSpherical"
    }
  ]
}
{
  "index": 114,
  "doc": "GET_FORMAT({DATE|DATETIME|TIME}, {'EUR'|'USA'|'JIS'|'ISO'|'INTERNAL'})\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime(str[, format[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTimeInJodaSyntax(str[, format[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    }
  ]
}
{
  "index": 115,
  "doc": "GET_LOCK(str,timeout)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " tumble(time_attr, interval [, timezone])"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " hopEnd(time_attr, hop_interval, window_interval [, timezone]);"
    },
    {
      "index": "Feature",
      "doc": " toDateTime(expr[, time_zone ])"
    }
  ]
}
{
  "index": 116,
  "doc": "GLength(ls)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " lgamma(x)"
    },
    {
      "index": "Feature",
      "doc": " ngramDistanceUTF8(haystack, needle)"
    },
    {
      "index": "Feature",
      "doc": " ngramDistance(haystack, needle)"
    }
  ]
}
{
  "index": 117,
  "doc": "GROUP_CONCAT(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " groupBitOr(expr)"
    },
    {
      "index": "Feature",
      "doc": " groupBitAnd(expr)"
    },
    {
      "index": "Feature",
      "doc": " groupBitXor(expr)"
    }
  ]
}
{
  "index": 118,
  "doc": "HEX(N_or_S)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hex(arg)"
    },
    {
      "index": "Feature",
      "doc": " toFixedString(s, N)"
    },
    {
      "index": "Feature",
      "doc": " h3HexRing(index, k)"
    },
    {
      "index": "Feature",
      "doc": " wordShingleSimHash(string[, shinglesize])"
    }
  ]
}
{
  "index": 119,
  "doc": "HOUR(time)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDateTime(year, month, day, hour, minute, second[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 120,
  "doc": "IF(expr1,expr2,expr3)\n,Control Flow Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    },
    {
      "index": "Feature",
      "doc": " exp(x)"
    },
    {
      "index": "Feature",
      "doc": " exp2(x)"
    },
    {
      "index": "Feature",
      "doc": " erfc(x)"
    }
  ]
}
{
  "index": 121,
  "doc": "IFNULL(expr1,expr2)\nNVL(expr1,expr2)\n,Control Flow Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ifNull(x, alt)"
    },
    {
      "index": "Feature",
      "doc": " isNotNull(x)"
    },
    {
      "index": "Feature",
      "doc": " assumeNotNull(x)"
    },
    {
      "index": "Feature",
      "doc": " isZeroOrNull(x)"
    }
  ]
}
{
  "index": 122,
  "doc": "INET6_ATON(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toInt128(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt256(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt128OrZero(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt16(expr)"
    }
  ]
}
{
  "index": 123,
  "doc": "INET6_NTOA(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toInt128(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt256(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt32(expr)"
    },
    {
      "index": "Feature",
      "doc": " toUInt128(expr)"
    }
  ]
}
{
  "index": 124,
  "doc": "INET_ATON(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toInt16(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt128(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt128OrZero(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt256(expr)"
    }
  ]
}
{
  "index": 125,
  "doc": "INET_NTOA(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toInt128(expr)"
    },
    {
      "index": "Feature",
      "doc": " toUInt128(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt32(expr)"
    },
    {
      "index": "Feature",
      "doc": " toUInt32(expr)"
    }
  ]
}
{
  "index": 126,
  "doc": "INSERT(str,pos,len,newstr)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 127,
  "doc": "INSTR(str,substr)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " substringIndexUTF8(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringIndex(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    }
  ]
}
{
  "index": 128,
  "doc": "INTERSECTS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geoToS2(lon, lat)"
    },
    {
      "index": "Feature",
      "doc": " s2CapContains(center, degrees, point)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 132,
  "doc": "IS_FREE_LOCK(str)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " isInfinite(x)"
    },
    {
      "index": "Feature",
      "doc": " unbin(arg)"
    },
    {
      "index": "Feature",
      "doc": " murmurHash3_128(expr)"
    },
    {
      "index": "Feature",
      "doc": " asin(x)"
    }
  ]
}
{
  "index": 133,
  "doc": "IS_IPV4(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " IPv4CIDRToRange(ipv4, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4ToIPv6(x)"
    },
    {
      "index": "Feature",
      "doc": " IPv6CIDRToRange(ipv6, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4StringToNumOrDefault(s)"
    }
  ]
}
{
  "index": 134,
  "doc": "IS_IPV4_COMPAT(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " IPv4CIDRToRange(ipv4, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4ToIPv6(x)"
    },
    {
      "index": "Feature",
      "doc": " IPv6CIDRToRange(ipv6, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4StringToNum(s)"
    }
  ]
}
{
  "index": 135,
  "doc": "IS_IPV4_MAPPED(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " IPv4CIDRToRange(ipv4, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4ToIPv6(x)"
    },
    {
      "index": "Feature",
      "doc": " IPv6CIDRToRange(ipv6, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4StringToNumOrNull(s)"
    }
  ]
}
{
  "index": 136,
  "doc": "IS_IPV6(expr)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " IPv6CIDRToRange(ipv6, Cidr),"
    },
    {
      "index": "Feature",
      "doc": " IPv4ToIPv6(x)"
    },
    {
      "index": "Feature",
      "doc": " IPv6StringToNum(string)"
    },
    {
      "index": "Feature",
      "doc": " IPv6StringToNumOrNull(s)"
    }
  ]
}
{
  "index": 137,
  "doc": "IS_USED_LOCK(str)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " retention(cond1, cond2, ..., cond32);"
    },
    {
      "index": "Feature",
      "doc": " rowNumberInAllBlocks()"
    },
    {
      "index": "Feature",
      "doc": " hasThreadFuzzer();"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    }
  ]
}
{
  "index": 138,
  "doc": "JSON_ARRAY([value[, value2] ...])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasAny(array1, array2)"
    },
    {
      "index": "Feature",
      "doc": " array(x1, ...), operator [x1, ...]"
    },
    {
      "index": "Feature",
      "doc": " arrayAll([func,] arr1, ...)"
    },
    {
      "index": "Feature",
      "doc": " flatten(array_of_arrays)"
    }
  ]
}
{
  "index": 139,
  "doc": "JSON_ARRAY_APPEND(json_doc, path, value[, path, value] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " arrayPushBack(array, single_value)"
    },
    {
      "index": "Feature",
      "doc": " array_concat_agg"
    }
  ]
}
{
  "index": 140,
  "doc": "JSON_ARRAY_INSERT(json_doc, path, value[, path, value] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " arrayPushBack(array, single_value)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " array_concat_agg"
    }
  ]
}
{
  "index": 141,
  "doc": "JSON_ARRAY_INTERSECT(arr1, arr2)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasAny(array1, array2)"
    },
    {
      "index": "Feature",
      "doc": " arrayExists([func,] arr1, ...)"
    },
    {
      "index": "Feature",
      "doc": " arrayAll([func,] arr1, ...)"
    },
    {
      "index": "Feature",
      "doc": " arrayFilter(func, arr1, ...)"
    }
  ]
}
{
  "index": 142,
  "doc": "JSON_COMPACT(json_doc)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 143,
  "doc": "JSON_CONTAINS(json_doc, val[, path])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 144,
  "doc": "JSON_CONTAINS_PATH(json_doc, return_arg, path[, path] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 145,
  "doc": "JSON_DEPTH(json_doc)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 146,
  "doc": "JSON_DETAILED(json_doc[, tab_size])\nJSON_PRETTY(json_doc[, tab_size])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 147,
  "doc": "JSON_EQUALS(json1, json2)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 148,
  "doc": ",JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " arrayLast(func, arr1, ...)"
    },
    {
      "index": "Feature",
      "doc": " arraySum([func,] arr)"
    },
    {
      "index": "Feature",
      "doc": " dictIsIn"
    },
    {
      "index": "Feature",
      "doc": " arrayAll([func,] arr1, ...)"
    }
  ]
}
{
  "index": 149,
  "doc": "JSON_EXTRACT(json_doc, path[, path] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 150,
  "doc": "JSON_INSERT(json_doc, path, val[, path, val] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 151,
  "doc": "JSON_KEYS(json_doc[, path])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 152,
  "doc": "JSON_LENGTH(json_doc[, path])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 153,
  "doc": "JSON_LOOSE(json_doc)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 154,
  "doc": "JSON_MERGE(json_doc, json_doc[, json_doc] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " merge(['db_name',] 'tables_regexp')"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 155,
  "doc": "JSON_NORMALIZE(json)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " normalizeQuery(x)"
    },
    {
      "index": "Feature",
      "doc": " normalizeUTF8NFD(words)"
    },
    {
      "index": "Feature",
      "doc": " normalizeUTF8NFKD(words)"
    },
    {
      "index": "Feature",
      "doc": " normalizeUTF8NFKC(words)"
    }
  ]
}
{
  "index": 156,
  "doc": "JSON_OBJECT([key, value[, key, value] ...])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " map(key1, value1[, key2, value2, ...])"
    },
    {
      "index": "Feature",
      "doc": " mapFromArrays(keys, values)"
    }
  ]
}
{
  "index": 157,
  "doc": "JSON_OBJECTAGG(key, value)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " map(key1, value1[, key2, value2, ...])"
    }
  ]
}
{
  "index": 158,
  "doc": "JSON_OBJECT_FILTER_KEYS(obj, array_keys)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " mapFromArrays(keys, values)"
    },
    {
      "index": "Feature",
      "doc": " arrayPushBack(array, single_value)"
    }
  ]
}
{
  "index": 159,
  "doc": "JSON_OBJECT_TO_ARRAY(Obj)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " flatten(array_of_arrays)"
    },
    {
      "index": "Feature",
      "doc": " arrayJoin function"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 160,
  "doc": "JSON_OVERLAPS(json_doc1, json_doc2)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 162,
  "doc": "JSON_QUERY(json_doc, path)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 163,
  "doc": "JSON_QUOTE(json_value)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " punycodeEncode(val)"
    },
    {
      "index": "Feature",
      "doc": " punycodeEncode(val)"
    },
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    }
  ]
}
{
  "index": 164,
  "doc": "JSON_REMOVE(json_doc, path[, path] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    }
  ]
}
{
  "index": 165,
  "doc": "JSON_REPLACE(json_doc, path, val[, path, val] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " extractKeyValuePairs(data[, key_value_delimiter[, pair_delimiter[, quoting_character]]])"
    },
    {
      "index": "Feature",
      "doc": " merge(['db_name',] 'tables_regexp')"
    },
    {
      "index": "Feature",
      "doc": " trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)"
    },
    {
      "index": "Feature",
      "doc": " dictGetAll('dict_name', attr_names, id_expr[, limit])"
    }
  ]
}
{
  "index": 166,
  "doc": ",JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " arrayLast(func, arr1, ...)"
    },
    {
      "index": "Feature",
      "doc": " arraySum([func,] arr)"
    },
    {
      "index": "Feature",
      "doc": " dictIsIn"
    },
    {
      "index": "Feature",
      "doc": " arrayAll([func,] arr1, ...)"
    }
  ]
}
{
  "index": 167,
  "doc": "JSON_SEARCH(json_doc, return_arg, search_str[, escape_char[, path] ...])\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " extractKeyValuePairs(data[, key_value_delimiter[, pair_delimiter[, quoting_character]]])"
    },
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " dictGetAll('dict_name', attr_names, id_expr[, limit])"
    }
  ]
}
{
  "index": 168,
  "doc": "JSON_SET(json_doc, path, val[, path, val] ...)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 169,
  "doc": "JSON_TABLE(json_doc, \n          context_path COLUMNS (column_list)\n) [AS] alias\ncolumn_list:\n    column[, column][, ...]\ncolumn:\n    name FOR ORDINALITY\n    |  name type PATH path_str [on_empty] [on_error]\n    |  name type EXISTS PATH path_str\n    |  NESTED PATH path_str COLUMNS (column_list)\non_empty:\n    {NULL | DEFAULT string | ERROR} ON EMPTY\non_error:\n    {NULL | DEFAULT string | ERROR} ON ERROR\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasColumnInTable(\\[\u2018hostname\u2019\\[, \u2018username\u2019\\[, \u2018password\u2019\\]\\],\\] \u2018database\u2019, \u2018table\u2019, \u2018column\u2019)"
    },
    {
      "index": "Feature",
      "doc": " dictGet[Type]('dict_name', 'attr_name', id_expr)dictGet[Type]OrDefault('dict_name', 'attr_name', id_expr, default_value_expr)"
    },
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " any(column) [RESPECT NULLS]"
    }
  ]
}
{
  "index": 170,
  "doc": "JSON_TYPE(json_val)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " blockSerializedSize(value[, value[, ...]])"
    }
  ]
}
{
  "index": 171,
  "doc": "JSON_UNQUOTE(val)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " punycodeEncode(val)"
    },
    {
      "index": "Feature",
      "doc": " punycodeEncode(val)"
    },
    {
      "index": "Feature",
      "doc": " not(val);"
    },
    {
      "index": "Feature",
      "doc": " xor(val1, val2...)"
    }
  ]
}
{
  "index": 172,
  "doc": "JSON_VALID(value)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 173,
  "doc": "JSON_VALUE(json_doc, path)\n,JSON Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleJSONHas(json, field_name)"
    },
    {
      "index": "Feature",
      "doc": " isValidJSON(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPathsAndTypes(json)"
    },
    {
      "index": "Feature",
      "doc": " distinctJSONPaths(json)"
    }
  ]
}
{
  "index": 174,
  "doc": "KDF(key_str, salt [, {info | iterations} [, kdf_name [, width ]]])\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sipHash64Keyed((k0, k1), par1,...)"
    },
    {
      "index": "Feature",
      "doc": " sipHash128Keyed((k0, k1), par1,...)"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " mapFromArrays(keys, values)"
    }
  ]
}
{
  "index": 175,
  "doc": "LAST_DAY(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toDaysSinceYearZero(date[, time_zone])"
    }
  ]
}
{
  "index": 176,
  "doc": "LAST_INSERT_ID(), LAST_INSERT_ID(expr)\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " generateUUIDv7([expr])"
    },
    {
      "index": "Feature",
      "doc": " generateUUIDv4([expr])"
    },
    {
      "index": "Feature",
      "doc": " generateSnowflakeID([expr, [machine_id]])"
    },
    {
      "index": "Feature",
      "doc": " transactionID()"
    }
  ]
}
{
  "index": 177,
  "doc": "LAST_VALUE(expr,[expr,...])\nLAST_VALUE(expr) OVER (\n  [ PARTITION BY partition_expression ]\n  [ ORDER BY order_list ]\n) \n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " last_value (column_name) [[RESPECT NULLS] | [IGNORE NULLS]]  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " first_value (column_name) [[RESPECT NULLS] | [IGNORE NULLS]]  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " row_number (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 178,
  "doc": "LCASE(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " endsWith(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)"
    }
  ]
}
{
  "index": 179,
  "doc": "LEFT(str,len)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPad(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " rightPad(string, length[, pad_string])"
    }
  ]
}
{
  "index": 180,
  "doc": "LENGTH(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " length(s)"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " randomString(length)"
    }
  ]
}
{
  "index": 181,
  "doc": "expr LIKE pat [ESCAPE 'escape_char']\nexpr NOT LIKE pat [ESCAPE 'escape_char']\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    }
  ]
}
{
  "index": 182,
  "doc": "LineString(pt1,pt2,...)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addressToLineWithInlines(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 185,
  "doc": "sys.list_add(list,value)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " tupleElement(tuple, index, [, default_value])tupleElement(tuple, name, [, default_value])"
    },
    {
      "index": "Feature",
      "doc": " generate_series"
    },
    {
      "index": "Feature",
      "doc": " dictGet[Type]('dict_name', 'attr_name', id_expr)dictGet[Type]OrDefault('dict_name', 'attr_name', id_expr, default_value_expr)"
    }
  ]
}
{
  "index": 186,
  "doc": "sys.list_drop(list,value)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " dictGet[Type]('dict_name', 'attr_name', id_expr)dictGet[Type]OrDefault('dict_name', 'attr_name', id_expr, default_value_expr)"
    },
    {
      "index": "Feature",
      "doc": " dictGetAll('dict_name', attr_names, id_expr[, limit])"
    },
    {
      "index": "Feature",
      "doc": " dictGetHierarchy('dict_name', key)"
    },
    {
      "index": "Feature",
      "doc": " tupleElement(tuple, index, [, default_value])tupleElement(tuple, name, [, default_value])"
    }
  ]
}
{
  "index": 187,
  "doc": "LN(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " log10(x)"
    },
    {
      "index": "Feature",
      "doc": " log(x)"
    },
    {
      "index": "Feature",
      "doc": " log2(x)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    }
  ]
}
{
  "index": 188,
  "doc": "LOAD_FILE(file_name)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    }
  ]
}
{
  "index": 189,
  "doc": "LOCALTIME\nLOCALTIME([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " toTime(date[,timezone])"
    },
    {
      "index": "Feature",
      "doc": " makeDateTime64(year, month, day, hour, minute, second[, precision])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime(str[, format[, timezone]])"
    }
  ]
}
{
  "index": 190,
  "doc": "LOCALTIMESTAMP\nLOCALTIMESTAMP([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " UTCTimestamp()"
    },
    {
      "index": "Feature",
      "doc": " toUnixTimestamp(date)toUnixTimestamp(str, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime64BestEffort(time_string [, precision [, time_zone]])"
    },
    {
      "index": "Feature",
      "doc": " fromUnixTimestamp64Micro(value[, timezone])"
    }
  ]
}
{
  "index": 191,
  "doc": "LOCATE(substr,str), LOCATE(substr,str,pos)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " locate(needle, haystack[, start_pos])"
    },
    {
      "index": "Feature",
      "doc": " position(haystack, needle[, start_pos])"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    }
  ]
}
{
  "index": 192,
  "doc": "LOG(X), LOG(B,X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " log2(x)"
    },
    {
      "index": "Feature",
      "doc": " log10(x)"
    },
    {
      "index": "Feature",
      "doc": " log(x)"
    },
    {
      "index": "Feature",
      "doc": " pow(x, y)"
    }
  ]
}
{
  "index": 193,
  "doc": "LOG10(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " log10(x)"
    },
    {
      "index": "Feature",
      "doc": " log(x)"
    },
    {
      "index": "Feature",
      "doc": " log2(x)"
    },
    {
      "index": "Feature",
      "doc": " exp10(x)"
    }
  ]
}
{
  "index": 194,
  "doc": "LOG2(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " log2(x)"
    },
    {
      "index": "Feature",
      "doc": " log10(x)"
    },
    {
      "index": "Feature",
      "doc": " log(x)"
    },
    {
      "index": "Feature",
      "doc": " exp2(x)"
    }
  ]
}
{
  "index": 195,
  "doc": "LOWER(str)\nLCASE(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    }
  ]
}
{
  "index": 196,
  "doc": "LPAD(str, len [,padstr])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " rightPad(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPad(string, length[, pad_string])"
    }
  ]
}
{
  "index": 197,
  "doc": "LTRIM(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " trimLeft(input_string)"
    },
    {
      "index": "Feature",
      "doc": " splitByChar(separator, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    }
  ]
}
{
  "index": 198,
  "doc": "MAKEDATE(year,dayofyear)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    },
    {
      "index": "Feature",
      "doc": " makeDate32(year, [month,] day)"
    },
    {
      "index": "Feature",
      "doc": " makeDateTime(year, month, day, hour, minute, second[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " makeDateTime64(year, month, day, hour, minute, second[, precision])"
    }
  ]
}
{
  "index": 199,
  "doc": "MAKETIME(hour,minute,second)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDateTime(year, month, day, hour, minute, second[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " makeDateTime64(year, month, day, hour, minute, second[, precision])"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 200,
  "doc": "MAKE_SET(bits,str1,str2,...)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " bitAnd(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitSlice(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " bitXor(a, b)"
    },
    {
      "index": "Feature",
      "doc": " bitNot(a)"
    }
  ]
}
{
  "index": 201,
  "doc": "MASTER_GTID_WAIT(gtid-list[, timeout)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sleep(seconds)"
    },
    {
      "index": "Feature",
      "doc": " hopEnd(time_attr, hop_interval, window_interval [, timezone]);"
    },
    {
      "index": "Feature",
      "doc": " hopStart(time_attr, hop_interval, window_interval [, timezone]);"
    },
    {
      "index": "Feature",
      "doc": " generateSnowflakeID([expr, [machine_id]])"
    }
  ]
}
{
  "index": 202,
  "doc": "MASTER_POS_WAIT(log_name,log_pos[,timeout,[\"connection_name\"]])\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " connection_id()"
    },
    {
      "index": "Feature",
      "doc": " log(x)"
    },
    {
      "index": "Feature",
      "doc": " log2(x)"
    },
    {
      "index": "Feature",
      "doc": " CREATE TABLE sum_map(    `date` Date,    `timeslot` DateTime,    `statusMap` Nested(status UInt16, requests UInt64))ENGINE = LogINSERT INTO sum_map VALUES     ('2000-01-01', '2000-01-01 00"
    }
  ]
}
{
  "index": 203,
  "doc": "MATCH (col1,col2,...) AGAINST (expr [search_modifier])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " match(haystack, pattern)"
    },
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])"
    },
    {
      "index": "Feature",
      "doc": " multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN])"
    }
  ]
}
{
  "index": 204,
  "doc": "MAX([DISTINCT] expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " max2(a, b)"
    },
    {
      "index": "Feature",
      "doc": " arrayMax([func,] arr)"
    },
    {
      "index": "Feature",
      "doc": " maxMap(key, value)"
    },
    {
      "index": "Feature",
      "doc": " groupArraySample(max_size[, seed])(x)"
    }
  ]
}
{
  "index": 205,
  "doc": "MBRContains(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 206,
  "doc": "MBRDisjoint(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceSpherical"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 207,
  "doc": "MBREqual(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " greaterOrEquals(a, b)"
    },
    {
      "index": "Feature",
      "doc": " lessOrEquals(a, b)"
    },
    {
      "index": "Feature",
      "doc": " polygonsEqualsCartesian"
    },
    {
      "index": "Feature",
      "doc": " notEquals(a, b)"
    }
  ]
}
{
  "index": 208,
  "doc": "MBRIntersects(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 209,
  "doc": "MBROverlaps(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 210,
  "doc": "MBRTouches(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " greatCircleDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    }
  ]
}
{
  "index": 211,
  "doc": "MBRWithin(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " bitHammingDistance(int1, int2)"
    },
    {
      "index": "Feature",
      "doc": " byteHammingDistance(string1, string2)"
    },
    {
      "index": "Feature",
      "doc": " addressToLine(address_of_binary_instruction)"
    }
  ]
}
{
  "index": 212,
  "doc": "MD5(str)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " MD5"
    },
    {
      "index": "Feature",
      "doc": " MD4"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " murmurHash3_32(par1, ...)murmurHash3_64(par1, ...)"
    }
  ]
}
{
  "index": 213,
  "doc": "MEDIAN(median expression) OVER (\n  [ PARTITION BY partition_expression ] \n)\n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " median"
    },
    {
      "index": "Feature",
      "doc": " percent_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]] | [window_name])FROM table_nameWINDOW window_name as ([PARTITION BY grouping_column] [ORDER BY sorting_column] RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)"
    },
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " dense_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 214,
  "doc": "MICROSECOND(expr)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 215,
  "doc": "MID(str,pos,len)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)"
    }
  ]
}
{
  "index": 216,
  "doc": "MIN([DISTINCT] expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " min2(a, b)"
    },
    {
      "index": "Feature",
      "doc": " least(a, b)"
    },
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " minSampleSizeContinous(baseline, sigma, mde, power, alpha)"
    }
  ]
}
{
  "index": 217,
  "doc": "MINUTE(time)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDateTime(year, month, day, hour, minute, second[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " addMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " makeDateTime64(year, month, day, hour, minute, second[, precision])"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 218,
  "doc": "MLineFromText(wkt[,srid])\nMultiLineStringFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    }
  ]
}
{
  "index": 219,
  "doc": "MLineFromWKB(wkb[,srid])\nMultiLineStringFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    }
  ]
}
{
  "index": 220,
  "doc": "MONTH(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " monthName(date)"
    },
    {
      "index": "Feature",
      "doc": " addMonths(date, num)"
    },
    {
      "index": "Feature",
      "doc": " makeDate32(year, [month,] day)"
    },
    {
      "index": "Feature",
      "doc": " subtractMonths(date, num)"
    }
  ]
}
{
  "index": 221,
  "doc": "MONTHNAME(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " monthName(date)"
    },
    {
      "index": "Feature",
      "doc": " makeDate32(year, [month,] day)"
    },
    {
      "index": "Feature",
      "doc": " addMonths(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMonths(date, num)"
    }
  ]
}
{
  "index": 222,
  "doc": "MPointFromText(wkt[,srid])\nMultiPointFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    }
  ]
}
{
  "index": 223,
  "doc": "MPointFromWKB(wkb[,srid])\nMultiPointFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 224,
  "doc": "MPolyFromText(wkt[,srid])\nMultiPolygonFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    }
  ]
}
{
  "index": 225,
  "doc": "MPolyFromWKB(wkb[,srid])\nMultiPolygonFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPolygon"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " polygonsSymDifferenceCartesian"
    }
  ]
}
{
  "index": 226,
  "doc": "MultiLineString(ls1,ls2,...)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " simpleLinearRegression(x, y)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 229,
  "doc": "MultiPoint(pt1,pt2,...)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " pointInEllipses(x, y, x\u2080, y\u2080, a\u2080, b\u2080,...,x\u2099, y\u2099, a\u2099, b\u2099)"
    }
  ]
}
{
  "index": 232,
  "doc": "MultiPolygon(poly1,poly2,...)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonAreaCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonAreaSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    }
  ]
}
{
  "index": 235,
  "doc": "NAME_CONST(name,value)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " tupleNames(tuple)"
    },
    {
      "index": "Feature",
      "doc": " basename(expr)"
    },
    {
      "index": "Feature",
      "doc": " displayName()"
    },
    {
      "index": "Feature",
      "doc": " dictGetAll('dict_name', attr_names, id_expr[, limit])"
    }
  ]
}
{
  "index": 236,
  "doc": "NATURAL_SORT_KEY(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " arraySort([func,] arr, ...)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " arrayReverseSort([func,] arr, ...)"
    },
    {
      "index": "Feature",
      "doc": " mapSort([func,], map)"
    }
  ]
}
{
  "index": 237,
  "doc": "NEXT VALUE FOR sequence\norNEXTVAL(sequence_name)\nor in Oracle mode (SQL_MODE=ORACLE)sequence_name.nextval\nNEXT VALUE FOR is ANSI SQL syntax while NEXTVAL() is PostgreSQL syntax.,SEQUENCE Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sequenceNextNode(direction, base)(timestamp, event_column, base_condition, event1, event2, event3, ...)"
    },
    {
      "index": "Feature",
      "doc": " sequenceMatch(pattern)(timestamp, cond1, cond2, ...)"
    },
    {
      "index": "Feature",
      "doc": " sequenceCount(pattern)(timestamp, cond1, cond2, ...)"
    },
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    }
  ]
}
{
  "index": 238,
  "doc": "expr NOT LIKE pat [ESCAPE 'escape_char']\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 239,
  "doc": "expr NOT REGEXP pat, expr NOT RLIKE pat\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " regexpQuoteMeta(s)"
    },
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " extractAllGroups(text, regexp)"
    },
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    }
  ]
}
{
  "index": 240,
  "doc": "NOW([precision])\nCURRENT_TIMESTAMP\nCURRENT_TIMESTAMP([precision])\nLOCALTIME, LOCALTIME([precision])\nLOCALTIMESTAMP\nLOCALTIMESTAMP([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " fromUTCTimestamp(time_val, time_zone)"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " toUTCTimestamp(time_val, time_zone)"
    }
  ]
}
{
  "index": 241,
  "doc": "NTILE (expr) OVER ( \n  [ PARTITION BY partition_expression ] \n  [ ORDER BY order_list ]\n)\n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " row_number (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " leadInFrame(x[, offset[, default]])  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " lagInFrame(x[, offset[, default]])  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 242,
  "doc": "NULLIF(expr1,expr2)\n,Control Flow Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " nullIf(x, y)"
    },
    {
      "index": "Feature",
      "doc": " NULL Values in Conditionals"
    },
    {
      "index": "Feature",
      "doc": " isNull(x)"
    },
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    }
  ]
}
{
  "index": 243,
  "doc": "OCT(N)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " floor(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " char(number_1, [number_2, ..., number_n]);"
    },
    {
      "index": "Feature",
      "doc": " roundBankers(x [, N])"
    }
  ]
}
{
  "index": 244,
  "doc": "OCTET_LENGTH(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " lengthUTF8(s)"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 245,
  "doc": "OLD_PASSWORD(str)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    }
  ]
}
{
  "index": 246,
  "doc": "ORD(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " endsWith(str, suffix)"
    }
  ]
}
{
  "index": 247,
  "doc": "OVERLAPS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 248,
  "doc": "PASSWORD(str)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " tryDecrypt"
    }
  ]
}
{
  "index": 249,
  "doc": ",Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " tanh(x)"
    },
    {
      "index": "Feature",
      "doc": " acosh(x)"
    },
    {
      "index": "Feature",
      "doc": " exp(x)"
    },
    {
      "index": "Feature",
      "doc": " runningDifference(x)"
    }
  ]
}
{
  "index": 250,
  "doc": ",Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " tanh(x)"
    },
    {
      "index": "Feature",
      "doc": " acosh(x)"
    },
    {
      "index": "Feature",
      "doc": " exp(x)"
    },
    {
      "index": "Feature",
      "doc": " runningDifference(x)"
    }
  ]
}
{
  "index": 251,
  "doc": "PERCENT_RANK() OVER (\n  [ PARTITION BY partition_expression ] \n  [ ORDER BY order_list ]\n)\n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " percent_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]] | [window_name])FROM table_nameWINDOW window_name as ([PARTITION BY grouping_column] [ORDER BY sorting_column] RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)"
    },
    {
      "index": "Feature",
      "doc": " rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " dense_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 252,
  "doc": "PERIOD_ADD(P,N)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " addMicroseconds(date_time, num)"
    }
  ]
}
{
  "index": 253,
  "doc": "PERIOD_DIFF(P1,P2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMicroseconds(date_time, num)"
    }
  ]
}
{
  "index": 254,
  "doc": "PI()\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " pi()"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " sin(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    }
  ]
}
{
  "index": 255,
  "doc": "Point(x,y)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    },
    {
      "index": "Feature",
      "doc": " covarPop(x, y)"
    },
    {
      "index": "Feature",
      "doc": " covarPop(x, y)"
    },
    {
      "index": "Feature",
      "doc": " atan2(y, x)"
    }
  ]
}
{
  "index": 257,
  "doc": "Polygon(ls1,ls2,...)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonAreaCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonAreaSpherical"
    }
  ]
}
{
  "index": 260,
  "doc": "POSITION(substr IN str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " splitByChar(separator, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " splitByString(separator, s[, max_substrings]))"
    }
  ]
}
{
  "index": 261,
  "doc": "POW(X,Y)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " pow(x, y)"
    },
    {
      "index": "Feature",
      "doc": " roundBankers(x [, N])"
    },
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " atan2(y, x)"
    }
  ]
}
{
  "index": 262,
  "doc": "POWER(X,Y)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " pow(x, y)"
    },
    {
      "index": "Feature",
      "doc": " atan2(y, x)"
    },
    {
      "index": "Feature",
      "doc": " corr(x, y)"
    },
    {
      "index": "Feature",
      "doc": " multiply(a, b)"
    }
  ]
}
{
  "index": 263,
  "doc": "PREVIOUS VALUE FOR sequence_name\norLASTVAL(sequence_name)\nor in Oracle mode (SQL_MODE=ORACLE)sequence_name.currval\nPREVIOUS VALUE FOR is IBM DB2 syntax while LASTVAL() is PostgreSQL syntax.,SEQUENCE Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sequenceNextNode(direction, base)(timestamp, event_column, base_condition, event1, event2, event3, ...)"
    },
    {
      "index": "Feature",
      "doc": " sequenceMatch(pattern)(timestamp, cond1, cond2, ...)"
    },
    {
      "index": "Feature",
      "doc": " sequenceCount(pattern)(timestamp, cond1, cond2, ...)"
    },
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    }
  ]
}
{
  "index": 264,
  "doc": "sys.ps_is_account_enabled(host,user)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " enabledRoles()"
    },
    {
      "index": "Feature",
      "doc": " hostName()"
    },
    {
      "index": "Feature",
      "doc": " enabledProfiles()"
    },
    {
      "index": "Feature",
      "doc": " connection_id()"
    }
  ]
}
{
  "index": 265,
  "doc": "sys.ps_is_consumer_enabled(consumer)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " enabledRoles()"
    },
    {
      "index": "Feature",
      "doc": " enabledProfiles()"
    },
    {
      "index": "Feature",
      "doc": " getOSKernelVersion()"
    },
    {
      "index": "Feature",
      "doc": " RIPEMD160(input)"
    }
  ]
}
{
  "index": 266,
  "doc": "sys.ps_is_instrument_default_enabled(instrument)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " generateSnowflakeID([expr, [machine_id]])"
    },
    {
      "index": "Feature",
      "doc": " studentTTest([confidence_level])(sample_data, sample_index)"
    },
    {
      "index": "Feature",
      "doc": " meanZTest(population_variance_x, population_variance_y, confidence_level)(sample_data, sample_index)"
    },
    {
      "index": "Feature",
      "doc": " arrayAUC(arr_scores, arr_labels[, scale])"
    }
  ]
}
{
  "index": 267,
  "doc": "sys.ps_is_instrument_default_timed(instrument)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toUTCTimestamp(time_val, time_zone)"
    },
    {
      "index": "Feature",
      "doc": " fromUTCTimestamp(time_val, time_zone)"
    },
    {
      "index": "Feature",
      "doc": " fromUnixTimestamp64Micro(value[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " toDateTimeOrDefault(expr [, time_zone [, default_value]])"
    }
  ]
}
{
  "index": 268,
  "doc": "sys.ps_is_thread_instrumented(connection_id)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " connection_id()"
    },
    {
      "index": "Feature",
      "doc": " connectionId()"
    },
    {
      "index": "Feature",
      "doc": " generateSnowflakeID([expr, [machine_id]])"
    },
    {
      "index": "Feature",
      "doc": " getServerPort(port_name)"
    }
  ]
}
{
  "index": 269,
  "doc": "sys.ps_thread_account(thread_id)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasThreadFuzzer();"
    },
    {
      "index": "Feature",
      "doc": " connection_id()"
    },
    {
      "index": "Feature",
      "doc": " generateSnowflakeID([expr, [machine_id]])"
    },
    {
      "index": "Feature",
      "doc": " connectionId()"
    }
  ]
}
{
  "index": 270,
  "doc": "sys.ps_thread_id(connection_id)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " connection_id()"
    },
    {
      "index": "Feature",
      "doc": " connectionId()"
    },
    {
      "index": "Feature",
      "doc": " generateSnowflakeID([expr, [machine_id]])"
    },
    {
      "index": "Feature",
      "doc": " queryID()"
    }
  ]
}
{
  "index": 271,
  "doc": "sys.ps_thread_stack(thread_id, verbose)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasThreadFuzzer();"
    },
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " structureToProtobufSchema(structure)"
    },
    {
      "index": "Feature",
      "doc": " YYYYMMDDToDate32"
    }
  ]
}
{
  "index": 272,
  "doc": "sys.ps_thread_trx_info(thread_id)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasThreadFuzzer();"
    },
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " toDate32OrZero"
    },
    {
      "index": "Feature",
      "doc": " toDate32(expr)"
    }
  ]
}
{
  "index": 273,
  "doc": "QUARTER(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subtractQuarters(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMonths(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMinutes(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    }
  ]
}
{
  "index": 274,
  "doc": "QUOTE(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " regexpQuoteMeta(s)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " extractKeyValuePairs(data[, key_value_delimiter[, pair_delimiter[, quoting_character]]])"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    }
  ]
}
{
  "index": 275,
  "doc": "sys.quote_identifier(str)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    }
  ]
}
{
  "index": 276,
  "doc": "RADIANS(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    },
    {
      "index": "Feature",
      "doc": " sin(x)"
    },
    {
      "index": "Feature",
      "doc": " atan(x)"
    }
  ]
}
{
  "index": 277,
  "doc": "RAND(), RAND(N)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " rand()"
    },
    {
      "index": "Feature",
      "doc": " rand64()"
    },
    {
      "index": "Feature",
      "doc": " randUniform(min, max)"
    },
    {
      "index": "Feature",
      "doc": " randPoisson(n)"
    }
  ]
}
{
  "index": 278,
  "doc": "RANK() OVER (\n  [ PARTITION BY partition_expression ]\n  [ ORDER BY order_list ]\n) \n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " dense_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " percent_rank (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]] | [window_name])FROM table_nameWINDOW window_name as ([PARTITION BY grouping_column] [ORDER BY sorting_column] RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)"
    },
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 279,
  "doc": "expr REGEXP pat, expr RLIKE pat\n,Regular Expressions Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " regexpQuoteMeta(s)"
    },
    {
      "index": "Feature",
      "doc": " extractAllGroups(text, regexp)"
    },
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    }
  ]
}
{
  "index": 280,
  "doc": "REGEXP_INSTR(subject, pattern)\nReturns the position of the first occurrence of the regular expression pattern in the string subject, or 0 if pattern was not found.The positions start with 1 and are measured in characters (i.e. not in bytes), which is important for multi-byte character sets. You can cast a multi-byte character set to BINARY to get offsets in bytes.The function follows the case sensitivity rules of the effective collation. Matching is performed case insensitively for case insensitive collations, and case sensitively for case sensitive collations and for binary data.The collation case sensitivity can be overwritten using the (?i) and (?-i) PCRE flags.MariaDB uses the PCRE regular expression library for enhanced regular expression performance, and REGEXP_INSTR was introduced as part of this enhancement.,Regular Expressions Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " hasSubsequenceCaseInsensitiveUTF8(haystack, needle)"
    },
    {
      "index": "Feature",
      "doc": " hasSubsequenceCaseInsensitive(haystack, needle)"
    },
    {
      "index": "Feature",
      "doc": " multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])"
    }
  ]
}
{
  "index": 281,
  "doc": "REGEXP_REPLACE(subject, pattern, replace)\n,Regular Expressions Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " replaceAll(haystack, pattern, replacement)"
    },
    {
      "index": "Feature",
      "doc": " replaceOne(haystack, pattern, replacement)"
    },
    {
      "index": "Feature",
      "doc": " replaceRegexpOne(haystack, pattern, replacement)"
    },
    {
      "index": "Feature",
      "doc": " replaceRegexpAll"
    }
  ]
}
{
  "index": 282,
  "doc": "REGEXP_SUBSTR(subject,pattern)\n,Regular Expressions Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " splitByRegexp(regexp, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " regexpQuoteMeta(s)"
    },
    {
      "index": "Feature",
      "doc": " extractAllGroups(text, regexp)"
    }
  ]
}
{
  "index": 283,
  "doc": "RELEASE_LOCK(str)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " hasThreadFuzzer();"
    },
    {
      "index": "Feature",
      "doc": " murmurHash3_128(expr)"
    },
    {
      "index": "Feature",
      "doc": " rowNumberInAllBlocks()"
    },
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    }
  ]
}
{
  "index": 284,
  "doc": "REPEAT(str,count)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " repeat(s, n)"
    },
    {
      "index": "Feature",
      "doc": " substringIndex(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " substringIndexUTF8(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " countSubstrings(haystack, needle[, start_pos])"
    }
  ]
}
{
  "index": 285,
  "doc": "REPLACE(str,from_str,to_str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " replaceAll(haystack, pattern, replacement)"
    },
    {
      "index": "Feature",
      "doc": " convertCharset(s, from, to)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " replaceOne(haystack, pattern, replacement)"
    }
  ]
}
{
  "index": 286,
  "doc": "REVERSE(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 287,
  "doc": "RIGHT(str,len)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " rightPad(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPad(string, length[, pad_string])"
    }
  ]
}
{
  "index": 288,
  "doc": "expr REGEXP pat, expr RLIKE pat\n,Regular Expressions Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " regexpQuoteMeta(s)"
    },
    {
      "index": "Feature",
      "doc": " extractAllGroups(text, regexp)"
    },
    {
      "index": "Feature",
      "doc": " regexpExtract(haystack, pattern[, index])"
    },
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    }
  ]
}
{
  "index": 289,
  "doc": "ROUND(X), ROUND(X,D)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " roundAge(num)"
    },
    {
      "index": "Feature",
      "doc": " roundBankers(x [, N])"
    },
    {
      "index": "Feature",
      "doc": " roundToExp2(num)"
    }
  ]
}
{
  "index": 290,
  "doc": "ROW_COUNT()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " topK(N)(column)topK(N, load_factor)(column)topK(N, load_factor, 'counts')(column)"
    },
    {
      "index": "Feature",
      "doc": " rowNumberInBlock()"
    },
    {
      "index": "Feature",
      "doc": " topKWeighted(N)(column, weight)topKWeighted(N, load_factor)(column, weight)topKWeighted(N, load_factor, 'counts')(column, weight)"
    },
    {
      "index": "Feature",
      "doc": " rowNumberInAllBlocks()"
    }
  ]
}
{
  "index": 291,
  "doc": "ROW_NUMBER() OVER (\n  [ PARTITION BY partition_expression ]\n  [ ORDER BY order_list ]\n) \n,Window Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " row_number (column_name)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " nth_value (x, offset)  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " lagInFrame(x[, offset[, default]])  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    },
    {
      "index": "Feature",
      "doc": " leadInFrame(x[, offset[, default]])  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])FROM table_nameWINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])"
    }
  ]
}
{
  "index": 292,
  "doc": "RPAD(str, len [, padstr])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " rightPad(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " leftPad(string, length[, pad_string])"
    }
  ]
}
{
  "index": 293,
  "doc": "RTRIM(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " trimRight(input_string)"
    },
    {
      "index": "Feature",
      "doc": " rightPadUTF8(string, length[, pad_string])"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    }
  ]
}
{
  "index": 294,
  "doc": "SCHEMA()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " Usage Example"
    },
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    },
    {
      "index": "Feature",
      "doc": " entropy(val)"
    },
    {
      "index": "Feature",
      "doc": " Distance functions"
    }
  ]
}
{
  "index": 295,
  "doc": "SECOND(time)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    }
  ]
}
{
  "index": 296,
  "doc": "SEC_TO_TIME(seconds)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addMilliseconds(date_time, num)"
    }
  ]
}
{
  "index": 297,
  "doc": "SESSION_USER()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " currentUser()"
    },
    {
      "index": "Feature",
      "doc": " connection_id()"
    },
    {
      "index": "Feature",
      "doc": " serverUUID()"
    },
    {
      "index": "Feature",
      "doc": " log(x)"
    }
  ]
}
{
  "index": 298,
  "doc": "SETVAL(sequence_name, next_value, [is_used, [round]])\n,SEQUENCE Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sequenceNextNode(direction, base)(timestamp, event_column, base_condition, event1, event2, event3, ...)"
    },
    {
      "index": "Feature",
      "doc": " sequenceMatch(pattern)(timestamp, cond1, cond2, ...)"
    },
    {
      "index": "Feature",
      "doc": " sequenceCount(pattern)(timestamp, cond1, cond2, ...)"
    },
    {
      "index": "Feature",
      "doc": " round(x[, N])"
    }
  ]
}
{
  "index": 299,
  "doc": "SHA1(str), SHA(str)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SHA1('s')...SHA512('s')"
    },
    {
      "index": "Feature",
      "doc": " shardNum()"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " shardCount()"
    }
  ]
}
{
  "index": 300,
  "doc": "SHA2(str,hash_len)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SHA1('s')...SHA512('s')"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " byteHammingDistance(string1, string2)"
    },
    {
      "index": "Feature",
      "doc": " wordShingleMinHash(string[, shinglesize, hashnum])"
    }
  ]
}
{
  "index": 301,
  "doc": "SIGN(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sign(x)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    }
  ]
}
{
  "index": 302,
  "doc": "SIN(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sin(x)"
    },
    {
      "index": "Feature",
      "doc": " sinh(x)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " tan(x)"
    }
  ]
}
{
  "index": 303,
  "doc": "SLEEP(duration)\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sleep(seconds)"
    },
    {
      "index": "Feature",
      "doc": " sleepEachRow(seconds)"
    },
    {
      "index": "Feature",
      "doc": " toIntervalMillisecond(n)"
    },
    {
      "index": "Feature",
      "doc": " parseDateTimeBestEffortUSOrZero"
    }
  ]
}
{
  "index": 304,
  "doc": "SOUNDEX(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " stringJaccardIndex(string1, string2)"
    },
    {
      "index": "Feature",
      "doc": " stringJaccardIndexUTF8"
    },
    {
      "index": "Feature",
      "doc": " trimLeft(input_string)"
    }
  ]
}
{
  "index": 305,
  "doc": "expr1 SOUNDS LIKE expr2\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    },
    {
      "index": "Feature",
      "doc": " exp2(x)"
    },
    {
      "index": "Feature",
      "doc": " exp(x)"
    },
    {
      "index": "Feature",
      "doc": " concatWithSeparator(sep, expr1, expr2, expr3...)"
    }
  ]
}
{
  "index": 306,
  "doc": "SPACE(N)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toFixedString(s, N)"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " leftPadUTF8(string, length[, pad_string])"
    }
  ]
}
{
  "index": 307,
  "doc": "SPIDER_BG_DIRECT_SQL('sql', 'tmp_table_list', 'parameters')\n,Spider Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    },
    {
      "index": "Feature",
      "doc": " joinGet(join_storage_table_name, `value_column`, join_keys)"
    },
    {
      "index": "Feature",
      "doc": " joinGetOrNull(join_storage_table_name, `value_column`, join_keys)"
    },
    {
      "index": "Feature",
      "doc": " merge(['db_name',] 'tables_regexp')"
    }
  ]
}
{
  "index": 308,
  "doc": "SPIDER_COPY_TABLES(spider_table_name, \n  source_link_id, destination_link_id_list [,parameters])\n,Spider Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    },
    {
      "index": "Feature",
      "doc": " merge(['db_name',] 'tables_regexp')"
    },
    {
      "index": "Feature",
      "doc": " joinGet(join_storage_table_name, `value_column`, join_keys)"
    },
    {
      "index": "Feature",
      "doc": " remote(addresses_expr, [db, table, user [, password], sharding_key])remote(addresses_expr, [db.table, user [, password], sharding_key])remote(named_collection[, option=value [,..]])remoteSecure(addresses_expr, [db, table, user [, password], sharding_key])remoteSecure(addresses_expr, [db.table, user [, password], sharding_key])remoteSecure(named_collection[, option=value [,..]])"
    }
  ]
}
{
  "index": 309,
  "doc": "SPIDER_DIRECT_SQL('sql', 'tmp_table_list', 'parameters')\n,Spider Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " SELECT ... FROM loop(database, table);SELECT ... FROM loop(database.table);SELECT ... FROM loop(table);SELECT ... FROM loop(other_table_function(...));"
    },
    {
      "index": "Feature",
      "doc": " joinGet(join_storage_table_name, `value_column`, join_keys)"
    },
    {
      "index": "Feature",
      "doc": " joinGetOrNull(join_storage_table_name, `value_column`, join_keys)"
    },
    {
      "index": "Feature",
      "doc": " remote(addresses_expr, [db, table, user [, password], sharding_key])remote(addresses_expr, [db.table, user [, password], sharding_key])remote(named_collection[, option=value [,..]])remoteSecure(addresses_expr, [db, table, user [, password], sharding_key])remoteSecure(addresses_expr, [db.table, user [, password], sharding_key])remoteSecure(named_collection[, option=value [,..]])"
    }
  ]
}
{
  "index": 310,
  "doc": "SPIDER_FLUSH_TABLE_MON_CACHE()\n,Spider Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " reinterpretAsFloat64(x)"
    },
    {
      "index": "Feature",
      "doc": " reinterpretAsFloat32(x)"
    },
    {
      "index": "Feature",
      "doc": " reinterpretAsInt64(x)"
    },
    {
      "index": "Feature",
      "doc": " reinterpretAsUInt64(x)"
    }
  ]
}
{
  "index": 311,
  "doc": "SQRT(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sqrt"
    },
    {
      "index": "Feature",
      "doc": " sqidEncode(number1, ...)"
    },
    {
      "index": "Feature",
      "doc": " sqidDecode(sqid)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    }
  ]
}
{
  "index": 312,
  "doc": "STD(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " groupBitOr(expr)"
    },
    {
      "index": "Feature",
      "doc": " groupBitXor(expr)"
    },
    {
      "index": "Feature",
      "doc": " groupBitAnd(expr)"
    }
  ]
}
{
  "index": 313,
  "doc": "STDDEV(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevSampStable(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPop(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPopStable(x)"
    }
  ]
}
{
  "index": 314,
  "doc": "STDDEV_POP(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stddevPop(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPopStable(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevSampStable(x)"
    }
  ]
}
{
  "index": 315,
  "doc": "STDDEV_SAMP(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevSampStable(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPop(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPopStable(x)"
    }
  ]
}
{
  "index": 316,
  "doc": "STRCMP(expr1,expr2)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " exp2(x)"
    },
    {
      "index": "Feature",
      "doc": " xxh3(expr)"
    },
    {
      "index": "Feature",
      "doc": " exp(x)"
    }
  ]
}
{
  "index": 317,
  "doc": "STR_TO_DATE(str,format)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " date_trunc(unit, value[, timezone])"
    },
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " date_sub(unit, value, date)"
    }
  ]
}
{
  "index": 318,
  "doc": "ST_Area(poly)\nArea(poly)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonAreaSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonAreaCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionSpherical"
    }
  ]
}
{
  "index": 319,
  "doc": "ST_AsBinary(g)\nAsBinary(g)\nST_AsWKB(g)\nAsWKB(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " addressToSymbol(address_of_binary_instruction)"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    }
  ]
}
{
  "index": 320,
  "doc": "ST_AsText(g)\nAsText(g)\nST_AsWKT(g)\nAsWKT(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    }
  ]
}
{
  "index": 323,
  "doc": "ST_BOUNDARY(g)\nBOUNDARY(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " regionIn(lhs, rhs\\[, geobase\\])"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    }
  ]
}
{
  "index": 324,
  "doc": "ST_BUFFER(g1,r)\nBUFFER(g1,r)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " greatCircleAngle(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " greatCircleDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    }
  ]
}
{
  "index": 325,
  "doc": "ST_Centroid(mpoly)\nCentroid(mpoly)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " s2CapContains(center, degrees, point)"
    },
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    }
  ]
}
{
  "index": 326,
  "doc": "ST_CONTAINS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " regionIn(lhs, rhs\\[, geobase\\])"
    },
    {
      "index": "Feature",
      "doc": " regionHierarchy(id\\[, geobase\\])"
    }
  ]
}
{
  "index": 327,
  "doc": "ST_ConvexHull(g)\nConvexHull(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsEqualsCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " polygonsWithinCartesian"
    }
  ]
}
{
  "index": 328,
  "doc": "ST_CROSSES(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 329,
  "doc": "ST_DIFFERENCE(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " greatCircleDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 330,
  "doc": "ST_Dimension(g)\nDimension(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " ngrams(string, ngramsize)"
    },
    {
      "index": "Feature",
      "doc": " ngramSimHash(string[, ngramsize])"
    }
  ]
}
{
  "index": 331,
  "doc": "ST_DISJOINT(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    }
  ]
}
{
  "index": 332,
  "doc": "ST_DISTANCE(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " Distance functions"
    },
    {
      "index": "Feature",
      "doc": " greatCircleDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " L1Distance(vector1, vector2)"
    }
  ]
}
{
  "index": 333,
  "doc": "ST_DISTANCE_SPHERE(g1,g2,[r])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " greatCircleDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " Distance functions"
    }
  ]
}
{
  "index": 334,
  "doc": "ST_EndPoint(ls)\nEndPoint(ls)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " s2RectAdd(s2pointLow, s2pointHigh, s2Point)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 335,
  "doc": "ST_ENVELOPE(g)\nENVELOPE(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " geohashesInBox(longitude_min, latitude_min, longitude_max, latitude_max, precision)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    }
  ]
}
{
  "index": 336,
  "doc": "ST_EQUALS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    }
  ]
}
{
  "index": 337,
  "doc": "ST_ExteriorRing(poly)\nExteriorRing(poly)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsUnionCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsWithinCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionSpherical"
    }
  ]
}
{
  "index": 338,
  "doc": "ST_GeomCollFromText(wkt[,srid])\nST_GeometryCollectionFromText(wkt[,srid])\nGeomCollFromText(wkt[,srid])\nGeometryCollectionFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    }
  ]
}
{
  "index": 339,
  "doc": "ST_GeomCollFromWKB(wkb[,srid])\nST_GeometryCollectionFromWKB(wkb[,srid])\nGeomCollFromWKB(wkb[,srid])\nGeometryCollectionFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    }
  ]
}
{
  "index": 344,
  "doc": "ST_GeometryN(gc,N)\nGeometryN(gc,N)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonPerimeterCartesian"
    },
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    },
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " polygonPerimeterSpherical"
    }
  ]
}
{
  "index": 345,
  "doc": "ST_GeometryType(g)\nGeometryType(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " polygonPerimeterCartesian"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionCartesian"
    }
  ]
}
{
  "index": 346,
  "doc": "ST_GeomFromText(wkt[,srid])\nST_GeometryFromText(wkt[,srid])\nGeomFromText(wkt[,srid])\nGeometryFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    }
  ]
}
{
  "index": 347,
  "doc": "ST_GeomFromWKB(wkb[,srid])\nST_GeometryFromWKB(wkb[,srid])\nGeomFromWKB(wkb[,srid])\nGeometryFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    }
  ]
}
{
  "index": 348,
  "doc": "ST_InteriorRingN(poly,N)\nInteriorRingN(poly,N)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsSymDifferenceCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsSymDifferenceSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsWithinCartesian"
    }
  ]
}
{
  "index": 349,
  "doc": "ST_INTERSECTION(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " s2CapContains(center, degrees, point)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    }
  ]
}
{
  "index": 350,
  "doc": "ST_INTERSECTS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " s2CapContains(center, degrees, point)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 351,
  "doc": "ST_IsClosed(g)\nIsClosed(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " regionIn(lhs, rhs\\[, geobase\\])"
    }
  ]
}
{
  "index": 352,
  "doc": "ST_IsEmpty(g)\nIsEmpty(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    }
  ]
}
{
  "index": 353,
  "doc": "ST_IsRing(g)\nIsRing(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geohashesInBox(longitude_min, latitude_min, longitude_max, latitude_max, precision)"
    }
  ]
}
{
  "index": 354,
  "doc": "ST_IsSimple(g)\nIsSimple(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    }
  ]
}
{
  "index": 355,
  "doc": "ST_LENGTH(ls)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " length(s)"
    },
    {
      "index": "Feature",
      "doc": " lengthUTF8(s)"
    },
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    }
  ]
}
{
  "index": 356,
  "doc": "ST_LineFromText(wkt[,srid])\nST_LineStringFromText(wkt[,srid])\nLineFromText(wkt[,srid])\nLineStringFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    }
  ]
}
{
  "index": 357,
  "doc": "ST_LineFromWKB(wkb[,srid])\nLineFromWKB(wkb[,srid])\nST_LineStringFromWKB(wkb[,srid])\nLineStringFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    }
  ]
}
{
  "index": 360,
  "doc": "ST_NumGeometries(gc)\nNumGeometries(gc)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    }
  ]
}
{
  "index": 361,
  "doc": "ST_NumInteriorRings(poly)\nNumInteriorRings(poly)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionCartesian"
    }
  ]
}
{
  "index": 362,
  "doc": "ST_NumPoints(ls)\nNumPoints(ls)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " s2RectAdd(s2pointLow, s2pointHigh, s2Point)"
    }
  ]
}
{
  "index": 363,
  "doc": "ST_OVERLAPS(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    }
  ]
}
{
  "index": 364,
  "doc": "ST_PointFromText(wkt[,srid])\nPointFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " WKT(geo_data)"
    },
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTMultiLineString(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    }
  ]
}
{
  "index": 365,
  "doc": "ST_PointFromWKB(wkb[,srid])\nPointFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " readWKTPoint(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " readWKTRing(wkt_string)"
    },
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    },
    {
      "index": "Feature",
      "doc": " readWKTLineString(wkt_string)"
    }
  ]
}
{
  "index": 366,
  "doc": "ST_PointN(ls,N)\nPointN(ls,N)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    }
  ]
}
{
  "index": 367,
  "doc": "ST_PointOnSurface(g)\nPointOnSurface(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    }
  ]
}
{
  "index": 368,
  "doc": "ST_PolyFromText(wkt[,srid])\nST_PolygonFromText(wkt[,srid])\nPolyFromText(wkt[,srid])\nPolygonFromText(wkt[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsDistanceSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsWithinSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionSpherical"
    },
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    }
  ]
}
{
  "index": 369,
  "doc": "ST_PolyFromWKB(wkb[,srid])\nST_PolygonFromWKB(wkb[,srid])\nPolyFromWKB(wkb[,srid])\nPolygonFromWKB(wkb[,srid])\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " polygonsDistanceCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsWithinCartesian"
    },
    {
      "index": "Feature",
      "doc": " polygonsUnionCartesian"
    },
    {
      "index": "Feature",
      "doc": " pointInPolygon((x, y), [(a, b), (c, d) ...], ...)"
    }
  ]
}
{
  "index": 372,
  "doc": "ST_Relate(g1, g2, i)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 373,
  "doc": "ST_SRID(g)\nSRID(g)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " geohashEncode(longitude, latitude, [precision])"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    }
  ]
}
{
  "index": 374,
  "doc": "ST_StartPoint(ls)\nStartPoint(ls)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " s2RectAdd(s2pointLow, s2pointHigh, s2Point)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 375,
  "doc": "ST_SYMDIFFERENCE(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " s2RectAdd(s2pointLow, s2pointHigh, s2Point)"
    }
  ]
}
{
  "index": 376,
  "doc": "ST_TOUCHES(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 377,
  "doc": "ST_UNION(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " s2CapUnion(center1, radius1, center2, radius2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 378,
  "doc": "ST_WITHIN(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " geohashDecode(hash_str)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 379,
  "doc": "ST_X(p)\nX(p)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevSampStable(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPop(x)"
    },
    {
      "index": "Feature",
      "doc": " stddevPopStable(x)"
    }
  ]
}
{
  "index": 380,
  "doc": "ST_Y(p)\nY(p)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " covarPop(x, y)"
    },
    {
      "index": "Feature",
      "doc": " covarPop(x, y)"
    },
    {
      "index": "Feature",
      "doc": " stddevSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " covarSamp(x, y)"
    }
  ]
}
{
  "index": 381,
  "doc": "SUBDATE(date,INTERVAL expr unit), SUBDATE(expr,days)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " subDate(date, interval)"
    },
    {
      "index": "Feature",
      "doc": " date_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " subtractDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " addDate(date, interval)"
    }
  ]
}
{
  "index": 382,
  "doc": ",String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " stringJaccardIndex(string1, string2)"
    },
    {
      "index": "Feature",
      "doc": " toString"
    },
    {
      "index": "Feature",
      "doc": " MACStringToOUI(s)"
    }
  ]
}
{
  "index": 383,
  "doc": "SUBSTRING(str,pos), \nSUBSTRING(str FROM pos), \nSUBSTRING(str,pos,len),\nSUBSTRING(str FROM pos FOR len)\n\nSUBSTR(str,pos), \nSUBSTR(str FROM pos), \nSUBSTR(str,pos,len),\nSUBSTR(str FROM pos FOR len)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " substring(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " substringUTF8(s, offset[, length])"
    },
    {
      "index": "Feature",
      "doc": " splitByChar(separator, s[, max_substrings]))"
    },
    {
      "index": "Feature",
      "doc": " splitByString(separator, s[, max_substrings]))"
    }
  ]
}
{
  "index": 384,
  "doc": "SUBSTRING_INDEX(str,delim,count)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " substringIndex(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " substringIndexUTF8(s, delim, count)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " countSubstrings(haystack, needle[, start_pos])"
    }
  ]
}
{
  "index": 385,
  "doc": "SUBTIME(expr1,expr2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " subtractMicroseconds(date_time, num)"
    }
  ]
}
{
  "index": 386,
  "doc": "SUM([DISTINCT] expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " groupArrayMovingSum(numbers_for_summing)groupArrayMovingSum(window_size)(numbers_for_summing)"
    },
    {
      "index": "Feature",
      "doc": " sum(num)"
    },
    {
      "index": "Feature",
      "doc": " sumWithOverflow(num)"
    }
  ]
}
{
  "index": 387,
  "doc": "SYSDATE([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDateTime64(year, month, day, hour, minute, second[, precision])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime64BestEffort(time_string [, precision [, time_zone]])"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 388,
  "doc": "SYSTEM_USER()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " currentUser()"
    },
    {
      "index": "Feature",
      "doc": " currentRoles()"
    },
    {
      "index": "Feature",
      "doc": " enabledRoles()"
    },
    {
      "index": "Feature",
      "doc": " serverUUID()"
    }
  ]
}
{
  "index": 389,
  "doc": "sys.sys_get_config(name,default)\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " defaultProfiles()"
    },
    {
      "index": "Feature",
      "doc": " getSetting('custom_setting');"
    },
    {
      "index": "Feature",
      "doc": " enabledProfiles()"
    },
    {
      "index": "Feature",
      "doc": " file(path[, default])"
    }
  ]
}
{
  "index": 390,
  "doc": "SYS_GUID()\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toInt32(expr)"
    },
    {
      "index": "Feature",
      "doc": " toInt32OrZero(x)"
    },
    {
      "index": "Feature",
      "doc": " toInt32OrNull(x)"
    },
    {
      "index": "Feature",
      "doc": " toDate32(expr)"
    }
  ]
}
{
  "index": 391,
  "doc": "TAN(X)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " tan(x)"
    },
    {
      "index": "Feature",
      "doc": " tanh(x)"
    },
    {
      "index": "Feature",
      "doc": " radians(x)"
    },
    {
      "index": "Feature",
      "doc": " atan(x)"
    }
  ]
}
{
  "index": 392,
  "doc": "TIME(expr)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " toDateTime(expr[, time_zone ])"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    }
  ]
}
{
  "index": 393,
  "doc": "TIMEDIFF(expr1,expr2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    }
  ]
}
{
  "index": 394,
  "doc": "TIMESTAMP(expr), TIMESTAMP(expr1,expr2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " toDateTime(expr[, time_zone ])"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    }
  ]
}
{
  "index": 395,
  "doc": "TIMESTAMPADD(unit,interval,datetime_expr)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 396,
  "doc": "TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    }
  ]
}
{
  "index": 397,
  "doc": "TIME_FORMAT(time,format)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime(str[, format[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " formatReadableTimeDelta(column[, maximum_unit, minimum_unit])"
    },
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    }
  ]
}
{
  "index": 398,
  "doc": "TIME_TO_SEC(time)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractNanoseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " addMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    }
  ]
}
{
  "index": 399,
  "doc": "Touches(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistM(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistKm(lat1, lon1, lat2, lon2)"
    },
    {
      "index": "Feature",
      "doc": " h3PointDistRads(lat1, lon1, lat2, lon2)"
    }
  ]
}
{
  "index": 400,
  "doc": "TO_BASE64(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " base64Encode(plaintext)"
    },
    {
      "index": "Feature",
      "doc": " base64Decode(encoded)"
    },
    {
      "index": "Feature",
      "doc": " base64URLEncode(url)"
    },
    {
      "index": "Feature",
      "doc": " base64URLDecode(encodedUrl)"
    }
  ]
}
{
  "index": 401,
  "doc": "TO_CHAR(expr[, fmt])\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toUInt256OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toUInt32OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toUInt16OrDefault(expr[, default])"
    },
    {
      "index": "Feature",
      "doc": " toUInt128OrDefault(expr[, default])"
    }
  ]
}
{
  "index": 402,
  "doc": "TO_DAYS(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addDays(date, num)"
    },
    {
      "index": "Feature",
      "doc": " date_diff('unit', startdate, enddate, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " date_add(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    }
  ]
}
{
  "index": 403,
  "doc": "TO_SECONDS(expr)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " subtractMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timeDiff(first_datetime, second_datetime)"
    },
    {
      "index": "Feature",
      "doc": " addMilliseconds(date_time, num)"
    }
  ]
}
{
  "index": 404,
  "doc": "TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str)\nFrom MariaDB 10.3.6TRIM_ORACLE([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)"
    },
    {
      "index": "Feature",
      "doc": " trimBoth(input_string)"
    },
    {
      "index": "Feature",
      "doc": " trimRight(input_string)"
    },
    {
      "index": "Feature",
      "doc": " endsWith(str, suffix)"
    }
  ]
}
{
  "index": 405,
  "doc": "TRUNCATE(X,D)\n,Numeric Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " truncate(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " floor(x[, N])"
    },
    {
      "index": "Feature",
      "doc": " roundBankers(x [, N])"
    },
    {
      "index": "Feature",
      "doc": " pow(x, y)"
    }
  ]
}
{
  "index": 406,
  "doc": "UCASE(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " ascii(s)"
    },
    {
      "index": "Feature",
      "doc": " endsWith(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    }
  ]
}
{
  "index": 407,
  "doc": "UNCOMPRESS(string_to_uncompress)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " aes_decrypt_mysql('mode', 'ciphertext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " aes_encrypt_mysql('mode', 'plaintext', 'key' [, iv])"
    },
    {
      "index": "Feature",
      "doc": " decrypt('mode', 'ciphertext', 'key' [, iv, aad])"
    },
    {
      "index": "Feature",
      "doc": " encrypt('mode', 'plaintext', 'key' [, iv, aad])"
    }
  ]
}
{
  "index": 408,
  "doc": "UNCOMPRESSED_LENGTH(compressed_string)\n,Encryption, Hashing and Compression Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " wordShingleMinHashArgUTF8(string[, shinglesize, hashnum])"
    },
    {
      "index": "Feature",
      "doc": " ngramMinHashArgUTF8(string[, ngramsize, hashnum])"
    },
    {
      "index": "Feature",
      "doc": " wordShingleMinHash(string[, shinglesize, hashnum])"
    },
    {
      "index": "Feature",
      "doc": " wordShingleMinHashUTF8(string[, shinglesize, hashnum])"
    }
  ]
}
{
  "index": 409,
  "doc": "UNHEX(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " wordShingleSimHash(string[, shinglesize])"
    },
    {
      "index": "Feature",
      "doc": " wordShingleSimHashUTF8(string[, shinglesize])"
    },
    {
      "index": "Feature",
      "doc": " wordShingleMinHashArgUTF8(string[, shinglesize, hashnum])"
    },
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    }
  ]
}
{
  "index": 410,
  "doc": "UNIX_TIMESTAMP()\nUNIX_TIMESTAMP(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " timestamp_sub(unit, value, date)"
    },
    {
      "index": "Feature",
      "doc": " timestamp(expr[, expr_time])"
    },
    {
      "index": "Feature",
      "doc": " addMilliseconds(date_time, num)"
    },
    {
      "index": "Feature",
      "doc": " timestamp_add(date, INTERVAL value unit)"
    }
  ]
}
{
  "index": 411,
  "doc": "UpdateXML(xml_target, xpath_expr, new_xml)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " encodeXMLComponent(x)"
    },
    {
      "index": "Feature",
      "doc": " decodeXMLComponent(x)"
    },
    {
      "index": "Feature",
      "doc": " replaceRegexpAll"
    },
    {
      "index": "Feature",
      "doc": " replaceRegexpOne(haystack, pattern, replacement)"
    }
  ]
}
{
  "index": 412,
  "doc": "UPPER(str)\nUCASE(str)\n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " upper(input)"
    },
    {
      "index": "Feature",
      "doc": " upperUTF8(input)"
    },
    {
      "index": "Feature",
      "doc": " endsWithUTF8(str, suffix)"
    },
    {
      "index": "Feature",
      "doc": " alphaTokens(s[, max_substrings]))"
    }
  ]
}
{
  "index": 413,
  "doc": "USER()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " currentUser()"
    },
    {
      "index": "Feature",
      "doc": " currentRoles()"
    },
    {
      "index": "Feature",
      "doc": " identity(x)"
    },
    {
      "index": "Feature",
      "doc": " e()"
    }
  ]
}
{
  "index": 414,
  "doc": "UTC_DATE, UTC_DATE()\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " UTCTimestamp()"
    },
    {
      "index": "Feature",
      "doc": " toTime(date[,timezone])"
    },
    {
      "index": "Feature",
      "doc": " toUnixTimestamp(date)toUnixTimestamp(str, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " timeZone()"
    }
  ]
}
{
  "index": 415,
  "doc": "UTC_TIME\nUTC_TIME([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " UTCTimestamp()"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime64BestEffort(time_string [, precision [, time_zone]])"
    },
    {
      "index": "Feature",
      "doc": " toTime(date[,timezone])"
    },
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    }
  ]
}
{
  "index": 416,
  "doc": "UTC_TIMESTAMP\nUTC_TIMESTAMP([precision])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " UTCTimestamp()"
    },
    {
      "index": "Feature",
      "doc": " parseDateTime64BestEffort(time_string [, precision [, time_zone]])"
    },
    {
      "index": "Feature",
      "doc": " toUnixTimestamp(date)toUnixTimestamp(str, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " formatDateTime(Time, Format[, Timezone])"
    }
  ]
}
{
  "index": 417,
  "doc": "UUID()\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " UUIDToNum(uuid[, variant = 1])"
    },
    {
      "index": "Feature",
      "doc": " UUIDNumToString(binary[, variant = 1])"
    },
    {
      "index": "Feature",
      "doc": " UUIDStringToNum(string[, variant = 1])"
    },
    {
      "index": "Feature",
      "doc": " empty(UUID)"
    }
  ]
}
{
  "index": 418,
  "doc": "UUID_SHORT()\n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " UUIDToNum(uuid[, variant = 1])"
    },
    {
      "index": "Feature",
      "doc": " UUIDStringToNum(string[, variant = 1])"
    },
    {
      "index": "Feature",
      "doc": " UUIDNumToString(binary[, variant = 1])"
    },
    {
      "index": "Feature",
      "doc": " empty(UUID)"
    }
  ]
}
{
  "index": 419,
  "doc": "MariaDB starting with 10.3.3VALUE(col_name) \nMariaDB until 10.3.2VALUES(col_name) \n,Miscellaneous Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " getSubcolumn(col_name, subcol_name)"
    },
    {
      "index": "Feature",
      "doc": " maxIntersections(start_column, end_column)"
    },
    {
      "index": "Feature",
      "doc": " joinGetOrNull(join_storage_table_name, `value_column`, join_keys)"
    },
    {
      "index": "Feature",
      "doc": " joinGet(join_storage_table_name, `value_column`, join_keys)"
    }
  ]
}
{
  "index": 420,
  "doc": "VARIANCE(expr) \n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " varSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " quantile(level)(expr)"
    },
    {
      "index": "Feature",
      "doc": " varPop(x)"
    },
    {
      "index": "Feature",
      "doc": " quantileTiming(level)(expr)"
    }
  ]
}
{
  "index": 421,
  "doc": "VAR_POP(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " varPop(x)"
    },
    {
      "index": "Feature",
      "doc": " initializeAggregation (aggregate_function, arg1, arg2, ..., argN)"
    },
    {
      "index": "Feature",
      "doc": " varPopStable(x)"
    },
    {
      "index": "Feature",
      "doc": " varSamp(x)"
    }
  ]
}
{
  "index": 422,
  "doc": "VAR_SAMP(expr)\n,Aggregate Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " varSamp(x)"
    },
    {
      "index": "Feature",
      "doc": " skewSamp(expr)"
    },
    {
      "index": "Feature",
      "doc": " groupBitOr(expr)"
    },
    {
      "index": "Feature",
      "doc": " groupBitAnd(expr)"
    }
  ]
}
{
  "index": 423,
  "doc": "VEC_DISTANCE(v, s)\n,Vector Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " Distance functions"
    },
    {
      "index": "Feature",
      "doc": " LinfDistance(vector1, vector2)"
    },
    {
      "index": "Feature",
      "doc": " L2Distance(vector1, vector2)"
    },
    {
      "index": "Feature",
      "doc": " L1Distance(vector1, vector2)"
    }
  ]
}
{
  "index": 424,
  "doc": "VEC_FromText(s)\n,Vector Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " LpNorm(vector, p)"
    },
    {
      "index": "Feature",
      "doc": " LinfNorm(vector)"
    },
    {
      "index": "Feature",
      "doc": " L2Norm(vector)"
    },
    {
      "index": "Feature",
      "doc": " L1Norm(vector)"
    }
  ]
}
{
  "index": 425,
  "doc": "VEC_ToText(v)\n,Vector Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " LinfNorm(vector)"
    },
    {
      "index": "Feature",
      "doc": " LpNorm(vector, p)"
    },
    {
      "index": "Feature",
      "doc": " L2Norm(vector)"
    },
    {
      "index": "Feature",
      "doc": " L1Norm(vector)"
    }
  ]
}
{
  "index": 426,
  "doc": "VERSION()\n,Information Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " version()"
    },
    {
      "index": "Feature",
      "doc": " revision()"
    },
    {
      "index": "Feature",
      "doc": " getOSKernelVersion()"
    },
    {
      "index": "Feature",
      "doc": " variantType(variant)"
    }
  ]
}
{
  "index": 427,
  "doc": "sys.version_major()\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " version()"
    },
    {
      "index": "Feature",
      "doc": " getOSKernelVersion()"
    },
    {
      "index": "Feature",
      "doc": " revision()"
    },
    {
      "index": "Feature",
      "doc": " YYYYMMDDToDate32"
    }
  ]
}
{
  "index": 428,
  "doc": "sys.version_minor()\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " version()"
    },
    {
      "index": "Feature",
      "doc": " getOSKernelVersion()"
    },
    {
      "index": "Feature",
      "doc": " revision()"
    },
    {
      "index": "Feature",
      "doc": " minSampleSizeConversion(baseline, mde, power, alpha)"
    }
  ]
}
{
  "index": 429,
  "doc": "sys.version_patch()\n,No Category",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " version()"
    },
    {
      "index": "Feature",
      "doc": " revision()"
    },
    {
      "index": "Feature",
      "doc": " getOSKernelVersion()"
    },
    {
      "index": "Feature",
      "doc": " YYYYMMDDToDate32"
    }
  ]
}
{
  "index": 430,
  "doc": "WEEK(date[,mode])\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toDayOfWeek(t[, mode[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " toLastDayOfWeek(t[, mode[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " addWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toStartOfWeek(t[, mode[, timezone]])"
    }
  ]
}
{
  "index": 431,
  "doc": "WEEKDAY(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toDayOfWeek(t[, mode[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " addWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toLastDayOfWeek(t[, mode[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " toRelativeWeekNum(date)"
    }
  ]
}
{
  "index": 432,
  "doc": "WEEKOFYEAR(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " toRelativeWeekNum(date)"
    },
    {
      "index": "Feature",
      "doc": " addWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " subtractWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toLastDayOfWeek(t[, mode[, timezone]])"
    }
  ]
}
{
  "index": 433,
  "doc": "WEIGHT_STRING(str [AS {CHAR|BINARY}(N)] [LEVEL levels] [flags])\n  levels: N [ASC|DESC|REVERSE] [, N [ASC|DESC|REVERSE]] ... \n,String Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " stringToH3(index_str)"
    },
    {
      "index": "Feature",
      "doc": " wordShingleMinHashArgUTF8(string[, shinglesize, hashnum])"
    },
    {
      "index": "Feature",
      "doc": " toFixedString(s, N)"
    },
    {
      "index": "Feature",
      "doc": " splitByNonAlpha(s[, max_substrings]))"
    }
  ]
}
{
  "index": 434,
  "doc": "Within(g1,g2)\n,Geographic Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " geoDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)"
    },
    {
      "index": "Feature",
      "doc": " Geohash"
    },
    {
      "index": "Feature",
      "doc": " geoToS2(lon, lat)"
    },
    {
      "index": "Feature",
      "doc": " Distance functions"
    }
  ]
}
{
  "index": 435,
  "doc": "WSREP_LAST_SEEN_GTID()\n,Galera Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " h3IsValid(h3index)"
    },
    {
      "index": "Feature",
      "doc": " h3UnidirectionalEdgeisValid(index)"
    },
    {
      "index": "Feature",
      "doc": " h3Distance(start,end)"
    },
    {
      "index": "Feature",
      "doc": " h3ExactEdgeLengthRads(index)"
    }
  ]
}
{
  "index": 436,
  "doc": "WSREP_LAST_WRITTEN_GTID()\n,Galera Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " notEmpty(UUID)"
    },
    {
      "index": "Feature",
      "doc": " transactionID()"
    },
    {
      "index": "Feature",
      "doc": " generateUUIDv4([expr])"
    },
    {
      "index": "Feature",
      "doc": " buildId()"
    }
  ]
}
{
  "index": 437,
  "doc": "WSREP_SYNC_WAIT_UPTO_GTID(gtid[,timeout])\n,Galera Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " sleep(seconds)"
    },
    {
      "index": "Feature",
      "doc": " toDateTime64OrZero(expr, scale, [timezone])"
    },
    {
      "index": "Feature",
      "doc": " toDateTimeOrZero"
    },
    {
      "index": "Feature",
      "doc": " toDecimal128(expr, S)"
    }
  ]
}
{
  "index": 438,
  "doc": "YEAR(date)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " makeDate(year, month, day);makeDate(year, day_of_year);"
    },
    {
      "index": "Feature",
      "doc": " subtractYears(date, num)"
    },
    {
      "index": "Feature",
      "doc": " addYears(date, num)"
    },
    {
      "index": "Feature",
      "doc": " changeYear(date_or_datetime, value)"
    }
  ]
}
{
  "index": 439,
  "doc": "YEARWEEK(date), YEARWEEK(date,mode)\n,Date & Time Functions",
  "mapping docs": [
    {
      "index": "Feature",
      "doc": " addWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toDayOfWeek(t[, mode[, timezone]])"
    },
    {
      "index": "Feature",
      "doc": " subtractWeeks(date, num)"
    },
    {
      "index": "Feature",
      "doc": " toLastDayOfWeek(t[, mode[, timezone]])"
    }
  ]
}
